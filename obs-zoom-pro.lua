--[[
=============================================================================
OBS Zoom Pro - Intelligent Camera Zoom for OBS Studio
=============================================================================
Version: 1.0.0
Author: OBS Zoom Pro Team
Description: An OBS Lua script providing intelligent camera zoom functionality
             with smooth transitions, easing curves, and configurable settings.
=============================================================================
]]




-- FFI not available in OBS Lua
local ffi_loaded = false

-- Stub FFI table to prevent errors when FFI is not available
local ffi = { new = function() return nil end, C = {}, sizeof = function() return 0 end, cast = function() return 0 end }

-- OBS provides global obs table
local obs = obs

-- Version constant
local VERSION = "1.0.0"

--================================================
-- MODULE: Logging & Debug (M20)
--================================================
local debug_logs = false

--[[ Log a message to OBS script log
--[[ @param msg string The message to log
local function log(msg)
    if debug_logs then
        obs.script_log(obs.LOG_INFO, "[OBS Zoom Pro] " .. tostring(msg))
    end
end

--[[ Log a table's contents recursively
--[[ @param tbl table The table to log
--[[ @param indent number|nil Current indentation level (default: 0)
local function log_table(tbl, indent)
    indent = indent or 0
    if type(tbl) ~= "table" then
        log(tostring(tbl))
        return
    end

    for k, v in pairs(tbl) do
        local formatting = string.rep("  ", indent) .. tostring(k) .. ": "
        if type(v) == "table" then
            log(formatting)
            log_table(v, indent + 1)
        else
            log(formatting .. tostring(v))
        end
    end
end

--================================================
-- MODULE: Math Utilities (M02)
--================================================

--[[ Clamp a value between min and max
--[[ @param min number Minimum value
--[[ @param max number Maximum value
--[[ @param value number Value to clamp
--[[ @return number Clamped value
local function clamp(min, max, value)
    if value < min then return min end
    if value > max then return max end
    return value
end

--[[ Linear interpolation between two values
--[[ @param a number Start value
--[[ @param b number End value
--[[ @param t number Interpolation factor (0-1)
--[[ @return number Interpolated value
local function lerp(a, b, t)
    return a + (b - a) * t
end

--[[ Calculate distance between two points
--[[ @param x1 number First point X
--[[ @param y1 number First point Y
--[[ @param x2 number Second point X
--[[ @param y2 number Second point Y
--[[ @return number Distance between points
local function distance(x1, y1, x2, y2)
    local dx = x2 - x1
    local dy = y2 - y1
    return math.sqrt(dx * dx + dy * dy)
end

--[[ Normalize a 2D vector
--[[ @param x number X component
--[[ @param y number Y component
--[[ @return number, number Normalized x, y components
local function normalize(x, y)
    local len = math.sqrt(x * x + y * y)
    if len == 0 then
        return 0, 0
    end
    return x / len, y / len
end

--================================================
-- MODULE: Easing Library (M03)
--================================================
local Easing = {}

--[[ Generator function for power easing curves
--[[ @param n number Power exponent
--[[ @return table Easing table with In, Out, InOut functions
local function make_power(n)
    return {
        In = function(t)
            return t ^ n
        end,
        Out = function(t)
            return 1 - (1 - t) ^ n
        end,
        InOut = function(t)
            if t < 0.5 then
                return (2 * t) ^ n / 2
            else
                return 1 - ((-2 * t + 2) ^ n) / 2
            end
        end
    }
end

-- Linear easing
Easing.Linear = {
    In = function(t)
        return t
    end,
    Out = function(t)
        return t
    end,
    InOut = function(t)
        return t
    end
}

-- Quadratic easing (power of 2)
Easing.Quad = make_power(2)

-- Cubic easing (power of 3)
Easing.Cubic = make_power(3)

-- Quartic easing (power of 4)
Easing.Quart = make_power(4)

-- Quintic easing (power of 5)
Easing.Quint = make_power(5)

-- Sine easing
Easing.Sine = {
    In = function(t)
        return 1 - math.cos(t * math.pi / 2)
    end,
    Out = function(t)
        return math.sin(t * math.pi / 2)
    end,
    InOut = function(t)
        return -(math.cos(math.pi * t) - 1) / 2
    end
}

-- Exponential easing
Easing.Expo = {
    In = function(t)
        if t == 0 then
            return 0
        end
        return 2 ^ (10 * (t - 1))
    end,
    Out = function(t)
        if t == 1 then
            return 1
        end
        return 1 - 2 ^ (-10 * t)
    end,
    InOut = function(t)
        if t == 0 then
            return 0
        end
        if t == 1 then
            return 1
        end
        if t < 0.5 then
            return 2 ^ (20 * t - 10) / 2
        else
            return (2 - 2 ^ (-20 * t + 10)) / 2
        end
    end
}

-- Circular easing
Easing.Circ = {
    In = function(t)
        return 1 - math.sqrt(1 - t * t)
    end,
    Out = function(t)
        return math.sqrt(1 - (t - 1) ^ 2)
    end,
    InOut = function(t)
        if t < 0.5 then
            return (1 - math.sqrt(1 - 4 * t * t)) / 2
        else
            return (math.sqrt(1 - (-2 * t + 2) ^ 2) + 1) / 2
        end
    end
}

-- Back easing with overshoot
Easing.Back = {
    In = function(t, overshoot)
        overshoot = overshoot or 1.70158
        return t * t * ((overshoot + 1) * t - overshoot)
    end,
    Out = function(t, overshoot)
        overshoot = overshoot or 1.70158
        t = t - 1
        return 1 + t * t * ((overshoot + 1) * t + overshoot)
    end,
    InOut = function(t, overshoot)
        overshoot = overshoot or 1.70158
        overshoot = overshoot * 1.525
        if t < 0.5 then
            return (2 * t) ^ 2 * ((overshoot + 1) * 2 * t - overshoot) / 2
        else
            t = 2 * t - 2
            return (t * t * ((overshoot + 1) * t + overshoot) + 2) / 2
        end
    end
}

-- Elastic easing
Easing.Elastic = {
    In = function(t)
        if t == 0 then
            return 0
        end
        if t == 1 then
            return 1
        end
        return -2 ^ (10 * t - 10) * math.sin((t * 10 - 10.75) * (2 * math.pi) / 3)
    end,
    Out = function(t)
        if t == 0 then
            return 0
        end
        if t == 1 then
            return 1
        end
        return 2 ^ (-10 * t) * math.sin((t * 10 - 0.75) * (2 * math.pi) / 3) + 1
    end,
    InOut = function(t)
        if t == 0 then
            return 0
        end
        if t == 1 then
            return 1
        end
        if t < 0.5 then
            return -(2 ^ (20 * t - 10) * math.sin((20 * t - 11.125) * (2 * math.pi) / 4.5)) / 2
        else
            return (2 ^ (-20 * t + 10) * math.sin((20 * t - 11.125) * (2 * math.pi) / 4.5)) / 2 + 1
        end
    end
}

-- Bounce easing
Easing.Bounce = {
    In = function(t)
        return 1 - Easing.Bounce.Out(1 - t)
    end,
    Out = function(t)
        local n1 = 7.5625
        local d1 = 2.75

        if t < 1 / d1 then
            return n1 * t * t
        elseif t < 2 / d1 then
            t = t - 1.5 / d1
            return n1 * t * t + 0.75
        elseif t < 2.5 / d1 then
            t = t - 2.25 / d1
            return n1 * t * t + 0.9375
        else
            t = t - 2.625 / d1
            return n1 * t * t + 0.984375
        end
    end,
    InOut = function(t)
        if t < 0.5 then
            return (1 - Easing.Bounce.Out(1 - 2 * t)) / 2
        else
            return (1 + Easing.Bounce.Out(2 * t - 1)) / 2
        end
    end
}

--[[ Names lookup table for UI display
Easing.NAMES = {
    "Linear",
    "QuadIn", "QuadOut", "QuadInOut",
    "CubicIn", "CubicOut", "CubicInOut",
    "QuartIn", "QuartOut", "QuartInOut",
    "QuintIn", "QuintOut", "QuintInOut",
    "SineIn", "SineOut", "SineInOut",
    "ExpoIn", "ExpoOut", "ExpoInOut",
    "CircIn", "CircOut", "CircInOut",
    "BackIn", "BackOut", "BackInOut",
    "ElasticIn", "ElasticOut", "ElasticInOut",
    "BounceIn", "BounceOut", "BounceInOut"
}

--[[ Get easing function by name
--[[ @param name string The easing name (e.g., "QuadIn", "ElasticOut")
--[[ @param overshoot number|nil Optional overshoot parameter for Back easing
--[[ @return function The easing function
function Easing.get(name, overshoot)
    local base_name = name:match("^(%a+)In?$") or name:match("^(%a+)Out$") or name:match("^(%a+)InOut$")
    local variant = "In"

    if name:match("Out$") and not name:match("InOut$") then
        variant = "Out"
    elseif name:match("InOut$") then
        variant = "InOut"
    end

    -- Handle Linear special case
    if base_name == "Linear" then
        return Easing.Linear[variant]
    end

    -- Handle Back with overshoot
    if base_name == "Back" then
        return function(t)
            return Easing.Back[variant](t, overshoot)
        end
    end

    -- Get the easing type
    local easing_type = Easing[base_name]
    if easing_type and easing_type[variant] then
        return easing_type[variant]
    end

    -- Default to Linear if not found
    return Easing.Linear.In
end

--================================================
-- MODULE: SmoothDamp (M04)
--================================================

--[[ Critically damped spring smoothing (Unity-style SmoothDamp)
--[[ Gradually changes a value towards a desired target over time
--[[ @param current number Current position
--[[ @param target number Target position
--[[ @param velocity table Velocity table with val field (modified by reference)
--[[ @param smoothTime number Approximate time to reach the target
--[[ @param maxSpeed number Maximum speed (prevents overshooting)
--[[ @param dt number Delta time since last frame
--[[ @return number Smoothed output value
local function SmoothDamp(current, target, velocity, smoothTime, maxSpeed, dt)
    -- Ensure smoothTime is positive
    smoothTime = math.max(0.0001, smoothTime)

    -- Calculate omega and exponential decay
    local omega = 2.0 / smoothTime
    local x = omega * dt
    local exp = 1.0 / (1.0 + x + 0.48 * x * x + 0.235 * x * x * x)

    -- Calculate change and clamp to max speed
    local change = current - target
    local maxChange = maxSpeed * smoothTime
    change = clamp(-maxChange, maxChange, change)

    -- Calculate temporary value and update velocity
    local temp = (velocity.val + omega * change) * dt
    velocity.val = (velocity.val - omega * temp) * exp

    -- Calculate output
    local output = (current - change) + (change + temp) * exp

    -- Prevent overshooting
    if (target - current > 0) == (output > target) then
        output = target
        velocity.val = 0
    end

    return output
end

--================================================
-- MODULE: Platform Layer (M01)
--================================================
-- Cross-platform mouse/cursor detection
-- Windows: Full support (position, click, cursor shape)
-- Linux/Mac: Basic support (position only)

-- Platform detection (pure Lua, no FFI required)
local function detect_platform()
    -- Use Lua's os.name instead of jit
    local raw_os = os.getenv('OS') or ''
    local is_windows = raw_os:match('Windows') ~= nil
    local is_linux = raw_os:match('') and not is_windows and package.config:sub(1,1) == '/'
    local is_macos = false

    -- Check for Darwin (macOS)
    local success, handle = pcall(io.popen, 'uname 2>/dev/null')
    if success and handle then
        local uname = handle:read('*a'):match('^%s*(.-)%s*
        -- Linux: Use xdotool if available, fallback to X11
        local success, result = pcall(function()
            local handle = io.popen("xdotool getmouselocation 2>/dev/null || echo 'x:0 y:0'")
            if handle then
                local output = handle:read("*a")
                handle:close()
                local x, y = output:match("x:(%d+)%s+y:(%d+)")
                if x and y then
                    return { x = tonumber(x), y = tonumber(y) }
                end
            end
            return nil
        end)
        if success and result then
            return result
        end
    elseif IS_MACOS then
        -- macOS: Use osascript
        local success, result = pcall(function()
            local handle = io.popen(--[[osascript -e 'tell application "System Events" to get position of the mouse' 2>/dev/null || echo "0, 0"]])
            if handle then
                local output = handle:read("*a")
                handle:close()
                local x, y = output:match("(%d+),%s*(%d+)")
                if x and y then
                    return { x = tonumber(x), y = tonumber(y) }
                end
            end
            return nil
        end)
        if success and result then
            return result
        end
    end

    -- Fallback
    return { x = 0, y = 0 }
end

-- Check if left mouse button is clicked (Windows only, others return false)
function Platform.is_clicking()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x01) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if a modifier key is held (Windows only)
function Platform.is_key_held(vk_code)
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(vk_code) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if cursor is a pointer/hand (Windows only)
function Platform.is_cursor_pointer()
    if IS_WINDOWS then
        local success, result = pcall(function()
            local ci = ffi.new("CURSORINFO")
            ci.cbSize = ffi.sizeof("CURSORINFO")
            if ffi.C.GetCursorInfo(ci) ~= 0 then
                -- Check if hCursor is a hand pointer
                -- This is a simplified check; real implementation would compare cursor handles
                return ci.flags ~= 0  -- Simplified; actual implementation needs cursor handle comparison
            end
            return false
        end)
        return success and result or false
    end
    return false
end

-- Get cursor shape (Windows only, returns "arrow" for others)
function Platform.get_cursor_shape()
    if IS_WINDOWS then
        local success, result = pcall(function()
            local ci = ffi.new("CURSORINFO")
            ci.cbSize = ffi.sizeof("CURSORINFO")
            if ffi.C.GetCursorInfo(ci) ~= 0 and ci.hCursor ~= nil then
                local addr = tonumber(ffi.cast("uintptr_t", ci.hCursor))
                -- Common cursor IDs (these are typical values, may vary)
                -- IDC_ARROW = 32512, IDC_IBEAM = 32513, IDC_HAND = 32649
                -- We use address ranges as heuristic
                return "arrow"  -- Simplified; actual implementation would map handles
            end
            return "arrow"
        end)
        return success and result or "arrow"
    end
    return "arrow"
end

-- Check if Control key is held
function Platform.is_ctrl_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x11) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if Shift key is held
function Platform.is_shift_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x10) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if Alt key is held
function Platform.is_alt_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x12) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Convenience wrapper functions
function platform_get_mouse_pos()
    return Platform.get_mouse_pos()
end

function platform_is_clicking()
    return Platform.is_clicking()
end

function platform_is_cursor_pointer()
    return Platform.is_cursor_pointer()
end

function platform_cursor_shape_available()
    return Platform.cursor_shape_available
end

function platform_is_ctrl_held()
    return Platform.is_ctrl_held()
end

function platform_is_shift_held()
    return Platform.is_shift_held()
end

function platform_is_alt_held()
    return Platform.is_alt_held()
end

--================================================
-- MODULE: State Machine (M05)
--================================================
-- Manages zoom states and transitions
-- States: IDLE, ZOOMING_IN, ZOOMED_IN, ZOOMING_OUT, SCROLLING, JUMPING

local ZoomState = {
    IDLE         = "idle",
    ZOOMING_IN   = "zooming_in",
    ZOOMED_IN    = "zoomed_in",
    ZOOMING_OUT  = "zooming_out",
    SCROLLING    = "scrolling",    -- Scroll wheel mid-transition
    JUMPING      = "jumping",      -- Bookmark transition
}

local StateMachine = {
    state = ZoomState.IDLE,
    zoom_time = 0,          -- Animation progress (0 Ã¢â€ â€™ 1)
    zoom_level = 1.0,       -- Current zoom factor
    target_level = 1.0,     -- Target zoom factor
    start_crop = nil,       -- Crop at animation start {x, y, w, h}
    target_crop = nil,      -- Crop at animation end {x, y, w, h}
    following = false,      -- Mouse follow active

    -- Transition guards
    can_zoom_in = function(self)
        return self.state == ZoomState.IDLE
    end,

    can_zoom_out = function(self)
        return self.state == ZoomState.ZOOMED_IN
            or self.state == ZoomState.SCROLLING
    end,

    can_scroll = function(self)
        return self.state == ZoomState.ZOOMED_IN
            or self.state == ZoomState.IDLE
            or self.state == ZoomState.SCROLLING
    end,

    can_jump = function(self)
        return self.state ~= ZoomState.ZOOMING_IN
           and self.state ~= ZoomState.ZOOMING_OUT
           and self.state ~= ZoomState.JUMPING
    end,

    is_animating = function(self)
        return self.state == ZoomState.ZOOMING_IN
            or self.state == ZoomState.ZOOMING_OUT
            or self.state == ZoomState.SCROLLING
            or self.state == ZoomState.JUMPING
    end,

    is_zoomed = function(self)
        return self.state ~= ZoomState.IDLE
    end,
}

-- Transition to a new state
function StateMachine:transition(new_state, params)
    local old = self.state
    self.state = new_state
    self.zoom_time = 0

    if params then
        if params.start_crop then self.start_crop = params.start_crop end
        if params.target_crop then self.target_crop = params.target_crop end
        if params.target_level then self.target_level = params.target_level end
    end

    log("State: " .. old .. " Ã¢â€ â€™ " .. new_state)
end

-- Complete the current animation
function StateMachine:complete()
    if self.state == ZoomState.ZOOMING_IN
       or self.state == ZoomState.SCROLLING
       or self.state == ZoomState.JUMPING then
        self.zoom_level = self.target_level
        self.state = ZoomState.ZOOMED_IN
        self.zoom_time = 0
        log("State: " .. self.state .. " Ã¢â€ â€™ ZOOMED_IN (complete)")
    elseif self.state == ZoomState.ZOOMING_OUT then
        self.zoom_level = 1.0
        self.target_level = 1.0
        self.start_crop = nil
        self.target_crop = nil
        self.following = false
        self.state = ZoomState.IDLE
        self.zoom_time = 0
        log("State: ZOOMING_OUT Ã¢â€ â€™ IDLE (complete)")
    end
end

-- Reset to initial state
function StateMachine:reset()
    self.state = ZoomState.IDLE
    self.zoom_time = 0
    self.zoom_level = 1.0
    self.target_level = 1.0
    self.start_crop = nil
    self.target_crop = nil
    self.following = false
    log("StateMachine: Reset to IDLE")
end

-- Get current animation progress (0-1)
function StateMachine:get_progress()
    return clamp(0, 1, self.zoom_time)
end

-- Check if in a specific state
function StateMachine:is_state(state)
    return self.state == state
end

-- Get state name for display
function StateMachine:get_state_name()
    return self.state
end

-- Create a new state machine instance (for testing/isolation)
function StateMachine:new()
    local sm = {}
    setmetatable(sm, { __index = self })
    sm.state = ZoomState.IDLE
    sm.zoom_time = 0
    sm.zoom_level = 1.0
    sm.target_level = 1.0
    sm.start_crop = nil
    sm.target_crop = nil
    sm.following = false
    return sm
end

-- Global state machine instance
local SM = StateMachine:new()

--================================================
-- MODULE: Crop Filter Manager (M07)
--================================================
-- Manages the crop/pad filter used to simulate zoom
-- Creates, updates, and destroys the filter automatically

local FILTER_PREFIX = "[ZoomPro] "
local CROP_FILTER_NAME = FILTER_PREFIX .. "Crop"

local CropFilterManager = {
    filter = nil,           -- The crop filter source
    source = nil,           -- The parent source
    original_crop = nil,    -- Original crop values for restoration
    current_crop = { x = 0, y = 0, w = 0, h = 0 },
    initialized = false,
}

-- Create the crop filter on a source
function CropFilterManager:create(source)
    if not source then
        log("CropFilter: No source provided")
        return false
    end

    self:cleanup()  -- Clean up any existing filter
    self.source = source

    -- Check if our filter already exists
    local existing = obs.obs_source_get_filter_by_name(source, CROP_FILTER_NAME)
    if existing then
        log("CropFilter: Found existing filter")
        self.filter = existing
        self.initialized = true
        return true
    end

    -- Create new crop/pad filter
    local settings = obs.obs_data_create()
    obs.obs_data_set_int(settings, "left", 0)
    obs.obs_data_set_int(settings, "top", 0)
    obs.obs_data_set_int(settings, "right", 0)
    obs.obs_data_set_int(settings, "bottom", 0)
    obs.obs_data_set_bool(settings, "relative", false)  -- Absolute positioning

    self.filter = obs.obs_source_create_private(
        "crop_filter",      -- Filter type
        CROP_FILTER_NAME,   -- Filter name
        settings            -- Settings
    )

    obs.obs_data_release(settings)

    if not self.filter then
        log("CropFilter: Failed to create filter")
        return false
    end

    -- Add filter to source
    obs.obs_source_filter_add(source, self.filter)

    -- Store original crop (none)
    self.original_crop = { x = 0, y = 0, w = 0, h = 0 }

    self.initialized = true
    log("CropFilter: Created successfully")
    return true
end

-- Update the crop filter with new values
function CropFilterManager:update(x, y, w, h)
    if not self.filter or not self.initialized then
        return false
    end

    -- Store current crop
    self.current_crop = { x = x, y = y, w = w, h = h }

    -- Get filter settings
    local settings = obs.obs_source_get_settings(self.filter)
    if not settings then
        return false
    end

    -- Calculate crop values
    -- For crop_filter: left, top are absolute position
    -- right, bottom are width/height from right/bottom edge
    -- We need to convert our x, y, w, h to this format

    -- Get source dimensions
    local source_w = obs.obs_source_get_width(self.source)
    local source_h = obs.obs_source_get_height(self.source)

    if source_w == 0 or source_h == 0 then
        obs.obs_data_release(settings)
        return false
    end

    -- Set crop values
    -- left = x offset from left
    -- top = y offset from top
    -- right = source_w - (x + w) = remaining width on right
    -- bottom = source_h - (y + h) = remaining height on bottom
    local left = math.floor(x)
    local top = math.floor(y)
    local right = math.floor(source_w - (x + w))
    local bottom = math.floor(source_h - (y + h))

    -- Clamp to valid values
    left = math.max(0, left)
    top = math.max(0, top)
    right = math.max(0, right)
    bottom = math.max(0, bottom)

    obs.obs_data_set_int(settings, "left", left)
    obs.obs_data_set_int(settings, "top", top)
    obs.obs_data_set_int(settings, "right", right)
    obs.obs_data_set_int(settings, "bottom", bottom)

    -- Update the filter
    obs.obs_source_update(self.filter, settings)
    obs.obs_data_release(settings)

    return true
end

-- Get current crop values
function CropFilterManager:get_crop()
    return self.current_crop
end

-- Reset crop to original (no crop)
function CropFilterManager:reset()
    if not self.filter or not self.initialized then
        return false
    end

    local settings = obs.obs_source_get_settings(self.filter)
    if settings then
        obs.obs_data_set_int(settings, "left", 0)
        obs.obs_data_set_int(settings, "top", 0)
        obs.obs_data_set_int(settings, "right", 0)
        obs.obs_data_set_int(settings, "bottom", 0)
        obs.obs_source_update(self.filter, settings)
        obs.obs_data_release(settings)
    end

    self.current_crop = { x = 0, y = 0, w = 0, h = 0 }
    return true
end

-- Remove the filter and restore original state
function CropFilterManager:cleanup()
    if self.filter and self.source then
        -- Reset to no crop first
        self:reset()

        -- Remove filter from source
        obs.obs_source_filter_remove(self.source, self.filter)
        obs.obs_source_release(self.filter)
        self.filter = nil
        log("CropFilter: Removed from source")
    end

    self.source = nil
    self.original_crop = nil
    self.current_crop = { x = 0, y = 0, w = 0, h = 0 }
    self.initialized = false
end

-- Check if filter is ready
function CropFilterManager:is_ready()
    return self.initialized and self.filter ~= nil
end

-- Get source dimensions
function CropFilterManager:get_source_size()
    if not self.source then
        return 0, 0
    end
    return obs.obs_source_get_width(self.source), obs.obs_source_get_height(self.source)
end

-- Convenience wrapper functions
function crop_filter_create(source)
    return CropFilterManager:create(source)
end

function crop_filter_update(x, y, w, h)
    return CropFilterManager:update(x, y, w, h)
end

function crop_filter_reset()
    return CropFilterManager:reset()
end

function crop_filter_cleanup()
    return CropFilterManager:cleanup()
end

function crop_filter_is_ready()
    return CropFilterManager:is_ready()
end

function crop_filter_get_crop()
    return CropFilterManager:get_crop()
end

function crop_filter_get_source_size()
    return CropFilterManager:get_source_size()
end

--================================================
-- MODULE: Source Manager (M08)
--================================================
-- Handles finding sources in scenes, capturing transforms,
-- and managing source state for zoom operations

local SourceManager = {
    source = nil,           -- Current zoom source
    sceneitem = nil,        -- Scene item reference
    scene = nil,            -- Current scene
    original_transform = nil, -- Saved original transform
    source_name = "",       -- Source name for settings
    initialized = false,
}

-- Transform data structure
local TransformData = {
    pos = { x = 0, y = 0 },
    scale = { x = 1.0, y = 1.0 },
    rot = 0,
    bounds_type = 0,
    bounds = { x = 0, y = 0 },
    crop = { left = 0, top = 0, right = 0, bottom = 0 },
}

-- Find a source in a scene (BFS through groups)
function SourceManager:find_sceneitem(scene, source_name)
    if not scene or not source_name then
        return nil
    end

    local scene_source = obs.obs_scene_from_source(scene)
    if not scene_source then
        return nil
    end

    -- BFS queue
    local queue = {}
    table.insert(queue, scene_source)

    while #queue > 0 do
        local current_scene = table.remove(queue, 1)

        -- Iterate through items
        local items = obs.obs_scene_enum_items(current_scene)
        if items then
            for _, item in ipairs(items) do
                local item_source = obs.obs_sceneitem_get_source(item)
                if item_source then
                    local name = obs.obs_source_get_name(item_source)

                    -- Check if this is our target
                    if name == source_name then
                        obs.sceneitem_list_release(items)
                        return item
                    end

                    -- Check if this is a group (nested scene)
                    if obs.obs_source_get_type(item_source) == obs.OBS_SOURCE_TYPE_INPUT then
                        local id = obs.obs_source_get_id(item_source)
                        if id == "group" then
                            local group_scene = obs.obs_group_from_source(item_source)
                            if group_scene then
                                table.insert(queue, group_scene)
                            end
                        end
                    end
                end
            end
            obs.sceneitem_list_release(items)
        end
    end

    return nil
end

-- Capture the current transform of a scene item
function SourceManager:capture_transform(sceneitem)
    if not sceneitem then
        return nil
    end

    local transform = {}

    -- Position
    local pos = obs.vec2()
    obs.obs_sceneitem_get_pos(sceneitem, pos)
    transform.pos = { x = pos.x, y = pos.y }

    -- Scale
    local scale = obs.vec2()
    obs.obs_sceneitem_get_scale(sceneitem, scale)
    transform.scale = { x = scale.x, y = scale.y }

    -- Rotation
    transform.rot = obs.obs_sceneitem_get_rot(sceneitem)

    -- Bounds
    transform.bounds_type = obs.obs_sceneitem_get_bounds_type(sceneitem)
    local bounds = obs.vec2()
    obs.obs_sceneitem_get_bounds(sceneitem, bounds)
    transform.bounds = { x = bounds.x, y = bounds.y }

    -- Crop
    local crop = obs.obs_sceneitem_crop()
    obs.obs_sceneitem_get_crop(sceneitem, crop)
    transform.crop = {
        left = crop.left,
        top = crop.top,
        right = crop.right,
        bottom = crop.bottom
    }

    return transform
end

-- Restore a saved transform to a scene item
function SourceManager:restore_transform(sceneitem, transform)
    if not sceneitem or not transform then
        return false
    end

    -- Position
    local pos = obs.vec2()
    pos.x = transform.pos.x
    pos.y = transform.pos.y
    obs.obs_sceneitem_set_pos(sceneitem, pos)

    -- Scale
    local scale = obs.vec2()
    scale.x = transform.scale.x
    scale.y = transform.scale.y
    obs.obs_sceneitem_set_scale(sceneitem, scale)

    -- Rotation
    obs.obs_sceneitem_set_rot(sceneitem, transform.rot)

    -- Bounds
    obs.obs_sceneitem_set_bounds_type(sceneitem, transform.bounds_type)
    local bounds = obs.vec2()
    bounds.x = transform.bounds.x
    bounds.y = transform.bounds.y
    obs.obs_sceneitem_set_bounds(sceneitem, bounds)

    -- Crop
    local crop = obs.obs_sceneitem_crop()
    crop.left = transform.crop.left
    crop.top = transform.crop.top
    crop.right = transform.crop.right
    crop.bottom = transform.crop.bottom
    obs.obs_sceneitem_set_crop(sceneitem, crop)

    return true
end

-- Initialize with a source name
function SourceManager:init(source_name)
    self:release()  -- Clean up any existing state

    if not source_name or source_name == "" then
        log("SourceManager: No source name provided")
        return false
    end

    self.source_name = source_name

    -- Get current scene
    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then
        log("SourceManager: No current scene")
        return false
    end

    self.scene = scene_source

    -- Find the scene item
    self.sceneitem = self:find_sceneitem(scene_source, source_name)
    if not self.sceneitem then
        log("SourceManager: Source not found in scene: " .. source_name)
        obs.obs_source_release(scene_source)
        return false
    end

    -- Get the source
    self.source = obs.obs_sceneitem_get_source(self.sceneitem)
    if not self.source then
        log("SourceManager: Failed to get source from sceneitem")
        obs.obs_source_release(scene_source)
        return false
    end

    -- Capture original transform
    self.original_transform = self:capture_transform(self.sceneitem)

    -- Create crop filter
    if not crop_filter_create(self.source) then
        log("SourceManager: Failed to create crop filter")
        obs.obs_source_release(scene_source)
        return false
    end

    self.initialized = true
    log("SourceManager: Initialized with source: " .. source_name)

    obs.obs_source_release(scene_source)
    return true
end

-- Release all resources
function SourceManager:release()
    -- Clean up crop filter
    crop_filter_cleanup()

    -- Restore original transform if we have it
    if self.sceneitem and self.original_transform then
        self:restore_transform(self.sceneitem, self.original_transform)
        log("SourceManager: Restored original transform")
    end

    self.source = nil
    self.sceneitem = nil
    self.scene = nil
    self.original_transform = nil
    self.initialized = false

    log("SourceManager: Released")
end

-- Get source dimensions
function SourceManager:get_source_size()
    if not self.source then
        return 0, 0
    end
    return obs.obs_source_get_width(self.source), obs.obs_source_get_height(self.source)
end

-- Check if source is valid
function SourceManager:is_valid()
    return self.initialized and self.source ~= nil and self.sceneitem ~= nil
end

-- Get source info
function SourceManager:get_info()
    if not self:is_valid() then
        return nil
    end

    return {
        name = self.source_name,
        width = obs.obs_source_get_width(self.source),
        height = obs.obs_source_get_height(self.source),
    }
end

-- Get list of available capture sources
function SourceManager.get_available_sources()
    local sources = {}

    -- Get all sources
    local source_list = obs.obs_enum_sources()
    if source_list then
        for _, source in ipairs(source_list) do
            local source_id = obs.obs_source_get_id(source)
            local name = obs.obs_source_get_name(source)

            -- Filter for capture sources
            local is_capture = false
            if source_id == "monitor_capture" or      -- Display capture
               source_id == "window_capture" or       -- Window capture
               source_id == "game_capture" or         -- Game capture
               source_id == "xshm_input" or           -- Linux X11 capture
               source_id == "av_capture_input" then   -- macOS capture
                is_capture = true
            end

            if is_capture then
                table.insert(sources, {
                    name = name,
                    id = source_id,
                })
            end
        end
        obs.source_list_release(source_list)
    end

    return sources
end

-- Convenience wrapper functions
function source_manager_init(source_name)
    return SourceManager:init(source_name)
end

function source_manager_release()
    return SourceManager:release()
end

function source_manager_is_valid()
    return SourceManager:is_valid()
end

function source_manager_get_source()
    return SourceManager.source
end

function source_manager_get_sceneitem()
    return SourceManager.sceneitem
end

function source_manager_get_size()
    return SourceManager:get_source_size()
end

function source_manager_get_available_sources()
    return SourceManager.get_available_sources()
end

--================================================
-- MODULE: Camera Physics (M06)
--================================================
-- Handles camera position calculations, dead zones,
-- and SmoothDamp-based camera movement

local CameraPhysics = {
    -- Smoothed camera position
    pos = { x = 0, y = 0 },

    -- Velocities for SmoothDamp
    vel_x = { val = 0 },
    vel_y = { val = 0 },

    -- Dead zone state
    tracked_pos = { x = 0, y = 0 },
    dead_zone_active = false,

    -- Last camera position (for velocity calculation)
    last_pos = { x = 0, y = 0 },

    -- Monitor offset (for multi-monitor setups)
    monitor_offset = { x = 0, y = 0 },
}

-- Initialize camera tracking with starting position
function CameraPhysics:init(mouse_pos)
    if mouse_pos then
        self.pos.x = mouse_pos.x
        self.pos.y = mouse_pos.y
        self.tracked_pos.x = mouse_pos.x
        self.tracked_pos.y = mouse_pos.y
    end
    self.vel_x.val = 0
    self.vel_y.val = 0
    self.last_pos.x = self.pos.x
    self.last_pos.y = self.pos.y
end

-- Apply dead zone to mouse input
-- Returns the position the camera should track
function CameraPhysics:apply_dead_zone(mouse_pos, dead_zone_radius)
    if not mouse_pos then
        return self.tracked_pos
    end

    if dead_zone_radius <= 0 then
        self.tracked_pos.x = mouse_pos.x
        self.tracked_pos.y = mouse_pos.y
        return self.tracked_pos
    end

    -- Calculate distance from tracked position to mouse
    local dx = mouse_pos.x - self.tracked_pos.x
    local dy = mouse_pos.y - self.tracked_pos.y
    local dist = math.sqrt(dx * dx + dy * dy)

    if dist <= dead_zone_radius then
        -- Mouse is within dead zone, don't move tracked position
        self.dead_zone_active = true
        return self.tracked_pos
    end

    -- Mouse is outside dead zone
    -- Move tracked position so it stays exactly dead_zone_radius from mouse
    self.dead_zone_active = false
    local excess = dist - dead_zone_radius
    local nx = dx / dist  -- Normalized direction
    local ny = dy / dist

    self.tracked_pos.x = self.tracked_pos.x + nx * excess
    self.tracked_pos.y = self.tracked_pos.y + ny * excess

    return self.tracked_pos
end

-- Smooth the input position using SmoothDamp
function CameraPhysics:smooth_input(target_pos, smooth_time, dt)
    if not target_pos then
        return self.pos
    end

    local max_speed = 100000  -- Very high max speed for smooth camera

    self.pos.x = SmoothDamp(self.pos.x, target_pos.x, self.vel_x, smooth_time, max_speed, dt)
    self.pos.y = SmoothDamp(self.pos.y, target_pos.y, self.vel_y, smooth_time, max_speed, dt)

    return self.pos
end

-- Calculate the crop rectangle for a given zoom level and center position
function CameraPhysics:compute_crop(center_x, center_y, zoom_level, source_w, source_h)
    if zoom_level <= 1.0 then
        -- No zoom, return full source
        return {
            x = 0,
            y = 0,
            w = source_w,
            h = source_h,
        }
    end

    -- Calculate crop dimensions
    local crop_w = source_w / zoom_level
    local crop_h = source_h / zoom_level

    -- Center the crop on the target position
    local crop_x = center_x - crop_w / 2
    local crop_y = center_y - crop_h / 2

    -- Clamp to source bounds
    crop_x = clamp(0, source_w - crop_w, crop_x)
    crop_y = clamp(0, source_h - crop_h, crop_y)

    return {
        x = crop_x,
        y = crop_y,
        w = crop_w,
        h = crop_h,
    }
end

-- Calculate target crop for zoom animation
-- mouse_pos: current mouse position
-- zoom_level: target zoom level
-- source_w, source_h: source dimensions
-- monitor_offset: offset for multi-monitor (optional)
function CameraPhysics:get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
    if not mouse_pos then
        return nil
    end

    -- Apply monitor offset if provided
    local target_x = mouse_pos.x
    local target_y = mouse_pos.y

    if monitor_offset then
        target_x = target_x - monitor_offset.x
        target_y = target_y - monitor_offset.y
    end

    -- Clamp to source bounds
    target_x = clamp(0, source_w, target_x)
    target_y = clamp(0, source_h, target_y)

    return self:compute_crop(target_x, target_y, zoom_level, source_w, source_h)
end

-- Interpolate between two crop rectangles
function CameraPhysics:lerp_crop(start_crop, end_crop, t, easing_fn)
    if not start_crop or not end_crop then
        return nil
    end

    t = clamp(0, 1, t)

    -- Apply easing
    local eased_t = easing_fn and easing_fn(t) or t

    return {
        x = lerp(start_crop.x, end_crop.x, eased_t),
        y = lerp(start_crop.y, end_crop.y, eased_t),
        w = lerp(start_crop.w, end_crop.w, eased_t),
        h = lerp(start_crop.h, end_crop.h, eased_t),
    }
end

-- Get camera velocity (for motion blur)
function CameraPhysics:get_velocity()
    return {
        x = self.pos.x - self.last_pos.x,
        y = self.pos.y - self.last_pos.y,
    }
end

-- Update last position (call at end of frame)
function CameraPhysics:update_last_pos()
    self.last_pos.x = self.pos.x
    self.last_pos.y = self.pos.y
end

-- Set monitor offset
function CameraPhysics:set_monitor_offset(offset)
    self.monitor_offset = offset or { x = 0, y = 0 }
end

-- Reset camera state
function CameraPhysics:reset()
    self.pos = { x = 0, y = 0 }
    self.vel_x = { val = 0 }
    self.vel_y = { val = 0 }
    self.tracked_pos = { x = 0, y = 0 }
    self.dead_zone_active = false
    self.last_pos = { x = 0, y = 0 }
end

-- Convenience wrapper functions
function camera_physics_init(mouse_pos)
    return CameraPhysics:init(mouse_pos)
end

function camera_physics_apply_dead_zone(mouse_pos, dead_zone_radius)
    return CameraPhysics:apply_dead_zone(mouse_pos, dead_zone_radius)
end

function camera_physics_smooth_input(target_pos, smooth_time, dt)
    return CameraPhysics:smooth_input(target_pos, smooth_time, dt)
end

function camera_physics_compute_crop(center_x, center_y, zoom_level, source_w, source_h)
    return CameraPhysics:compute_crop(center_x, center_y, zoom_level, source_w, source_h)
end

function camera_physics_get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
    return CameraPhysics:get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
end

function camera_physics_lerp_crop(start_crop, end_crop, t, easing_fn)
    return CameraPhysics:lerp_crop(start_crop, end_crop, t, easing_fn)
end

function camera_physics_get_velocity()
    return CameraPhysics:get_velocity()
end

function camera_physics_update_last_pos()
    return CameraPhysics:update_last_pos()
end

function camera_physics_reset()
    return CameraPhysics:reset()
end

--================================================
-- MODULE: Timer & Main Loop (M09)
--================================================
-- Core integration module that handles frame-by-frame updates,
-- input processing, state machine updates, and output

-- Configuration (will be populated from settings)
local cfg = {
    source_name = "",
    zoom_value = 2.0,
    max_zoom = 10.0,
    zoom_duration = 0.6,
    zoom_overshoot = 0.0,
    zoom_easing = "Cubic.Out",

    auto_follow = true,
    follow_smooth_time = 0.15,
    follow_dead_zone = 5,

    debug_logs = false,
}

-- Timing
local last_tick_time = 0
local timer_running = false

-- Frame diff tracking (skip updates if nothing changed)
local last_output = { x = -1, y = -1, w = -1, h = -1 }

-- Original crop for zoom out
local original_crop = { x = 0, y = 0, w = 0, h = 0 }

-- Hotkey IDs
local hotkey_toggle_zoom = nil
local hotkey_toggle_follow = nil

-- Get reliable delta time
local function get_dt()
    local now = os.clock()
    local dt = now - last_tick_time
    last_tick_time = now
    return clamp(0.001, 0.1, dt)  -- Guard against freezes and div/zero
end

-- Start the timer
local function start_timer()
    if not timer_running then
        timer_running = true
        last_tick_time = os.clock()
        -- Use frame-synced interval
        local interval = 16  -- Default to ~60fps
        obs.timer_add(on_timer, interval)
        log("Timer: Started")
    end
end

-- Stop the timer
local function stop_timer()
    if timer_running then
        timer_running = false
        obs.timer_remove(on_timer)
        log("Timer: Stopped")
    end
end

-- Initialize mouse tracking
local function init_mouse_tracking(mouse_pos)
    camera_physics_init(mouse_pos)
    original_crop = {
        x = 0,
        y = 0,
        w = 0,
        h = 0,
    }
end

-- Main timer callback
function on_timer()
    local dt = get_dt()

    -- Guard: No valid source
    if not source_manager_is_valid() then
        return
    end

    --==========================
    -- 1. INPUT
    --==========================
    local raw_mouse = platform_get_mouse_pos()

    --==========================
    -- 2. STATE MACHINE UPDATE
    --==========================
    if SM:is_animating() then
        SM.zoom_time = SM.zoom_time + (dt / cfg.zoom_duration)

        -- Check for completion
        if SM.zoom_time >= 1.0 then
            SM:complete()

            -- Auto-enable follow after zoom in
            if SM.state == ZoomState.ZOOMED_IN and cfg.auto_follow then
                SM.following = true
            end

            -- Stop timer if idle
            if SM.state == ZoomState.IDLE then
                stop_timer()
            end
        end
    end

    --==========================
    -- 3. CAMERA POSITION
    --==========================
    local crop = nil
    local source_w, source_h = source_manager_get_size()

    if source_w == 0 or source_h == 0 then
        return
    end

    if SM:is_animating() then
        -- Animate between start and target crop
        local easing_fn = Easing.get(cfg.zoom_easing, cfg.zoom_overshoot)
        crop = camera_physics_lerp_crop(SM.start_crop, SM.target_crop, SM.zoom_time, easing_fn)
    elseif SM:is_zoomed() and SM.following then
        -- Follow mouse with dead zone and smoothing
        local tracked = camera_physics_apply_dead_zone(raw_mouse, cfg.follow_dead_zone)
        local smoothed = camera_physics_smooth_input(tracked, cfg.follow_smooth_time, dt)
        crop = camera_physics_compute_crop(smoothed.x, smoothed.y, SM.zoom_level, source_w, source_h)
        camera_physics_update_last_pos()
    elseif SM:is_zoomed() then
        -- Static zoom (not following)
        crop = camera_physics_get_target_crop(
            { x = SM.target_crop.x + SM.target_crop.w / 2, y = SM.target_crop.y + SM.target_crop.h / 2 },
            SM.zoom_level, source_w, source_h, nil
        )
    end

    --==========================
    -- 4. OUTPUT (Diff-based)
    --==========================
    if crop then
        local cx = math.floor(crop.x)
        local cy = math.floor(crop.y)
        local cw = math.floor(crop.w)
        local ch = math.floor(crop.h)

        if cx ~= last_output.x or cy ~= last_output.y or
           cw ~= last_output.w or ch ~= last_output.h then
            crop_filter_update(cx, cy, cw, ch)
            last_output.x = cx
            last_output.y = cy
            last_output.w = cw
            last_output.h = ch
        end
    end
end

--==========================
-- HOTKEY HANDLERS
--==========================

function on_toggle_zoom(pressed)
    if not pressed then return end

    if not source_manager_is_valid() then
        log("Toggle Zoom: No valid source")
        return
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        log("Toggle Zoom: Invalid source dimensions")
        return
    end

    if SM.state == ZoomState.IDLE then
        -- ZOOM IN
        local mouse = platform_get_mouse_pos()
        init_mouse_tracking(mouse)

        -- Store original crop
        original_crop = { x = 0, y = 0, w = source_w, h = source_h }

        -- Calculate target crop
        local target_crop = camera_physics_get_target_crop(mouse, cfg.zoom_value, source_w, source_h, nil)

        SM:transition(ZoomState.ZOOMING_IN, {
            start_crop = original_crop,
            target_crop = target_crop,
            target_level = cfg.zoom_value
        })

        start_timer()

    elseif SM.state == ZoomState.ZOOMED_IN then
        -- ZOOM OUT
        SM.following = false

        local current = crop_filter_get_crop()
        SM:transition(ZoomState.ZOOMING_OUT, {
            start_crop = current,
            target_crop = original_crop,
            target_level = 1.0
        })

        start_timer()
    end
    -- Ignore if already animating (guard against rapid presses)
end

function on_toggle_follow(pressed)
    if not pressed then return end
    if not SM:is_zoomed() then return end

    SM.following = not SM.following
    log("Follow: " .. tostring(SM.following))

    if SM.following and not timer_running then
        start_timer()
    end
end

--==========================
-- HOTKEY REGISTRATION
--==========================

local function register_hotkeys(settings)
    -- Toggle Zoom hotkey
    hotkey_toggle_zoom = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.toggle_zoom",
        "Toggle Zoom to Mouse",
        on_toggle_zoom
    )

    -- Toggle Follow hotkey
    hotkey_toggle_follow = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.toggle_follow",
        "Toggle Mouse Follow",
        on_toggle_follow
    )

    -- Load saved hotkey bindings
    local toggle_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.toggle_zoom")
    if toggle_array then
        obs.obs_hotkey_load(hotkey_toggle_zoom, toggle_array)
        obs.obs_data_array_release(toggle_array)
    end

    local follow_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.toggle_follow")
    if follow_array then
        obs.obs_hotkey_load(hotkey_toggle_follow, follow_array)
        obs.obs_data_array_release(follow_array)
    end

    -- Register scroll zoom hotkeys
    register_scroll_hotkeys(settings)

    log("Hotkeys: Registered")
end

local function save_hotkeys(settings)
    if hotkey_toggle_zoom then
        local array = obs.obs_hotkey_save(hotkey_toggle_zoom)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.toggle_zoom", array)
        obs.obs_data_array_release(array)
    end

    if hotkey_toggle_follow then
        local array = obs.obs_hotkey_save(hotkey_toggle_follow)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.toggle_follow", array)
        obs.obs_data_array_release(array)
    end

    -- Save scroll zoom hotkeys
    save_scroll_hotkeys(settings)
end

local function unregister_hotkeys()
    if hotkey_toggle_zoom then
        obs.obs_hotkey_unregister(hotkey_toggle_zoom)
        hotkey_toggle_zoom = nil
    end
    if hotkey_toggle_follow then
        obs.obs_hotkey_unregister(hotkey_toggle_follow)
        hotkey_toggle_follow = nil
    end
    -- Unregister scroll zoom hotkeys
    unregister_scroll_hotkeys()
    log("Hotkeys: Unregistered")
end

--==========================
-- SCENE EVENT HANDLERS
--==========================

function on_frontend_event(event)
    if event == obs.OBS_FRONTEND_EVENT_SCENE_CHANGED then
        -- Scene changed, re-acquire source
        log("Event: Scene changed")

        -- Handle scene memory
        scene_memory_on_scene_change()

        if cfg.source_name and cfg.source_name ~= "" then
            source_manager_release()
            source_manager_init(cfg.source_name)
        end
    elseif event == obs.OBS_FRONTEND_EVENT_EXIT then
        -- OBS is closing
        log("Event: OBS exiting")
        stop_timer()
        source_manager_release()
    end
end

--==========================
-- CONFIGURATION UPDATE
--==========================

local function update_config(settings)
    cfg.source_name = obs.obs_data_get_string(settings, "source") or ""
    cfg.zoom_value = obs.obs_data_get_double(settings, "zoom_value")
    cfg.zoom_duration = obs.obs_data_get_double(settings, "zoom_duration")
    cfg.zoom_overshoot = obs.obs_data_get_double(settings, "zoom_overshoot")
    cfg.zoom_easing = obs.obs_data_get_string(settings, "zoom_easing") or "Cubic.Out"

    cfg.auto_follow = obs.obs_data_get_bool(settings, "auto_follow")
    cfg.follow_smooth_time = obs.obs_data_get_double(settings, "follow_smooth_time")
    cfg.follow_dead_zone = obs.obs_data_get_int(settings, "follow_dead_zone")

    cfg.debug_logs = obs.obs_data_get_bool(settings, "debug_logs")
    debug_logs = cfg.debug_logs

    -- Update scroll zoom config
    update_scroll_config(settings)

    -- Check if source changed
    local current_source = source_manager_is_valid() and cfg.source_name
    if cfg.source_name ~= "" and cfg.source_name ~= current_source then
        -- Reset state and reinitialize
        SM:reset()
        stop_timer()
        source_manager_release()
        source_manager_init(cfg.source_name)
    end
end

--================================================
-- MODULE: Scroll Zoom (M10)
--================================================
-- Enables gradual zoom control via scroll wheel with modifier key
-- Provides dynamic zoom level adjustment during zoomed state

local ScrollZoom = {
    -- Hotkey IDs for scroll zoom
    hotkey_scroll_up = nil,
    hotkey_scroll_down = nil,

    -- Configuration (populated from settings)
    scroll_step = 0.25,
    scroll_modifier = "ctrl",  -- "ctrl", "alt", "shift"
}

-- Check if modifier key is held
local function is_modifier_held()
    if ScrollZoom.scroll_modifier == "ctrl" then
        return platform_is_ctrl_held()
    elseif ScrollZoom.scroll_modifier == "alt" then
        return platform_is_alt_held()
    elseif ScrollZoom.scroll_modifier == "shift" then
        return platform_is_shift_held()
    end
    return false
end

-- Handle scroll zoom in
function on_scroll_zoom_up(pressed)
    if not pressed then return end
    on_scroll_zoom(1)
end

-- Handle scroll zoom out
function on_scroll_zoom_down(pressed)
    if not pressed then return end
    on_scroll_zoom(-1)
end

-- Main scroll zoom handler
function on_scroll_zoom(direction)
    -- Check if we can scroll
    if not SM:can_scroll() then return end

    -- Check modifier (optional - can be configured)
    -- For now, we rely on OBS hotkey bindings which can include modifiers

    if not source_manager_is_valid() then
        log("Scroll Zoom: No valid source")
        return
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        return
    end

    -- Calculate new zoom level
    local step = ScrollZoom.scroll_step * direction  -- e.g., 0.25
    local new_level

    if SM.state == ZoomState.IDLE then
        -- Starting from unzoomed
        new_level = 1.0 + step
    else
        -- Already zoomed, adjust level
        new_level = SM.target_level + step
    end

    -- Clamp to valid range
    new_level = clamp(1.0, cfg.max_zoom, new_level)

    -- If we hit 1.0, fully zoom out
    if new_level <= 1.0 then
        if SM:is_zoomed() then
            -- Trigger full zoom out
            local current = crop_filter_get_crop()
            SM.following = false
            SM:transition(ZoomState.ZOOMING_OUT, {
                start_crop = current,
                target_crop = original_crop,
                target_level = 1.0
            })
            start_timer()
        end
        return
    end

    -- Get current mouse position
    local mouse = platform_get_mouse_pos()

    -- Calculate new target crop for new zoom level
    local target_crop = camera_physics_get_target_crop(mouse, new_level, source_w, source_h, nil)

    -- Get current crop as start
    local start_crop
    if SM:is_animating() then
        -- Use current interpolated crop
        start_crop = crop_filter_get_crop()
    elseif SM:is_zoomed() then
        -- Use current crop
        start_crop = crop_filter_get_crop()
    else
        -- Starting from unzoomed
        start_crop = { x = 0, y = 0, w = source_w, h = source_h }
        original_crop = start_crop
        camera_physics_init(mouse)
    end

    -- Transition to new zoom level
    if SM.state == ZoomState.IDLE then
        -- First scroll from unzoomed
        SM:transition(ZoomState.SCROLLING, {
            start_crop = start_crop,
            target_crop = target_crop,
            target_level = new_level
        })
    else
        -- Already zoomed, adjust level (interrupt current animation)
        SM:transition(ZoomState.SCROLLING, {
            start_crop = start_crop,
            target_crop = target_crop,
            target_level = new_level
        })
    end

    start_timer()
    log("Scroll Zoom: Level " .. string.format("%.2f", new_level))
end

-- Zoom to a specific level (for API calls)
function on_scroll_zoom_to(level)
    if not source_manager_is_valid() then return end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then return end

    level = clamp(1.0, cfg.max_zoom, level)

    if level <= 1.0 then
        -- Zoom out
        if SM:is_zoomed() then
            local current = crop_filter_get_crop()
            SM.following = false
            SM:transition(ZoomState.ZOOMING_OUT, {
                start_crop = current,
                target_crop = original_crop,
                target_level = 1.0
            })
            start_timer()
        end
        return
    end

    local mouse = platform_get_mouse_pos()
    local target_crop = camera_physics_get_target_crop(mouse, level, source_w, source_h, nil)

    local start_crop
    if SM:is_zoomed() then
        start_crop = crop_filter_get_crop()
    else
        start_crop = { x = 0, y = 0, w = source_w, h = source_h }
        original_crop = start_crop
        camera_physics_init(mouse)
    end

    SM:transition(ZoomState.SCROLLING, {
        start_crop = start_crop,
        target_crop = target_crop,
        target_level = level
    })

    start_timer()
end

-- Register scroll zoom hotkeys
local function register_scroll_hotkeys(settings)
    -- Scroll Up hotkey
    ScrollZoom.hotkey_scroll_up = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.scroll_up",
        "Zoom In (Scroll)",
        on_scroll_zoom_up
    )

    -- Scroll Down hotkey
    ScrollZoom.hotkey_scroll_down = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.scroll_down",
        "Zoom Out (Scroll)",
        on_scroll_zoom_down
    )

    -- Load saved bindings
    local up_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.scroll_up")
    if up_array then
        obs.obs_hotkey_load(ScrollZoom.hotkey_scroll_up, up_array)
        obs.obs_data_array_release(up_array)
    end

    local down_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.scroll_down")
    if down_array then
        obs.obs_hotkey_load(ScrollZoom.hotkey_scroll_down, down_array)
        obs.obs_data_array_release(down_array)
    end

    log("Scroll Zoom: Hotkeys registered")
end

-- Save scroll hotkey bindings
local function save_scroll_hotkeys(settings)
    if ScrollZoom.hotkey_scroll_up then
        local array = obs.obs_hotkey_save(ScrollZoom.hotkey_scroll_up)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.scroll_up", array)
        obs.obs_data_array_release(array)
    end

    if ScrollZoom.hotkey_scroll_down then
        local array = obs.obs_hotkey_save(ScrollZoom.hotkey_scroll_down)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.scroll_down", array)
        obs.obs_data_array_release(array)
    end
end

-- Unregister scroll hotkeys
local function unregister_scroll_hotkeys()
    if ScrollZoom.hotkey_scroll_up then
        obs.obs_hotkey_unregister(ScrollZoom.hotkey_scroll_up)
        ScrollZoom.hotkey_scroll_up = nil
    end
    if ScrollZoom.hotkey_scroll_down then
        obs.obs_hotkey_unregister(ScrollZoom.hotkey_scroll_down)
        ScrollZoom.hotkey_scroll_down = nil
    end
end

-- Update scroll zoom config
local function update_scroll_config(settings)
    ScrollZoom.scroll_step = obs.obs_data_get_double(settings, "scroll_step")
    ScrollZoom.scroll_modifier = obs.obs_data_get_string(settings, "scroll_modifier") or "ctrl"
end

--================================================
-- PLACEHOLDER: Future Modules
--================================================

-- M01: Configuration & Settings (TODO)
-- M05: Scene Manager (TODO)
-- M06: Source Manager (TODO)
-- M07: Crop/Zoom Controller (TODO)
-- M08: Motion Tracker (TODO)
-- M09: Face Detection (TODO)
-- M11: Audio Reactor (TODO)
-- M12: Transition Manager (TODO)
-- M13: Animation Controller (TODO)
-- M14: Preset Manager (TODO)
-- M15: Hotkey Manager (TODO)
-- M16: UI Components (TODO)
-- M17: Timer/Scheduler (TODO)
-- M18: State Machine (TODO)
-- M19: Performance Monitor (TODO)

--================================================
-- SCRIPT SETTINGS
--================================================
local settings = {}

-- Default settings
local defaults = {
    debug_logging = false,
    easing_type = "QuadInOut",
    smooth_time = 0.3,
    max_speed = 100.0
}

--================================================
-- MODULE: Preset Manager (M13)
--================================================
-- Manages built-in and custom animation presets

local PresetManager = {
    -- Built-in presets (read-only)
    built_in = {
        {
            name = "Smooth",
            duration = 0.8,
            overshoot = 0.0,
            smoothness = 0.25,
            easing = "Cubic.Out",
        },
        {
            name = "Bounce",
            duration = 0.6,
            overshoot = 0.35,
            smoothness = 0.15,
            easing = "Back.Out",
        },
        {
            name = "Snappy",
            duration = 0.3,
            overshoot = 0.0,
            smoothness = 0.05,
            easing = "Expo.Out",
        },
        {
            name = "Cinematic",
            duration = 1.2,
            overshoot = 0.05,
            smoothness = 0.4,
            easing = "Sine.Out",
        },
    },

    -- Custom user presets
    custom = {},

    -- Currently selected preset name
    current_preset = "Smooth",
}

-- Get all preset names (built-in + custom)
function PresetManager:get_all_names()
    local names = {}

    -- Add built-in presets
    for _, preset in ipairs(self.built_in) do
        table.insert(names, preset.name)
    end

    -- Add custom presets
    for name, _ in pairs(self.custom) do
        table.insert(names, name)
    end

    table.sort(names)
    return names
end

-- Get preset by name
function PresetManager:get_preset(name)
    -- Check built-in first
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            return preset
        end
    end

    -- Check custom
    if self.custom[name] then
        return self.custom[name]
    end

    -- Default to Smooth
    return self.built_in[1]
end

-- Apply preset to configuration
function PresetManager:apply_preset(name)
    local preset = self:get_preset(name)
    if not preset then
        log("Preset: Unknown preset: " .. name)
        return false
    end

    cfg.zoom_duration = preset.duration
    cfg.zoom_overshoot = preset.overshoot
    cfg.follow_smooth_time = preset.smoothness

    if preset.easing then
        cfg.zoom_easing = preset.easing
    end

    self.current_preset = name
    log("Preset: Applied '" .. name .. "'")
    return true
end

-- Save a custom preset
function PresetManager:save_preset(name, duration, overshoot, smoothness, easing)
    if not name or name == "" then
        return false
    end

    -- Check if it's a built-in preset (can't override)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            log("Preset: Cannot override built-in preset: " .. name)
            return false
        end
    end

    -- Save custom preset
    self.custom[name] = {
        name = name,
        duration = duration or cfg.zoom_duration,
        overshoot = overshoot or cfg.zoom_overshoot,
        smoothness = smoothness or cfg.follow_smooth_time,
        easing = easing or cfg.zoom_easing,
    }

    log("Preset: Saved custom preset '" .. name .. "'")
    return true
end

-- Delete a custom preset
function PresetManager:delete_preset(name)
    -- Check if it's a built-in preset (can't delete)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            log("Preset: Cannot delete built-in preset: " .. name)
            return false
        end
    end

    -- Delete custom preset
    if self.custom[name] then
        self.custom[name] = nil
        log("Preset: Deleted custom preset '" .. name .. "'")
        return true
    end

    return false
end

-- Check if a preset is built-in
function PresetManager:is_built_in(name)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            return true
        end
    end
    return false
end

-- Persist custom presets to settings
function PresetManager:persist(settings)
    local array = obs.obs_data_array_create()

    for name, preset in pairs(self.custom) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "name", name)
        obs.obs_data_set_double(item, "duration", preset.duration)
        obs.obs_data_set_double(item, "overshoot", preset.overshoot)
        obs.obs_data_set_double(item, "smoothness", preset.smoothness)
        obs.obs_data_set_string(item, "easing", preset.easing)
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "custom_presets", array)
    obs.obs_data_array_release(array)
end

-- Load custom presets from settings
function PresetManager:load(settings)
    self.custom = {}

    local array = obs.obs_data_get_array(settings, "custom_presets")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local name = obs.obs_data_get_string(item, "name")

        if name and name ~= "" then
            self.custom[name] = {
                name = name,
                duration = obs.obs_data_get_double(item, "duration"),
                overshoot = obs.obs_data_get_double(item, "overshoot"),
                smoothness = obs.obs_data_get_double(item, "smoothness"),
                easing = obs.obs_data_get_string(item, "easing"),
            }
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)
    log("Preset: Loaded " .. self:get_custom_count() .. " custom presets")
end

-- Get count of custom presets
function PresetManager:get_custom_count()
    local count = 0
    for _, _ in pairs(self.custom) do
        count = count + 1
    end
    return count
end

-- Get current preset name
function PresetManager:get_current_name()
    return self.current_preset
end

-- Set current preset name
function PresetManager:set_current_name(name)
    self.current_preset = name
end

-- Check if current preset is custom
function PresetManager:is_current_custom()
    return not self:is_built_in(self.current_preset)
end

-- Global convenience functions
function preset_get_all_names()
    return PresetManager:get_all_names()
end

function preset_apply(name)
    return PresetManager:apply_preset(name)
end

function preset_save(name, duration, overshoot, smoothness, easing)
    return PresetManager:save_preset(name, duration, overshoot, smoothness, easing)
end

function preset_delete(name)
    return PresetManager:delete_preset(name)
end

function preset_is_built_in(name)
    return PresetManager:is_built_in(name)
end

function preset_get_current()
    return PresetManager:get_current_name()
end

--================================================
-- MODULE: Auto Source Detection (M11)
--================================================
-- Automatically detects and selects the best zoom source on first run

local AutoSourceDetector = {
    -- Source type priorities (higher = more likely to be the main display)
    type_priorities = {
        ["monitor_capture"] = 100,     -- Display capture (highest priority)
        ["game_capture"] = 80,          -- Game capture
        ["window_capture"] = 60,        -- Window capture
        ["xshm_input"] = 40,           -- Linux X11 capture
        ["av_capture_input"] = 20,     -- macOS capture
    },

    -- Whether auto-detection has been run
    auto_detected = false,
}

-- Get all capture sources sorted by priority
function AutoSourceDetector:get_capture_sources()
    local sources = {}
    local source_list = obs.obs_enum_sources()

    if not source_list then
        return sources
    end

    for _, source in ipairs(source_list) do
        local source_id = obs.obs_source_get_id(source)
        local name = obs.obs_source_get_name(source)

        -- Check if it's a capture source
        local priority = self.type_priorities[source_id]
        if priority then
            table.insert(sources, {
                name = name,
                id = source_id,
                priority = priority,
            })
        end
    end

    obs.source_list_release(source_list)

    -- Sort by priority (highest first)
    table.sort(sources, function(a, b)
        return a.priority > b.priority
    end)

    return sources
end

-- Auto-detect the best source
function AutoSourceDetector:auto_detect()
    local sources = self:get_capture_sources()

    if #sources == 0 then
        log("AutoSource: No capture sources found")
        return nil
    end

    if #sources == 1 then
        -- Only one source, use it
        log("AutoSource: Found single source: " .. sources[1].name)
        return sources[1].name
    end

    -- Multiple sources - prioritize by type
    -- Prefer monitor_capture > game_capture > window_capture
    local best = sources[1]

    log("AutoSource: Found " .. #sources .. " sources, selecting: " .. best.name)
    return best.name
end

-- Get monitor geometry from a source (if available)
function AutoSourceDetector:get_monitor_geometry(source_name)
    local source = obs.obs_get_source_by_name(source_name)
    if not source then
        return nil
    end

    local settings = obs.obs_source_get_settings(source)
    if not settings then
        obs.obs_source_release(source)
        return nil
    end

    -- Try to get monitor info from settings
    local monitor = obs.obs_data_get_int(settings, "monitor")
    local x = obs.obs_data_get_int(settings, "x")
    local y = obs.obs_data_get_int(settings, "y")
    local width = obs.obs_data_get_int(settings, "width")
    local height = obs.obs_data_get_int(settings, "height")

    obs.obs_data_release(settings)
    obs.obs_source_release(source)

    -- Return geometry if available
    if monitor >= 0 or width > 0 then
        return {
            monitor = monitor,
            x = x,
            y = y,
            width = width or 1920,
            height = height or 1080,
        }
    end

    return nil
end

-- Check if we should auto-detect on first run
function AutoSourceDetector:should_auto_detect(settings)
    -- Check if source has ever been set
    local last_source = obs.obs_data_get_string(settings, "source")
    if last_source and last_source ~= "" then
        return false
    end

    -- Check if auto-detect has been done
    return not self.auto_detected
end

-- Run auto-detection and return the source name
function AutoSourceDetector:run(settings)
    local source_name = self:auto_detect()

    if source_name then
        -- Save the detected source
        obs.obs_data_set_string(settings, "source", source_name)
        self.auto_detected = true
    end

    return source_name
end

-- Global convenience functions
function auto_source_detect()
    return AutoSourceDetector:auto_detect()
end

function auto_source_should_detect(settings)
    return AutoSourceDetector:should_auto_detect(settings)
end

function auto_source_run(settings)
    return AutoSourceDetector:run(settings)
end

--================================================
-- MODULE: Scene Memory (M12)
--================================================
-- Remembers which zoom source to use for each OBS scene

local SceneMemory = {
    -- Scene to source mapping
    scene_source_map = {},

    -- Maximum number of mappings to store
    max_mappings = 50,
}

-- Get the current scene name
function SceneMemory:get_current_scene_name()
    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then
        return nil
    end

    local name = obs.obs_source_get_name(scene_source)
    obs.obs_source_release(scene_source)
    return name
end

-- Get the source to use for the current scene
function SceneMemory:get_source_for_current_scene()
    local scene_name = self:get_current_scene_name()
    if not scene_name then
        return nil
    end

    -- 1. Check explicit mapping for this scene
    if self.scene_source_map[scene_name] then
        return self.scene_source_map[scene_name]
    end

    -- 2. Fall back to global source from config
    return cfg.source_name
end

-- Set the source for a specific scene
function SceneMemory:set(scene_name, source_name)
    if not scene_name or scene_name == "" then
        return false
    end

    -- Check if we're at capacity
    local count = 0
    for _, _ in pairs(self.scene_source_map) do
        count = count + 1
    end

    if count >= self.max_mappings and not self.scene_source_map[scene_name] then
        log("SceneMemory: At capacity (" .. self.max_mappings .. "), cannot add: " .. scene_name)
        return false
    end

    self.scene_source_map[scene_name] = source_name
    log("SceneMemory: " .. scene_name .. " Ã¢â€ â€™ " .. source_name)
    return true
end

-- Remove a scene mapping
function SceneMemory:remove(scene_name)
    if self.scene_source_map[scene_name] then
        self.scene_source_map[scene_name] = nil
        log("SceneMemory: Removed mapping for " .. scene_name)
        return true
    end
    return false
end

-- Get all scene mappings
function SceneMemory:get_all()
    local mappings = {}
    for scene, source in pairs(self.scene_source_map) do
        table.insert(mappings, { scene = scene, source = source })
    end
    table.sort(mappings, function(a, b)
        return a.scene < b.scene
    end)
    return mappings
end

-- Check if a scene has a mapping
function SceneMemory:has_mapping(scene_name)
    return self.scene_source_map[scene_name] ~= nil
end

-- Persist mappings to settings
function SceneMemory:persist(settings)
    local array = obs.obs_data_array_create()

    for scene, source in pairs(self.scene_source_map) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "scene", scene)
        obs.obs_data_set_string(item, "source", source)
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "scene_source_map", array)
    obs.obs_data_array_release(array)
end

-- Load mappings from settings
function SceneMemory:load(settings)
    self.scene_source_map = {}

    local array = obs.obs_data_get_array(settings, "scene_source_map")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local scene = obs.obs_data_get_string(item, "scene")
        local source = obs.obs_data_get_string(item, "source")

        if scene and scene ~= "" and source and source ~= "" then
            self.scene_source_map[scene] = source
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)

    local count = 0
    for _, _ in pairs(self.scene_source_map) do count = count + 1 end
    log("SceneMemory: Loaded " .. count .. " scene mappings")
end

-- Handle scene change
function SceneMemory:on_scene_change()
    local scene_name = self:get_current_scene_name()
    if not scene_name then
        return
    end

    -- Get the source for this scene
    local source_name = self:get_source_for_current_scene()

    if source_name and source_name ~= "" then
        -- Check if source changed
        local current = source_manager_is_valid() and cfg.source_name

        if source_name ~= current then
            log("SceneMemory: Scene changed to " .. scene_name)

            -- Release current source
            source_manager_release()

            -- Initialize with new source
            cfg.source_name = source_name
            source_manager_init(source_name)
        end
    end
end

-- Global convenience functions
function scene_memory_get_source()
    return SceneMemory:get_source_for_current_scene()
end

function scene_memory_set(scene_name, source_name)
    return SceneMemory:set(scene_name, source_name)
end

function scene_memory_remove(scene_name)
    return SceneMemory:remove(scene_name)
end

function scene_memory_get_all()
    return SceneMemory:get_all()
end

function scene_memory_on_scene_change()
    return SceneMemory:on_scene_change()
end

--================================================
-- MODULE: Blur Manager (M14)
--================================================
-- Provides built-in blur effects without external plugins
-- Supports multiple strategies: shader, composite_blur plugin, or none

local BlurManager = {
    -- Current strategy: "shader", "composite_blur", "none"
    strategy = "none",

    -- Filter references
    zoom_blur_filter = nil,
    motion_blur_filter = nil,

    -- Settings references
    zoom_blur_settings = nil,
    motion_blur_settings = nil,

    -- State
    initialized = false,

    -- Configuration
    zoom_blur_enabled = false,
    zoom_blur_intensity = 5,
    zoom_blur_clear_radius = 150,
    motion_blur_enabled = false,
    motion_blur_intensity = 1.0,
}

-- Try to use custom shader (if effect files exist)
function BlurManager:try_shader_strategy(source)
    -- This would require .effect files in assets/shaders/
    -- For now, we'll use a simpler approach
    log("Blur: Shader strategy not implemented (requires effect files)")
    return false
end

-- Try to auto-create Composite Blur filters
function BlurManager:try_composite_blur_strategy(source)
    if not source then return false end

    -- Check if composite_blur filter type exists
    local test_filter = obs.obs_source_create_private("composite_blur", "__test_blur__", nil)
    if test_filter then
        obs.obs_source_release(test_filter)
    else
        log("Blur: Composite Blur plugin not available")
        return false
    end

    -- Create Zoom Blur filter
    local zs = obs.obs_data_create()
    obs.obs_data_set_double(zs, "radius", 0)
    obs.obs_data_set_int(zs, "blur_type", 2) -- Zoom type
    self.zoom_blur_filter = obs.obs_source_create_private(
        "composite_blur",
        FILTER_PREFIX .. "Zoom Blur",
        zs
    )

    if self.zoom_blur_filter then
        obs.obs_source_filter_add(source, self.zoom_blur_filter)
        self.zoom_blur_settings = zs
    else
        obs.obs_data_release(zs)
        return false
    end

    -- Create Motion Blur filter
    local ms = obs.obs_data_create()
    obs.obs_data_set_double(ms, "radius", 0)
    obs.obs_data_set_int(ms, "blur_type", 3) -- Motion/directional type
    self.motion_blur_filter = obs.obs_source_create_private(
        "composite_blur",
        FILTER_PREFIX .. "Motion Blur",
        ms
    )

    if self.motion_blur_filter then
        obs.obs_source_filter_add(source, self.motion_blur_filter)
        self.motion_blur_settings = ms
    else
        obs.obs_data_release(ms)
    end

    self.initialized = true
    return true
end

-- Initialize blur manager
function BlurManager:init(source)
    if not source then
        return false
    end

    self:cleanup()

    -- Try composite_blur strategy
    if self:try_composite_blur_strategy(source) then
        self.strategy = "composite_blur"
        log("Blur: Using Composite Blur plugin (auto-configured)")
        return true
    end

    -- No blur available
    self.strategy = "none"
    log("Blur: No blur backend available. Blur effects disabled.")
    return false
end

-- Update blur based on zoom state
function BlurManager:update(state_machine, crop, camera_velocity)
    if not self.initialized then return end
    if self.strategy == "none" then return end

    -- Zoom Blur: Active during zoom transitions
    if self.zoom_blur_enabled and self.zoom_blur_filter then
        local radius = 0

        if state_machine:is_animating() and
           (state_machine.state == ZoomState.ZOOMING_IN or
            state_machine.state == ZoomState.ZOOMING_OUT) then
            -- Bell curve: 0 at start Ã¢â€ â€™ peak at 50% Ã¢â€ â€™ 0 at end
            local t = clamp(0, 1, state_machine.zoom_time)
            local curve = math.sin(t * math.pi)
            radius = curve * curve * self.zoom_blur_intensity
        end

        self:set_zoom_blur(radius, crop)
    end

    -- Motion Blur: Active during camera panning (not during zoom transition)
    if self.motion_blur_enabled and self.motion_blur_filter then
        if not state_machine:is_animating() and state_machine:is_zoomed() and camera_velocity then
            local speed = math.sqrt(
                camera_velocity.x * camera_velocity.x +
                camera_velocity.y * camera_velocity.y
            )

            if speed > 1.0 then
                local radius = math.min(10, speed * self.motion_blur_intensity * 0.5)
                local angle = math.deg(math.atan2(camera_velocity.y, camera_velocity.x))
                self:set_motion_blur(radius, angle)
            else
                self:set_motion_blur(0, 0)
            end
        else
            self:set_motion_blur(0, 0)
        end
    end
end

-- Set zoom blur parameters
function BlurManager:set_zoom_blur(radius, crop)
    if self.strategy == "composite_blur" and self.zoom_blur_settings then
        obs.obs_data_set_double(self.zoom_blur_settings, "radius", radius)

        if crop then
            local cx = crop.x + (crop.w / 2)
            local cy = crop.y + (crop.h / 2)
            obs.obs_data_set_double(self.zoom_blur_settings, "center_x", cx)
            obs.obs_data_set_double(self.zoom_blur_settings, "center_y", cy)
        end

        obs.obs_data_set_double(self.zoom_blur_settings, "inactive_radius", self.zoom_blur_clear_radius)
        obs.obs_source_update(self.zoom_blur_filter, self.zoom_blur_settings)
    end
end

-- Set motion blur parameters
function BlurManager:set_motion_blur(radius, angle)
    if self.strategy == "composite_blur" and self.motion_blur_settings then
        obs.obs_data_set_double(self.motion_blur_settings, "radius", radius)
        obs.obs_data_set_double(self.motion_blur_settings, "angle", angle)
        obs.obs_source_update(self.motion_blur_filter, self.motion_blur_settings)
    end
end

-- Update configuration
function BlurManager:update_config(settings)
    self.zoom_blur_enabled = obs.obs_data_get_bool(settings, "zoom_blur_enabled")
    self.zoom_blur_intensity = obs.obs_data_get_double(settings, "zoom_blur_intensity")
    self.zoom_blur_clear_radius = obs.obs_data_get_double(settings, "zoom_blur_clear_radius")
    self.motion_blur_enabled = obs.obs_data_get_bool(settings, "motion_blur_enabled")
    self.motion_blur_intensity = obs.obs_data_get_double(settings, "motion_blur_intensity")
end

-- Cleanup filters
function BlurManager:cleanup()
    local source = source_manager_get_source()

    if self.zoom_blur_filter and source then
        obs.obs_source_filter_remove(source, self.zoom_blur_filter)
        obs.obs_source_release(self.zoom_blur_filter)
        self.zoom_blur_filter = nil
    end

    if self.motion_blur_filter and source then
        obs.obs_source_filter_remove(source, self.motion_blur_filter)
        obs.obs_source_release(self.motion_blur_filter)
        self.motion_blur_filter = nil
    end

    if self.zoom_blur_settings then
        obs.obs_data_release(self.zoom_blur_settings)
        self.zoom_blur_settings = nil
    end

    if self.motion_blur_settings then
        obs.obs_data_release(self.motion_blur_settings)
        self.motion_blur_settings = nil
    end

    self.initialized = false
    self.strategy = "none"
end

-- Check if blur is available
function BlurManager:is_available()
    return self.strategy ~= "none"
end

-- Global convenience functions
function blur_manager_init(source)
    return BlurManager:init(source)
end

function blur_manager_update(state_machine, crop, camera_velocity)
    return BlurManager:update(state_machine, crop, camera_velocity)
end

function blur_manager_update_config(settings)
    return BlurManager:update_config(settings)
end

function blur_manager_cleanup()
    return BlurManager:cleanup()
end

function blur_manager_is_available()
    return BlurManager:is_available()
end

--================================================
-- MODULE: Cursor Asset Manager (M16)
--================================================
-- Handles extracting and managing cursor image assets

local CursorAssets = {
    extracted = false,
    dir = nil,
}

-- Get the platform-specific asset directory
function CursorAssets:get_platform_dir()
    if IS_WINDOWS then
        local appdata = os.getenv("APPDATA")
        return appdata and (appdata .. "\\obs-studio\\obs-zoom-pro\\cursors") or nil
    elseif IS_LINUX then
        local home = os.getenv("HOME")
        return home and (home .. "/.config/obs-studio/obs-zoom-pro/cursors") or nil
    elseif IS_MACOS then
        local home = os.getenv("HOME")
        return home and (home .. "/Library/Application Support/obs-studio/obs-zoom-pro/cursors") or nil
    end
    -- Fallback for non-FFI environments
    return "cursors"
end

-- Ensure assets are extracted
function CursorAssets:ensure_extracted()
    if self.extracted then
        return self.dir
    end

    local dir = self:get_platform_dir()
    if not dir then
        log("CursorAssets: Could not determine asset directory")
        return nil
    end

    -- Create directory
    local cmd
    if IS_WINDOWS then
        cmd = 'mkdir "' .. dir .. '" 2>nul'
    else
        cmd = 'mkdir -p "' .. dir .. '"'
    end
    os.execute(cmd)

    -- Check if assets exist
    local sep = IS_WINDOWS and "\\" or "/"
    local arrow_path = dir .. sep .. "arrow.png"

    local f = io.open(arrow_path, "rb")
    if f then
        f:close()
        self.dir = dir
        self.extracted = true
        log("CursorAssets: Using existing assets from " .. dir)
        return dir
    end

    -- Try to copy from script directory
    local script_dir = get_script_directory()
    local assets_src = script_dir .. "assets" .. sep .. "cursors" .. sep

    local files = { "arrow.png", "pointer.png", "ibeam.png" }
    for _, filename in ipairs(files) do
        local src_path = assets_src .. filename
        local dst_path = dir .. sep .. filename

        local src = io.open(src_path, "rb")
        if src then
            local data = src:read("*a")
            src:close()

            local dst = io.open(dst_path, "wb")
            if dst then
                dst:write(data)
                dst:close()
                log("CursorAssets: Copied " .. filename)
            end
        end
    end

    self.dir = dir
    self.extracted = true
    return dir
end

-- Get the asset directory
function CursorAssets:get_dir()
    return self.dir
end

-- Check if assets are available
function CursorAssets:is_available()
    if not self.extracted then
        self:ensure_extracted()
    end
    return self.dir ~= nil
end

-- Get cursor image path
function CursorAssets:get_cursor_path(cursor_type)
    if not self:is_available() then
        return nil
    end

    local sep = IS_WINDOWS and "\\" or "/"
    local filename = (cursor_type or "arrow") .. ".png"
    return self.dir .. sep .. filename
end

-- Global convenience functions
function cursor_assets_ensure_extracted()
    return CursorAssets:ensure_extracted()
end

function cursor_assets_get_dir()
    return CursorAssets:get_dir()
end

function cursor_assets_is_available()
    return CursorAssets:is_available()
end

function cursor_assets_get_cursor_path(cursor_type)
    return CursorAssets:get_cursor_path(cursor_type)
end

--================================================
-- MODULE: Cursor Renderer (M15)
--================================================
-- Provides automatic cursor overlay rendering

local CursorRenderer = {
    enabled = false,
    source = nil,
    sceneitem = nil,

    -- Smoothed state
    pos = { x = 0, y = 0 },
    current_scale = 1.0,
    current_rot = 0,
    swap_pulse = 1.0,

    -- Velocities (SmoothDamp)
    vel_x = { val = 0 },
    vel_y = { val = 0 },
    vel_scale = { val = 0 },
    vel_rot = { val = 0 },
    vel_swap = { val = 0 },

    -- State
    was_pointer = false,
    initialized = false,

    -- Configuration
    cursor_scale = 1.0,
    cursor_click_scale = 0.78,
    cursor_smooth_time = 0.1,
    cursor_offset_x = -6,
    cursor_offset_y = -2,
    cursor_rotation_mode = "None",
    cursor_angle_offset = 0,
    cursor_tilt_strength = 0,
}

-- Initialize cursor renderer
function CursorRenderer:init()
    if not cfg.cursor_enabled then
        self.enabled = false
        return false
    end

    -- Ensure cursor assets are available
    local asset_dir = cursor_assets_ensure_extracted()
    if not asset_dir then
        log("CursorRenderer: Failed to extract cursor assets")
        self.enabled = false
        return false
    end

    -- Get or create the cursor image source
    local source_name = FILTER_PREFIX .. "Cursor"
    self.source = obs.obs_get_source_by_name(source_name)

    if not self.source then
        -- Create new image source
        local settings = obs.obs_data_create()
        local cursor_path = cursor_assets_get_cursor_path("arrow")
        if cursor_path then
            obs.obs_data_set_string(settings, "file", cursor_path)
        end
        self.source = obs.obs_source_create("image_source", source_name, settings, nil)
        obs.obs_data_release(settings)

        if not self.source then
            log("CursorRenderer: Failed to create image source")
            self.enabled = false
            return false
        end
    end

    -- Add to current scene
    self:add_to_scene()

    -- Initialize position
    local mouse = platform_get_mouse_pos()
    self.pos.x = mouse.x
    self.pos.y = mouse.y

    self.enabled = true
    self.initialized = true
    log("CursorRenderer: Initialized")
    return true
end

-- Add cursor source to scene
function CursorRenderer:add_to_scene()
    if not self.source then return false end

    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then return false end

    local scene = obs.obs_scene_from_source(scene_source)
    if not scene then
        obs.obs_source_release(scene_source)
        return false
    end

    -- Check if already in scene
    local source_name = obs.obs_source_get_name(self.source)
    self.sceneitem = obs.obs_scene_find_source(scene, source_name)

    if not self.sceneitem then
        -- Add to scene
        self.sceneitem = obs.obs_scene_add(scene, self.source)
        if self.sceneitem then
            -- Move to top (render last = on top)
            obs.obs_sceneitem_set_order(self.sceneitem, obs.OBS_ORDER_MOVE_TOP)
        end
    end

    obs.obs_source_release(scene_source)
    return true
end

-- Update cursor position and state
function CursorRenderer:update(dt, raw_mouse, camera_crop)
    if not self.enabled or not self.sceneitem then return end

    -- Smooth cursor position
    self.pos.x = SmoothDamp(self.pos.x, raw_mouse.x, self.vel_x, self.cursor_smooth_time, 100000, dt)
    self.pos.y = SmoothDamp(self.pos.y, raw_mouse.y, self.vel_y, self.cursor_smooth_time, 100000, dt)

    -- Snap when very close
    if math.abs(self.pos.x - raw_mouse.x) < 0.5 then
        self.pos.x = raw_mouse.x
        self.vel_x.val = 0
    end
    if math.abs(self.pos.y - raw_mouse.y) < 0.5 then
        self.pos.y = raw_mouse.y
        self.vel_y.val = 0
    end

    -- Cursor shape detection (Windows only)
    local is_pointer = false
    if platform_cursor_shape_available() then
        is_pointer = platform_is_cursor_pointer()
    end

    -- Swap cursor image if needed
    if is_pointer ~= self.was_pointer then
        local asset_dir = cursor_assets_get_dir()
        local sep = IS_WINDOWS and "\\" or "/"
        local new_file = is_pointer and (asset_dir .. sep .. "pointer.png") or (asset_dir .. sep .. "arrow.png")

        local s = obs.obs_source_get_settings(self.source)
        if s then
            obs.obs_data_set_string(s, "file", new_file)
            obs.obs_source_update(self.source, s)
            obs.obs_data_release(s)
        end

        -- Trigger swap pulse
        self.swap_pulse = 0.75
        self.vel_swap.val = 1
        self.was_pointer = is_pointer
    end

    self.swap_pulse = SmoothDamp(self.swap_pulse, 1.0, self.vel_swap, 0.12, 100000, dt)

    -- Click animation
    local is_clicking = platform_is_clicking()
    local target_scale = is_clicking and (self.cursor_scale * self.cursor_click_scale) or self.cursor_scale
    self.current_scale = SmoothDamp(self.current_scale, target_scale, self.vel_scale, 0.1, 100000, dt)

    -- Calculate position relative to zoom
    local zoom_factor = 1.0
    local crop_x, crop_y = 0, 0

    if camera_crop and SM:is_zoomed() then
        zoom_factor = source_manager_get_size() / camera_crop.w
        crop_x = camera_crop.x
        crop_y = camera_crop.y
    end

    local final_x = (self.pos.x - crop_x) * zoom_factor + (self.cursor_offset_x * zoom_factor)
    local final_y = (self.pos.y - crop_y) * zoom_factor + (self.cursor_offset_y * zoom_factor)

    -- Apply to scene item
    local pos = obs.vec2()
    pos.x = final_x
    pos.y = final_y
    obs.obs_sceneitem_set_pos(self.sceneitem, pos)

    local scale = obs.vec2()
    local s = self.current_scale * zoom_factor * self.swap_pulse
    scale.x = s
    scale.y = s
    obs.obs_sceneitem_set_scale(self.sceneitem, scale)

    -- Rotation
    local dynamic_rot = self:compute_rotation(dt)
    obs.obs_sceneitem_set_rot(self.sceneitem, dynamic_rot)
end

-- Compute rotation based on mode
function CursorRenderer:compute_rotation(dt)
    local vx = self.vel_x.val
    local vy = self.vel_y.val
    local speed = math.sqrt(vx * vx + vy * vy)

    if self.cursor_rotation_mode == "Directional" then
        if speed > 20 then
            local angle = math.atan2(vy, vx) * (180 / math.pi)
            local target = angle + self.cursor_angle_offset
            local diff = (target - self.current_rot + 180) % 360 - 180
            self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.05, 100000, dt)
        end
        return self.current_rot

    elseif self.cursor_rotation_mode == "Lean" then
        local lean = clamp(-40, 40, vx * 0.05 * self.cursor_tilt_strength) + self.cursor_angle_offset
        local diff = (lean - self.current_rot + 180) % 360 - 180
        self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.08, 100000, dt)
        return self.current_rot
    end

    -- "None" mode
    local diff = (self.cursor_angle_offset - self.current_rot + 180) % 360 - 180
    self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.15, 100000, dt)
    return self.current_rot
end

-- Update configuration
function CursorRenderer:update_config(settings)
    self.cursor_scale = obs.obs_data_get_double(settings, "cursor_scale")
    self.cursor_click_scale = obs.obs_data_get_double(settings, "cursor_click_scale")
    self.cursor_smooth_time = obs.obs_data_get_double(settings, "cursor_smooth_time")
    self.cursor_offset_x = obs.obs_data_get_int(settings, "cursor_offset_x")
    self.cursor_offset_y = obs.obs_data_get_int(settings, "cursor_offset_y")
    self.cursor_rotation_mode = obs.obs_data_get_string(settings, "cursor_rotation_mode") or "None"
    self.cursor_angle_offset = obs.obs_data_get_double(settings, "cursor_angle_offset")
    self.cursor_tilt_strength = obs.obs_data_get_double(settings, "cursor_tilt_strength")
end

-- Cleanup
function CursorRenderer:cleanup()
    if self.sceneitem then
        obs.obs_sceneitem_remove(self.sceneitem)
        self.sceneitem = nil
    end

    if self.source then
        local source_name = obs.obs_source_get_name(self.source)
        obs.obs_source_release(self.source)

        -- Remove from OBS source list
        local s = obs.obs_get_source_by_name(source_name)
        if s then
            obs.obs_source_remove(s)
            obs.obs_source_release(s)
        end
        self.source = nil
    end

    self.enabled = false
    self.initialized = false
end

-- Check if active
function CursorRenderer:is_active()
    return self.enabled and self.initialized
end

-- Global convenience functions
function cursor_renderer_init()
    return CursorRenderer:init()
end

function cursor_renderer_update(dt, raw_mouse, camera_crop)
    return CursorRenderer:update(dt, raw_mouse, camera_crop)
end

function cursor_renderer_update_config(settings)
    return CursorRenderer:update_config(settings)
end

function cursor_renderer_cleanup()
    return CursorRenderer:cleanup()
end

function cursor_renderer_is_active()
    return CursorRenderer:is_active()
end

--================================================
-- MODULE: Bookmark Manager (M17)
--================================================
-- Manages saved zoom positions (bookmarks)

local BookmarkManager = {
    -- Saved bookmarks: { name = { zoom_level, x, y, w, h, source } }
    bookmarks = {},

    -- Maximum bookmarks
    max_bookmarks = 20,

    -- Hotkey IDs
    hotkeys = {},
}

-- Save current zoom position as a bookmark
function BookmarkManager:save(name)
    if not name or name == "" then
        return false
    end

    -- Check limit
    local count = 0
    for _, _ in pairs(self.bookmarks) do count = count + 1 end

    if count >= self.max_bookmarks and not self.bookmarks[name] then
        log("Bookmark: Max bookmarks reached (" .. self.max_bookmarks .. ")")
        return false
    end

    -- Get current crop
    local crop = crop_filter_get_crop()
    if not crop then
        return false
    end

    -- Save bookmark
    self.bookmarks[name] = {
        zoom_level = SM.zoom_level,
        x = crop.x,
        y = crop.y,
        w = crop.w,
        h = crop.h,
        source = cfg.source_name,
    }

    log("Bookmark: Saved '" .. name .. "' (zoom=" .. string.format("%.2f", SM.zoom_level) .. ")")
    return true
end

-- Recall a bookmark
function BookmarkManager:recall(name)
    local bm = self.bookmarks[name]
    if not bm then
        log("Bookmark: Not found: " .. name)
        return false
    end

    if not SM:can_jump() then
        return false
    end

    if not source_manager_is_valid() then
        return false
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        return false
    end

    -- Get current crop as start
    local start_crop = crop_filter_get_crop() or { x = 0, y = 0, w = source_w, h = source_h }

    -- Set target
    local target_crop = {
        x = bm.x,
        y = bm.y,
        w = bm.w,
        h = bm.h,
    }

    -- Transition to bookmark
    SM:transition(ZoomState.JUMPING, {
        start_crop = start_crop,
        target_crop = target_crop,
        target_level = bm.zoom_level
    })

    start_timer()
    log("Bookmark: Recall '" .. name .. "'")
    return true
end

-- Delete a bookmark
function BookmarkManager:delete(name)
    if self.bookmarks[name] then
        self.bookmarks[name] = nil
        log("Bookmark: Deleted '" .. name .. "'")
        return true
    end
    return false
end

-- Rename a bookmark
function BookmarkManager:rename(old_name, new_name)
    if not self.bookmarks[old_name] then
        return false
    end

    if self.bookmarks[new_name] then
        return false
    end

    self.bookmarks[new_name] = self.bookmarks[old_name]
    self.bookmarks[old_name] = nil
    log("Bookmark: Renamed '" .. old_name .. "' to '" .. new_name .. "'")
    return true
end

-- Get all bookmark names
function BookmarkManager:get_names()
    local names = {}
    for k, _ in pairs(self.bookmarks) do
        table.insert(names, k)
    end
    table.sort(names)
    return names
end

-- Get bookmark info
function BookmarkManager:get(name)
    return self.bookmarks[name]
end

-- Persist bookmarks to settings
function BookmarkManager:persist(settings)
    local array = obs.obs_data_array_create()

    for name, bm in pairs(self.bookmarks) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "name", name)
        obs.obs_data_set_double(item, "zoom_level", bm.zoom_level)
        obs.obs_data_set_double(item, "x", bm.x)
        obs.obs_data_set_double(item, "y", bm.y)
        obs.obs_data_set_double(item, "w", bm.w)
        obs.obs_data_set_double(item, "h", bm.h)
        obs.obs_data_set_string(item, "source", bm.source or "")
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "zoom_bookmarks", array)
    obs.obs_data_array_release(array)
end

-- Load bookmarks from settings
function BookmarkManager:load(settings)
    self.bookmarks = {}

    local array = obs.obs_data_get_array(settings, "zoom_bookmarks")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local name = obs.obs_data_get_string(item, "name")

        if name and name ~= "" then
            self.bookmarks[name] = {
                zoom_level = obs.obs_data_get_double(item, "zoom_level"),
                x = obs.obs_data_get_double(item, "x"),
                y = obs.obs_data_get_double(item, "y"),
                w = obs.obs_data_get_double(item, "w"),
                h = obs.obs_data_get_double(item, "h"),
                source = obs.obs_data_get_string(item, "source"),
            }
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)

    local count = 0
    for _, _ in pairs(self.bookmarks) do count = count + 1 end
    log("Bookmark: Loaded " .. count .. " bookmarks")
end

-- Register bookmark hotkeys
function BookmarkManager:register_hotkeys(settings)
    for i = 1, 5 do
        self.hotkeys[i] = obs.obs_hotkey_register_frontend(
            "obs_zoom_pro.bookmark_" .. i,
            "Zoom to Bookmark " .. i,
            function(pressed)
                if not pressed then return end
                local names = self:get_names()
                if names[i] then
                    self:recall(names[i])
                end
            end
        )

        -- Load saved bindings
        local key = "obs_zoom_pro.hotkey.bookmark_" .. i
        local save_array = obs.obs_data_get_array(settings, key)
        if save_array then
            obs.obs_hotkey_load(self.hotkeys[i], save_array)
            obs.obs_data_array_release(save_array)
        end
    end
end

-- Save bookmark hotkeys
function BookmarkManager:save_hotkeys(settings)
    for i = 1, 5 do
        if self.hotkeys[i] then
            local save_array = obs.obs_hotkey_save(self.hotkeys[i])
            obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.bookmark_" .. i, save_array)
            obs.obs_data_array_release(save_array)
        end
    end
end

-- Global convenience functions
function bookmark_save(name)
    return BookmarkManager:save(name)
end

function bookmark_recall(name)
    return BookmarkManager:recall(name)
end

function bookmark_delete(name)
    return BookmarkManager:delete(name)
end

function bookmark_get_names()
    return BookmarkManager:get_names()
end

function bookmark_get(name)
    return BookmarkManager:get(name)
end

--================================================
-- MODULE: UDP API Server (M18)
--================================================
-- Provides external control via UDP for Stream Deck integration

local APIServer = {
    enabled = false,
    port = 12345,
    socket = nil,
}

-- Command handlers
local API_COMMANDS = {
    ZOOM_IN = function(args)
        local level = tonumber(args[1]) or cfg.zoom_value
        on_scroll_zoom_to(level)
        return "OK"
    end,

    ZOOM_OUT = function(args)
        if SM:is_zoomed() then
            on_toggle_zoom(true)
        end
        return "OK"
    end,

    ZOOM_SET = function(args)
        local level = tonumber(args[1])
        if not level then return "ERROR: Missing level" end
        on_scroll_zoom_to(level)
        return "OK"
    end,

    ZOOM_TOGGLE = function(args)
        on_toggle_zoom(true)
        return "OK"
    end,

    FOLLOW_ON = function(args)
        if SM:is_zoomed() then SM.following = true end
        return "OK"
    end,

    FOLLOW_OFF = function(args)
        SM.following = false
        return "OK"
    end,

    FOLLOW_TOGGLE = function(args)
        if SM:is_zoomed() then SM.following = not SM.following end
        return "OK"
    end,

    PRESET = function(args)
        local name = args[1]
        if not name then return "ERROR: Missing preset name" end
        local ok = preset_apply(name)
        return ok and "OK" or "ERROR: Unknown preset"
    end,

    BOOKMARK = function(args)
        local name = args[1]
        if not name then return "ERROR: Missing bookmark name" end
        local ok = bookmark_recall(name)
        return ok and "OK" or "ERROR: Bookmark not found"
    end,

    STATUS = function(args)
        local crop = crop_filter_get_crop()
        return string.format(
            '{"version":"%s","zoom_level":%.2f,"state":"%s","following":%s,"position":{"x":%.0f,"y":%.0f},"preset":"%s"}',
            VERSION,
            SM.zoom_level,
            SM.state,
            tostring(SM.following),
            crop and crop.x or 0,
            crop and crop.y or 0,
            cfg.zoom_preset or ""
        )
    end,

    HELP = function(args)
        return "Commands: ZOOM_IN [level], ZOOM_OUT, ZOOM_SET level, ZOOM_TOGGLE, FOLLOW_ON, FOLLOW_OFF, FOLLOW_TOGGLE, PRESET name, BOOKMARK name, STATUS"
    end,
}

-- Start the API server
function APIServer:start(port)
    self:stop()

    self.port = port or self.port

    -- Try to use luasocket if available
    local socket_ok, socket = pcall(require, "socket")
    if not socket_ok then
        log("API: Socket library not available")
        return false
    end

    -- Try UDP
    local udp, err = socket.udp()
    if not udp then
        log("API: Failed to create UDP socket: " .. tostring(err))
        return false
    end

    -- Set socket options
    udp:setoption("reuseaddr", true)
    udp:settimeout(0)  -- Non-blocking

    -- Bind to port
    local bind_ok, err = udp:setsockname("*", self.port)
    if not bind_ok then
        log("API: Failed to bind to port " .. self.port .. ": " .. tostring(err))
        udp:close()
        return false
    end

    self.socket = udp
    self.enabled = true

    -- Start polling timer
    obs.timer_add(function() self:poll() end, 50)  -- 20Hz polling

    log("API: Listening on port " .. self.port)
    return true
end

-- Stop the API server
function APIServer:stop()
    if self.socket then
        self.socket:close()
        self.socket = nil
    end
    self.enabled = false
    log("API: Stopped")
end

-- Poll for incoming commands
function APIServer:poll()
    if not self.enabled or not self.socket then
        return
    end

    repeat
        local data, err = self.socket:receivefrom()
        if data then
            local response = self:handle_command(data)
            if response then
                -- Note: UDP response requires sender address
                log("API: " .. data:gsub("%s+", " ") .. " Ã¢â€ â€™ " .. response)
            end
        elseif err ~= "timeout" then
            log("API: Error: " .. tostring(err))
        end
    until not data
end

-- Handle a command
function APIServer:handle_command(raw)
    -- Parse command
    local parts = {}
    for word in raw:gmatch("%S+") do
        table.insert(parts, word)
    end

    if #parts == 0 then
        return "ERROR: Empty command"
    end

    local cmd = parts[1]:upper()
    local args = {}
    for i = 2, #parts do
        table.insert(args, parts[i])
    end

    -- Look up handler
    local handler = API_COMMANDS[cmd]
    if handler then
        local ok, result = pcall(handler, args)
        if ok then
            return result
        else
            return "ERROR: " .. tostring(result)
        end
    end

    return "ERROR: Unknown command: " .. cmd
end

-- Check if enabled
function APIServer:is_enabled()
    return self.enabled
end

-- Global convenience functions
function api_start(port)
    return APIServer:start(port)
end

function api_stop()
    return APIServer:stop()
end

function api_is_enabled()
    return APIServer:is_enabled()
end

--================================================
-- OBS SCRIPT REGISTRATION
--================================================

--[[ Called when the script is loaded
--[[ @param data table Script data
function script_load(data)
    log("Script loaded - OBS Zoom Pro v" .. VERSION)

    -- Load custom presets
    PresetManager:load(data)

    -- Load scene memory
    SceneMemory:load(data)

    -- Load bookmarks
    BookmarkManager:load(data)

    -- Register hotkeys
    register_hotkeys(data)

    -- Register bookmark hotkeys
    BookmarkManager:register_hotkeys(data)

    -- Register frontend event handler
    obs.obs_frontend_add_event_callback(on_frontend_event)

    -- Start API server if enabled
    local api_enabled = obs.obs_data_get_bool(data, "api_enabled")
    if api_enabled then
        local api_port = obs.obs_data_get_int(data, "api_port")
        APIServer:start(api_port)
    end
end

--[[ Called when the script is unloaded
function script_unload()
    log("Script unloaded - OBS Zoom Pro")

    -- Stop timer and cleanup
    stop_timer()
    unregister_hotkeys()
    source_manager_release()

    -- Stop API server
    APIServer:stop()

    -- Remove frontend event handler
    obs.obs_frontend_remove_event_callback(on_frontend_event)
end

--[[ Called when settings are updated
--[[ @param data table Settings data
function script_update(data)
    log("Settings updated")

    -- Update legacy settings
    debug_logs = obs.obs_data_get_bool(data, "debug_logging") or false
    settings.debug_logging = debug_logs
    settings.easing_type = obs.obs_data_get_string(data, "easing_type") or defaults.easing_type
    settings.smooth_time = obs.obs_data_get_double(data, "smooth_time") or defaults.smooth_time
    settings.max_speed = obs.obs_data_get_double(data, "max_speed") or defaults.max_speed

    -- Update M09 configuration
    update_config(data)

    -- Update API server settings
    local api_enabled = obs.obs_data_get_bool(data, "api_enabled")
    local api_port = obs.obs_data_get_int(data, "api_port")

    if api_enabled and not APIServer:is_enabled() then
        APIServer:start(api_port)
    elseif not api_enabled and APIServer:is_enabled() then
        APIServer:stop()
    elseif APIServer:is_enabled() and APIServer.port ~= api_port then
        APIServer:start(api_port)
    end
end

--[[ Called to save settings
--[[ @param data table Settings data to save
function script_save(data)
    log("Settings saved")

    -- Save custom presets
    PresetManager:persist(data)

    -- Save scene memory
    SceneMemory:persist(data)

    -- Save bookmarks
    BookmarkManager:persist(data)

    -- Save hotkey bindings
    save_hotkeys(data)

    -- Save bookmark hotkeys
    BookmarkManager:save_hotkeys(data)
end

--[[ Called to create the properties UI
--[[ @return obs.obs_properties_t Properties object
function script_properties()
    local props = obs.obs_properties_create()

    --==========================
    -- QUICK SETUP (always expanded)
    --==========================
    local grp_quick = obs.obs_properties_create()

    -- Source dropdown
    local src_list = obs.obs_properties_add_list(grp_quick, "source", "Zoom Source",
        obs.OBS_COMBO_TYPE_LIST, obs.OBS_COMBO_FORMAT_STRING)
    obs.obs_property_list_add_string(src_list, "-- Select Source --", "")

    -- Populate with available capture sources
    local sources = source_manager_get_available_sources()
    for _, src in ipairs(sources) do
        obs.obs_property_list_add_string(src_list, src.name, src.name)
    end

    -- Zoom Factor
    obs.obs_properties_add_float_slider(grp_quick, "zoom_value", "Zoom Factor", 1.0, 10.0, 0.1)

    -- Duration
    obs.obs_properties_add_float_slider(grp_quick, "zoom_duration", "Duration (s)", 0.05, 3.0, 0.05)

    obs.obs_properties_add_group(props, "quick_setup", "Ã¢Å¡Â¡ Quick Setup", obs.OBS_GROUP_NORMAL, grp_quick)

    --==========================
    -- ANIMATION (collapsed)
    --==========================
    local grp_anim = obs.obs_properties_create()

    -- Overshoot/Bounce
    obs.obs_properties_add_float_slider(grp_anim, "zoom_overshoot", "Bounce", 0.0, 1.0, 0.01)

    -- Easing Curve
    local p_easing = obs.obs_properties_add_list(grp_anim, "zoom_easing", "Easing Curve",
        obs.OBS_COMBO_TYPE_LIST, obs.OBS_COMBO_FORMAT_STRING)
    for _, name in ipairs(Easing.NAMES) do
        obs.obs_property_list_add_string(p_easing, name, name)
    end

    obs.obs_properties_add_group(props, "animation", "Ã°Å¸Å½Â¬ Animation", obs.OBS_GROUP_NORMAL, grp_anim)

    --==========================
    -- MOUSE FOLLOW (collapsed)
    --==========================
    local grp_follow = obs.obs_properties_create()

    obs.obs_properties_add_bool(grp_follow, "auto_follow", "Auto-Follow Mouse")
    obs.obs_properties_add_float_slider(grp_follow, "follow_smooth_time", "Smoothness", 0.01, 1.0, 0.01)
    obs.obs_properties_add_int_slider(grp_follow, "follow_dead_zone", "Dead Zone (px)", 0, 500, 1)

    obs.obs_properties_add_group(props, "follow", "Ã°Å¸Å½Â¯ Mouse Follow", obs.OBS_GROUP_NORMAL, grp_follow)

    --==========================
    -- ADVANCED (collapsed)
    --==========================
    local grp_adv = obs.obs_properties_create()
    obs.obs_properties_add_float_slider(grp_adv, "scroll_step", "Scroll Zoom Step", 0.1, 1.0, 0.05)
    obs.obs_properties_add_bool(grp_adv, "debug_logs", "Debug Logging")
    obs.obs_properties_add_group(props, "advanced", "Ã¢Å¡â„¢Ã¯Â¸Â Advanced", obs.OBS_GROUP_NORMAL, grp_adv)

    --==========================
    -- API SERVER (collapsed)
    --==========================
    local grp_api = obs.obs_properties_create()
    obs.obs_properties_add_bool(grp_api, "api_enabled", "Enable UDP API Server")
    obs.obs_properties_add_int(grp_api, "api_port", "API Port", 1024, 65535, 1)
    obs.obs_properties_add_group(props, "api_server", "Ã°Å¸Å’Â UDP API Server", obs.OBS_GROUP_NORMAL, grp_api)

    --==========================
    -- HELP (collapsed)
    --==========================
    local grp_help = obs.obs_properties_create()
    obs.obs_properties_add_text(grp_help, "help_text",
        "QUICK START:\n" ..
        "1. Select your capture source above\n" ..
        "2. Set hotkeys in OBS Settings Ã¢â€ â€™ Hotkeys\n" ..
        "   Ã¢â‚¬Â¢ 'Toggle Zoom to Mouse' Ã¢â‚¬â€ Main zoom\n" ..
        "   Ã¢â‚¬Â¢ 'Toggle Mouse Follow' Ã¢â‚¬â€ Enable/disable follow\n" ..
        "3. Press the hotkey to zoom!\n\n" ..
        "TIPS:\n" ..
        "Ã¢â‚¬Â¢ Zoom centers on mouse position\n" ..
        "Ã¢â‚¬Â¢ Enable Auto-Follow for smooth tracking\n" ..
        "Ã¢â‚¬Â¢ Adjust Dead Zone to reduce jitter",
        obs.OBS_TEXT_INFO)
    obs.obs_properties_add_group(props, "help", "Ã¢Ââ€œ Help", obs.OBS_GROUP_NORMAL, grp_help)

    return props
end

--[[ Called to set default values
--[[ @param data table Settings data
function script_defaults(data)
    obs.obs_data_set_default_string(data, "source", "")
    obs.obs_data_set_default_double(data, "zoom_value", 2.0)
    obs.obs_data_set_default_double(data, "zoom_duration", 0.6)
    obs.obs_data_set_default_double(data, "zoom_overshoot", 0.0)
    obs.obs_data_set_default_string(data, "zoom_easing", "Cubic.Out")
    obs.obs_data_set_default_bool(data, "auto_follow", true)
    obs.obs_data_set_default_double(data, "follow_smooth_time", 0.15)
    obs.obs_data_set_default_int(data, "follow_dead_zone", 5)
    obs.obs_data_set_default_double(data, "scroll_step", 0.25)
    obs.obs_data_set_default_bool(data, "debug_logs", false)
    obs.obs_data_set_default_bool(data, "api_enabled", false)
    obs.obs_data_set_default_int(data, "api_port", 12345)
end

--================================================
-- SCRIPT METADATA
--================================================
script_info = {
    name = "OBS Zoom Pro",
    version = VERSION,
    description = "Intelligent camera zoom functionality with smooth transitions and easing curves.",
    author = "OBS Zoom Pro Team"
}
)
        handle:close()
        if uname == 'Darwin' then
            is_macos = true
            is_linux = false
        end
    end

    return {
        WINDOWS = is_windows,
        LINUX = is_linux,
        MACOS = is_macos
    }
end

local platform = detect_platform()
local IS_WINDOWS = platform.WINDOWS
local IS_LINUX = platform.LINUX
local IS_MACOS = platform.MACOS

-- Log platform detection
log("Platform detected: " .. (jit and jit.os or "Unknown") .. (IS_WINDOWS and " (Full support)" or " (Basic support)"))

-- Virtual key codes (Lua constants instead of C #define)
local VK_LBUTTON = 0x01
local VK_RBUTTON = 0x02
local VK_MBUTTON = 0x04
local VK_CONTROL = 0x11
local VK_SHIFT = 0x10
local VK_MENU = 0x12  -- Alt

-- FFI declarations for Windows (only if FFI is available)


-- Cursor shape constants (Windows)
local CURSOR_ARROW = 1
local CURSOR_IBEAM = 2
local CURSOR_HAND = 3
local CURSOR_WAIT = 4

-- Module state
local Platform = {
    cursor_shape_available = IS_WINDOWS,
    last_mouse = { x = 0, y = 0 },
    last_click = false,
}

-- Get mouse position (cross-platform)
function Platform.get_mouse_pos()
    if IS_WINDOWS then
        local success, pt = pcall(function()
            local pt = ffi.new("POINT")
            if ffi.C.GetCursorPos(pt) ~= 0 then
                return { x = tonumber(pt.x), y = tonumber(pt.y) }
            end
            return nil
        end)
        if success and pt then
            return pt
        end
    elseif IS_LINUX then
        -- Linux: Use xdotool if available, fallback to X11
        local success, result = pcall(function()
            local handle = io.popen("xdotool getmouselocation 2>/dev/null || echo 'x:0 y:0'")
            if handle then
                local output = handle:read("*a")
                handle:close()
                local x, y = output:match("x:(%d+)%s+y:(%d+)")
                if x and y then
                    return { x = tonumber(x), y = tonumber(y) }
                end
            end
            return nil
        end)
        if success and result then
            return result
        end
    elseif IS_MACOS then
        -- macOS: Use osascript
        local success, result = pcall(function()
            local handle = io.popen(--[[osascript -e 'tell application "System Events" to get position of the mouse' 2>/dev/null || echo "0, 0"]])
            if handle then
                local output = handle:read("*a")
                handle:close()
                local x, y = output:match("(%d+),%s*(%d+)")
                if x and y then
                    return { x = tonumber(x), y = tonumber(y) }
                end
            end
            return nil
        end)
        if success and result then
            return result
        end
    end

    -- Fallback
    return { x = 0, y = 0 }
end

-- Check if left mouse button is clicked (Windows only, others return false)
function Platform.is_clicking()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x01) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if a modifier key is held (Windows only)
function Platform.is_key_held(vk_code)
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(vk_code) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if cursor is a pointer/hand (Windows only)
function Platform.is_cursor_pointer()
    if IS_WINDOWS then
        local success, result = pcall(function()
            local ci = ffi.new("CURSORINFO")
            ci.cbSize = ffi.sizeof("CURSORINFO")
            if ffi.C.GetCursorInfo(ci) ~= 0 then
                -- Check if hCursor is a hand pointer
                -- This is a simplified check; real implementation would compare cursor handles
                return ci.flags ~= 0  -- Simplified; actual implementation needs cursor handle comparison
            end
            return false
        end)
        return success and result or false
    end
    return false
end

-- Get cursor shape (Windows only, returns "arrow" for others)
function Platform.get_cursor_shape()
    if IS_WINDOWS then
        local success, result = pcall(function()
            local ci = ffi.new("CURSORINFO")
            ci.cbSize = ffi.sizeof("CURSORINFO")
            if ffi.C.GetCursorInfo(ci) ~= 0 and ci.hCursor ~= nil then
                local addr = tonumber(ffi.cast("uintptr_t", ci.hCursor))
                -- Common cursor IDs (these are typical values, may vary)
                -- IDC_ARROW = 32512, IDC_IBEAM = 32513, IDC_HAND = 32649
                -- We use address ranges as heuristic
                return "arrow"  -- Simplified; actual implementation would map handles
            end
            return "arrow"
        end)
        return success and result or "arrow"
    end
    return "arrow"
end

-- Check if Control key is held
function Platform.is_ctrl_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x11) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if Shift key is held
function Platform.is_shift_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x10) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if Alt key is held
function Platform.is_alt_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x12) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Convenience wrapper functions
function platform_get_mouse_pos()
    return Platform.get_mouse_pos()
end

function platform_is_clicking()
    return Platform.is_clicking()
end

function platform_is_cursor_pointer()
    return Platform.is_cursor_pointer()
end

function platform_cursor_shape_available()
    return Platform.cursor_shape_available
end

function platform_is_ctrl_held()
    return Platform.is_ctrl_held()
end

function platform_is_shift_held()
    return Platform.is_shift_held()
end

function platform_is_alt_held()
    return Platform.is_alt_held()
end

--================================================
-- MODULE: State Machine (M05)
--================================================
-- Manages zoom states and transitions
-- States: IDLE, ZOOMING_IN, ZOOMED_IN, ZOOMING_OUT, SCROLLING, JUMPING

local ZoomState = {
    IDLE         = "idle",
    ZOOMING_IN   = "zooming_in",
    ZOOMED_IN    = "zoomed_in",
    ZOOMING_OUT  = "zooming_out",
    SCROLLING    = "scrolling",    -- Scroll wheel mid-transition
    JUMPING      = "jumping",      -- Bookmark transition
}

local StateMachine = {
    state = ZoomState.IDLE,
    zoom_time = 0,          -- Animation progress (0 Ã¢â€ â€™ 1)
    zoom_level = 1.0,       -- Current zoom factor
    target_level = 1.0,     -- Target zoom factor
    start_crop = nil,       -- Crop at animation start {x, y, w, h}
    target_crop = nil,      -- Crop at animation end {x, y, w, h}
    following = false,      -- Mouse follow active

    -- Transition guards
    can_zoom_in = function(self)
        return self.state == ZoomState.IDLE
    end,

    can_zoom_out = function(self)
        return self.state == ZoomState.ZOOMED_IN
            or self.state == ZoomState.SCROLLING
    end,

    can_scroll = function(self)
        return self.state == ZoomState.ZOOMED_IN
            or self.state == ZoomState.IDLE
            or self.state == ZoomState.SCROLLING
    end,

    can_jump = function(self)
        return self.state ~= ZoomState.ZOOMING_IN
           and self.state ~= ZoomState.ZOOMING_OUT
           and self.state ~= ZoomState.JUMPING
    end,

    is_animating = function(self)
        return self.state == ZoomState.ZOOMING_IN
            or self.state == ZoomState.ZOOMING_OUT
            or self.state == ZoomState.SCROLLING
            or self.state == ZoomState.JUMPING
    end,

    is_zoomed = function(self)
        return self.state ~= ZoomState.IDLE
    end,
}

-- Transition to a new state
function StateMachine:transition(new_state, params)
    local old = self.state
    self.state = new_state
    self.zoom_time = 0

    if params then
        if params.start_crop then self.start_crop = params.start_crop end
        if params.target_crop then self.target_crop = params.target_crop end
        if params.target_level then self.target_level = params.target_level end
    end

    log("State: " .. old .. " Ã¢â€ â€™ " .. new_state)
end

-- Complete the current animation
function StateMachine:complete()
    if self.state == ZoomState.ZOOMING_IN
       or self.state == ZoomState.SCROLLING
       or self.state == ZoomState.JUMPING then
        self.zoom_level = self.target_level
        self.state = ZoomState.ZOOMED_IN
        self.zoom_time = 0
        log("State: " .. self.state .. " Ã¢â€ â€™ ZOOMED_IN (complete)")
    elseif self.state == ZoomState.ZOOMING_OUT then
        self.zoom_level = 1.0
        self.target_level = 1.0
        self.start_crop = nil
        self.target_crop = nil
        self.following = false
        self.state = ZoomState.IDLE
        self.zoom_time = 0
        log("State: ZOOMING_OUT Ã¢â€ â€™ IDLE (complete)")
    end
end

-- Reset to initial state
function StateMachine:reset()
    self.state = ZoomState.IDLE
    self.zoom_time = 0
    self.zoom_level = 1.0
    self.target_level = 1.0
    self.start_crop = nil
    self.target_crop = nil
    self.following = false
    log("StateMachine: Reset to IDLE")
end

-- Get current animation progress (0-1)
function StateMachine:get_progress()
    return clamp(0, 1, self.zoom_time)
end

-- Check if in a specific state
function StateMachine:is_state(state)
    return self.state == state
end

-- Get state name for display
function StateMachine:get_state_name()
    return self.state
end

-- Create a new state machine instance (for testing/isolation)
function StateMachine:new()
    local sm = {}
    setmetatable(sm, { __index = self })
    sm.state = ZoomState.IDLE
    sm.zoom_time = 0
    sm.zoom_level = 1.0
    sm.target_level = 1.0
    sm.start_crop = nil
    sm.target_crop = nil
    sm.following = false
    return sm
end

-- Global state machine instance
local SM = StateMachine:new()

--================================================
-- MODULE: Crop Filter Manager (M07)
--================================================
-- Manages the crop/pad filter used to simulate zoom
-- Creates, updates, and destroys the filter automatically

local FILTER_PREFIX = "[ZoomPro] "
local CROP_FILTER_NAME = FILTER_PREFIX .. "Crop"

local CropFilterManager = {
    filter = nil,           -- The crop filter source
    source = nil,           -- The parent source
    original_crop = nil,    -- Original crop values for restoration
    current_crop = { x = 0, y = 0, w = 0, h = 0 },
    initialized = false,
}

-- Create the crop filter on a source
function CropFilterManager:create(source)
    if not source then
        log("CropFilter: No source provided")
        return false
    end

    self:cleanup()  -- Clean up any existing filter
    self.source = source

    -- Check if our filter already exists
    local existing = obs.obs_source_get_filter_by_name(source, CROP_FILTER_NAME)
    if existing then
        log("CropFilter: Found existing filter")
        self.filter = existing
        self.initialized = true
        return true
    end

    -- Create new crop/pad filter
    local settings = obs.obs_data_create()
    obs.obs_data_set_int(settings, "left", 0)
    obs.obs_data_set_int(settings, "top", 0)
    obs.obs_data_set_int(settings, "right", 0)
    obs.obs_data_set_int(settings, "bottom", 0)
    obs.obs_data_set_bool(settings, "relative", false)  -- Absolute positioning

    self.filter = obs.obs_source_create_private(
        "crop_filter",      -- Filter type
        CROP_FILTER_NAME,   -- Filter name
        settings            -- Settings
    )

    obs.obs_data_release(settings)

    if not self.filter then
        log("CropFilter: Failed to create filter")
        return false
    end

    -- Add filter to source
    obs.obs_source_filter_add(source, self.filter)

    -- Store original crop (none)
    self.original_crop = { x = 0, y = 0, w = 0, h = 0 }

    self.initialized = true
    log("CropFilter: Created successfully")
    return true
end

-- Update the crop filter with new values
function CropFilterManager:update(x, y, w, h)
    if not self.filter or not self.initialized then
        return false
    end

    -- Store current crop
    self.current_crop = { x = x, y = y, w = w, h = h }

    -- Get filter settings
    local settings = obs.obs_source_get_settings(self.filter)
    if not settings then
        return false
    end

    -- Calculate crop values
    -- For crop_filter: left, top are absolute position
    -- right, bottom are width/height from right/bottom edge
    -- We need to convert our x, y, w, h to this format

    -- Get source dimensions
    local source_w = obs.obs_source_get_width(self.source)
    local source_h = obs.obs_source_get_height(self.source)

    if source_w == 0 or source_h == 0 then
        obs.obs_data_release(settings)
        return false
    end

    -- Set crop values
    -- left = x offset from left
    -- top = y offset from top
    -- right = source_w - (x + w) = remaining width on right
    -- bottom = source_h - (y + h) = remaining height on bottom
    local left = math.floor(x)
    local top = math.floor(y)
    local right = math.floor(source_w - (x + w))
    local bottom = math.floor(source_h - (y + h))

    -- Clamp to valid values
    left = math.max(0, left)
    top = math.max(0, top)
    right = math.max(0, right)
    bottom = math.max(0, bottom)

    obs.obs_data_set_int(settings, "left", left)
    obs.obs_data_set_int(settings, "top", top)
    obs.obs_data_set_int(settings, "right", right)
    obs.obs_data_set_int(settings, "bottom", bottom)

    -- Update the filter
    obs.obs_source_update(self.filter, settings)
    obs.obs_data_release(settings)

    return true
end

-- Get current crop values
function CropFilterManager:get_crop()
    return self.current_crop
end

-- Reset crop to original (no crop)
function CropFilterManager:reset()
    if not self.filter or not self.initialized then
        return false
    end

    local settings = obs.obs_source_get_settings(self.filter)
    if settings then
        obs.obs_data_set_int(settings, "left", 0)
        obs.obs_data_set_int(settings, "top", 0)
        obs.obs_data_set_int(settings, "right", 0)
        obs.obs_data_set_int(settings, "bottom", 0)
        obs.obs_source_update(self.filter, settings)
        obs.obs_data_release(settings)
    end

    self.current_crop = { x = 0, y = 0, w = 0, h = 0 }
    return true
end

-- Remove the filter and restore original state
function CropFilterManager:cleanup()
    if self.filter and self.source then
        -- Reset to no crop first
        self:reset()

        -- Remove filter from source
        obs.obs_source_filter_remove(self.source, self.filter)
        obs.obs_source_release(self.filter)
        self.filter = nil
        log("CropFilter: Removed from source")
    end

    self.source = nil
    self.original_crop = nil
    self.current_crop = { x = 0, y = 0, w = 0, h = 0 }
    self.initialized = false
end

-- Check if filter is ready
function CropFilterManager:is_ready()
    return self.initialized and self.filter ~= nil
end

-- Get source dimensions
function CropFilterManager:get_source_size()
    if not self.source then
        return 0, 0
    end
    return obs.obs_source_get_width(self.source), obs.obs_source_get_height(self.source)
end

-- Convenience wrapper functions
function crop_filter_create(source)
    return CropFilterManager:create(source)
end

function crop_filter_update(x, y, w, h)
    return CropFilterManager:update(x, y, w, h)
end

function crop_filter_reset()
    return CropFilterManager:reset()
end

function crop_filter_cleanup()
    return CropFilterManager:cleanup()
end

function crop_filter_is_ready()
    return CropFilterManager:is_ready()
end

function crop_filter_get_crop()
    return CropFilterManager:get_crop()
end

function crop_filter_get_source_size()
    return CropFilterManager:get_source_size()
end

--================================================
-- MODULE: Source Manager (M08)
--================================================
-- Handles finding sources in scenes, capturing transforms,
-- and managing source state for zoom operations

local SourceManager = {
    source = nil,           -- Current zoom source
    sceneitem = nil,        -- Scene item reference
    scene = nil,            -- Current scene
    original_transform = nil, -- Saved original transform
    source_name = "",       -- Source name for settings
    initialized = false,
}

-- Transform data structure
local TransformData = {
    pos = { x = 0, y = 0 },
    scale = { x = 1.0, y = 1.0 },
    rot = 0,
    bounds_type = 0,
    bounds = { x = 0, y = 0 },
    crop = { left = 0, top = 0, right = 0, bottom = 0 },
}

-- Find a source in a scene (BFS through groups)
function SourceManager:find_sceneitem(scene, source_name)
    if not scene or not source_name then
        return nil
    end

    local scene_source = obs.obs_scene_from_source(scene)
    if not scene_source then
        return nil
    end

    -- BFS queue
    local queue = {}
    table.insert(queue, scene_source)

    while #queue > 0 do
        local current_scene = table.remove(queue, 1)

        -- Iterate through items
        local items = obs.obs_scene_enum_items(current_scene)
        if items then
            for _, item in ipairs(items) do
                local item_source = obs.obs_sceneitem_get_source(item)
                if item_source then
                    local name = obs.obs_source_get_name(item_source)

                    -- Check if this is our target
                    if name == source_name then
                        obs.sceneitem_list_release(items)
                        return item
                    end

                    -- Check if this is a group (nested scene)
                    if obs.obs_source_get_type(item_source) == obs.OBS_SOURCE_TYPE_INPUT then
                        local id = obs.obs_source_get_id(item_source)
                        if id == "group" then
                            local group_scene = obs.obs_group_from_source(item_source)
                            if group_scene then
                                table.insert(queue, group_scene)
                            end
                        end
                    end
                end
            end
            obs.sceneitem_list_release(items)
        end
    end

    return nil
end

-- Capture the current transform of a scene item
function SourceManager:capture_transform(sceneitem)
    if not sceneitem then
        return nil
    end

    local transform = {}

    -- Position
    local pos = obs.vec2()
    obs.obs_sceneitem_get_pos(sceneitem, pos)
    transform.pos = { x = pos.x, y = pos.y }

    -- Scale
    local scale = obs.vec2()
    obs.obs_sceneitem_get_scale(sceneitem, scale)
    transform.scale = { x = scale.x, y = scale.y }

    -- Rotation
    transform.rot = obs.obs_sceneitem_get_rot(sceneitem)

    -- Bounds
    transform.bounds_type = obs.obs_sceneitem_get_bounds_type(sceneitem)
    local bounds = obs.vec2()
    obs.obs_sceneitem_get_bounds(sceneitem, bounds)
    transform.bounds = { x = bounds.x, y = bounds.y }

    -- Crop
    local crop = obs.obs_sceneitem_crop()
    obs.obs_sceneitem_get_crop(sceneitem, crop)
    transform.crop = {
        left = crop.left,
        top = crop.top,
        right = crop.right,
        bottom = crop.bottom
    }

    return transform
end

-- Restore a saved transform to a scene item
function SourceManager:restore_transform(sceneitem, transform)
    if not sceneitem or not transform then
        return false
    end

    -- Position
    local pos = obs.vec2()
    pos.x = transform.pos.x
    pos.y = transform.pos.y
    obs.obs_sceneitem_set_pos(sceneitem, pos)

    -- Scale
    local scale = obs.vec2()
    scale.x = transform.scale.x
    scale.y = transform.scale.y
    obs.obs_sceneitem_set_scale(sceneitem, scale)

    -- Rotation
    obs.obs_sceneitem_set_rot(sceneitem, transform.rot)

    -- Bounds
    obs.obs_sceneitem_set_bounds_type(sceneitem, transform.bounds_type)
    local bounds = obs.vec2()
    bounds.x = transform.bounds.x
    bounds.y = transform.bounds.y
    obs.obs_sceneitem_set_bounds(sceneitem, bounds)

    -- Crop
    local crop = obs.obs_sceneitem_crop()
    crop.left = transform.crop.left
    crop.top = transform.crop.top
    crop.right = transform.crop.right
    crop.bottom = transform.crop.bottom
    obs.obs_sceneitem_set_crop(sceneitem, crop)

    return true
end

-- Initialize with a source name
function SourceManager:init(source_name)
    self:release()  -- Clean up any existing state

    if not source_name or source_name == "" then
        log("SourceManager: No source name provided")
        return false
    end

    self.source_name = source_name

    -- Get current scene
    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then
        log("SourceManager: No current scene")
        return false
    end

    self.scene = scene_source

    -- Find the scene item
    self.sceneitem = self:find_sceneitem(scene_source, source_name)
    if not self.sceneitem then
        log("SourceManager: Source not found in scene: " .. source_name)
        obs.obs_source_release(scene_source)
        return false
    end

    -- Get the source
    self.source = obs.obs_sceneitem_get_source(self.sceneitem)
    if not self.source then
        log("SourceManager: Failed to get source from sceneitem")
        obs.obs_source_release(scene_source)
        return false
    end

    -- Capture original transform
    self.original_transform = self:capture_transform(self.sceneitem)

    -- Create crop filter
    if not crop_filter_create(self.source) then
        log("SourceManager: Failed to create crop filter")
        obs.obs_source_release(scene_source)
        return false
    end

    self.initialized = true
    log("SourceManager: Initialized with source: " .. source_name)

    obs.obs_source_release(scene_source)
    return true
end

-- Release all resources
function SourceManager:release()
    -- Clean up crop filter
    crop_filter_cleanup()

    -- Restore original transform if we have it
    if self.sceneitem and self.original_transform then
        self:restore_transform(self.sceneitem, self.original_transform)
        log("SourceManager: Restored original transform")
    end

    self.source = nil
    self.sceneitem = nil
    self.scene = nil
    self.original_transform = nil
    self.initialized = false

    log("SourceManager: Released")
end

-- Get source dimensions
function SourceManager:get_source_size()
    if not self.source then
        return 0, 0
    end
    return obs.obs_source_get_width(self.source), obs.obs_source_get_height(self.source)
end

-- Check if source is valid
function SourceManager:is_valid()
    return self.initialized and self.source ~= nil and self.sceneitem ~= nil
end

-- Get source info
function SourceManager:get_info()
    if not self:is_valid() then
        return nil
    end

    return {
        name = self.source_name,
        width = obs.obs_source_get_width(self.source),
        height = obs.obs_source_get_height(self.source),
    }
end

-- Get list of available capture sources
function SourceManager.get_available_sources()
    local sources = {}

    -- Get all sources
    local source_list = obs.obs_enum_sources()
    if source_list then
        for _, source in ipairs(source_list) do
            local source_id = obs.obs_source_get_id(source)
            local name = obs.obs_source_get_name(source)

            -- Filter for capture sources
            local is_capture = false
            if source_id == "monitor_capture" or      -- Display capture
               source_id == "window_capture" or       -- Window capture
               source_id == "game_capture" or         -- Game capture
               source_id == "xshm_input" or           -- Linux X11 capture
               source_id == "av_capture_input" then   -- macOS capture
                is_capture = true
            end

            if is_capture then
                table.insert(sources, {
                    name = name,
                    id = source_id,
                })
            end
        end
        obs.source_list_release(source_list)
    end

    return sources
end

-- Convenience wrapper functions
function source_manager_init(source_name)
    return SourceManager:init(source_name)
end

function source_manager_release()
    return SourceManager:release()
end

function source_manager_is_valid()
    return SourceManager:is_valid()
end

function source_manager_get_source()
    return SourceManager.source
end

function source_manager_get_sceneitem()
    return SourceManager.sceneitem
end

function source_manager_get_size()
    return SourceManager:get_source_size()
end

function source_manager_get_available_sources()
    return SourceManager.get_available_sources()
end

--================================================
-- MODULE: Camera Physics (M06)
--================================================
-- Handles camera position calculations, dead zones,
-- and SmoothDamp-based camera movement

local CameraPhysics = {
    -- Smoothed camera position
    pos = { x = 0, y = 0 },

    -- Velocities for SmoothDamp
    vel_x = { val = 0 },
    vel_y = { val = 0 },

    -- Dead zone state
    tracked_pos = { x = 0, y = 0 },
    dead_zone_active = false,

    -- Last camera position (for velocity calculation)
    last_pos = { x = 0, y = 0 },

    -- Monitor offset (for multi-monitor setups)
    monitor_offset = { x = 0, y = 0 },
}

-- Initialize camera tracking with starting position
function CameraPhysics:init(mouse_pos)
    if mouse_pos then
        self.pos.x = mouse_pos.x
        self.pos.y = mouse_pos.y
        self.tracked_pos.x = mouse_pos.x
        self.tracked_pos.y = mouse_pos.y
    end
    self.vel_x.val = 0
    self.vel_y.val = 0
    self.last_pos.x = self.pos.x
    self.last_pos.y = self.pos.y
end

-- Apply dead zone to mouse input
-- Returns the position the camera should track
function CameraPhysics:apply_dead_zone(mouse_pos, dead_zone_radius)
    if not mouse_pos then
        return self.tracked_pos
    end

    if dead_zone_radius <= 0 then
        self.tracked_pos.x = mouse_pos.x
        self.tracked_pos.y = mouse_pos.y
        return self.tracked_pos
    end

    -- Calculate distance from tracked position to mouse
    local dx = mouse_pos.x - self.tracked_pos.x
    local dy = mouse_pos.y - self.tracked_pos.y
    local dist = math.sqrt(dx * dx + dy * dy)

    if dist <= dead_zone_radius then
        -- Mouse is within dead zone, don't move tracked position
        self.dead_zone_active = true
        return self.tracked_pos
    end

    -- Mouse is outside dead zone
    -- Move tracked position so it stays exactly dead_zone_radius from mouse
    self.dead_zone_active = false
    local excess = dist - dead_zone_radius
    local nx = dx / dist  -- Normalized direction
    local ny = dy / dist

    self.tracked_pos.x = self.tracked_pos.x + nx * excess
    self.tracked_pos.y = self.tracked_pos.y + ny * excess

    return self.tracked_pos
end

-- Smooth the input position using SmoothDamp
function CameraPhysics:smooth_input(target_pos, smooth_time, dt)
    if not target_pos then
        return self.pos
    end

    local max_speed = 100000  -- Very high max speed for smooth camera

    self.pos.x = SmoothDamp(self.pos.x, target_pos.x, self.vel_x, smooth_time, max_speed, dt)
    self.pos.y = SmoothDamp(self.pos.y, target_pos.y, self.vel_y, smooth_time, max_speed, dt)

    return self.pos
end

-- Calculate the crop rectangle for a given zoom level and center position
function CameraPhysics:compute_crop(center_x, center_y, zoom_level, source_w, source_h)
    if zoom_level <= 1.0 then
        -- No zoom, return full source
        return {
            x = 0,
            y = 0,
            w = source_w,
            h = source_h,
        }
    end

    -- Calculate crop dimensions
    local crop_w = source_w / zoom_level
    local crop_h = source_h / zoom_level

    -- Center the crop on the target position
    local crop_x = center_x - crop_w / 2
    local crop_y = center_y - crop_h / 2

    -- Clamp to source bounds
    crop_x = clamp(0, source_w - crop_w, crop_x)
    crop_y = clamp(0, source_h - crop_h, crop_y)

    return {
        x = crop_x,
        y = crop_y,
        w = crop_w,
        h = crop_h,
    }
end

-- Calculate target crop for zoom animation
-- mouse_pos: current mouse position
-- zoom_level: target zoom level
-- source_w, source_h: source dimensions
-- monitor_offset: offset for multi-monitor (optional)
function CameraPhysics:get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
    if not mouse_pos then
        return nil
    end

    -- Apply monitor offset if provided
    local target_x = mouse_pos.x
    local target_y = mouse_pos.y

    if monitor_offset then
        target_x = target_x - monitor_offset.x
        target_y = target_y - monitor_offset.y
    end

    -- Clamp to source bounds
    target_x = clamp(0, source_w, target_x)
    target_y = clamp(0, source_h, target_y)

    return self:compute_crop(target_x, target_y, zoom_level, source_w, source_h)
end

-- Interpolate between two crop rectangles
function CameraPhysics:lerp_crop(start_crop, end_crop, t, easing_fn)
    if not start_crop or not end_crop then
        return nil
    end

    t = clamp(0, 1, t)

    -- Apply easing
    local eased_t = easing_fn and easing_fn(t) or t

    return {
        x = lerp(start_crop.x, end_crop.x, eased_t),
        y = lerp(start_crop.y, end_crop.y, eased_t),
        w = lerp(start_crop.w, end_crop.w, eased_t),
        h = lerp(start_crop.h, end_crop.h, eased_t),
    }
end

-- Get camera velocity (for motion blur)
function CameraPhysics:get_velocity()
    return {
        x = self.pos.x - self.last_pos.x,
        y = self.pos.y - self.last_pos.y,
    }
end

-- Update last position (call at end of frame)
function CameraPhysics:update_last_pos()
    self.last_pos.x = self.pos.x
    self.last_pos.y = self.pos.y
end

-- Set monitor offset
function CameraPhysics:set_monitor_offset(offset)
    self.monitor_offset = offset or { x = 0, y = 0 }
end

-- Reset camera state
function CameraPhysics:reset()
    self.pos = { x = 0, y = 0 }
    self.vel_x = { val = 0 }
    self.vel_y = { val = 0 }
    self.tracked_pos = { x = 0, y = 0 }
    self.dead_zone_active = false
    self.last_pos = { x = 0, y = 0 }
end

-- Convenience wrapper functions
function camera_physics_init(mouse_pos)
    return CameraPhysics:init(mouse_pos)
end

function camera_physics_apply_dead_zone(mouse_pos, dead_zone_radius)
    return CameraPhysics:apply_dead_zone(mouse_pos, dead_zone_radius)
end

function camera_physics_smooth_input(target_pos, smooth_time, dt)
    return CameraPhysics:smooth_input(target_pos, smooth_time, dt)
end

function camera_physics_compute_crop(center_x, center_y, zoom_level, source_w, source_h)
    return CameraPhysics:compute_crop(center_x, center_y, zoom_level, source_w, source_h)
end

function camera_physics_get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
    return CameraPhysics:get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
end

function camera_physics_lerp_crop(start_crop, end_crop, t, easing_fn)
    return CameraPhysics:lerp_crop(start_crop, end_crop, t, easing_fn)
end

function camera_physics_get_velocity()
    return CameraPhysics:get_velocity()
end

function camera_physics_update_last_pos()
    return CameraPhysics:update_last_pos()
end

function camera_physics_reset()
    return CameraPhysics:reset()
end

--================================================
-- MODULE: Timer & Main Loop (M09)
--================================================
-- Core integration module that handles frame-by-frame updates,
-- input processing, state machine updates, and output

-- Configuration (will be populated from settings)
local cfg = {
    source_name = "",
    zoom_value = 2.0,
    max_zoom = 10.0,
    zoom_duration = 0.6,
    zoom_overshoot = 0.0,
    zoom_easing = "Cubic.Out",

    auto_follow = true,
    follow_smooth_time = 0.15,
    follow_dead_zone = 5,

    debug_logs = false,
}

-- Timing
local last_tick_time = 0
local timer_running = false

-- Frame diff tracking (skip updates if nothing changed)
local last_output = { x = -1, y = -1, w = -1, h = -1 }

-- Original crop for zoom out
local original_crop = { x = 0, y = 0, w = 0, h = 0 }

-- Hotkey IDs
local hotkey_toggle_zoom = nil
local hotkey_toggle_follow = nil

-- Get reliable delta time
local function get_dt()
    local now = os.clock()
    local dt = now - last_tick_time
    last_tick_time = now
    return clamp(0.001, 0.1, dt)  -- Guard against freezes and div/zero
end

-- Start the timer
local function start_timer()
    if not timer_running then
        timer_running = true
        last_tick_time = os.clock()
        -- Use frame-synced interval
        local interval = 16  -- Default to ~60fps
        obs.timer_add(on_timer, interval)
        log("Timer: Started")
    end
end

-- Stop the timer
local function stop_timer()
    if timer_running then
        timer_running = false
        obs.timer_remove(on_timer)
        log("Timer: Stopped")
    end
end

-- Initialize mouse tracking
local function init_mouse_tracking(mouse_pos)
    camera_physics_init(mouse_pos)
    original_crop = {
        x = 0,
        y = 0,
        w = 0,
        h = 0,
    }
end

-- Main timer callback
function on_timer()
    local dt = get_dt()

    -- Guard: No valid source
    if not source_manager_is_valid() then
        return
    end

    --==========================
    -- 1. INPUT
    --==========================
    local raw_mouse = platform_get_mouse_pos()

    --==========================
    -- 2. STATE MACHINE UPDATE
    --==========================
    if SM:is_animating() then
        SM.zoom_time = SM.zoom_time + (dt / cfg.zoom_duration)

        -- Check for completion
        if SM.zoom_time >= 1.0 then
            SM:complete()

            -- Auto-enable follow after zoom in
            if SM.state == ZoomState.ZOOMED_IN and cfg.auto_follow then
                SM.following = true
            end

            -- Stop timer if idle
            if SM.state == ZoomState.IDLE then
                stop_timer()
            end
        end
    end

    --==========================
    -- 3. CAMERA POSITION
    --==========================
    local crop = nil
    local source_w, source_h = source_manager_get_size()

    if source_w == 0 or source_h == 0 then
        return
    end

    if SM:is_animating() then
        -- Animate between start and target crop
        local easing_fn = Easing.get(cfg.zoom_easing, cfg.zoom_overshoot)
        crop = camera_physics_lerp_crop(SM.start_crop, SM.target_crop, SM.zoom_time, easing_fn)
    elseif SM:is_zoomed() and SM.following then
        -- Follow mouse with dead zone and smoothing
        local tracked = camera_physics_apply_dead_zone(raw_mouse, cfg.follow_dead_zone)
        local smoothed = camera_physics_smooth_input(tracked, cfg.follow_smooth_time, dt)
        crop = camera_physics_compute_crop(smoothed.x, smoothed.y, SM.zoom_level, source_w, source_h)
        camera_physics_update_last_pos()
    elseif SM:is_zoomed() then
        -- Static zoom (not following)
        crop = camera_physics_get_target_crop(
            { x = SM.target_crop.x + SM.target_crop.w / 2, y = SM.target_crop.y + SM.target_crop.h / 2 },
            SM.zoom_level, source_w, source_h, nil
        )
    end

    --==========================
    -- 4. OUTPUT (Diff-based)
    --==========================
    if crop then
        local cx = math.floor(crop.x)
        local cy = math.floor(crop.y)
        local cw = math.floor(crop.w)
        local ch = math.floor(crop.h)

        if cx ~= last_output.x or cy ~= last_output.y or
           cw ~= last_output.w or ch ~= last_output.h then
            crop_filter_update(cx, cy, cw, ch)
            last_output.x = cx
            last_output.y = cy
            last_output.w = cw
            last_output.h = ch
        end
    end
end

--==========================
-- HOTKEY HANDLERS
--==========================

function on_toggle_zoom(pressed)
    if not pressed then return end

    if not source_manager_is_valid() then
        log("Toggle Zoom: No valid source")
        return
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        log("Toggle Zoom: Invalid source dimensions")
        return
    end

    if SM.state == ZoomState.IDLE then
        -- ZOOM IN
        local mouse = platform_get_mouse_pos()
        init_mouse_tracking(mouse)

        -- Store original crop
        original_crop = { x = 0, y = 0, w = source_w, h = source_h }

        -- Calculate target crop
        local target_crop = camera_physics_get_target_crop(mouse, cfg.zoom_value, source_w, source_h, nil)

        SM:transition(ZoomState.ZOOMING_IN, {
            start_crop = original_crop,
            target_crop = target_crop,
            target_level = cfg.zoom_value
        })

        start_timer()

    elseif SM.state == ZoomState.ZOOMED_IN then
        -- ZOOM OUT
        SM.following = false

        local current = crop_filter_get_crop()
        SM:transition(ZoomState.ZOOMING_OUT, {
            start_crop = current,
            target_crop = original_crop,
            target_level = 1.0
        })

        start_timer()
    end
    -- Ignore if already animating (guard against rapid presses)
end

function on_toggle_follow(pressed)
    if not pressed then return end
    if not SM:is_zoomed() then return end

    SM.following = not SM.following
    log("Follow: " .. tostring(SM.following))

    if SM.following and not timer_running then
        start_timer()
    end
end

--==========================
-- HOTKEY REGISTRATION
--==========================

local function register_hotkeys(settings)
    -- Toggle Zoom hotkey
    hotkey_toggle_zoom = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.toggle_zoom",
        "Toggle Zoom to Mouse",
        on_toggle_zoom
    )

    -- Toggle Follow hotkey
    hotkey_toggle_follow = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.toggle_follow",
        "Toggle Mouse Follow",
        on_toggle_follow
    )

    -- Load saved hotkey bindings
    local toggle_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.toggle_zoom")
    if toggle_array then
        obs.obs_hotkey_load(hotkey_toggle_zoom, toggle_array)
        obs.obs_data_array_release(toggle_array)
    end

    local follow_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.toggle_follow")
    if follow_array then
        obs.obs_hotkey_load(hotkey_toggle_follow, follow_array)
        obs.obs_data_array_release(follow_array)
    end

    -- Register scroll zoom hotkeys
    register_scroll_hotkeys(settings)

    log("Hotkeys: Registered")
end

local function save_hotkeys(settings)
    if hotkey_toggle_zoom then
        local array = obs.obs_hotkey_save(hotkey_toggle_zoom)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.toggle_zoom", array)
        obs.obs_data_array_release(array)
    end

    if hotkey_toggle_follow then
        local array = obs.obs_hotkey_save(hotkey_toggle_follow)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.toggle_follow", array)
        obs.obs_data_array_release(array)
    end

    -- Save scroll zoom hotkeys
    save_scroll_hotkeys(settings)
end

local function unregister_hotkeys()
    if hotkey_toggle_zoom then
        obs.obs_hotkey_unregister(hotkey_toggle_zoom)
        hotkey_toggle_zoom = nil
    end
    if hotkey_toggle_follow then
        obs.obs_hotkey_unregister(hotkey_toggle_follow)
        hotkey_toggle_follow = nil
    end
    -- Unregister scroll zoom hotkeys
    unregister_scroll_hotkeys()
    log("Hotkeys: Unregistered")
end

--==========================
-- SCENE EVENT HANDLERS
--==========================

function on_frontend_event(event)
    if event == obs.OBS_FRONTEND_EVENT_SCENE_CHANGED then
        -- Scene changed, re-acquire source
        log("Event: Scene changed")

        -- Handle scene memory
        scene_memory_on_scene_change()

        if cfg.source_name and cfg.source_name ~= "" then
            source_manager_release()
            source_manager_init(cfg.source_name)
        end
    elseif event == obs.OBS_FRONTEND_EVENT_EXIT then
        -- OBS is closing
        log("Event: OBS exiting")
        stop_timer()
        source_manager_release()
    end
end

--==========================
-- CONFIGURATION UPDATE
--==========================

local function update_config(settings)
    cfg.source_name = obs.obs_data_get_string(settings, "source") or ""
    cfg.zoom_value = obs.obs_data_get_double(settings, "zoom_value")
    cfg.zoom_duration = obs.obs_data_get_double(settings, "zoom_duration")
    cfg.zoom_overshoot = obs.obs_data_get_double(settings, "zoom_overshoot")
    cfg.zoom_easing = obs.obs_data_get_string(settings, "zoom_easing") or "Cubic.Out"

    cfg.auto_follow = obs.obs_data_get_bool(settings, "auto_follow")
    cfg.follow_smooth_time = obs.obs_data_get_double(settings, "follow_smooth_time")
    cfg.follow_dead_zone = obs.obs_data_get_int(settings, "follow_dead_zone")

    cfg.debug_logs = obs.obs_data_get_bool(settings, "debug_logs")
    debug_logs = cfg.debug_logs

    -- Update scroll zoom config
    update_scroll_config(settings)

    -- Check if source changed
    local current_source = source_manager_is_valid() and cfg.source_name
    if cfg.source_name ~= "" and cfg.source_name ~= current_source then
        -- Reset state and reinitialize
        SM:reset()
        stop_timer()
        source_manager_release()
        source_manager_init(cfg.source_name)
    end
end

--================================================
-- MODULE: Scroll Zoom (M10)
--================================================
-- Enables gradual zoom control via scroll wheel with modifier key
-- Provides dynamic zoom level adjustment during zoomed state

local ScrollZoom = {
    -- Hotkey IDs for scroll zoom
    hotkey_scroll_up = nil,
    hotkey_scroll_down = nil,

    -- Configuration (populated from settings)
    scroll_step = 0.25,
    scroll_modifier = "ctrl",  -- "ctrl", "alt", "shift"
}

-- Check if modifier key is held
local function is_modifier_held()
    if ScrollZoom.scroll_modifier == "ctrl" then
        return platform_is_ctrl_held()
    elseif ScrollZoom.scroll_modifier == "alt" then
        return platform_is_alt_held()
    elseif ScrollZoom.scroll_modifier == "shift" then
        return platform_is_shift_held()
    end
    return false
end

-- Handle scroll zoom in
function on_scroll_zoom_up(pressed)
    if not pressed then return end
    on_scroll_zoom(1)
end

-- Handle scroll zoom out
function on_scroll_zoom_down(pressed)
    if not pressed then return end
    on_scroll_zoom(-1)
end

-- Main scroll zoom handler
function on_scroll_zoom(direction)
    -- Check if we can scroll
    if not SM:can_scroll() then return end

    -- Check modifier (optional - can be configured)
    -- For now, we rely on OBS hotkey bindings which can include modifiers

    if not source_manager_is_valid() then
        log("Scroll Zoom: No valid source")
        return
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        return
    end

    -- Calculate new zoom level
    local step = ScrollZoom.scroll_step * direction  -- e.g., 0.25
    local new_level

    if SM.state == ZoomState.IDLE then
        -- Starting from unzoomed
        new_level = 1.0 + step
    else
        -- Already zoomed, adjust level
        new_level = SM.target_level + step
    end

    -- Clamp to valid range
    new_level = clamp(1.0, cfg.max_zoom, new_level)

    -- If we hit 1.0, fully zoom out
    if new_level <= 1.0 then
        if SM:is_zoomed() then
            -- Trigger full zoom out
            local current = crop_filter_get_crop()
            SM.following = false
            SM:transition(ZoomState.ZOOMING_OUT, {
                start_crop = current,
                target_crop = original_crop,
                target_level = 1.0
            })
            start_timer()
        end
        return
    end

    -- Get current mouse position
    local mouse = platform_get_mouse_pos()

    -- Calculate new target crop for new zoom level
    local target_crop = camera_physics_get_target_crop(mouse, new_level, source_w, source_h, nil)

    -- Get current crop as start
    local start_crop
    if SM:is_animating() then
        -- Use current interpolated crop
        start_crop = crop_filter_get_crop()
    elseif SM:is_zoomed() then
        -- Use current crop
        start_crop = crop_filter_get_crop()
    else
        -- Starting from unzoomed
        start_crop = { x = 0, y = 0, w = source_w, h = source_h }
        original_crop = start_crop
        camera_physics_init(mouse)
    end

    -- Transition to new zoom level
    if SM.state == ZoomState.IDLE then
        -- First scroll from unzoomed
        SM:transition(ZoomState.SCROLLING, {
            start_crop = start_crop,
            target_crop = target_crop,
            target_level = new_level
        })
    else
        -- Already zoomed, adjust level (interrupt current animation)
        SM:transition(ZoomState.SCROLLING, {
            start_crop = start_crop,
            target_crop = target_crop,
            target_level = new_level
        })
    end

    start_timer()
    log("Scroll Zoom: Level " .. string.format("%.2f", new_level))
end

-- Zoom to a specific level (for API calls)
function on_scroll_zoom_to(level)
    if not source_manager_is_valid() then return end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then return end

    level = clamp(1.0, cfg.max_zoom, level)

    if level <= 1.0 then
        -- Zoom out
        if SM:is_zoomed() then
            local current = crop_filter_get_crop()
            SM.following = false
            SM:transition(ZoomState.ZOOMING_OUT, {
                start_crop = current,
                target_crop = original_crop,
                target_level = 1.0
            })
            start_timer()
        end
        return
    end

    local mouse = platform_get_mouse_pos()
    local target_crop = camera_physics_get_target_crop(mouse, level, source_w, source_h, nil)

    local start_crop
    if SM:is_zoomed() then
        start_crop = crop_filter_get_crop()
    else
        start_crop = { x = 0, y = 0, w = source_w, h = source_h }
        original_crop = start_crop
        camera_physics_init(mouse)
    end

    SM:transition(ZoomState.SCROLLING, {
        start_crop = start_crop,
        target_crop = target_crop,
        target_level = level
    })

    start_timer()
end

-- Register scroll zoom hotkeys
local function register_scroll_hotkeys(settings)
    -- Scroll Up hotkey
    ScrollZoom.hotkey_scroll_up = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.scroll_up",
        "Zoom In (Scroll)",
        on_scroll_zoom_up
    )

    -- Scroll Down hotkey
    ScrollZoom.hotkey_scroll_down = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.scroll_down",
        "Zoom Out (Scroll)",
        on_scroll_zoom_down
    )

    -- Load saved bindings
    local up_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.scroll_up")
    if up_array then
        obs.obs_hotkey_load(ScrollZoom.hotkey_scroll_up, up_array)
        obs.obs_data_array_release(up_array)
    end

    local down_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.scroll_down")
    if down_array then
        obs.obs_hotkey_load(ScrollZoom.hotkey_scroll_down, down_array)
        obs.obs_data_array_release(down_array)
    end

    log("Scroll Zoom: Hotkeys registered")
end

-- Save scroll hotkey bindings
local function save_scroll_hotkeys(settings)
    if ScrollZoom.hotkey_scroll_up then
        local array = obs.obs_hotkey_save(ScrollZoom.hotkey_scroll_up)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.scroll_up", array)
        obs.obs_data_array_release(array)
    end

    if ScrollZoom.hotkey_scroll_down then
        local array = obs.obs_hotkey_save(ScrollZoom.hotkey_scroll_down)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.scroll_down", array)
        obs.obs_data_array_release(array)
    end
end

-- Unregister scroll hotkeys
local function unregister_scroll_hotkeys()
    if ScrollZoom.hotkey_scroll_up then
        obs.obs_hotkey_unregister(ScrollZoom.hotkey_scroll_up)
        ScrollZoom.hotkey_scroll_up = nil
    end
    if ScrollZoom.hotkey_scroll_down then
        obs.obs_hotkey_unregister(ScrollZoom.hotkey_scroll_down)
        ScrollZoom.hotkey_scroll_down = nil
    end
end

-- Update scroll zoom config
local function update_scroll_config(settings)
    ScrollZoom.scroll_step = obs.obs_data_get_double(settings, "scroll_step")
    ScrollZoom.scroll_modifier = obs.obs_data_get_string(settings, "scroll_modifier") or "ctrl"
end

--================================================
-- PLACEHOLDER: Future Modules
--================================================

-- M01: Configuration & Settings (TODO)
-- M05: Scene Manager (TODO)
-- M06: Source Manager (TODO)
-- M07: Crop/Zoom Controller (TODO)
-- M08: Motion Tracker (TODO)
-- M09: Face Detection (TODO)
-- M11: Audio Reactor (TODO)
-- M12: Transition Manager (TODO)
-- M13: Animation Controller (TODO)
-- M14: Preset Manager (TODO)
-- M15: Hotkey Manager (TODO)
-- M16: UI Components (TODO)
-- M17: Timer/Scheduler (TODO)
-- M18: State Machine (TODO)
-- M19: Performance Monitor (TODO)

--================================================
-- SCRIPT SETTINGS
--================================================
local settings = {}

-- Default settings
local defaults = {
    debug_logging = false,
    easing_type = "QuadInOut",
    smooth_time = 0.3,
    max_speed = 100.0
}

--================================================
-- MODULE: Preset Manager (M13)
--================================================
-- Manages built-in and custom animation presets

local PresetManager = {
    -- Built-in presets (read-only)
    built_in = {
        {
            name = "Smooth",
            duration = 0.8,
            overshoot = 0.0,
            smoothness = 0.25,
            easing = "Cubic.Out",
        },
        {
            name = "Bounce",
            duration = 0.6,
            overshoot = 0.35,
            smoothness = 0.15,
            easing = "Back.Out",
        },
        {
            name = "Snappy",
            duration = 0.3,
            overshoot = 0.0,
            smoothness = 0.05,
            easing = "Expo.Out",
        },
        {
            name = "Cinematic",
            duration = 1.2,
            overshoot = 0.05,
            smoothness = 0.4,
            easing = "Sine.Out",
        },
    },

    -- Custom user presets
    custom = {},

    -- Currently selected preset name
    current_preset = "Smooth",
}

-- Get all preset names (built-in + custom)
function PresetManager:get_all_names()
    local names = {}

    -- Add built-in presets
    for _, preset in ipairs(self.built_in) do
        table.insert(names, preset.name)
    end

    -- Add custom presets
    for name, _ in pairs(self.custom) do
        table.insert(names, name)
    end

    table.sort(names)
    return names
end

-- Get preset by name
function PresetManager:get_preset(name)
    -- Check built-in first
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            return preset
        end
    end

    -- Check custom
    if self.custom[name] then
        return self.custom[name]
    end

    -- Default to Smooth
    return self.built_in[1]
end

-- Apply preset to configuration
function PresetManager:apply_preset(name)
    local preset = self:get_preset(name)
    if not preset then
        log("Preset: Unknown preset: " .. name)
        return false
    end

    cfg.zoom_duration = preset.duration
    cfg.zoom_overshoot = preset.overshoot
    cfg.follow_smooth_time = preset.smoothness

    if preset.easing then
        cfg.zoom_easing = preset.easing
    end

    self.current_preset = name
    log("Preset: Applied '" .. name .. "'")
    return true
end

-- Save a custom preset
function PresetManager:save_preset(name, duration, overshoot, smoothness, easing)
    if not name or name == "" then
        return false
    end

    -- Check if it's a built-in preset (can't override)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            log("Preset: Cannot override built-in preset: " .. name)
            return false
        end
    end

    -- Save custom preset
    self.custom[name] = {
        name = name,
        duration = duration or cfg.zoom_duration,
        overshoot = overshoot or cfg.zoom_overshoot,
        smoothness = smoothness or cfg.follow_smooth_time,
        easing = easing or cfg.zoom_easing,
    }

    log("Preset: Saved custom preset '" .. name .. "'")
    return true
end

-- Delete a custom preset
function PresetManager:delete_preset(name)
    -- Check if it's a built-in preset (can't delete)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            log("Preset: Cannot delete built-in preset: " .. name)
            return false
        end
    end

    -- Delete custom preset
    if self.custom[name] then
        self.custom[name] = nil
        log("Preset: Deleted custom preset '" .. name .. "'")
        return true
    end

    return false
end

-- Check if a preset is built-in
function PresetManager:is_built_in(name)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            return true
        end
    end
    return false
end

-- Persist custom presets to settings
function PresetManager:persist(settings)
    local array = obs.obs_data_array_create()

    for name, preset in pairs(self.custom) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "name", name)
        obs.obs_data_set_double(item, "duration", preset.duration)
        obs.obs_data_set_double(item, "overshoot", preset.overshoot)
        obs.obs_data_set_double(item, "smoothness", preset.smoothness)
        obs.obs_data_set_string(item, "easing", preset.easing)
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "custom_presets", array)
    obs.obs_data_array_release(array)
end

-- Load custom presets from settings
function PresetManager:load(settings)
    self.custom = {}

    local array = obs.obs_data_get_array(settings, "custom_presets")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local name = obs.obs_data_get_string(item, "name")

        if name and name ~= "" then
            self.custom[name] = {
                name = name,
                duration = obs.obs_data_get_double(item, "duration"),
                overshoot = obs.obs_data_get_double(item, "overshoot"),
                smoothness = obs.obs_data_get_double(item, "smoothness"),
                easing = obs.obs_data_get_string(item, "easing"),
            }
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)
    log("Preset: Loaded " .. self:get_custom_count() .. " custom presets")
end

-- Get count of custom presets
function PresetManager:get_custom_count()
    local count = 0
    for _, _ in pairs(self.custom) do
        count = count + 1
    end
    return count
end

-- Get current preset name
function PresetManager:get_current_name()
    return self.current_preset
end

-- Set current preset name
function PresetManager:set_current_name(name)
    self.current_preset = name
end

-- Check if current preset is custom
function PresetManager:is_current_custom()
    return not self:is_built_in(self.current_preset)
end

-- Global convenience functions
function preset_get_all_names()
    return PresetManager:get_all_names()
end

function preset_apply(name)
    return PresetManager:apply_preset(name)
end

function preset_save(name, duration, overshoot, smoothness, easing)
    return PresetManager:save_preset(name, duration, overshoot, smoothness, easing)
end

function preset_delete(name)
    return PresetManager:delete_preset(name)
end

function preset_is_built_in(name)
    return PresetManager:is_built_in(name)
end

function preset_get_current()
    return PresetManager:get_current_name()
end

--================================================
-- MODULE: Auto Source Detection (M11)
--================================================
-- Automatically detects and selects the best zoom source on first run

local AutoSourceDetector = {
    -- Source type priorities (higher = more likely to be the main display)
    type_priorities = {
        ["monitor_capture"] = 100,     -- Display capture (highest priority)
        ["game_capture"] = 80,          -- Game capture
        ["window_capture"] = 60,        -- Window capture
        ["xshm_input"] = 40,           -- Linux X11 capture
        ["av_capture_input"] = 20,     -- macOS capture
    },

    -- Whether auto-detection has been run
    auto_detected = false,
}

-- Get all capture sources sorted by priority
function AutoSourceDetector:get_capture_sources()
    local sources = {}
    local source_list = obs.obs_enum_sources()

    if not source_list then
        return sources
    end

    for _, source in ipairs(source_list) do
        local source_id = obs.obs_source_get_id(source)
        local name = obs.obs_source_get_name(source)

        -- Check if it's a capture source
        local priority = self.type_priorities[source_id]
        if priority then
            table.insert(sources, {
                name = name,
                id = source_id,
                priority = priority,
            })
        end
    end

    obs.source_list_release(source_list)

    -- Sort by priority (highest first)
    table.sort(sources, function(a, b)
        return a.priority > b.priority
    end)

    return sources
end

-- Auto-detect the best source
function AutoSourceDetector:auto_detect()
    local sources = self:get_capture_sources()

    if #sources == 0 then
        log("AutoSource: No capture sources found")
        return nil
    end

    if #sources == 1 then
        -- Only one source, use it
        log("AutoSource: Found single source: " .. sources[1].name)
        return sources[1].name
    end

    -- Multiple sources - prioritize by type
    -- Prefer monitor_capture > game_capture > window_capture
    local best = sources[1]

    log("AutoSource: Found " .. #sources .. " sources, selecting: " .. best.name)
    return best.name
end

-- Get monitor geometry from a source (if available)
function AutoSourceDetector:get_monitor_geometry(source_name)
    local source = obs.obs_get_source_by_name(source_name)
    if not source then
        return nil
    end

    local settings = obs.obs_source_get_settings(source)
    if not settings then
        obs.obs_source_release(source)
        return nil
    end

    -- Try to get monitor info from settings
    local monitor = obs.obs_data_get_int(settings, "monitor")
    local x = obs.obs_data_get_int(settings, "x")
    local y = obs.obs_data_get_int(settings, "y")
    local width = obs.obs_data_get_int(settings, "width")
    local height = obs.obs_data_get_int(settings, "height")

    obs.obs_data_release(settings)
    obs.obs_source_release(source)

    -- Return geometry if available
    if monitor >= 0 or width > 0 then
        return {
            monitor = monitor,
            x = x,
            y = y,
            width = width or 1920,
            height = height or 1080,
        }
    end

    return nil
end

-- Check if we should auto-detect on first run
function AutoSourceDetector:should_auto_detect(settings)
    -- Check if source has ever been set
    local last_source = obs.obs_data_get_string(settings, "source")
    if last_source and last_source ~= "" then
        return false
    end

    -- Check if auto-detect has been done
    return not self.auto_detected
end

-- Run auto-detection and return the source name
function AutoSourceDetector:run(settings)
    local source_name = self:auto_detect()

    if source_name then
        -- Save the detected source
        obs.obs_data_set_string(settings, "source", source_name)
        self.auto_detected = true
    end

    return source_name
end

-- Global convenience functions
function auto_source_detect()
    return AutoSourceDetector:auto_detect()
end

function auto_source_should_detect(settings)
    return AutoSourceDetector:should_auto_detect(settings)
end

function auto_source_run(settings)
    return AutoSourceDetector:run(settings)
end

--================================================
-- MODULE: Scene Memory (M12)
--================================================
-- Remembers which zoom source to use for each OBS scene

local SceneMemory = {
    -- Scene to source mapping
    scene_source_map = {},

    -- Maximum number of mappings to store
    max_mappings = 50,
}

-- Get the current scene name
function SceneMemory:get_current_scene_name()
    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then
        return nil
    end

    local name = obs.obs_source_get_name(scene_source)
    obs.obs_source_release(scene_source)
    return name
end

-- Get the source to use for the current scene
function SceneMemory:get_source_for_current_scene()
    local scene_name = self:get_current_scene_name()
    if not scene_name then
        return nil
    end

    -- 1. Check explicit mapping for this scene
    if self.scene_source_map[scene_name] then
        return self.scene_source_map[scene_name]
    end

    -- 2. Fall back to global source from config
    return cfg.source_name
end

-- Set the source for a specific scene
function SceneMemory:set(scene_name, source_name)
    if not scene_name or scene_name == "" then
        return false
    end

    -- Check if we're at capacity
    local count = 0
    for _, _ in pairs(self.scene_source_map) do
        count = count + 1
    end

    if count >= self.max_mappings and not self.scene_source_map[scene_name] then
        log("SceneMemory: At capacity (" .. self.max_mappings .. "), cannot add: " .. scene_name)
        return false
    end

    self.scene_source_map[scene_name] = source_name
    log("SceneMemory: " .. scene_name .. " Ã¢â€ â€™ " .. source_name)
    return true
end

-- Remove a scene mapping
function SceneMemory:remove(scene_name)
    if self.scene_source_map[scene_name] then
        self.scene_source_map[scene_name] = nil
        log("SceneMemory: Removed mapping for " .. scene_name)
        return true
    end
    return false
end

-- Get all scene mappings
function SceneMemory:get_all()
    local mappings = {}
    for scene, source in pairs(self.scene_source_map) do
        table.insert(mappings, { scene = scene, source = source })
    end
    table.sort(mappings, function(a, b)
        return a.scene < b.scene
    end)
    return mappings
end

-- Check if a scene has a mapping
function SceneMemory:has_mapping(scene_name)
    return self.scene_source_map[scene_name] ~= nil
end

-- Persist mappings to settings
function SceneMemory:persist(settings)
    local array = obs.obs_data_array_create()

    for scene, source in pairs(self.scene_source_map) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "scene", scene)
        obs.obs_data_set_string(item, "source", source)
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "scene_source_map", array)
    obs.obs_data_array_release(array)
end

-- Load mappings from settings
function SceneMemory:load(settings)
    self.scene_source_map = {}

    local array = obs.obs_data_get_array(settings, "scene_source_map")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local scene = obs.obs_data_get_string(item, "scene")
        local source = obs.obs_data_get_string(item, "source")

        if scene and scene ~= "" and source and source ~= "" then
            self.scene_source_map[scene] = source
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)

    local count = 0
    for _, _ in pairs(self.scene_source_map) do count = count + 1 end
    log("SceneMemory: Loaded " .. count .. " scene mappings")
end

-- Handle scene change
function SceneMemory:on_scene_change()
    local scene_name = self:get_current_scene_name()
    if not scene_name then
        return
    end

    -- Get the source for this scene
    local source_name = self:get_source_for_current_scene()

    if source_name and source_name ~= "" then
        -- Check if source changed
        local current = source_manager_is_valid() and cfg.source_name

        if source_name ~= current then
            log("SceneMemory: Scene changed to " .. scene_name)

            -- Release current source
            source_manager_release()

            -- Initialize with new source
            cfg.source_name = source_name
            source_manager_init(source_name)
        end
    end
end

-- Global convenience functions
function scene_memory_get_source()
    return SceneMemory:get_source_for_current_scene()
end

function scene_memory_set(scene_name, source_name)
    return SceneMemory:set(scene_name, source_name)
end

function scene_memory_remove(scene_name)
    return SceneMemory:remove(scene_name)
end

function scene_memory_get_all()
    return SceneMemory:get_all()
end

function scene_memory_on_scene_change()
    return SceneMemory:on_scene_change()
end

--================================================
-- MODULE: Blur Manager (M14)
--================================================
-- Provides built-in blur effects without external plugins
-- Supports multiple strategies: shader, composite_blur plugin, or none

local BlurManager = {
    -- Current strategy: "shader", "composite_blur", "none"
    strategy = "none",

    -- Filter references
    zoom_blur_filter = nil,
    motion_blur_filter = nil,

    -- Settings references
    zoom_blur_settings = nil,
    motion_blur_settings = nil,

    -- State
    initialized = false,

    -- Configuration
    zoom_blur_enabled = false,
    zoom_blur_intensity = 5,
    zoom_blur_clear_radius = 150,
    motion_blur_enabled = false,
    motion_blur_intensity = 1.0,
}

-- Try to use custom shader (if effect files exist)
function BlurManager:try_shader_strategy(source)
    -- This would require .effect files in assets/shaders/
    -- For now, we'll use a simpler approach
    log("Blur: Shader strategy not implemented (requires effect files)")
    return false
end

-- Try to auto-create Composite Blur filters
function BlurManager:try_composite_blur_strategy(source)
    if not source then return false end

    -- Check if composite_blur filter type exists
    local test_filter = obs.obs_source_create_private("composite_blur", "__test_blur__", nil)
    if test_filter then
        obs.obs_source_release(test_filter)
    else
        log("Blur: Composite Blur plugin not available")
        return false
    end

    -- Create Zoom Blur filter
    local zs = obs.obs_data_create()
    obs.obs_data_set_double(zs, "radius", 0)
    obs.obs_data_set_int(zs, "blur_type", 2) -- Zoom type
    self.zoom_blur_filter = obs.obs_source_create_private(
        "composite_blur",
        FILTER_PREFIX .. "Zoom Blur",
        zs
    )

    if self.zoom_blur_filter then
        obs.obs_source_filter_add(source, self.zoom_blur_filter)
        self.zoom_blur_settings = zs
    else
        obs.obs_data_release(zs)
        return false
    end

    -- Create Motion Blur filter
    local ms = obs.obs_data_create()
    obs.obs_data_set_double(ms, "radius", 0)
    obs.obs_data_set_int(ms, "blur_type", 3) -- Motion/directional type
    self.motion_blur_filter = obs.obs_source_create_private(
        "composite_blur",
        FILTER_PREFIX .. "Motion Blur",
        ms
    )

    if self.motion_blur_filter then
        obs.obs_source_filter_add(source, self.motion_blur_filter)
        self.motion_blur_settings = ms
    else
        obs.obs_data_release(ms)
    end

    self.initialized = true
    return true
end

-- Initialize blur manager
function BlurManager:init(source)
    if not source then
        return false
    end

    self:cleanup()

    -- Try composite_blur strategy
    if self:try_composite_blur_strategy(source) then
        self.strategy = "composite_blur"
        log("Blur: Using Composite Blur plugin (auto-configured)")
        return true
    end

    -- No blur available
    self.strategy = "none"
    log("Blur: No blur backend available. Blur effects disabled.")
    return false
end

-- Update blur based on zoom state
function BlurManager:update(state_machine, crop, camera_velocity)
    if not self.initialized then return end
    if self.strategy == "none" then return end

    -- Zoom Blur: Active during zoom transitions
    if self.zoom_blur_enabled and self.zoom_blur_filter then
        local radius = 0

        if state_machine:is_animating() and
           (state_machine.state == ZoomState.ZOOMING_IN or
            state_machine.state == ZoomState.ZOOMING_OUT) then
            -- Bell curve: 0 at start Ã¢â€ â€™ peak at 50% Ã¢â€ â€™ 0 at end
            local t = clamp(0, 1, state_machine.zoom_time)
            local curve = math.sin(t * math.pi)
            radius = curve * curve * self.zoom_blur_intensity
        end

        self:set_zoom_blur(radius, crop)
    end

    -- Motion Blur: Active during camera panning (not during zoom transition)
    if self.motion_blur_enabled and self.motion_blur_filter then
        if not state_machine:is_animating() and state_machine:is_zoomed() and camera_velocity then
            local speed = math.sqrt(
                camera_velocity.x * camera_velocity.x +
                camera_velocity.y * camera_velocity.y
            )

            if speed > 1.0 then
                local radius = math.min(10, speed * self.motion_blur_intensity * 0.5)
                local angle = math.deg(math.atan2(camera_velocity.y, camera_velocity.x))
                self:set_motion_blur(radius, angle)
            else
                self:set_motion_blur(0, 0)
            end
        else
            self:set_motion_blur(0, 0)
        end
    end
end

-- Set zoom blur parameters
function BlurManager:set_zoom_blur(radius, crop)
    if self.strategy == "composite_blur" and self.zoom_blur_settings then
        obs.obs_data_set_double(self.zoom_blur_settings, "radius", radius)

        if crop then
            local cx = crop.x + (crop.w / 2)
            local cy = crop.y + (crop.h / 2)
            obs.obs_data_set_double(self.zoom_blur_settings, "center_x", cx)
            obs.obs_data_set_double(self.zoom_blur_settings, "center_y", cy)
        end

        obs.obs_data_set_double(self.zoom_blur_settings, "inactive_radius", self.zoom_blur_clear_radius)
        obs.obs_source_update(self.zoom_blur_filter, self.zoom_blur_settings)
    end
end

-- Set motion blur parameters
function BlurManager:set_motion_blur(radius, angle)
    if self.strategy == "composite_blur" and self.motion_blur_settings then
        obs.obs_data_set_double(self.motion_blur_settings, "radius", radius)
        obs.obs_data_set_double(self.motion_blur_settings, "angle", angle)
        obs.obs_source_update(self.motion_blur_filter, self.motion_blur_settings)
    end
end

-- Update configuration
function BlurManager:update_config(settings)
    self.zoom_blur_enabled = obs.obs_data_get_bool(settings, "zoom_blur_enabled")
    self.zoom_blur_intensity = obs.obs_data_get_double(settings, "zoom_blur_intensity")
    self.zoom_blur_clear_radius = obs.obs_data_get_double(settings, "zoom_blur_clear_radius")
    self.motion_blur_enabled = obs.obs_data_get_bool(settings, "motion_blur_enabled")
    self.motion_blur_intensity = obs.obs_data_get_double(settings, "motion_blur_intensity")
end

-- Cleanup filters
function BlurManager:cleanup()
    local source = source_manager_get_source()

    if self.zoom_blur_filter and source then
        obs.obs_source_filter_remove(source, self.zoom_blur_filter)
        obs.obs_source_release(self.zoom_blur_filter)
        self.zoom_blur_filter = nil
    end

    if self.motion_blur_filter and source then
        obs.obs_source_filter_remove(source, self.motion_blur_filter)
        obs.obs_source_release(self.motion_blur_filter)
        self.motion_blur_filter = nil
    end

    if self.zoom_blur_settings then
        obs.obs_data_release(self.zoom_blur_settings)
        self.zoom_blur_settings = nil
    end

    if self.motion_blur_settings then
        obs.obs_data_release(self.motion_blur_settings)
        self.motion_blur_settings = nil
    end

    self.initialized = false
    self.strategy = "none"
end

-- Check if blur is available
function BlurManager:is_available()
    return self.strategy ~= "none"
end

-- Global convenience functions
function blur_manager_init(source)
    return BlurManager:init(source)
end

function blur_manager_update(state_machine, crop, camera_velocity)
    return BlurManager:update(state_machine, crop, camera_velocity)
end

function blur_manager_update_config(settings)
    return BlurManager:update_config(settings)
end

function blur_manager_cleanup()
    return BlurManager:cleanup()
end

function blur_manager_is_available()
    return BlurManager:is_available()
end

--================================================
-- MODULE: Cursor Asset Manager (M16)
--================================================
-- Handles extracting and managing cursor image assets

local CursorAssets = {
    extracted = false,
    dir = nil,
}

-- Get the platform-specific asset directory
function CursorAssets:get_platform_dir()
    if IS_WINDOWS then
        local appdata = os.getenv("APPDATA")
        return appdata and (appdata .. "\\obs-studio\\obs-zoom-pro\\cursors") or nil
    elseif IS_LINUX then
        local home = os.getenv("HOME")
        return home and (home .. "/.config/obs-studio/obs-zoom-pro/cursors") or nil
    elseif IS_MACOS then
        local home = os.getenv("HOME")
        return home and (home .. "/Library/Application Support/obs-studio/obs-zoom-pro/cursors") or nil
    end
    -- Fallback for non-FFI environments
    return "cursors"
end

-- Ensure assets are extracted
function CursorAssets:ensure_extracted()
    if self.extracted then
        return self.dir
    end

    local dir = self:get_platform_dir()
    if not dir then
        log("CursorAssets: Could not determine asset directory")
        return nil
    end

    -- Create directory
    local cmd
    if IS_WINDOWS then
        cmd = 'mkdir "' .. dir .. '" 2>nul'
    else
        cmd = 'mkdir -p "' .. dir .. '"'
    end
    os.execute(cmd)

    -- Check if assets exist
    local sep = IS_WINDOWS and "\\" or "/"
    local arrow_path = dir .. sep .. "arrow.png"

    local f = io.open(arrow_path, "rb")
    if f then
        f:close()
        self.dir = dir
        self.extracted = true
        log("CursorAssets: Using existing assets from " .. dir)
        return dir
    end

    -- Try to copy from script directory
    local script_dir = get_script_directory()
    local assets_src = script_dir .. "assets" .. sep .. "cursors" .. sep

    local files = { "arrow.png", "pointer.png", "ibeam.png" }
    for _, filename in ipairs(files) do
        local src_path = assets_src .. filename
        local dst_path = dir .. sep .. filename

        local src = io.open(src_path, "rb")
        if src then
            local data = src:read("*a")
            src:close()

            local dst = io.open(dst_path, "wb")
            if dst then
                dst:write(data)
                dst:close()
                log("CursorAssets: Copied " .. filename)
            end
        end
    end

    self.dir = dir
    self.extracted = true
    return dir
end

-- Get the asset directory
function CursorAssets:get_dir()
    return self.dir
end

-- Check if assets are available
function CursorAssets:is_available()
    if not self.extracted then
        self:ensure_extracted()
    end
    return self.dir ~= nil
end

-- Get cursor image path
function CursorAssets:get_cursor_path(cursor_type)
    if not self:is_available() then
        return nil
    end

    local sep = IS_WINDOWS and "\\" or "/"
    local filename = (cursor_type or "arrow") .. ".png"
    return self.dir .. sep .. filename
end

-- Global convenience functions
function cursor_assets_ensure_extracted()
    return CursorAssets:ensure_extracted()
end

function cursor_assets_get_dir()
    return CursorAssets:get_dir()
end

function cursor_assets_is_available()
    return CursorAssets:is_available()
end

function cursor_assets_get_cursor_path(cursor_type)
    return CursorAssets:get_cursor_path(cursor_type)
end

--================================================
-- MODULE: Cursor Renderer (M15)
--================================================
-- Provides automatic cursor overlay rendering

local CursorRenderer = {
    enabled = false,
    source = nil,
    sceneitem = nil,

    -- Smoothed state
    pos = { x = 0, y = 0 },
    current_scale = 1.0,
    current_rot = 0,
    swap_pulse = 1.0,

    -- Velocities (SmoothDamp)
    vel_x = { val = 0 },
    vel_y = { val = 0 },
    vel_scale = { val = 0 },
    vel_rot = { val = 0 },
    vel_swap = { val = 0 },

    -- State
    was_pointer = false,
    initialized = false,

    -- Configuration
    cursor_scale = 1.0,
    cursor_click_scale = 0.78,
    cursor_smooth_time = 0.1,
    cursor_offset_x = -6,
    cursor_offset_y = -2,
    cursor_rotation_mode = "None",
    cursor_angle_offset = 0,
    cursor_tilt_strength = 0,
}

-- Initialize cursor renderer
function CursorRenderer:init()
    if not cfg.cursor_enabled then
        self.enabled = false
        return false
    end

    -- Ensure cursor assets are available
    local asset_dir = cursor_assets_ensure_extracted()
    if not asset_dir then
        log("CursorRenderer: Failed to extract cursor assets")
        self.enabled = false
        return false
    end

    -- Get or create the cursor image source
    local source_name = FILTER_PREFIX .. "Cursor"
    self.source = obs.obs_get_source_by_name(source_name)

    if not self.source then
        -- Create new image source
        local settings = obs.obs_data_create()
        local cursor_path = cursor_assets_get_cursor_path("arrow")
        if cursor_path then
            obs.obs_data_set_string(settings, "file", cursor_path)
        end
        self.source = obs.obs_source_create("image_source", source_name, settings, nil)
        obs.obs_data_release(settings)

        if not self.source then
            log("CursorRenderer: Failed to create image source")
            self.enabled = false
            return false
        end
    end

    -- Add to current scene
    self:add_to_scene()

    -- Initialize position
    local mouse = platform_get_mouse_pos()
    self.pos.x = mouse.x
    self.pos.y = mouse.y

    self.enabled = true
    self.initialized = true
    log("CursorRenderer: Initialized")
    return true
end

-- Add cursor source to scene
function CursorRenderer:add_to_scene()
    if not self.source then return false end

    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then return false end

    local scene = obs.obs_scene_from_source(scene_source)
    if not scene then
        obs.obs_source_release(scene_source)
        return false
    end

    -- Check if already in scene
    local source_name = obs.obs_source_get_name(self.source)
    self.sceneitem = obs.obs_scene_find_source(scene, source_name)

    if not self.sceneitem then
        -- Add to scene
        self.sceneitem = obs.obs_scene_add(scene, self.source)
        if self.sceneitem then
            -- Move to top (render last = on top)
            obs.obs_sceneitem_set_order(self.sceneitem, obs.OBS_ORDER_MOVE_TOP)
        end
    end

    obs.obs_source_release(scene_source)
    return true
end

-- Update cursor position and state
function CursorRenderer:update(dt, raw_mouse, camera_crop)
    if not self.enabled or not self.sceneitem then return end

    -- Smooth cursor position
    self.pos.x = SmoothDamp(self.pos.x, raw_mouse.x, self.vel_x, self.cursor_smooth_time, 100000, dt)
    self.pos.y = SmoothDamp(self.pos.y, raw_mouse.y, self.vel_y, self.cursor_smooth_time, 100000, dt)

    -- Snap when very close
    if math.abs(self.pos.x - raw_mouse.x) < 0.5 then
        self.pos.x = raw_mouse.x
        self.vel_x.val = 0
    end
    if math.abs(self.pos.y - raw_mouse.y) < 0.5 then
        self.pos.y = raw_mouse.y
        self.vel_y.val = 0
    end

    -- Cursor shape detection (Windows only)
    local is_pointer = false
    if platform_cursor_shape_available() then
        is_pointer = platform_is_cursor_pointer()
    end

    -- Swap cursor image if needed
    if is_pointer ~= self.was_pointer then
        local asset_dir = cursor_assets_get_dir()
        local sep = IS_WINDOWS and "\\" or "/"
        local new_file = is_pointer and (asset_dir .. sep .. "pointer.png") or (asset_dir .. sep .. "arrow.png")

        local s = obs.obs_source_get_settings(self.source)
        if s then
            obs.obs_data_set_string(s, "file", new_file)
            obs.obs_source_update(self.source, s)
            obs.obs_data_release(s)
        end

        -- Trigger swap pulse
        self.swap_pulse = 0.75
        self.vel_swap.val = 1
        self.was_pointer = is_pointer
    end

    self.swap_pulse = SmoothDamp(self.swap_pulse, 1.0, self.vel_swap, 0.12, 100000, dt)

    -- Click animation
    local is_clicking = platform_is_clicking()
    local target_scale = is_clicking and (self.cursor_scale * self.cursor_click_scale) or self.cursor_scale
    self.current_scale = SmoothDamp(self.current_scale, target_scale, self.vel_scale, 0.1, 100000, dt)

    -- Calculate position relative to zoom
    local zoom_factor = 1.0
    local crop_x, crop_y = 0, 0

    if camera_crop and SM:is_zoomed() then
        zoom_factor = source_manager_get_size() / camera_crop.w
        crop_x = camera_crop.x
        crop_y = camera_crop.y
    end

    local final_x = (self.pos.x - crop_x) * zoom_factor + (self.cursor_offset_x * zoom_factor)
    local final_y = (self.pos.y - crop_y) * zoom_factor + (self.cursor_offset_y * zoom_factor)

    -- Apply to scene item
    local pos = obs.vec2()
    pos.x = final_x
    pos.y = final_y
    obs.obs_sceneitem_set_pos(self.sceneitem, pos)

    local scale = obs.vec2()
    local s = self.current_scale * zoom_factor * self.swap_pulse
    scale.x = s
    scale.y = s
    obs.obs_sceneitem_set_scale(self.sceneitem, scale)

    -- Rotation
    local dynamic_rot = self:compute_rotation(dt)
    obs.obs_sceneitem_set_rot(self.sceneitem, dynamic_rot)
end

-- Compute rotation based on mode
function CursorRenderer:compute_rotation(dt)
    local vx = self.vel_x.val
    local vy = self.vel_y.val
    local speed = math.sqrt(vx * vx + vy * vy)

    if self.cursor_rotation_mode == "Directional" then
        if speed > 20 then
            local angle = math.atan2(vy, vx) * (180 / math.pi)
            local target = angle + self.cursor_angle_offset
            local diff = (target - self.current_rot + 180) % 360 - 180
            self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.05, 100000, dt)
        end
        return self.current_rot

    elseif self.cursor_rotation_mode == "Lean" then
        local lean = clamp(-40, 40, vx * 0.05 * self.cursor_tilt_strength) + self.cursor_angle_offset
        local diff = (lean - self.current_rot + 180) % 360 - 180
        self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.08, 100000, dt)
        return self.current_rot
    end

    -- "None" mode
    local diff = (self.cursor_angle_offset - self.current_rot + 180) % 360 - 180
    self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.15, 100000, dt)
    return self.current_rot
end

-- Update configuration
function CursorRenderer:update_config(settings)
    self.cursor_scale = obs.obs_data_get_double(settings, "cursor_scale")
    self.cursor_click_scale = obs.obs_data_get_double(settings, "cursor_click_scale")
    self.cursor_smooth_time = obs.obs_data_get_double(settings, "cursor_smooth_time")
    self.cursor_offset_x = obs.obs_data_get_int(settings, "cursor_offset_x")
    self.cursor_offset_y = obs.obs_data_get_int(settings, "cursor_offset_y")
    self.cursor_rotation_mode = obs.obs_data_get_string(settings, "cursor_rotation_mode") or "None"
    self.cursor_angle_offset = obs.obs_data_get_double(settings, "cursor_angle_offset")
    self.cursor_tilt_strength = obs.obs_data_get_double(settings, "cursor_tilt_strength")
end

-- Cleanup
function CursorRenderer:cleanup()
    if self.sceneitem then
        obs.obs_sceneitem_remove(self.sceneitem)
        self.sceneitem = nil
    end

    if self.source then
        local source_name = obs.obs_source_get_name(self.source)
        obs.obs_source_release(self.source)

        -- Remove from OBS source list
        local s = obs.obs_get_source_by_name(source_name)
        if s then
            obs.obs_source_remove(s)
            obs.obs_source_release(s)
        end
        self.source = nil
    end

    self.enabled = false
    self.initialized = false
end

-- Check if active
function CursorRenderer:is_active()
    return self.enabled and self.initialized
end

-- Global convenience functions
function cursor_renderer_init()
    return CursorRenderer:init()
end

function cursor_renderer_update(dt, raw_mouse, camera_crop)
    return CursorRenderer:update(dt, raw_mouse, camera_crop)
end

function cursor_renderer_update_config(settings)
    return CursorRenderer:update_config(settings)
end

function cursor_renderer_cleanup()
    return CursorRenderer:cleanup()
end

function cursor_renderer_is_active()
    return CursorRenderer:is_active()
end

--================================================
-- MODULE: Bookmark Manager (M17)
--================================================
-- Manages saved zoom positions (bookmarks)

local BookmarkManager = {
    -- Saved bookmarks: { name = { zoom_level, x, y, w, h, source } }
    bookmarks = {},

    -- Maximum bookmarks
    max_bookmarks = 20,

    -- Hotkey IDs
    hotkeys = {},
}

-- Save current zoom position as a bookmark
function BookmarkManager:save(name)
    if not name or name == "" then
        return false
    end

    -- Check limit
    local count = 0
    for _, _ in pairs(self.bookmarks) do count = count + 1 end

    if count >= self.max_bookmarks and not self.bookmarks[name] then
        log("Bookmark: Max bookmarks reached (" .. self.max_bookmarks .. ")")
        return false
    end

    -- Get current crop
    local crop = crop_filter_get_crop()
    if not crop then
        return false
    end

    -- Save bookmark
    self.bookmarks[name] = {
        zoom_level = SM.zoom_level,
        x = crop.x,
        y = crop.y,
        w = crop.w,
        h = crop.h,
        source = cfg.source_name,
    }

    log("Bookmark: Saved '" .. name .. "' (zoom=" .. string.format("%.2f", SM.zoom_level) .. ")")
    return true
end

-- Recall a bookmark
function BookmarkManager:recall(name)
    local bm = self.bookmarks[name]
    if not bm then
        log("Bookmark: Not found: " .. name)
        return false
    end

    if not SM:can_jump() then
        return false
    end

    if not source_manager_is_valid() then
        return false
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        return false
    end

    -- Get current crop as start
    local start_crop = crop_filter_get_crop() or { x = 0, y = 0, w = source_w, h = source_h }

    -- Set target
    local target_crop = {
        x = bm.x,
        y = bm.y,
        w = bm.w,
        h = bm.h,
    }

    -- Transition to bookmark
    SM:transition(ZoomState.JUMPING, {
        start_crop = start_crop,
        target_crop = target_crop,
        target_level = bm.zoom_level
    })

    start_timer()
    log("Bookmark: Recall '" .. name .. "'")
    return true
end

-- Delete a bookmark
function BookmarkManager:delete(name)
    if self.bookmarks[name] then
        self.bookmarks[name] = nil
        log("Bookmark: Deleted '" .. name .. "'")
        return true
    end
    return false
end

-- Rename a bookmark
function BookmarkManager:rename(old_name, new_name)
    if not self.bookmarks[old_name] then
        return false
    end

    if self.bookmarks[new_name] then
        return false
    end

    self.bookmarks[new_name] = self.bookmarks[old_name]
    self.bookmarks[old_name] = nil
    log("Bookmark: Renamed '" .. old_name .. "' to '" .. new_name .. "'")
    return true
end

-- Get all bookmark names
function BookmarkManager:get_names()
    local names = {}
    for k, _ in pairs(self.bookmarks) do
        table.insert(names, k)
    end
    table.sort(names)
    return names
end

-- Get bookmark info
function BookmarkManager:get(name)
    return self.bookmarks[name]
end

-- Persist bookmarks to settings
function BookmarkManager:persist(settings)
    local array = obs.obs_data_array_create()

    for name, bm in pairs(self.bookmarks) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "name", name)
        obs.obs_data_set_double(item, "zoom_level", bm.zoom_level)
        obs.obs_data_set_double(item, "x", bm.x)
        obs.obs_data_set_double(item, "y", bm.y)
        obs.obs_data_set_double(item, "w", bm.w)
        obs.obs_data_set_double(item, "h", bm.h)
        obs.obs_data_set_string(item, "source", bm.source or "")
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "zoom_bookmarks", array)
    obs.obs_data_array_release(array)
end

-- Load bookmarks from settings
function BookmarkManager:load(settings)
    self.bookmarks = {}

    local array = obs.obs_data_get_array(settings, "zoom_bookmarks")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local name = obs.obs_data_get_string(item, "name")

        if name and name ~= "" then
            self.bookmarks[name] = {
                zoom_level = obs.obs_data_get_double(item, "zoom_level"),
                x = obs.obs_data_get_double(item, "x"),
                y = obs.obs_data_get_double(item, "y"),
                w = obs.obs_data_get_double(item, "w"),
                h = obs.obs_data_get_double(item, "h"),
                source = obs.obs_data_get_string(item, "source"),
            }
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)

    local count = 0
    for _, _ in pairs(self.bookmarks) do count = count + 1 end
    log("Bookmark: Loaded " .. count .. " bookmarks")
end

-- Register bookmark hotkeys
function BookmarkManager:register_hotkeys(settings)
    for i = 1, 5 do
        self.hotkeys[i] = obs.obs_hotkey_register_frontend(
            "obs_zoom_pro.bookmark_" .. i,
            "Zoom to Bookmark " .. i,
            function(pressed)
                if not pressed then return end
                local names = self:get_names()
                if names[i] then
                    self:recall(names[i])
                end
            end
        )

        -- Load saved bindings
        local key = "obs_zoom_pro.hotkey.bookmark_" .. i
        local save_array = obs.obs_data_get_array(settings, key)
        if save_array then
            obs.obs_hotkey_load(self.hotkeys[i], save_array)
            obs.obs_data_array_release(save_array)
        end
    end
end

-- Save bookmark hotkeys
function BookmarkManager:save_hotkeys(settings)
    for i = 1, 5 do
        if self.hotkeys[i] then
            local save_array = obs.obs_hotkey_save(self.hotkeys[i])
            obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.bookmark_" .. i, save_array)
            obs.obs_data_array_release(save_array)
        end
    end
end

-- Global convenience functions
function bookmark_save(name)
    return BookmarkManager:save(name)
end

function bookmark_recall(name)
    return BookmarkManager:recall(name)
end

function bookmark_delete(name)
    return BookmarkManager:delete(name)
end

function bookmark_get_names()
    return BookmarkManager:get_names()
end

function bookmark_get(name)
    return BookmarkManager:get(name)
end

--================================================
-- MODULE: UDP API Server (M18)
--================================================
-- Provides external control via UDP for Stream Deck integration

local APIServer = {
    enabled = false,
    port = 12345,
    socket = nil,
}

-- Command handlers
local API_COMMANDS = {
    ZOOM_IN = function(args)
        local level = tonumber(args[1]) or cfg.zoom_value
        on_scroll_zoom_to(level)
        return "OK"
    end,

    ZOOM_OUT = function(args)
        if SM:is_zoomed() then
            on_toggle_zoom(true)
        end
        return "OK"
    end,

    ZOOM_SET = function(args)
        local level = tonumber(args[1])
        if not level then return "ERROR: Missing level" end
        on_scroll_zoom_to(level)
        return "OK"
    end,

    ZOOM_TOGGLE = function(args)
        on_toggle_zoom(true)
        return "OK"
    end,

    FOLLOW_ON = function(args)
        if SM:is_zoomed() then SM.following = true end
        return "OK"
    end,

    FOLLOW_OFF = function(args)
        SM.following = false
        return "OK"
    end,

    FOLLOW_TOGGLE = function(args)
        if SM:is_zoomed() then SM.following = not SM.following end
        return "OK"
    end,

    PRESET = function(args)
        local name = args[1]
        if not name then return "ERROR: Missing preset name" end
        local ok = preset_apply(name)
        return ok and "OK" or "ERROR: Unknown preset"
    end,

    BOOKMARK = function(args)
        local name = args[1]
        if not name then return "ERROR: Missing bookmark name" end
        local ok = bookmark_recall(name)
        return ok and "OK" or "ERROR: Bookmark not found"
    end,

    STATUS = function(args)
        local crop = crop_filter_get_crop()
        return string.format(
            '{"version":"%s","zoom_level":%.2f,"state":"%s","following":%s,"position":{"x":%.0f,"y":%.0f},"preset":"%s"}',
            VERSION,
            SM.zoom_level,
            SM.state,
            tostring(SM.following),
            crop and crop.x or 0,
            crop and crop.y or 0,
            cfg.zoom_preset or ""
        )
    end,

    HELP = function(args)
        return "Commands: ZOOM_IN [level], ZOOM_OUT, ZOOM_SET level, ZOOM_TOGGLE, FOLLOW_ON, FOLLOW_OFF, FOLLOW_TOGGLE, PRESET name, BOOKMARK name, STATUS"
    end,
}

-- Start the API server
function APIServer:start(port)
    self:stop()

    self.port = port or self.port

    -- Try to use luasocket if available
    local socket_ok, socket = pcall(require, "socket")
    if not socket_ok then
        log("API: Socket library not available")
        return false
    end

    -- Try UDP
    local udp, err = socket.udp()
    if not udp then
        log("API: Failed to create UDP socket: " .. tostring(err))
        return false
    end

    -- Set socket options
    udp:setoption("reuseaddr", true)
    udp:settimeout(0)  -- Non-blocking

    -- Bind to port
    local bind_ok, err = udp:setsockname("*", self.port)
    if not bind_ok then
        log("API: Failed to bind to port " .. self.port .. ": " .. tostring(err))
        udp:close()
        return false
    end

    self.socket = udp
    self.enabled = true

    -- Start polling timer
    obs.timer_add(function() self:poll() end, 50)  -- 20Hz polling

    log("API: Listening on port " .. self.port)
    return true
end

-- Stop the API server
function APIServer:stop()
    if self.socket then
        self.socket:close()
        self.socket = nil
    end
    self.enabled = false
    log("API: Stopped")
end

-- Poll for incoming commands
function APIServer:poll()
    if not self.enabled or not self.socket then
        return
    end

    repeat
        local data, err = self.socket:receivefrom()
        if data then
            local response = self:handle_command(data)
            if response then
                -- Note: UDP response requires sender address
                log("API: " .. data:gsub("%s+", " ") .. " Ã¢â€ â€™ " .. response)
            end
        elseif err ~= "timeout" then
            log("API: Error: " .. tostring(err))
        end
    until not data
end

-- Handle a command
function APIServer:handle_command(raw)
    -- Parse command
    local parts = {}
    for word in raw:gmatch("%S+") do
        table.insert(parts, word)
    end

    if #parts == 0 then
        return "ERROR: Empty command"
    end

    local cmd = parts[1]:upper()
    local args = {}
    for i = 2, #parts do
        table.insert(args, parts[i])
    end

    -- Look up handler
    local handler = API_COMMANDS[cmd]
    if handler then
        local ok, result = pcall(handler, args)
        if ok then
            return result
        else
            return "ERROR: " .. tostring(result)
        end
    end

    return "ERROR: Unknown command: " .. cmd
end

-- Check if enabled
function APIServer:is_enabled()
    return self.enabled
end

-- Global convenience functions
function api_start(port)
    return APIServer:start(port)
end

function api_stop()
    return APIServer:stop()
end

function api_is_enabled()
    return APIServer:is_enabled()
end

--================================================
-- OBS SCRIPT REGISTRATION
--================================================

--[[ Called when the script is loaded
--[[ @param data table Script data
function script_load(data)
    log("Script loaded - OBS Zoom Pro v" .. VERSION)

    -- Load custom presets
    PresetManager:load(data)

    -- Load scene memory
    SceneMemory:load(data)

    -- Load bookmarks
    BookmarkManager:load(data)

    -- Register hotkeys
    register_hotkeys(data)

    -- Register bookmark hotkeys
    BookmarkManager:register_hotkeys(data)

    -- Register frontend event handler
    obs.obs_frontend_add_event_callback(on_frontend_event)

    -- Start API server if enabled
    local api_enabled = obs.obs_data_get_bool(data, "api_enabled")
    if api_enabled then
        local api_port = obs.obs_data_get_int(data, "api_port")
        APIServer:start(api_port)
    end
end

--[[ Called when the script is unloaded
function script_unload()
    log("Script unloaded - OBS Zoom Pro")

    -- Stop timer and cleanup
    stop_timer()
    unregister_hotkeys()
    source_manager_release()

    -- Stop API server
    APIServer:stop()

    -- Remove frontend event handler
    obs.obs_frontend_remove_event_callback(on_frontend_event)
end

--[[ Called when settings are updated
--[[ @param data table Settings data
function script_update(data)
    log("Settings updated")

    -- Update legacy settings
    debug_logs = obs.obs_data_get_bool(data, "debug_logging") or false
    settings.debug_logging = debug_logs
    settings.easing_type = obs.obs_data_get_string(data, "easing_type") or defaults.easing_type
    settings.smooth_time = obs.obs_data_get_double(data, "smooth_time") or defaults.smooth_time
    settings.max_speed = obs.obs_data_get_double(data, "max_speed") or defaults.max_speed

    -- Update M09 configuration
    update_config(data)

    -- Update API server settings
    local api_enabled = obs.obs_data_get_bool(data, "api_enabled")
    local api_port = obs.obs_data_get_int(data, "api_port")

    if api_enabled and not APIServer:is_enabled() then
        APIServer:start(api_port)
    elseif not api_enabled and APIServer:is_enabled() then
        APIServer:stop()
    elseif APIServer:is_enabled() and APIServer.port ~= api_port then
        APIServer:start(api_port)
    end
end

--[[ Called to save settings
--[[ @param data table Settings data to save
function script_save(data)
    log("Settings saved")

    -- Save custom presets
    PresetManager:persist(data)

    -- Save scene memory
    SceneMemory:persist(data)

    -- Save bookmarks
    BookmarkManager:persist(data)

    -- Save hotkey bindings
    save_hotkeys(data)

    -- Save bookmark hotkeys
    BookmarkManager:save_hotkeys(data)
end

--[[ Called to create the properties UI
--[[ @return obs.obs_properties_t Properties object
function script_properties()
    local props = obs.obs_properties_create()

    --==========================
    -- QUICK SETUP (always expanded)
    --==========================
    local grp_quick = obs.obs_properties_create()

    -- Source dropdown
    local src_list = obs.obs_properties_add_list(grp_quick, "source", "Zoom Source",
        obs.OBS_COMBO_TYPE_LIST, obs.OBS_COMBO_FORMAT_STRING)
    obs.obs_property_list_add_string(src_list, "-- Select Source --", "")

    -- Populate with available capture sources
    local sources = source_manager_get_available_sources()
    for _, src in ipairs(sources) do
        obs.obs_property_list_add_string(src_list, src.name, src.name)
    end

    -- Zoom Factor
    obs.obs_properties_add_float_slider(grp_quick, "zoom_value", "Zoom Factor", 1.0, 10.0, 0.1)

    -- Duration
    obs.obs_properties_add_float_slider(grp_quick, "zoom_duration", "Duration (s)", 0.05, 3.0, 0.05)

    obs.obs_properties_add_group(props, "quick_setup", "Ã¢Å¡Â¡ Quick Setup", obs.OBS_GROUP_NORMAL, grp_quick)

    --==========================
    -- ANIMATION (collapsed)
    --==========================
    local grp_anim = obs.obs_properties_create()

    -- Overshoot/Bounce
    obs.obs_properties_add_float_slider(grp_anim, "zoom_overshoot", "Bounce", 0.0, 1.0, 0.01)

    -- Easing Curve
    local p_easing = obs.obs_properties_add_list(grp_anim, "zoom_easing", "Easing Curve",
        obs.OBS_COMBO_TYPE_LIST, obs.OBS_COMBO_FORMAT_STRING)
    for _, name in ipairs(Easing.NAMES) do
        obs.obs_property_list_add_string(p_easing, name, name)
    end

    obs.obs_properties_add_group(props, "animation", "Ã°Å¸Å½Â¬ Animation", obs.OBS_GROUP_NORMAL, grp_anim)

    --==========================
    -- MOUSE FOLLOW (collapsed)
    --==========================
    local grp_follow = obs.obs_properties_create()

    obs.obs_properties_add_bool(grp_follow, "auto_follow", "Auto-Follow Mouse")
    obs.obs_properties_add_float_slider(grp_follow, "follow_smooth_time", "Smoothness", 0.01, 1.0, 0.01)
    obs.obs_properties_add_int_slider(grp_follow, "follow_dead_zone", "Dead Zone (px)", 0, 500, 1)

    obs.obs_properties_add_group(props, "follow", "Ã°Å¸Å½Â¯ Mouse Follow", obs.OBS_GROUP_NORMAL, grp_follow)

    --==========================
    -- ADVANCED (collapsed)
    --==========================
    local grp_adv = obs.obs_properties_create()
    obs.obs_properties_add_float_slider(grp_adv, "scroll_step", "Scroll Zoom Step", 0.1, 1.0, 0.05)
    obs.obs_properties_add_bool(grp_adv, "debug_logs", "Debug Logging")
    obs.obs_properties_add_group(props, "advanced", "Ã¢Å¡â„¢Ã¯Â¸Â Advanced", obs.OBS_GROUP_NORMAL, grp_adv)

    --==========================
    -- API SERVER (collapsed)
    --==========================
    local grp_api = obs.obs_properties_create()
    obs.obs_properties_add_bool(grp_api, "api_enabled", "Enable UDP API Server")
    obs.obs_properties_add_int(grp_api, "api_port", "API Port", 1024, 65535, 1)
    obs.obs_properties_add_group(props, "api_server", "Ã°Å¸Å’Â UDP API Server", obs.OBS_GROUP_NORMAL, grp_api)

    --==========================
    -- HELP (collapsed)
    --==========================
    local grp_help = obs.obs_properties_create()
    obs.obs_properties_add_text(grp_help, "help_text",
        "QUICK START:\n" ..
        "1. Select your capture source above\n" ..
        "2. Set hotkeys in OBS Settings Ã¢â€ â€™ Hotkeys\n" ..
        "   Ã¢â‚¬Â¢ 'Toggle Zoom to Mouse' Ã¢â‚¬â€ Main zoom\n" ..
        "   Ã¢â‚¬Â¢ 'Toggle Mouse Follow' Ã¢â‚¬â€ Enable/disable follow\n" ..
        "3. Press the hotkey to zoom!\n\n" ..
        "TIPS:\n" ..
        "Ã¢â‚¬Â¢ Zoom centers on mouse position\n" ..
        "Ã¢â‚¬Â¢ Enable Auto-Follow for smooth tracking\n" ..
        "Ã¢â‚¬Â¢ Adjust Dead Zone to reduce jitter",
        obs.OBS_TEXT_INFO)
    obs.obs_properties_add_group(props, "help", "Ã¢Ââ€œ Help", obs.OBS_GROUP_NORMAL, grp_help)

    return props
end

--[[ Called to set default values
--[[ @param data table Settings data
function script_defaults(data)
    obs.obs_data_set_default_string(data, "source", "")
    obs.obs_data_set_default_double(data, "zoom_value", 2.0)
    obs.obs_data_set_default_double(data, "zoom_duration", 0.6)
    obs.obs_data_set_default_double(data, "zoom_overshoot", 0.0)
    obs.obs_data_set_default_string(data, "zoom_easing", "Cubic.Out")
    obs.obs_data_set_default_bool(data, "auto_follow", true)
    obs.obs_data_set_default_double(data, "follow_smooth_time", 0.15)
    obs.obs_data_set_default_int(data, "follow_dead_zone", 5)
    obs.obs_data_set_default_double(data, "scroll_step", 0.25)
    obs.obs_data_set_default_bool(data, "debug_logs", false)
    obs.obs_data_set_default_bool(data, "api_enabled", false)
    obs.obs_data_set_default_int(data, "api_port", 12345)
end

--================================================
-- SCRIPT METADATA
--================================================
script_info = {
    name = "OBS Zoom Pro",
    version = VERSION,
    description = "Intelligent camera zoom functionality with smooth transitions and easing curves.",
    author = "OBS Zoom Pro Team"
}
)

local platform = detect_platform()
local IS_WINDOWS = platform.WINDOWS
local IS_LINUX = platform.LINUX
local IS_MACOS = platform.MACOS

-- Log platform detection
log("Platform detected: " .. (jit and jit.os or "Unknown") .. (IS_WINDOWS and " (Full support)" or " (Basic support)"))

-- Virtual key codes (Lua constants instead of C #define)
local VK_LBUTTON = 0x01
local VK_RBUTTON = 0x02
local VK_MBUTTON = 0x04
local VK_CONTROL = 0x11
local VK_SHIFT = 0x10
local VK_MENU = 0x12  -- Alt

-- FFI declarations for Windows (only if FFI is available)


-- Cursor shape constants (Windows)
local CURSOR_ARROW = 1
local CURSOR_IBEAM = 2
local CURSOR_HAND = 3
local CURSOR_WAIT = 4

-- Module state
local Platform = {
    cursor_shape_available = IS_WINDOWS,
    last_mouse = { x = 0, y = 0 },
    last_click = false,
}

-- Get mouse position (cross-platform)
function Platform.get_mouse_pos()
    if IS_WINDOWS then
        local success, pt = pcall(function()
            local pt = ffi.new("POINT")
            if ffi.C.GetCursorPos(pt) ~= 0 then
                return { x = tonumber(pt.x), y = tonumber(pt.y) }
            end
            return nil
        end)
        if success and pt then
            return pt
        end
    elseif IS_LINUX then
        -- Linux: Use xdotool if available, fallback to X11
        local success, result = pcall(function()
            local handle = io.popen("xdotool getmouselocation 2>/dev/null || echo 'x:0 y:0'")
            if handle then
                local output = handle:read("*a")
                handle:close()
                local x, y = output:match("x:(%d+)%s+y:(%d+)")
                if x and y then
                    return { x = tonumber(x), y = tonumber(y) }
                end
            end
            return nil
        end)
        if success and result then
            return result
        end
    elseif IS_MACOS then
        -- macOS: Use osascript
        local success, result = pcall(function()
            local handle = io.popen(--[[osascript -e 'tell application "System Events" to get position of the mouse' 2>/dev/null || echo "0, 0"]])
            if handle then
                local output = handle:read("*a")
                handle:close()
                local x, y = output:match("(%d+),%s*(%d+)")
                if x and y then
                    return { x = tonumber(x), y = tonumber(y) }
                end
            end
            return nil
        end)
        if success and result then
            return result
        end
    end

    -- Fallback
    return { x = 0, y = 0 }
end

-- Check if left mouse button is clicked (Windows only, others return false)
function Platform.is_clicking()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x01) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if a modifier key is held (Windows only)
function Platform.is_key_held(vk_code)
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(vk_code) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if cursor is a pointer/hand (Windows only)
function Platform.is_cursor_pointer()
    if IS_WINDOWS then
        local success, result = pcall(function()
            local ci = ffi.new("CURSORINFO")
            ci.cbSize = ffi.sizeof("CURSORINFO")
            if ffi.C.GetCursorInfo(ci) ~= 0 then
                -- Check if hCursor is a hand pointer
                -- This is a simplified check; real implementation would compare cursor handles
                return ci.flags ~= 0  -- Simplified; actual implementation needs cursor handle comparison
            end
            return false
        end)
        return success and result or false
    end
    return false
end

-- Get cursor shape (Windows only, returns "arrow" for others)
function Platform.get_cursor_shape()
    if IS_WINDOWS then
        local success, result = pcall(function()
            local ci = ffi.new("CURSORINFO")
            ci.cbSize = ffi.sizeof("CURSORINFO")
            if ffi.C.GetCursorInfo(ci) ~= 0 and ci.hCursor ~= nil then
                local addr = tonumber(ffi.cast("uintptr_t", ci.hCursor))
                -- Common cursor IDs (these are typical values, may vary)
                -- IDC_ARROW = 32512, IDC_IBEAM = 32513, IDC_HAND = 32649
                -- We use address ranges as heuristic
                return "arrow"  -- Simplified; actual implementation would map handles
            end
            return "arrow"
        end)
        return success and result or "arrow"
    end
    return "arrow"
end

-- Check if Control key is held
function Platform.is_ctrl_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x11) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if Shift key is held
function Platform.is_shift_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x10) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if Alt key is held
function Platform.is_alt_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x12) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Convenience wrapper functions
function platform_get_mouse_pos()
    return Platform.get_mouse_pos()
end

function platform_is_clicking()
    return Platform.is_clicking()
end

function platform_is_cursor_pointer()
    return Platform.is_cursor_pointer()
end

function platform_cursor_shape_available()
    return Platform.cursor_shape_available
end

function platform_is_ctrl_held()
    return Platform.is_ctrl_held()
end

function platform_is_shift_held()
    return Platform.is_shift_held()
end

function platform_is_alt_held()
    return Platform.is_alt_held()
end

--================================================
-- MODULE: State Machine (M05)
--================================================
-- Manages zoom states and transitions
-- States: IDLE, ZOOMING_IN, ZOOMED_IN, ZOOMING_OUT, SCROLLING, JUMPING

local ZoomState = {
    IDLE         = "idle",
    ZOOMING_IN   = "zooming_in",
    ZOOMED_IN    = "zoomed_in",
    ZOOMING_OUT  = "zooming_out",
    SCROLLING    = "scrolling",    -- Scroll wheel mid-transition
    JUMPING      = "jumping",      -- Bookmark transition
}

local StateMachine = {
    state = ZoomState.IDLE,
    zoom_time = 0,          -- Animation progress (0 Ã¢â€ â€™ 1)
    zoom_level = 1.0,       -- Current zoom factor
    target_level = 1.0,     -- Target zoom factor
    start_crop = nil,       -- Crop at animation start {x, y, w, h}
    target_crop = nil,      -- Crop at animation end {x, y, w, h}
    following = false,      -- Mouse follow active

    -- Transition guards
    can_zoom_in = function(self)
        return self.state == ZoomState.IDLE
    end,

    can_zoom_out = function(self)
        return self.state == ZoomState.ZOOMED_IN
            or self.state == ZoomState.SCROLLING
    end,

    can_scroll = function(self)
        return self.state == ZoomState.ZOOMED_IN
            or self.state == ZoomState.IDLE
            or self.state == ZoomState.SCROLLING
    end,

    can_jump = function(self)
        return self.state ~= ZoomState.ZOOMING_IN
           and self.state ~= ZoomState.ZOOMING_OUT
           and self.state ~= ZoomState.JUMPING
    end,

    is_animating = function(self)
        return self.state == ZoomState.ZOOMING_IN
            or self.state == ZoomState.ZOOMING_OUT
            or self.state == ZoomState.SCROLLING
            or self.state == ZoomState.JUMPING
    end,

    is_zoomed = function(self)
        return self.state ~= ZoomState.IDLE
    end,
}

-- Transition to a new state
function StateMachine:transition(new_state, params)
    local old = self.state
    self.state = new_state
    self.zoom_time = 0

    if params then
        if params.start_crop then self.start_crop = params.start_crop end
        if params.target_crop then self.target_crop = params.target_crop end
        if params.target_level then self.target_level = params.target_level end
    end

    log("State: " .. old .. " Ã¢â€ â€™ " .. new_state)
end

-- Complete the current animation
function StateMachine:complete()
    if self.state == ZoomState.ZOOMING_IN
       or self.state == ZoomState.SCROLLING
       or self.state == ZoomState.JUMPING then
        self.zoom_level = self.target_level
        self.state = ZoomState.ZOOMED_IN
        self.zoom_time = 0
        log("State: " .. self.state .. " Ã¢â€ â€™ ZOOMED_IN (complete)")
    elseif self.state == ZoomState.ZOOMING_OUT then
        self.zoom_level = 1.0
        self.target_level = 1.0
        self.start_crop = nil
        self.target_crop = nil
        self.following = false
        self.state = ZoomState.IDLE
        self.zoom_time = 0
        log("State: ZOOMING_OUT Ã¢â€ â€™ IDLE (complete)")
    end
end

-- Reset to initial state
function StateMachine:reset()
    self.state = ZoomState.IDLE
    self.zoom_time = 0
    self.zoom_level = 1.0
    self.target_level = 1.0
    self.start_crop = nil
    self.target_crop = nil
    self.following = false
    log("StateMachine: Reset to IDLE")
end

-- Get current animation progress (0-1)
function StateMachine:get_progress()
    return clamp(0, 1, self.zoom_time)
end

-- Check if in a specific state
function StateMachine:is_state(state)
    return self.state == state
end

-- Get state name for display
function StateMachine:get_state_name()
    return self.state
end

-- Create a new state machine instance (for testing/isolation)
function StateMachine:new()
    local sm = {}
    setmetatable(sm, { __index = self })
    sm.state = ZoomState.IDLE
    sm.zoom_time = 0
    sm.zoom_level = 1.0
    sm.target_level = 1.0
    sm.start_crop = nil
    sm.target_crop = nil
    sm.following = false
    return sm
end

-- Global state machine instance
local SM = StateMachine:new()

--================================================
-- MODULE: Crop Filter Manager (M07)
--================================================
-- Manages the crop/pad filter used to simulate zoom
-- Creates, updates, and destroys the filter automatically

local FILTER_PREFIX = "[ZoomPro] "
local CROP_FILTER_NAME = FILTER_PREFIX .. "Crop"

local CropFilterManager = {
    filter = nil,           -- The crop filter source
    source = nil,           -- The parent source
    original_crop = nil,    -- Original crop values for restoration
    current_crop = { x = 0, y = 0, w = 0, h = 0 },
    initialized = false,
}

-- Create the crop filter on a source
function CropFilterManager:create(source)
    if not source then
        log("CropFilter: No source provided")
        return false
    end

    self:cleanup()  -- Clean up any existing filter
    self.source = source

    -- Check if our filter already exists
    local existing = obs.obs_source_get_filter_by_name(source, CROP_FILTER_NAME)
    if existing then
        log("CropFilter: Found existing filter")
        self.filter = existing
        self.initialized = true
        return true
    end

    -- Create new crop/pad filter
    local settings = obs.obs_data_create()
    obs.obs_data_set_int(settings, "left", 0)
    obs.obs_data_set_int(settings, "top", 0)
    obs.obs_data_set_int(settings, "right", 0)
    obs.obs_data_set_int(settings, "bottom", 0)
    obs.obs_data_set_bool(settings, "relative", false)  -- Absolute positioning

    self.filter = obs.obs_source_create_private(
        "crop_filter",      -- Filter type
        CROP_FILTER_NAME,   -- Filter name
        settings            -- Settings
    )

    obs.obs_data_release(settings)

    if not self.filter then
        log("CropFilter: Failed to create filter")
        return false
    end

    -- Add filter to source
    obs.obs_source_filter_add(source, self.filter)

    -- Store original crop (none)
    self.original_crop = { x = 0, y = 0, w = 0, h = 0 }

    self.initialized = true
    log("CropFilter: Created successfully")
    return true
end

-- Update the crop filter with new values
function CropFilterManager:update(x, y, w, h)
    if not self.filter or not self.initialized then
        return false
    end

    -- Store current crop
    self.current_crop = { x = x, y = y, w = w, h = h }

    -- Get filter settings
    local settings = obs.obs_source_get_settings(self.filter)
    if not settings then
        return false
    end

    -- Calculate crop values
    -- For crop_filter: left, top are absolute position
    -- right, bottom are width/height from right/bottom edge
    -- We need to convert our x, y, w, h to this format

    -- Get source dimensions
    local source_w = obs.obs_source_get_width(self.source)
    local source_h = obs.obs_source_get_height(self.source)

    if source_w == 0 or source_h == 0 then
        obs.obs_data_release(settings)
        return false
    end

    -- Set crop values
    -- left = x offset from left
    -- top = y offset from top
    -- right = source_w - (x + w) = remaining width on right
    -- bottom = source_h - (y + h) = remaining height on bottom
    local left = math.floor(x)
    local top = math.floor(y)
    local right = math.floor(source_w - (x + w))
    local bottom = math.floor(source_h - (y + h))

    -- Clamp to valid values
    left = math.max(0, left)
    top = math.max(0, top)
    right = math.max(0, right)
    bottom = math.max(0, bottom)

    obs.obs_data_set_int(settings, "left", left)
    obs.obs_data_set_int(settings, "top", top)
    obs.obs_data_set_int(settings, "right", right)
    obs.obs_data_set_int(settings, "bottom", bottom)

    -- Update the filter
    obs.obs_source_update(self.filter, settings)
    obs.obs_data_release(settings)

    return true
end

-- Get current crop values
function CropFilterManager:get_crop()
    return self.current_crop
end

-- Reset crop to original (no crop)
function CropFilterManager:reset()
    if not self.filter or not self.initialized then
        return false
    end

    local settings = obs.obs_source_get_settings(self.filter)
    if settings then
        obs.obs_data_set_int(settings, "left", 0)
        obs.obs_data_set_int(settings, "top", 0)
        obs.obs_data_set_int(settings, "right", 0)
        obs.obs_data_set_int(settings, "bottom", 0)
        obs.obs_source_update(self.filter, settings)
        obs.obs_data_release(settings)
    end

    self.current_crop = { x = 0, y = 0, w = 0, h = 0 }
    return true
end

-- Remove the filter and restore original state
function CropFilterManager:cleanup()
    if self.filter and self.source then
        -- Reset to no crop first
        self:reset()

        -- Remove filter from source
        obs.obs_source_filter_remove(self.source, self.filter)
        obs.obs_source_release(self.filter)
        self.filter = nil
        log("CropFilter: Removed from source")
    end

    self.source = nil
    self.original_crop = nil
    self.current_crop = { x = 0, y = 0, w = 0, h = 0 }
    self.initialized = false
end

-- Check if filter is ready
function CropFilterManager:is_ready()
    return self.initialized and self.filter ~= nil
end

-- Get source dimensions
function CropFilterManager:get_source_size()
    if not self.source then
        return 0, 0
    end
    return obs.obs_source_get_width(self.source), obs.obs_source_get_height(self.source)
end

-- Convenience wrapper functions
function crop_filter_create(source)
    return CropFilterManager:create(source)
end

function crop_filter_update(x, y, w, h)
    return CropFilterManager:update(x, y, w, h)
end

function crop_filter_reset()
    return CropFilterManager:reset()
end

function crop_filter_cleanup()
    return CropFilterManager:cleanup()
end

function crop_filter_is_ready()
    return CropFilterManager:is_ready()
end

function crop_filter_get_crop()
    return CropFilterManager:get_crop()
end

function crop_filter_get_source_size()
    return CropFilterManager:get_source_size()
end

--================================================
-- MODULE: Source Manager (M08)
--================================================
-- Handles finding sources in scenes, capturing transforms,
-- and managing source state for zoom operations

local SourceManager = {
    source = nil,           -- Current zoom source
    sceneitem = nil,        -- Scene item reference
    scene = nil,            -- Current scene
    original_transform = nil, -- Saved original transform
    source_name = "",       -- Source name for settings
    initialized = false,
}

-- Transform data structure
local TransformData = {
    pos = { x = 0, y = 0 },
    scale = { x = 1.0, y = 1.0 },
    rot = 0,
    bounds_type = 0,
    bounds = { x = 0, y = 0 },
    crop = { left = 0, top = 0, right = 0, bottom = 0 },
}

-- Find a source in a scene (BFS through groups)
function SourceManager:find_sceneitem(scene, source_name)
    if not scene or not source_name then
        return nil
    end

    local scene_source = obs.obs_scene_from_source(scene)
    if not scene_source then
        return nil
    end

    -- BFS queue
    local queue = {}
    table.insert(queue, scene_source)

    while #queue > 0 do
        local current_scene = table.remove(queue, 1)

        -- Iterate through items
        local items = obs.obs_scene_enum_items(current_scene)
        if items then
            for _, item in ipairs(items) do
                local item_source = obs.obs_sceneitem_get_source(item)
                if item_source then
                    local name = obs.obs_source_get_name(item_source)

                    -- Check if this is our target
                    if name == source_name then
                        obs.sceneitem_list_release(items)
                        return item
                    end

                    -- Check if this is a group (nested scene)
                    if obs.obs_source_get_type(item_source) == obs.OBS_SOURCE_TYPE_INPUT then
                        local id = obs.obs_source_get_id(item_source)
                        if id == "group" then
                            local group_scene = obs.obs_group_from_source(item_source)
                            if group_scene then
                                table.insert(queue, group_scene)
                            end
                        end
                    end
                end
            end
            obs.sceneitem_list_release(items)
        end
    end

    return nil
end

-- Capture the current transform of a scene item
function SourceManager:capture_transform(sceneitem)
    if not sceneitem then
        return nil
    end

    local transform = {}

    -- Position
    local pos = obs.vec2()
    obs.obs_sceneitem_get_pos(sceneitem, pos)
    transform.pos = { x = pos.x, y = pos.y }

    -- Scale
    local scale = obs.vec2()
    obs.obs_sceneitem_get_scale(sceneitem, scale)
    transform.scale = { x = scale.x, y = scale.y }

    -- Rotation
    transform.rot = obs.obs_sceneitem_get_rot(sceneitem)

    -- Bounds
    transform.bounds_type = obs.obs_sceneitem_get_bounds_type(sceneitem)
    local bounds = obs.vec2()
    obs.obs_sceneitem_get_bounds(sceneitem, bounds)
    transform.bounds = { x = bounds.x, y = bounds.y }

    -- Crop
    local crop = obs.obs_sceneitem_crop()
    obs.obs_sceneitem_get_crop(sceneitem, crop)
    transform.crop = {
        left = crop.left,
        top = crop.top,
        right = crop.right,
        bottom = crop.bottom
    }

    return transform
end

-- Restore a saved transform to a scene item
function SourceManager:restore_transform(sceneitem, transform)
    if not sceneitem or not transform then
        return false
    end

    -- Position
    local pos = obs.vec2()
    pos.x = transform.pos.x
    pos.y = transform.pos.y
    obs.obs_sceneitem_set_pos(sceneitem, pos)

    -- Scale
    local scale = obs.vec2()
    scale.x = transform.scale.x
    scale.y = transform.scale.y
    obs.obs_sceneitem_set_scale(sceneitem, scale)

    -- Rotation
    obs.obs_sceneitem_set_rot(sceneitem, transform.rot)

    -- Bounds
    obs.obs_sceneitem_set_bounds_type(sceneitem, transform.bounds_type)
    local bounds = obs.vec2()
    bounds.x = transform.bounds.x
    bounds.y = transform.bounds.y
    obs.obs_sceneitem_set_bounds(sceneitem, bounds)

    -- Crop
    local crop = obs.obs_sceneitem_crop()
    crop.left = transform.crop.left
    crop.top = transform.crop.top
    crop.right = transform.crop.right
    crop.bottom = transform.crop.bottom
    obs.obs_sceneitem_set_crop(sceneitem, crop)

    return true
end

-- Initialize with a source name
function SourceManager:init(source_name)
    self:release()  -- Clean up any existing state

    if not source_name or source_name == "" then
        log("SourceManager: No source name provided")
        return false
    end

    self.source_name = source_name

    -- Get current scene
    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then
        log("SourceManager: No current scene")
        return false
    end

    self.scene = scene_source

    -- Find the scene item
    self.sceneitem = self:find_sceneitem(scene_source, source_name)
    if not self.sceneitem then
        log("SourceManager: Source not found in scene: " .. source_name)
        obs.obs_source_release(scene_source)
        return false
    end

    -- Get the source
    self.source = obs.obs_sceneitem_get_source(self.sceneitem)
    if not self.source then
        log("SourceManager: Failed to get source from sceneitem")
        obs.obs_source_release(scene_source)
        return false
    end

    -- Capture original transform
    self.original_transform = self:capture_transform(self.sceneitem)

    -- Create crop filter
    if not crop_filter_create(self.source) then
        log("SourceManager: Failed to create crop filter")
        obs.obs_source_release(scene_source)
        return false
    end

    self.initialized = true
    log("SourceManager: Initialized with source: " .. source_name)

    obs.obs_source_release(scene_source)
    return true
end

-- Release all resources
function SourceManager:release()
    -- Clean up crop filter
    crop_filter_cleanup()

    -- Restore original transform if we have it
    if self.sceneitem and self.original_transform then
        self:restore_transform(self.sceneitem, self.original_transform)
        log("SourceManager: Restored original transform")
    end

    self.source = nil
    self.sceneitem = nil
    self.scene = nil
    self.original_transform = nil
    self.initialized = false

    log("SourceManager: Released")
end

-- Get source dimensions
function SourceManager:get_source_size()
    if not self.source then
        return 0, 0
    end
    return obs.obs_source_get_width(self.source), obs.obs_source_get_height(self.source)
end

-- Check if source is valid
function SourceManager:is_valid()
    return self.initialized and self.source ~= nil and self.sceneitem ~= nil
end

-- Get source info
function SourceManager:get_info()
    if not self:is_valid() then
        return nil
    end

    return {
        name = self.source_name,
        width = obs.obs_source_get_width(self.source),
        height = obs.obs_source_get_height(self.source),
    }
end

-- Get list of available capture sources
function SourceManager.get_available_sources()
    local sources = {}

    -- Get all sources
    local source_list = obs.obs_enum_sources()
    if source_list then
        for _, source in ipairs(source_list) do
            local source_id = obs.obs_source_get_id(source)
            local name = obs.obs_source_get_name(source)

            -- Filter for capture sources
            local is_capture = false
            if source_id == "monitor_capture" or      -- Display capture
               source_id == "window_capture" or       -- Window capture
               source_id == "game_capture" or         -- Game capture
               source_id == "xshm_input" or           -- Linux X11 capture
               source_id == "av_capture_input" then   -- macOS capture
                is_capture = true
            end

            if is_capture then
                table.insert(sources, {
                    name = name,
                    id = source_id,
                })
            end
        end
        obs.source_list_release(source_list)
    end

    return sources
end

-- Convenience wrapper functions
function source_manager_init(source_name)
    return SourceManager:init(source_name)
end

function source_manager_release()
    return SourceManager:release()
end

function source_manager_is_valid()
    return SourceManager:is_valid()
end

function source_manager_get_source()
    return SourceManager.source
end

function source_manager_get_sceneitem()
    return SourceManager.sceneitem
end

function source_manager_get_size()
    return SourceManager:get_source_size()
end

function source_manager_get_available_sources()
    return SourceManager.get_available_sources()
end

--================================================
-- MODULE: Camera Physics (M06)
--================================================
-- Handles camera position calculations, dead zones,
-- and SmoothDamp-based camera movement

local CameraPhysics = {
    -- Smoothed camera position
    pos = { x = 0, y = 0 },

    -- Velocities for SmoothDamp
    vel_x = { val = 0 },
    vel_y = { val = 0 },

    -- Dead zone state
    tracked_pos = { x = 0, y = 0 },
    dead_zone_active = false,

    -- Last camera position (for velocity calculation)
    last_pos = { x = 0, y = 0 },

    -- Monitor offset (for multi-monitor setups)
    monitor_offset = { x = 0, y = 0 },
}

-- Initialize camera tracking with starting position
function CameraPhysics:init(mouse_pos)
    if mouse_pos then
        self.pos.x = mouse_pos.x
        self.pos.y = mouse_pos.y
        self.tracked_pos.x = mouse_pos.x
        self.tracked_pos.y = mouse_pos.y
    end
    self.vel_x.val = 0
    self.vel_y.val = 0
    self.last_pos.x = self.pos.x
    self.last_pos.y = self.pos.y
end

-- Apply dead zone to mouse input
-- Returns the position the camera should track
function CameraPhysics:apply_dead_zone(mouse_pos, dead_zone_radius)
    if not mouse_pos then
        return self.tracked_pos
    end

    if dead_zone_radius <= 0 then
        self.tracked_pos.x = mouse_pos.x
        self.tracked_pos.y = mouse_pos.y
        return self.tracked_pos
    end

    -- Calculate distance from tracked position to mouse
    local dx = mouse_pos.x - self.tracked_pos.x
    local dy = mouse_pos.y - self.tracked_pos.y
    local dist = math.sqrt(dx * dx + dy * dy)

    if dist <= dead_zone_radius then
        -- Mouse is within dead zone, don't move tracked position
        self.dead_zone_active = true
        return self.tracked_pos
    end

    -- Mouse is outside dead zone
    -- Move tracked position so it stays exactly dead_zone_radius from mouse
    self.dead_zone_active = false
    local excess = dist - dead_zone_radius
    local nx = dx / dist  -- Normalized direction
    local ny = dy / dist

    self.tracked_pos.x = self.tracked_pos.x + nx * excess
    self.tracked_pos.y = self.tracked_pos.y + ny * excess

    return self.tracked_pos
end

-- Smooth the input position using SmoothDamp
function CameraPhysics:smooth_input(target_pos, smooth_time, dt)
    if not target_pos then
        return self.pos
    end

    local max_speed = 100000  -- Very high max speed for smooth camera

    self.pos.x = SmoothDamp(self.pos.x, target_pos.x, self.vel_x, smooth_time, max_speed, dt)
    self.pos.y = SmoothDamp(self.pos.y, target_pos.y, self.vel_y, smooth_time, max_speed, dt)

    return self.pos
end

-- Calculate the crop rectangle for a given zoom level and center position
function CameraPhysics:compute_crop(center_x, center_y, zoom_level, source_w, source_h)
    if zoom_level <= 1.0 then
        -- No zoom, return full source
        return {
            x = 0,
            y = 0,
            w = source_w,
            h = source_h,
        }
    end

    -- Calculate crop dimensions
    local crop_w = source_w / zoom_level
    local crop_h = source_h / zoom_level

    -- Center the crop on the target position
    local crop_x = center_x - crop_w / 2
    local crop_y = center_y - crop_h / 2

    -- Clamp to source bounds
    crop_x = clamp(0, source_w - crop_w, crop_x)
    crop_y = clamp(0, source_h - crop_h, crop_y)

    return {
        x = crop_x,
        y = crop_y,
        w = crop_w,
        h = crop_h,
    }
end

-- Calculate target crop for zoom animation
-- mouse_pos: current mouse position
-- zoom_level: target zoom level
-- source_w, source_h: source dimensions
-- monitor_offset: offset for multi-monitor (optional)
function CameraPhysics:get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
    if not mouse_pos then
        return nil
    end

    -- Apply monitor offset if provided
    local target_x = mouse_pos.x
    local target_y = mouse_pos.y

    if monitor_offset then
        target_x = target_x - monitor_offset.x
        target_y = target_y - monitor_offset.y
    end

    -- Clamp to source bounds
    target_x = clamp(0, source_w, target_x)
    target_y = clamp(0, source_h, target_y)

    return self:compute_crop(target_x, target_y, zoom_level, source_w, source_h)
end

-- Interpolate between two crop rectangles
function CameraPhysics:lerp_crop(start_crop, end_crop, t, easing_fn)
    if not start_crop or not end_crop then
        return nil
    end

    t = clamp(0, 1, t)

    -- Apply easing
    local eased_t = easing_fn and easing_fn(t) or t

    return {
        x = lerp(start_crop.x, end_crop.x, eased_t),
        y = lerp(start_crop.y, end_crop.y, eased_t),
        w = lerp(start_crop.w, end_crop.w, eased_t),
        h = lerp(start_crop.h, end_crop.h, eased_t),
    }
end

-- Get camera velocity (for motion blur)
function CameraPhysics:get_velocity()
    return {
        x = self.pos.x - self.last_pos.x,
        y = self.pos.y - self.last_pos.y,
    }
end

-- Update last position (call at end of frame)
function CameraPhysics:update_last_pos()
    self.last_pos.x = self.pos.x
    self.last_pos.y = self.pos.y
end

-- Set monitor offset
function CameraPhysics:set_monitor_offset(offset)
    self.monitor_offset = offset or { x = 0, y = 0 }
end

-- Reset camera state
function CameraPhysics:reset()
    self.pos = { x = 0, y = 0 }
    self.vel_x = { val = 0 }
    self.vel_y = { val = 0 }
    self.tracked_pos = { x = 0, y = 0 }
    self.dead_zone_active = false
    self.last_pos = { x = 0, y = 0 }
end

-- Convenience wrapper functions
function camera_physics_init(mouse_pos)
    return CameraPhysics:init(mouse_pos)
end

function camera_physics_apply_dead_zone(mouse_pos, dead_zone_radius)
    return CameraPhysics:apply_dead_zone(mouse_pos, dead_zone_radius)
end

function camera_physics_smooth_input(target_pos, smooth_time, dt)
    return CameraPhysics:smooth_input(target_pos, smooth_time, dt)
end

function camera_physics_compute_crop(center_x, center_y, zoom_level, source_w, source_h)
    return CameraPhysics:compute_crop(center_x, center_y, zoom_level, source_w, source_h)
end

function camera_physics_get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
    return CameraPhysics:get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
end

function camera_physics_lerp_crop(start_crop, end_crop, t, easing_fn)
    return CameraPhysics:lerp_crop(start_crop, end_crop, t, easing_fn)
end

function camera_physics_get_velocity()
    return CameraPhysics:get_velocity()
end

function camera_physics_update_last_pos()
    return CameraPhysics:update_last_pos()
end

function camera_physics_reset()
    return CameraPhysics:reset()
end

--================================================
-- MODULE: Timer & Main Loop (M09)
--================================================
-- Core integration module that handles frame-by-frame updates,
-- input processing, state machine updates, and output

-- Configuration (will be populated from settings)
local cfg = {
    source_name = "",
    zoom_value = 2.0,
    max_zoom = 10.0,
    zoom_duration = 0.6,
    zoom_overshoot = 0.0,
    zoom_easing = "Cubic.Out",

    auto_follow = true,
    follow_smooth_time = 0.15,
    follow_dead_zone = 5,

    debug_logs = false,
}

-- Timing
local last_tick_time = 0
local timer_running = false

-- Frame diff tracking (skip updates if nothing changed)
local last_output = { x = -1, y = -1, w = -1, h = -1 }

-- Original crop for zoom out
local original_crop = { x = 0, y = 0, w = 0, h = 0 }

-- Hotkey IDs
local hotkey_toggle_zoom = nil
local hotkey_toggle_follow = nil

-- Get reliable delta time
local function get_dt()
    local now = os.clock()
    local dt = now - last_tick_time
    last_tick_time = now
    return clamp(0.001, 0.1, dt)  -- Guard against freezes and div/zero
end

-- Start the timer
local function start_timer()
    if not timer_running then
        timer_running = true
        last_tick_time = os.clock()
        -- Use frame-synced interval
        local interval = 16  -- Default to ~60fps
        obs.timer_add(on_timer, interval)
        log("Timer: Started")
    end
end

-- Stop the timer
local function stop_timer()
    if timer_running then
        timer_running = false
        obs.timer_remove(on_timer)
        log("Timer: Stopped")
    end
end

-- Initialize mouse tracking
local function init_mouse_tracking(mouse_pos)
    camera_physics_init(mouse_pos)
    original_crop = {
        x = 0,
        y = 0,
        w = 0,
        h = 0,
    }
end

-- Main timer callback
function on_timer()
    local dt = get_dt()

    -- Guard: No valid source
    if not source_manager_is_valid() then
        return
    end

    --==========================
    -- 1. INPUT
    --==========================
    local raw_mouse = platform_get_mouse_pos()

    --==========================
    -- 2. STATE MACHINE UPDATE
    --==========================
    if SM:is_animating() then
        SM.zoom_time = SM.zoom_time + (dt / cfg.zoom_duration)

        -- Check for completion
        if SM.zoom_time >= 1.0 then
            SM:complete()

            -- Auto-enable follow after zoom in
            if SM.state == ZoomState.ZOOMED_IN and cfg.auto_follow then
                SM.following = true
            end

            -- Stop timer if idle
            if SM.state == ZoomState.IDLE then
                stop_timer()
            end
        end
    end

    --==========================
    -- 3. CAMERA POSITION
    --==========================
    local crop = nil
    local source_w, source_h = source_manager_get_size()

    if source_w == 0 or source_h == 0 then
        return
    end

    if SM:is_animating() then
        -- Animate between start and target crop
        local easing_fn = Easing.get(cfg.zoom_easing, cfg.zoom_overshoot)
        crop = camera_physics_lerp_crop(SM.start_crop, SM.target_crop, SM.zoom_time, easing_fn)
    elseif SM:is_zoomed() and SM.following then
        -- Follow mouse with dead zone and smoothing
        local tracked = camera_physics_apply_dead_zone(raw_mouse, cfg.follow_dead_zone)
        local smoothed = camera_physics_smooth_input(tracked, cfg.follow_smooth_time, dt)
        crop = camera_physics_compute_crop(smoothed.x, smoothed.y, SM.zoom_level, source_w, source_h)
        camera_physics_update_last_pos()
    elseif SM:is_zoomed() then
        -- Static zoom (not following)
        crop = camera_physics_get_target_crop(
            { x = SM.target_crop.x + SM.target_crop.w / 2, y = SM.target_crop.y + SM.target_crop.h / 2 },
            SM.zoom_level, source_w, source_h, nil
        )
    end

    --==========================
    -- 4. OUTPUT (Diff-based)
    --==========================
    if crop then
        local cx = math.floor(crop.x)
        local cy = math.floor(crop.y)
        local cw = math.floor(crop.w)
        local ch = math.floor(crop.h)

        if cx ~= last_output.x or cy ~= last_output.y or
           cw ~= last_output.w or ch ~= last_output.h then
            crop_filter_update(cx, cy, cw, ch)
            last_output.x = cx
            last_output.y = cy
            last_output.w = cw
            last_output.h = ch
        end
    end
end

--==========================
-- HOTKEY HANDLERS
--==========================

function on_toggle_zoom(pressed)
    if not pressed then return end

    if not source_manager_is_valid() then
        log("Toggle Zoom: No valid source")
        return
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        log("Toggle Zoom: Invalid source dimensions")
        return
    end

    if SM.state == ZoomState.IDLE then
        -- ZOOM IN
        local mouse = platform_get_mouse_pos()
        init_mouse_tracking(mouse)

        -- Store original crop
        original_crop = { x = 0, y = 0, w = source_w, h = source_h }

        -- Calculate target crop
        local target_crop = camera_physics_get_target_crop(mouse, cfg.zoom_value, source_w, source_h, nil)

        SM:transition(ZoomState.ZOOMING_IN, {
            start_crop = original_crop,
            target_crop = target_crop,
            target_level = cfg.zoom_value
        })

        start_timer()

    elseif SM.state == ZoomState.ZOOMED_IN then
        -- ZOOM OUT
        SM.following = false

        local current = crop_filter_get_crop()
        SM:transition(ZoomState.ZOOMING_OUT, {
            start_crop = current,
            target_crop = original_crop,
            target_level = 1.0
        })

        start_timer()
    end
    -- Ignore if already animating (guard against rapid presses)
end

function on_toggle_follow(pressed)
    if not pressed then return end
    if not SM:is_zoomed() then return end

    SM.following = not SM.following
    log("Follow: " .. tostring(SM.following))

    if SM.following and not timer_running then
        start_timer()
    end
end

--==========================
-- HOTKEY REGISTRATION
--==========================

local function register_hotkeys(settings)
    -- Toggle Zoom hotkey
    hotkey_toggle_zoom = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.toggle_zoom",
        "Toggle Zoom to Mouse",
        on_toggle_zoom
    )

    -- Toggle Follow hotkey
    hotkey_toggle_follow = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.toggle_follow",
        "Toggle Mouse Follow",
        on_toggle_follow
    )

    -- Load saved hotkey bindings
    local toggle_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.toggle_zoom")
    if toggle_array then
        obs.obs_hotkey_load(hotkey_toggle_zoom, toggle_array)
        obs.obs_data_array_release(toggle_array)
    end

    local follow_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.toggle_follow")
    if follow_array then
        obs.obs_hotkey_load(hotkey_toggle_follow, follow_array)
        obs.obs_data_array_release(follow_array)
    end

    -- Register scroll zoom hotkeys
    register_scroll_hotkeys(settings)

    log("Hotkeys: Registered")
end

local function save_hotkeys(settings)
    if hotkey_toggle_zoom then
        local array = obs.obs_hotkey_save(hotkey_toggle_zoom)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.toggle_zoom", array)
        obs.obs_data_array_release(array)
    end

    if hotkey_toggle_follow then
        local array = obs.obs_hotkey_save(hotkey_toggle_follow)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.toggle_follow", array)
        obs.obs_data_array_release(array)
    end

    -- Save scroll zoom hotkeys
    save_scroll_hotkeys(settings)
end

local function unregister_hotkeys()
    if hotkey_toggle_zoom then
        obs.obs_hotkey_unregister(hotkey_toggle_zoom)
        hotkey_toggle_zoom = nil
    end
    if hotkey_toggle_follow then
        obs.obs_hotkey_unregister(hotkey_toggle_follow)
        hotkey_toggle_follow = nil
    end
    -- Unregister scroll zoom hotkeys
    unregister_scroll_hotkeys()
    log("Hotkeys: Unregistered")
end

--==========================
-- SCENE EVENT HANDLERS
--==========================

function on_frontend_event(event)
    if event == obs.OBS_FRONTEND_EVENT_SCENE_CHANGED then
        -- Scene changed, re-acquire source
        log("Event: Scene changed")

        -- Handle scene memory
        scene_memory_on_scene_change()

        if cfg.source_name and cfg.source_name ~= "" then
            source_manager_release()
            source_manager_init(cfg.source_name)
        end
    elseif event == obs.OBS_FRONTEND_EVENT_EXIT then
        -- OBS is closing
        log("Event: OBS exiting")
        stop_timer()
        source_manager_release()
    end
end

--==========================
-- CONFIGURATION UPDATE
--==========================

local function update_config(settings)
    cfg.source_name = obs.obs_data_get_string(settings, "source") or ""
    cfg.zoom_value = obs.obs_data_get_double(settings, "zoom_value")
    cfg.zoom_duration = obs.obs_data_get_double(settings, "zoom_duration")
    cfg.zoom_overshoot = obs.obs_data_get_double(settings, "zoom_overshoot")
    cfg.zoom_easing = obs.obs_data_get_string(settings, "zoom_easing") or "Cubic.Out"

    cfg.auto_follow = obs.obs_data_get_bool(settings, "auto_follow")
    cfg.follow_smooth_time = obs.obs_data_get_double(settings, "follow_smooth_time")
    cfg.follow_dead_zone = obs.obs_data_get_int(settings, "follow_dead_zone")

    cfg.debug_logs = obs.obs_data_get_bool(settings, "debug_logs")
    debug_logs = cfg.debug_logs

    -- Update scroll zoom config
    update_scroll_config(settings)

    -- Check if source changed
    local current_source = source_manager_is_valid() and cfg.source_name
    if cfg.source_name ~= "" and cfg.source_name ~= current_source then
        -- Reset state and reinitialize
        SM:reset()
        stop_timer()
        source_manager_release()
        source_manager_init(cfg.source_name)
    end
end

--================================================
-- MODULE: Scroll Zoom (M10)
--================================================
-- Enables gradual zoom control via scroll wheel with modifier key
-- Provides dynamic zoom level adjustment during zoomed state

local ScrollZoom = {
    -- Hotkey IDs for scroll zoom
    hotkey_scroll_up = nil,
    hotkey_scroll_down = nil,

    -- Configuration (populated from settings)
    scroll_step = 0.25,
    scroll_modifier = "ctrl",  -- "ctrl", "alt", "shift"
}

-- Check if modifier key is held
local function is_modifier_held()
    if ScrollZoom.scroll_modifier == "ctrl" then
        return platform_is_ctrl_held()
    elseif ScrollZoom.scroll_modifier == "alt" then
        return platform_is_alt_held()
    elseif ScrollZoom.scroll_modifier == "shift" then
        return platform_is_shift_held()
    end
    return false
end

-- Handle scroll zoom in
function on_scroll_zoom_up(pressed)
    if not pressed then return end
    on_scroll_zoom(1)
end

-- Handle scroll zoom out
function on_scroll_zoom_down(pressed)
    if not pressed then return end
    on_scroll_zoom(-1)
end

-- Main scroll zoom handler
function on_scroll_zoom(direction)
    -- Check if we can scroll
    if not SM:can_scroll() then return end

    -- Check modifier (optional - can be configured)
    -- For now, we rely on OBS hotkey bindings which can include modifiers

    if not source_manager_is_valid() then
        log("Scroll Zoom: No valid source")
        return
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        return
    end

    -- Calculate new zoom level
    local step = ScrollZoom.scroll_step * direction  -- e.g., 0.25
    local new_level

    if SM.state == ZoomState.IDLE then
        -- Starting from unzoomed
        new_level = 1.0 + step
    else
        -- Already zoomed, adjust level
        new_level = SM.target_level + step
    end

    -- Clamp to valid range
    new_level = clamp(1.0, cfg.max_zoom, new_level)

    -- If we hit 1.0, fully zoom out
    if new_level <= 1.0 then
        if SM:is_zoomed() then
            -- Trigger full zoom out
            local current = crop_filter_get_crop()
            SM.following = false
            SM:transition(ZoomState.ZOOMING_OUT, {
                start_crop = current,
                target_crop = original_crop,
                target_level = 1.0
            })
            start_timer()
        end
        return
    end

    -- Get current mouse position
    local mouse = platform_get_mouse_pos()

    -- Calculate new target crop for new zoom level
    local target_crop = camera_physics_get_target_crop(mouse, new_level, source_w, source_h, nil)

    -- Get current crop as start
    local start_crop
    if SM:is_animating() then
        -- Use current interpolated crop
        start_crop = crop_filter_get_crop()
    elseif SM:is_zoomed() then
        -- Use current crop
        start_crop = crop_filter_get_crop()
    else
        -- Starting from unzoomed
        start_crop = { x = 0, y = 0, w = source_w, h = source_h }
        original_crop = start_crop
        camera_physics_init(mouse)
    end

    -- Transition to new zoom level
    if SM.state == ZoomState.IDLE then
        -- First scroll from unzoomed
        SM:transition(ZoomState.SCROLLING, {
            start_crop = start_crop,
            target_crop = target_crop,
            target_level = new_level
        })
    else
        -- Already zoomed, adjust level (interrupt current animation)
        SM:transition(ZoomState.SCROLLING, {
            start_crop = start_crop,
            target_crop = target_crop,
            target_level = new_level
        })
    end

    start_timer()
    log("Scroll Zoom: Level " .. string.format("%.2f", new_level))
end

-- Zoom to a specific level (for API calls)
function on_scroll_zoom_to(level)
    if not source_manager_is_valid() then return end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then return end

    level = clamp(1.0, cfg.max_zoom, level)

    if level <= 1.0 then
        -- Zoom out
        if SM:is_zoomed() then
            local current = crop_filter_get_crop()
            SM.following = false
            SM:transition(ZoomState.ZOOMING_OUT, {
                start_crop = current,
                target_crop = original_crop,
                target_level = 1.0
            })
            start_timer()
        end
        return
    end

    local mouse = platform_get_mouse_pos()
    local target_crop = camera_physics_get_target_crop(mouse, level, source_w, source_h, nil)

    local start_crop
    if SM:is_zoomed() then
        start_crop = crop_filter_get_crop()
    else
        start_crop = { x = 0, y = 0, w = source_w, h = source_h }
        original_crop = start_crop
        camera_physics_init(mouse)
    end

    SM:transition(ZoomState.SCROLLING, {
        start_crop = start_crop,
        target_crop = target_crop,
        target_level = level
    })

    start_timer()
end

-- Register scroll zoom hotkeys
local function register_scroll_hotkeys(settings)
    -- Scroll Up hotkey
    ScrollZoom.hotkey_scroll_up = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.scroll_up",
        "Zoom In (Scroll)",
        on_scroll_zoom_up
    )

    -- Scroll Down hotkey
    ScrollZoom.hotkey_scroll_down = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.scroll_down",
        "Zoom Out (Scroll)",
        on_scroll_zoom_down
    )

    -- Load saved bindings
    local up_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.scroll_up")
    if up_array then
        obs.obs_hotkey_load(ScrollZoom.hotkey_scroll_up, up_array)
        obs.obs_data_array_release(up_array)
    end

    local down_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.scroll_down")
    if down_array then
        obs.obs_hotkey_load(ScrollZoom.hotkey_scroll_down, down_array)
        obs.obs_data_array_release(down_array)
    end

    log("Scroll Zoom: Hotkeys registered")
end

-- Save scroll hotkey bindings
local function save_scroll_hotkeys(settings)
    if ScrollZoom.hotkey_scroll_up then
        local array = obs.obs_hotkey_save(ScrollZoom.hotkey_scroll_up)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.scroll_up", array)
        obs.obs_data_array_release(array)
    end

    if ScrollZoom.hotkey_scroll_down then
        local array = obs.obs_hotkey_save(ScrollZoom.hotkey_scroll_down)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.scroll_down", array)
        obs.obs_data_array_release(array)
    end
end

-- Unregister scroll hotkeys
local function unregister_scroll_hotkeys()
    if ScrollZoom.hotkey_scroll_up then
        obs.obs_hotkey_unregister(ScrollZoom.hotkey_scroll_up)
        ScrollZoom.hotkey_scroll_up = nil
    end
    if ScrollZoom.hotkey_scroll_down then
        obs.obs_hotkey_unregister(ScrollZoom.hotkey_scroll_down)
        ScrollZoom.hotkey_scroll_down = nil
    end
end

-- Update scroll zoom config
local function update_scroll_config(settings)
    ScrollZoom.scroll_step = obs.obs_data_get_double(settings, "scroll_step")
    ScrollZoom.scroll_modifier = obs.obs_data_get_string(settings, "scroll_modifier") or "ctrl"
end

--================================================
-- PLACEHOLDER: Future Modules
--================================================

-- M01: Configuration & Settings (TODO)
-- M05: Scene Manager (TODO)
-- M06: Source Manager (TODO)
-- M07: Crop/Zoom Controller (TODO)
-- M08: Motion Tracker (TODO)
-- M09: Face Detection (TODO)
-- M11: Audio Reactor (TODO)
-- M12: Transition Manager (TODO)
-- M13: Animation Controller (TODO)
-- M14: Preset Manager (TODO)
-- M15: Hotkey Manager (TODO)
-- M16: UI Components (TODO)
-- M17: Timer/Scheduler (TODO)
-- M18: State Machine (TODO)
-- M19: Performance Monitor (TODO)

--================================================
-- SCRIPT SETTINGS
--================================================
local settings = {}

-- Default settings
local defaults = {
    debug_logging = false,
    easing_type = "QuadInOut",
    smooth_time = 0.3,
    max_speed = 100.0
}

--================================================
-- MODULE: Preset Manager (M13)
--================================================
-- Manages built-in and custom animation presets

local PresetManager = {
    -- Built-in presets (read-only)
    built_in = {
        {
            name = "Smooth",
            duration = 0.8,
            overshoot = 0.0,
            smoothness = 0.25,
            easing = "Cubic.Out",
        },
        {
            name = "Bounce",
            duration = 0.6,
            overshoot = 0.35,
            smoothness = 0.15,
            easing = "Back.Out",
        },
        {
            name = "Snappy",
            duration = 0.3,
            overshoot = 0.0,
            smoothness = 0.05,
            easing = "Expo.Out",
        },
        {
            name = "Cinematic",
            duration = 1.2,
            overshoot = 0.05,
            smoothness = 0.4,
            easing = "Sine.Out",
        },
    },

    -- Custom user presets
    custom = {},

    -- Currently selected preset name
    current_preset = "Smooth",
}

-- Get all preset names (built-in + custom)
function PresetManager:get_all_names()
    local names = {}

    -- Add built-in presets
    for _, preset in ipairs(self.built_in) do
        table.insert(names, preset.name)
    end

    -- Add custom presets
    for name, _ in pairs(self.custom) do
        table.insert(names, name)
    end

    table.sort(names)
    return names
end

-- Get preset by name
function PresetManager:get_preset(name)
    -- Check built-in first
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            return preset
        end
    end

    -- Check custom
    if self.custom[name] then
        return self.custom[name]
    end

    -- Default to Smooth
    return self.built_in[1]
end

-- Apply preset to configuration
function PresetManager:apply_preset(name)
    local preset = self:get_preset(name)
    if not preset then
        log("Preset: Unknown preset: " .. name)
        return false
    end

    cfg.zoom_duration = preset.duration
    cfg.zoom_overshoot = preset.overshoot
    cfg.follow_smooth_time = preset.smoothness

    if preset.easing then
        cfg.zoom_easing = preset.easing
    end

    self.current_preset = name
    log("Preset: Applied '" .. name .. "'")
    return true
end

-- Save a custom preset
function PresetManager:save_preset(name, duration, overshoot, smoothness, easing)
    if not name or name == "" then
        return false
    end

    -- Check if it's a built-in preset (can't override)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            log("Preset: Cannot override built-in preset: " .. name)
            return false
        end
    end

    -- Save custom preset
    self.custom[name] = {
        name = name,
        duration = duration or cfg.zoom_duration,
        overshoot = overshoot or cfg.zoom_overshoot,
        smoothness = smoothness or cfg.follow_smooth_time,
        easing = easing or cfg.zoom_easing,
    }

    log("Preset: Saved custom preset '" .. name .. "'")
    return true
end

-- Delete a custom preset
function PresetManager:delete_preset(name)
    -- Check if it's a built-in preset (can't delete)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            log("Preset: Cannot delete built-in preset: " .. name)
            return false
        end
    end

    -- Delete custom preset
    if self.custom[name] then
        self.custom[name] = nil
        log("Preset: Deleted custom preset '" .. name .. "'")
        return true
    end

    return false
end

-- Check if a preset is built-in
function PresetManager:is_built_in(name)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            return true
        end
    end
    return false
end

-- Persist custom presets to settings
function PresetManager:persist(settings)
    local array = obs.obs_data_array_create()

    for name, preset in pairs(self.custom) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "name", name)
        obs.obs_data_set_double(item, "duration", preset.duration)
        obs.obs_data_set_double(item, "overshoot", preset.overshoot)
        obs.obs_data_set_double(item, "smoothness", preset.smoothness)
        obs.obs_data_set_string(item, "easing", preset.easing)
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "custom_presets", array)
    obs.obs_data_array_release(array)
end

-- Load custom presets from settings
function PresetManager:load(settings)
    self.custom = {}

    local array = obs.obs_data_get_array(settings, "custom_presets")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local name = obs.obs_data_get_string(item, "name")

        if name and name ~= "" then
            self.custom[name] = {
                name = name,
                duration = obs.obs_data_get_double(item, "duration"),
                overshoot = obs.obs_data_get_double(item, "overshoot"),
                smoothness = obs.obs_data_get_double(item, "smoothness"),
                easing = obs.obs_data_get_string(item, "easing"),
            }
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)
    log("Preset: Loaded " .. self:get_custom_count() .. " custom presets")
end

-- Get count of custom presets
function PresetManager:get_custom_count()
    local count = 0
    for _, _ in pairs(self.custom) do
        count = count + 1
    end
    return count
end

-- Get current preset name
function PresetManager:get_current_name()
    return self.current_preset
end

-- Set current preset name
function PresetManager:set_current_name(name)
    self.current_preset = name
end

-- Check if current preset is custom
function PresetManager:is_current_custom()
    return not self:is_built_in(self.current_preset)
end

-- Global convenience functions
function preset_get_all_names()
    return PresetManager:get_all_names()
end

function preset_apply(name)
    return PresetManager:apply_preset(name)
end

function preset_save(name, duration, overshoot, smoothness, easing)
    return PresetManager:save_preset(name, duration, overshoot, smoothness, easing)
end

function preset_delete(name)
    return PresetManager:delete_preset(name)
end

function preset_is_built_in(name)
    return PresetManager:is_built_in(name)
end

function preset_get_current()
    return PresetManager:get_current_name()
end

--================================================
-- MODULE: Auto Source Detection (M11)
--================================================
-- Automatically detects and selects the best zoom source on first run

local AutoSourceDetector = {
    -- Source type priorities (higher = more likely to be the main display)
    type_priorities = {
        ["monitor_capture"] = 100,     -- Display capture (highest priority)
        ["game_capture"] = 80,          -- Game capture
        ["window_capture"] = 60,        -- Window capture
        ["xshm_input"] = 40,           -- Linux X11 capture
        ["av_capture_input"] = 20,     -- macOS capture
    },

    -- Whether auto-detection has been run
    auto_detected = false,
}

-- Get all capture sources sorted by priority
function AutoSourceDetector:get_capture_sources()
    local sources = {}
    local source_list = obs.obs_enum_sources()

    if not source_list then
        return sources
    end

    for _, source in ipairs(source_list) do
        local source_id = obs.obs_source_get_id(source)
        local name = obs.obs_source_get_name(source)

        -- Check if it's a capture source
        local priority = self.type_priorities[source_id]
        if priority then
            table.insert(sources, {
                name = name,
                id = source_id,
                priority = priority,
            })
        end
    end

    obs.source_list_release(source_list)

    -- Sort by priority (highest first)
    table.sort(sources, function(a, b)
        return a.priority > b.priority
    end)

    return sources
end

-- Auto-detect the best source
function AutoSourceDetector:auto_detect()
    local sources = self:get_capture_sources()

    if #sources == 0 then
        log("AutoSource: No capture sources found")
        return nil
    end

    if #sources == 1 then
        -- Only one source, use it
        log("AutoSource: Found single source: " .. sources[1].name)
        return sources[1].name
    end

    -- Multiple sources - prioritize by type
    -- Prefer monitor_capture > game_capture > window_capture
    local best = sources[1]

    log("AutoSource: Found " .. #sources .. " sources, selecting: " .. best.name)
    return best.name
end

-- Get monitor geometry from a source (if available)
function AutoSourceDetector:get_monitor_geometry(source_name)
    local source = obs.obs_get_source_by_name(source_name)
    if not source then
        return nil
    end

    local settings = obs.obs_source_get_settings(source)
    if not settings then
        obs.obs_source_release(source)
        return nil
    end

    -- Try to get monitor info from settings
    local monitor = obs.obs_data_get_int(settings, "monitor")
    local x = obs.obs_data_get_int(settings, "x")
    local y = obs.obs_data_get_int(settings, "y")
    local width = obs.obs_data_get_int(settings, "width")
    local height = obs.obs_data_get_int(settings, "height")

    obs.obs_data_release(settings)
    obs.obs_source_release(source)

    -- Return geometry if available
    if monitor >= 0 or width > 0 then
        return {
            monitor = monitor,
            x = x,
            y = y,
            width = width or 1920,
            height = height or 1080,
        }
    end

    return nil
end

-- Check if we should auto-detect on first run
function AutoSourceDetector:should_auto_detect(settings)
    -- Check if source has ever been set
    local last_source = obs.obs_data_get_string(settings, "source")
    if last_source and last_source ~= "" then
        return false
    end

    -- Check if auto-detect has been done
    return not self.auto_detected
end

-- Run auto-detection and return the source name
function AutoSourceDetector:run(settings)
    local source_name = self:auto_detect()

    if source_name then
        -- Save the detected source
        obs.obs_data_set_string(settings, "source", source_name)
        self.auto_detected = true
    end

    return source_name
end

-- Global convenience functions
function auto_source_detect()
    return AutoSourceDetector:auto_detect()
end

function auto_source_should_detect(settings)
    return AutoSourceDetector:should_auto_detect(settings)
end

function auto_source_run(settings)
    return AutoSourceDetector:run(settings)
end

--================================================
-- MODULE: Scene Memory (M12)
--================================================
-- Remembers which zoom source to use for each OBS scene

local SceneMemory = {
    -- Scene to source mapping
    scene_source_map = {},

    -- Maximum number of mappings to store
    max_mappings = 50,
}

-- Get the current scene name
function SceneMemory:get_current_scene_name()
    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then
        return nil
    end

    local name = obs.obs_source_get_name(scene_source)
    obs.obs_source_release(scene_source)
    return name
end

-- Get the source to use for the current scene
function SceneMemory:get_source_for_current_scene()
    local scene_name = self:get_current_scene_name()
    if not scene_name then
        return nil
    end

    -- 1. Check explicit mapping for this scene
    if self.scene_source_map[scene_name] then
        return self.scene_source_map[scene_name]
    end

    -- 2. Fall back to global source from config
    return cfg.source_name
end

-- Set the source for a specific scene
function SceneMemory:set(scene_name, source_name)
    if not scene_name or scene_name == "" then
        return false
    end

    -- Check if we're at capacity
    local count = 0
    for _, _ in pairs(self.scene_source_map) do
        count = count + 1
    end

    if count >= self.max_mappings and not self.scene_source_map[scene_name] then
        log("SceneMemory: At capacity (" .. self.max_mappings .. "), cannot add: " .. scene_name)
        return false
    end

    self.scene_source_map[scene_name] = source_name
    log("SceneMemory: " .. scene_name .. " Ã¢â€ â€™ " .. source_name)
    return true
end

-- Remove a scene mapping
function SceneMemory:remove(scene_name)
    if self.scene_source_map[scene_name] then
        self.scene_source_map[scene_name] = nil
        log("SceneMemory: Removed mapping for " .. scene_name)
        return true
    end
    return false
end

-- Get all scene mappings
function SceneMemory:get_all()
    local mappings = {}
    for scene, source in pairs(self.scene_source_map) do
        table.insert(mappings, { scene = scene, source = source })
    end
    table.sort(mappings, function(a, b)
        return a.scene < b.scene
    end)
    return mappings
end

-- Check if a scene has a mapping
function SceneMemory:has_mapping(scene_name)
    return self.scene_source_map[scene_name] ~= nil
end

-- Persist mappings to settings
function SceneMemory:persist(settings)
    local array = obs.obs_data_array_create()

    for scene, source in pairs(self.scene_source_map) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "scene", scene)
        obs.obs_data_set_string(item, "source", source)
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "scene_source_map", array)
    obs.obs_data_array_release(array)
end

-- Load mappings from settings
function SceneMemory:load(settings)
    self.scene_source_map = {}

    local array = obs.obs_data_get_array(settings, "scene_source_map")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local scene = obs.obs_data_get_string(item, "scene")
        local source = obs.obs_data_get_string(item, "source")

        if scene and scene ~= "" and source and source ~= "" then
            self.scene_source_map[scene] = source
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)

    local count = 0
    for _, _ in pairs(self.scene_source_map) do count = count + 1 end
    log("SceneMemory: Loaded " .. count .. " scene mappings")
end

-- Handle scene change
function SceneMemory:on_scene_change()
    local scene_name = self:get_current_scene_name()
    if not scene_name then
        return
    end

    -- Get the source for this scene
    local source_name = self:get_source_for_current_scene()

    if source_name and source_name ~= "" then
        -- Check if source changed
        local current = source_manager_is_valid() and cfg.source_name

        if source_name ~= current then
            log("SceneMemory: Scene changed to " .. scene_name)

            -- Release current source
            source_manager_release()

            -- Initialize with new source
            cfg.source_name = source_name
            source_manager_init(source_name)
        end
    end
end

-- Global convenience functions
function scene_memory_get_source()
    return SceneMemory:get_source_for_current_scene()
end

function scene_memory_set(scene_name, source_name)
    return SceneMemory:set(scene_name, source_name)
end

function scene_memory_remove(scene_name)
    return SceneMemory:remove(scene_name)
end

function scene_memory_get_all()
    return SceneMemory:get_all()
end

function scene_memory_on_scene_change()
    return SceneMemory:on_scene_change()
end

--================================================
-- MODULE: Blur Manager (M14)
--================================================
-- Provides built-in blur effects without external plugins
-- Supports multiple strategies: shader, composite_blur plugin, or none

local BlurManager = {
    -- Current strategy: "shader", "composite_blur", "none"
    strategy = "none",

    -- Filter references
    zoom_blur_filter = nil,
    motion_blur_filter = nil,

    -- Settings references
    zoom_blur_settings = nil,
    motion_blur_settings = nil,

    -- State
    initialized = false,

    -- Configuration
    zoom_blur_enabled = false,
    zoom_blur_intensity = 5,
    zoom_blur_clear_radius = 150,
    motion_blur_enabled = false,
    motion_blur_intensity = 1.0,
}

-- Try to use custom shader (if effect files exist)
function BlurManager:try_shader_strategy(source)
    -- This would require .effect files in assets/shaders/
    -- For now, we'll use a simpler approach
    log("Blur: Shader strategy not implemented (requires effect files)")
    return false
end

-- Try to auto-create Composite Blur filters
function BlurManager:try_composite_blur_strategy(source)
    if not source then return false end

    -- Check if composite_blur filter type exists
    local test_filter = obs.obs_source_create_private("composite_blur", "__test_blur__", nil)
    if test_filter then
        obs.obs_source_release(test_filter)
    else
        log("Blur: Composite Blur plugin not available")
        return false
    end

    -- Create Zoom Blur filter
    local zs = obs.obs_data_create()
    obs.obs_data_set_double(zs, "radius", 0)
    obs.obs_data_set_int(zs, "blur_type", 2) -- Zoom type
    self.zoom_blur_filter = obs.obs_source_create_private(
        "composite_blur",
        FILTER_PREFIX .. "Zoom Blur",
        zs
    )

    if self.zoom_blur_filter then
        obs.obs_source_filter_add(source, self.zoom_blur_filter)
        self.zoom_blur_settings = zs
    else
        obs.obs_data_release(zs)
        return false
    end

    -- Create Motion Blur filter
    local ms = obs.obs_data_create()
    obs.obs_data_set_double(ms, "radius", 0)
    obs.obs_data_set_int(ms, "blur_type", 3) -- Motion/directional type
    self.motion_blur_filter = obs.obs_source_create_private(
        "composite_blur",
        FILTER_PREFIX .. "Motion Blur",
        ms
    )

    if self.motion_blur_filter then
        obs.obs_source_filter_add(source, self.motion_blur_filter)
        self.motion_blur_settings = ms
    else
        obs.obs_data_release(ms)
    end

    self.initialized = true
    return true
end

-- Initialize blur manager
function BlurManager:init(source)
    if not source then
        return false
    end

    self:cleanup()

    -- Try composite_blur strategy
    if self:try_composite_blur_strategy(source) then
        self.strategy = "composite_blur"
        log("Blur: Using Composite Blur plugin (auto-configured)")
        return true
    end

    -- No blur available
    self.strategy = "none"
    log("Blur: No blur backend available. Blur effects disabled.")
    return false
end

-- Update blur based on zoom state
function BlurManager:update(state_machine, crop, camera_velocity)
    if not self.initialized then return end
    if self.strategy == "none" then return end

    -- Zoom Blur: Active during zoom transitions
    if self.zoom_blur_enabled and self.zoom_blur_filter then
        local radius = 0

        if state_machine:is_animating() and
           (state_machine.state == ZoomState.ZOOMING_IN or
            state_machine.state == ZoomState.ZOOMING_OUT) then
            -- Bell curve: 0 at start Ã¢â€ â€™ peak at 50% Ã¢â€ â€™ 0 at end
            local t = clamp(0, 1, state_machine.zoom_time)
            local curve = math.sin(t * math.pi)
            radius = curve * curve * self.zoom_blur_intensity
        end

        self:set_zoom_blur(radius, crop)
    end

    -- Motion Blur: Active during camera panning (not during zoom transition)
    if self.motion_blur_enabled and self.motion_blur_filter then
        if not state_machine:is_animating() and state_machine:is_zoomed() and camera_velocity then
            local speed = math.sqrt(
                camera_velocity.x * camera_velocity.x +
                camera_velocity.y * camera_velocity.y
            )

            if speed > 1.0 then
                local radius = math.min(10, speed * self.motion_blur_intensity * 0.5)
                local angle = math.deg(math.atan2(camera_velocity.y, camera_velocity.x))
                self:set_motion_blur(radius, angle)
            else
                self:set_motion_blur(0, 0)
            end
        else
            self:set_motion_blur(0, 0)
        end
    end
end

-- Set zoom blur parameters
function BlurManager:set_zoom_blur(radius, crop)
    if self.strategy == "composite_blur" and self.zoom_blur_settings then
        obs.obs_data_set_double(self.zoom_blur_settings, "radius", radius)

        if crop then
            local cx = crop.x + (crop.w / 2)
            local cy = crop.y + (crop.h / 2)
            obs.obs_data_set_double(self.zoom_blur_settings, "center_x", cx)
            obs.obs_data_set_double(self.zoom_blur_settings, "center_y", cy)
        end

        obs.obs_data_set_double(self.zoom_blur_settings, "inactive_radius", self.zoom_blur_clear_radius)
        obs.obs_source_update(self.zoom_blur_filter, self.zoom_blur_settings)
    end
end

-- Set motion blur parameters
function BlurManager:set_motion_blur(radius, angle)
    if self.strategy == "composite_blur" and self.motion_blur_settings then
        obs.obs_data_set_double(self.motion_blur_settings, "radius", radius)
        obs.obs_data_set_double(self.motion_blur_settings, "angle", angle)
        obs.obs_source_update(self.motion_blur_filter, self.motion_blur_settings)
    end
end

-- Update configuration
function BlurManager:update_config(settings)
    self.zoom_blur_enabled = obs.obs_data_get_bool(settings, "zoom_blur_enabled")
    self.zoom_blur_intensity = obs.obs_data_get_double(settings, "zoom_blur_intensity")
    self.zoom_blur_clear_radius = obs.obs_data_get_double(settings, "zoom_blur_clear_radius")
    self.motion_blur_enabled = obs.obs_data_get_bool(settings, "motion_blur_enabled")
    self.motion_blur_intensity = obs.obs_data_get_double(settings, "motion_blur_intensity")
end

-- Cleanup filters
function BlurManager:cleanup()
    local source = source_manager_get_source()

    if self.zoom_blur_filter and source then
        obs.obs_source_filter_remove(source, self.zoom_blur_filter)
        obs.obs_source_release(self.zoom_blur_filter)
        self.zoom_blur_filter = nil
    end

    if self.motion_blur_filter and source then
        obs.obs_source_filter_remove(source, self.motion_blur_filter)
        obs.obs_source_release(self.motion_blur_filter)
        self.motion_blur_filter = nil
    end

    if self.zoom_blur_settings then
        obs.obs_data_release(self.zoom_blur_settings)
        self.zoom_blur_settings = nil
    end

    if self.motion_blur_settings then
        obs.obs_data_release(self.motion_blur_settings)
        self.motion_blur_settings = nil
    end

    self.initialized = false
    self.strategy = "none"
end

-- Check if blur is available
function BlurManager:is_available()
    return self.strategy ~= "none"
end

-- Global convenience functions
function blur_manager_init(source)
    return BlurManager:init(source)
end

function blur_manager_update(state_machine, crop, camera_velocity)
    return BlurManager:update(state_machine, crop, camera_velocity)
end

function blur_manager_update_config(settings)
    return BlurManager:update_config(settings)
end

function blur_manager_cleanup()
    return BlurManager:cleanup()
end

function blur_manager_is_available()
    return BlurManager:is_available()
end

--================================================
-- MODULE: Cursor Asset Manager (M16)
--================================================
-- Handles extracting and managing cursor image assets

local CursorAssets = {
    extracted = false,
    dir = nil,
}

-- Get the platform-specific asset directory
function CursorAssets:get_platform_dir()
    if IS_WINDOWS then
        local appdata = os.getenv("APPDATA")
        return appdata and (appdata .. "\\obs-studio\\obs-zoom-pro\\cursors") or nil
    elseif IS_LINUX then
        local home = os.getenv("HOME")
        return home and (home .. "/.config/obs-studio/obs-zoom-pro/cursors") or nil
    elseif IS_MACOS then
        local home = os.getenv("HOME")
        return home and (home .. "/Library/Application Support/obs-studio/obs-zoom-pro/cursors") or nil
    end
    -- Fallback for non-FFI environments
    return "cursors"
end

-- Ensure assets are extracted
function CursorAssets:ensure_extracted()
    if self.extracted then
        return self.dir
    end

    local dir = self:get_platform_dir()
    if not dir then
        log("CursorAssets: Could not determine asset directory")
        return nil
    end

    -- Create directory
    local cmd
    if IS_WINDOWS then
        cmd = 'mkdir "' .. dir .. '" 2>nul'
    else
        cmd = 'mkdir -p "' .. dir .. '"'
    end
    os.execute(cmd)

    -- Check if assets exist
    local sep = IS_WINDOWS and "\\" or "/"
    local arrow_path = dir .. sep .. "arrow.png"

    local f = io.open(arrow_path, "rb")
    if f then
        f:close()
        self.dir = dir
        self.extracted = true
        log("CursorAssets: Using existing assets from " .. dir)
        return dir
    end

    -- Try to copy from script directory
    local script_dir = get_script_directory()
    local assets_src = script_dir .. "assets" .. sep .. "cursors" .. sep

    local files = { "arrow.png", "pointer.png", "ibeam.png" }
    for _, filename in ipairs(files) do
        local src_path = assets_src .. filename
        local dst_path = dir .. sep .. filename

        local src = io.open(src_path, "rb")
        if src then
            local data = src:read("*a")
            src:close()

            local dst = io.open(dst_path, "wb")
            if dst then
                dst:write(data)
                dst:close()
                log("CursorAssets: Copied " .. filename)
            end
        end
    end

    self.dir = dir
    self.extracted = true
    return dir
end

-- Get the asset directory
function CursorAssets:get_dir()
    return self.dir
end

-- Check if assets are available
function CursorAssets:is_available()
    if not self.extracted then
        self:ensure_extracted()
    end
    return self.dir ~= nil
end

-- Get cursor image path
function CursorAssets:get_cursor_path(cursor_type)
    if not self:is_available() then
        return nil
    end

    local sep = IS_WINDOWS and "\\" or "/"
    local filename = (cursor_type or "arrow") .. ".png"
    return self.dir .. sep .. filename
end

-- Global convenience functions
function cursor_assets_ensure_extracted()
    return CursorAssets:ensure_extracted()
end

function cursor_assets_get_dir()
    return CursorAssets:get_dir()
end

function cursor_assets_is_available()
    return CursorAssets:is_available()
end

function cursor_assets_get_cursor_path(cursor_type)
    return CursorAssets:get_cursor_path(cursor_type)
end

--================================================
-- MODULE: Cursor Renderer (M15)
--================================================
-- Provides automatic cursor overlay rendering

local CursorRenderer = {
    enabled = false,
    source = nil,
    sceneitem = nil,

    -- Smoothed state
    pos = { x = 0, y = 0 },
    current_scale = 1.0,
    current_rot = 0,
    swap_pulse = 1.0,

    -- Velocities (SmoothDamp)
    vel_x = { val = 0 },
    vel_y = { val = 0 },
    vel_scale = { val = 0 },
    vel_rot = { val = 0 },
    vel_swap = { val = 0 },

    -- State
    was_pointer = false,
    initialized = false,

    -- Configuration
    cursor_scale = 1.0,
    cursor_click_scale = 0.78,
    cursor_smooth_time = 0.1,
    cursor_offset_x = -6,
    cursor_offset_y = -2,
    cursor_rotation_mode = "None",
    cursor_angle_offset = 0,
    cursor_tilt_strength = 0,
}

-- Initialize cursor renderer
function CursorRenderer:init()
    if not cfg.cursor_enabled then
        self.enabled = false
        return false
    end

    -- Ensure cursor assets are available
    local asset_dir = cursor_assets_ensure_extracted()
    if not asset_dir then
        log("CursorRenderer: Failed to extract cursor assets")
        self.enabled = false
        return false
    end

    -- Get or create the cursor image source
    local source_name = FILTER_PREFIX .. "Cursor"
    self.source = obs.obs_get_source_by_name(source_name)

    if not self.source then
        -- Create new image source
        local settings = obs.obs_data_create()
        local cursor_path = cursor_assets_get_cursor_path("arrow")
        if cursor_path then
            obs.obs_data_set_string(settings, "file", cursor_path)
        end
        self.source = obs.obs_source_create("image_source", source_name, settings, nil)
        obs.obs_data_release(settings)

        if not self.source then
            log("CursorRenderer: Failed to create image source")
            self.enabled = false
            return false
        end
    end

    -- Add to current scene
    self:add_to_scene()

    -- Initialize position
    local mouse = platform_get_mouse_pos()
    self.pos.x = mouse.x
    self.pos.y = mouse.y

    self.enabled = true
    self.initialized = true
    log("CursorRenderer: Initialized")
    return true
end

-- Add cursor source to scene
function CursorRenderer:add_to_scene()
    if not self.source then return false end

    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then return false end

    local scene = obs.obs_scene_from_source(scene_source)
    if not scene then
        obs.obs_source_release(scene_source)
        return false
    end

    -- Check if already in scene
    local source_name = obs.obs_source_get_name(self.source)
    self.sceneitem = obs.obs_scene_find_source(scene, source_name)

    if not self.sceneitem then
        -- Add to scene
        self.sceneitem = obs.obs_scene_add(scene, self.source)
        if self.sceneitem then
            -- Move to top (render last = on top)
            obs.obs_sceneitem_set_order(self.sceneitem, obs.OBS_ORDER_MOVE_TOP)
        end
    end

    obs.obs_source_release(scene_source)
    return true
end

-- Update cursor position and state
function CursorRenderer:update(dt, raw_mouse, camera_crop)
    if not self.enabled or not self.sceneitem then return end

    -- Smooth cursor position
    self.pos.x = SmoothDamp(self.pos.x, raw_mouse.x, self.vel_x, self.cursor_smooth_time, 100000, dt)
    self.pos.y = SmoothDamp(self.pos.y, raw_mouse.y, self.vel_y, self.cursor_smooth_time, 100000, dt)

    -- Snap when very close
    if math.abs(self.pos.x - raw_mouse.x) < 0.5 then
        self.pos.x = raw_mouse.x
        self.vel_x.val = 0
    end
    if math.abs(self.pos.y - raw_mouse.y) < 0.5 then
        self.pos.y = raw_mouse.y
        self.vel_y.val = 0
    end

    -- Cursor shape detection (Windows only)
    local is_pointer = false
    if platform_cursor_shape_available() then
        is_pointer = platform_is_cursor_pointer()
    end

    -- Swap cursor image if needed
    if is_pointer ~= self.was_pointer then
        local asset_dir = cursor_assets_get_dir()
        local sep = IS_WINDOWS and "\\" or "/"
        local new_file = is_pointer and (asset_dir .. sep .. "pointer.png") or (asset_dir .. sep .. "arrow.png")

        local s = obs.obs_source_get_settings(self.source)
        if s then
            obs.obs_data_set_string(s, "file", new_file)
            obs.obs_source_update(self.source, s)
            obs.obs_data_release(s)
        end

        -- Trigger swap pulse
        self.swap_pulse = 0.75
        self.vel_swap.val = 1
        self.was_pointer = is_pointer
    end

    self.swap_pulse = SmoothDamp(self.swap_pulse, 1.0, self.vel_swap, 0.12, 100000, dt)

    -- Click animation
    local is_clicking = platform_is_clicking()
    local target_scale = is_clicking and (self.cursor_scale * self.cursor_click_scale) or self.cursor_scale
    self.current_scale = SmoothDamp(self.current_scale, target_scale, self.vel_scale, 0.1, 100000, dt)

    -- Calculate position relative to zoom
    local zoom_factor = 1.0
    local crop_x, crop_y = 0, 0

    if camera_crop and SM:is_zoomed() then
        zoom_factor = source_manager_get_size() / camera_crop.w
        crop_x = camera_crop.x
        crop_y = camera_crop.y
    end

    local final_x = (self.pos.x - crop_x) * zoom_factor + (self.cursor_offset_x * zoom_factor)
    local final_y = (self.pos.y - crop_y) * zoom_factor + (self.cursor_offset_y * zoom_factor)

    -- Apply to scene item
    local pos = obs.vec2()
    pos.x = final_x
    pos.y = final_y
    obs.obs_sceneitem_set_pos(self.sceneitem, pos)

    local scale = obs.vec2()
    local s = self.current_scale * zoom_factor * self.swap_pulse
    scale.x = s
    scale.y = s
    obs.obs_sceneitem_set_scale(self.sceneitem, scale)

    -- Rotation
    local dynamic_rot = self:compute_rotation(dt)
    obs.obs_sceneitem_set_rot(self.sceneitem, dynamic_rot)
end

-- Compute rotation based on mode
function CursorRenderer:compute_rotation(dt)
    local vx = self.vel_x.val
    local vy = self.vel_y.val
    local speed = math.sqrt(vx * vx + vy * vy)

    if self.cursor_rotation_mode == "Directional" then
        if speed > 20 then
            local angle = math.atan2(vy, vx) * (180 / math.pi)
            local target = angle + self.cursor_angle_offset
            local diff = (target - self.current_rot + 180) % 360 - 180
            self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.05, 100000, dt)
        end
        return self.current_rot

    elseif self.cursor_rotation_mode == "Lean" then
        local lean = clamp(-40, 40, vx * 0.05 * self.cursor_tilt_strength) + self.cursor_angle_offset
        local diff = (lean - self.current_rot + 180) % 360 - 180
        self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.08, 100000, dt)
        return self.current_rot
    end

    -- "None" mode
    local diff = (self.cursor_angle_offset - self.current_rot + 180) % 360 - 180
    self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.15, 100000, dt)
    return self.current_rot
end

-- Update configuration
function CursorRenderer:update_config(settings)
    self.cursor_scale = obs.obs_data_get_double(settings, "cursor_scale")
    self.cursor_click_scale = obs.obs_data_get_double(settings, "cursor_click_scale")
    self.cursor_smooth_time = obs.obs_data_get_double(settings, "cursor_smooth_time")
    self.cursor_offset_x = obs.obs_data_get_int(settings, "cursor_offset_x")
    self.cursor_offset_y = obs.obs_data_get_int(settings, "cursor_offset_y")
    self.cursor_rotation_mode = obs.obs_data_get_string(settings, "cursor_rotation_mode") or "None"
    self.cursor_angle_offset = obs.obs_data_get_double(settings, "cursor_angle_offset")
    self.cursor_tilt_strength = obs.obs_data_get_double(settings, "cursor_tilt_strength")
end

-- Cleanup
function CursorRenderer:cleanup()
    if self.sceneitem then
        obs.obs_sceneitem_remove(self.sceneitem)
        self.sceneitem = nil
    end

    if self.source then
        local source_name = obs.obs_source_get_name(self.source)
        obs.obs_source_release(self.source)

        -- Remove from OBS source list
        local s = obs.obs_get_source_by_name(source_name)
        if s then
            obs.obs_source_remove(s)
            obs.obs_source_release(s)
        end
        self.source = nil
    end

    self.enabled = false
    self.initialized = false
end

-- Check if active
function CursorRenderer:is_active()
    return self.enabled and self.initialized
end

-- Global convenience functions
function cursor_renderer_init()
    return CursorRenderer:init()
end

function cursor_renderer_update(dt, raw_mouse, camera_crop)
    return CursorRenderer:update(dt, raw_mouse, camera_crop)
end

function cursor_renderer_update_config(settings)
    return CursorRenderer:update_config(settings)
end

function cursor_renderer_cleanup()
    return CursorRenderer:cleanup()
end

function cursor_renderer_is_active()
    return CursorRenderer:is_active()
end

--================================================
-- MODULE: Bookmark Manager (M17)
--================================================
-- Manages saved zoom positions (bookmarks)

local BookmarkManager = {
    -- Saved bookmarks: { name = { zoom_level, x, y, w, h, source } }
    bookmarks = {},

    -- Maximum bookmarks
    max_bookmarks = 20,

    -- Hotkey IDs
    hotkeys = {},
}

-- Save current zoom position as a bookmark
function BookmarkManager:save(name)
    if not name or name == "" then
        return false
    end

    -- Check limit
    local count = 0
    for _, _ in pairs(self.bookmarks) do count = count + 1 end

    if count >= self.max_bookmarks and not self.bookmarks[name] then
        log("Bookmark: Max bookmarks reached (" .. self.max_bookmarks .. ")")
        return false
    end

    -- Get current crop
    local crop = crop_filter_get_crop()
    if not crop then
        return false
    end

    -- Save bookmark
    self.bookmarks[name] = {
        zoom_level = SM.zoom_level,
        x = crop.x,
        y = crop.y,
        w = crop.w,
        h = crop.h,
        source = cfg.source_name,
    }

    log("Bookmark: Saved '" .. name .. "' (zoom=" .. string.format("%.2f", SM.zoom_level) .. ")")
    return true
end

-- Recall a bookmark
function BookmarkManager:recall(name)
    local bm = self.bookmarks[name]
    if not bm then
        log("Bookmark: Not found: " .. name)
        return false
    end

    if not SM:can_jump() then
        return false
    end

    if not source_manager_is_valid() then
        return false
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        return false
    end

    -- Get current crop as start
    local start_crop = crop_filter_get_crop() or { x = 0, y = 0, w = source_w, h = source_h }

    -- Set target
    local target_crop = {
        x = bm.x,
        y = bm.y,
        w = bm.w,
        h = bm.h,
    }

    -- Transition to bookmark
    SM:transition(ZoomState.JUMPING, {
        start_crop = start_crop,
        target_crop = target_crop,
        target_level = bm.zoom_level
    })

    start_timer()
    log("Bookmark: Recall '" .. name .. "'")
    return true
end

-- Delete a bookmark
function BookmarkManager:delete(name)
    if self.bookmarks[name] then
        self.bookmarks[name] = nil
        log("Bookmark: Deleted '" .. name .. "'")
        return true
    end
    return false
end

-- Rename a bookmark
function BookmarkManager:rename(old_name, new_name)
    if not self.bookmarks[old_name] then
        return false
    end

    if self.bookmarks[new_name] then
        return false
    end

    self.bookmarks[new_name] = self.bookmarks[old_name]
    self.bookmarks[old_name] = nil
    log("Bookmark: Renamed '" .. old_name .. "' to '" .. new_name .. "'")
    return true
end

-- Get all bookmark names
function BookmarkManager:get_names()
    local names = {}
    for k, _ in pairs(self.bookmarks) do
        table.insert(names, k)
    end
    table.sort(names)
    return names
end

-- Get bookmark info
function BookmarkManager:get(name)
    return self.bookmarks[name]
end

-- Persist bookmarks to settings
function BookmarkManager:persist(settings)
    local array = obs.obs_data_array_create()

    for name, bm in pairs(self.bookmarks) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "name", name)
        obs.obs_data_set_double(item, "zoom_level", bm.zoom_level)
        obs.obs_data_set_double(item, "x", bm.x)
        obs.obs_data_set_double(item, "y", bm.y)
        obs.obs_data_set_double(item, "w", bm.w)
        obs.obs_data_set_double(item, "h", bm.h)
        obs.obs_data_set_string(item, "source", bm.source or "")
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "zoom_bookmarks", array)
    obs.obs_data_array_release(array)
end

-- Load bookmarks from settings
function BookmarkManager:load(settings)
    self.bookmarks = {}

    local array = obs.obs_data_get_array(settings, "zoom_bookmarks")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local name = obs.obs_data_get_string(item, "name")

        if name and name ~= "" then
            self.bookmarks[name] = {
                zoom_level = obs.obs_data_get_double(item, "zoom_level"),
                x = obs.obs_data_get_double(item, "x"),
                y = obs.obs_data_get_double(item, "y"),
                w = obs.obs_data_get_double(item, "w"),
                h = obs.obs_data_get_double(item, "h"),
                source = obs.obs_data_get_string(item, "source"),
            }
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)

    local count = 0
    for _, _ in pairs(self.bookmarks) do count = count + 1 end
    log("Bookmark: Loaded " .. count .. " bookmarks")
end

-- Register bookmark hotkeys
function BookmarkManager:register_hotkeys(settings)
    for i = 1, 5 do
        self.hotkeys[i] = obs.obs_hotkey_register_frontend(
            "obs_zoom_pro.bookmark_" .. i,
            "Zoom to Bookmark " .. i,
            function(pressed)
                if not pressed then return end
                local names = self:get_names()
                if names[i] then
                    self:recall(names[i])
                end
            end
        )

        -- Load saved bindings
        local key = "obs_zoom_pro.hotkey.bookmark_" .. i
        local save_array = obs.obs_data_get_array(settings, key)
        if save_array then
            obs.obs_hotkey_load(self.hotkeys[i], save_array)
            obs.obs_data_array_release(save_array)
        end
    end
end

-- Save bookmark hotkeys
function BookmarkManager:save_hotkeys(settings)
    for i = 1, 5 do
        if self.hotkeys[i] then
            local save_array = obs.obs_hotkey_save(self.hotkeys[i])
            obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.bookmark_" .. i, save_array)
            obs.obs_data_array_release(save_array)
        end
    end
end

-- Global convenience functions
function bookmark_save(name)
    return BookmarkManager:save(name)
end

function bookmark_recall(name)
    return BookmarkManager:recall(name)
end

function bookmark_delete(name)
    return BookmarkManager:delete(name)
end

function bookmark_get_names()
    return BookmarkManager:get_names()
end

function bookmark_get(name)
    return BookmarkManager:get(name)
end

--================================================
-- MODULE: UDP API Server (M18)
--================================================
-- Provides external control via UDP for Stream Deck integration

local APIServer = {
    enabled = false,
    port = 12345,
    socket = nil,
}

-- Command handlers
local API_COMMANDS = {
    ZOOM_IN = function(args)
        local level = tonumber(args[1]) or cfg.zoom_value
        on_scroll_zoom_to(level)
        return "OK"
    end,

    ZOOM_OUT = function(args)
        if SM:is_zoomed() then
            on_toggle_zoom(true)
        end
        return "OK"
    end,

    ZOOM_SET = function(args)
        local level = tonumber(args[1])
        if not level then return "ERROR: Missing level" end
        on_scroll_zoom_to(level)
        return "OK"
    end,

    ZOOM_TOGGLE = function(args)
        on_toggle_zoom(true)
        return "OK"
    end,

    FOLLOW_ON = function(args)
        if SM:is_zoomed() then SM.following = true end
        return "OK"
    end,

    FOLLOW_OFF = function(args)
        SM.following = false
        return "OK"
    end,

    FOLLOW_TOGGLE = function(args)
        if SM:is_zoomed() then SM.following = not SM.following end
        return "OK"
    end,

    PRESET = function(args)
        local name = args[1]
        if not name then return "ERROR: Missing preset name" end
        local ok = preset_apply(name)
        return ok and "OK" or "ERROR: Unknown preset"
    end,

    BOOKMARK = function(args)
        local name = args[1]
        if not name then return "ERROR: Missing bookmark name" end
        local ok = bookmark_recall(name)
        return ok and "OK" or "ERROR: Bookmark not found"
    end,

    STATUS = function(args)
        local crop = crop_filter_get_crop()
        return string.format(
            '{"version":"%s","zoom_level":%.2f,"state":"%s","following":%s,"position":{"x":%.0f,"y":%.0f},"preset":"%s"}',
            VERSION,
            SM.zoom_level,
            SM.state,
            tostring(SM.following),
            crop and crop.x or 0,
            crop and crop.y or 0,
            cfg.zoom_preset or ""
        )
    end,

    HELP = function(args)
        return "Commands: ZOOM_IN [level], ZOOM_OUT, ZOOM_SET level, ZOOM_TOGGLE, FOLLOW_ON, FOLLOW_OFF, FOLLOW_TOGGLE, PRESET name, BOOKMARK name, STATUS"
    end,
}

-- Start the API server
function APIServer:start(port)
    self:stop()

    self.port = port or self.port

    -- Try to use luasocket if available
    local socket_ok, socket = pcall(require, "socket")
    if not socket_ok then
        log("API: Socket library not available")
        return false
    end

    -- Try UDP
    local udp, err = socket.udp()
    if not udp then
        log("API: Failed to create UDP socket: " .. tostring(err))
        return false
    end

    -- Set socket options
    udp:setoption("reuseaddr", true)
    udp:settimeout(0)  -- Non-blocking

    -- Bind to port
    local bind_ok, err = udp:setsockname("*", self.port)
    if not bind_ok then
        log("API: Failed to bind to port " .. self.port .. ": " .. tostring(err))
        udp:close()
        return false
    end

    self.socket = udp
    self.enabled = true

    -- Start polling timer
    obs.timer_add(function() self:poll() end, 50)  -- 20Hz polling

    log("API: Listening on port " .. self.port)
    return true
end

-- Stop the API server
function APIServer:stop()
    if self.socket then
        self.socket:close()
        self.socket = nil
    end
    self.enabled = false
    log("API: Stopped")
end

-- Poll for incoming commands
function APIServer:poll()
    if not self.enabled or not self.socket then
        return
    end

    repeat
        local data, err = self.socket:receivefrom()
        if data then
            local response = self:handle_command(data)
            if response then
                -- Note: UDP response requires sender address
                log("API: " .. data:gsub("%s+", " ") .. " Ã¢â€ â€™ " .. response)
            end
        elseif err ~= "timeout" then
            log("API: Error: " .. tostring(err))
        end
    until not data
end

-- Handle a command
function APIServer:handle_command(raw)
    -- Parse command
    local parts = {}
    for word in raw:gmatch("%S+") do
        table.insert(parts, word)
    end

    if #parts == 0 then
        return "ERROR: Empty command"
    end

    local cmd = parts[1]:upper()
    local args = {}
    for i = 2, #parts do
        table.insert(args, parts[i])
    end

    -- Look up handler
    local handler = API_COMMANDS[cmd]
    if handler then
        local ok, result = pcall(handler, args)
        if ok then
            return result
        else
            return "ERROR: " .. tostring(result)
        end
    end

    return "ERROR: Unknown command: " .. cmd
end

-- Check if enabled
function APIServer:is_enabled()
    return self.enabled
end

-- Global convenience functions
function api_start(port)
    return APIServer:start(port)
end

function api_stop()
    return APIServer:stop()
end

function api_is_enabled()
    return APIServer:is_enabled()
end

--================================================
-- OBS SCRIPT REGISTRATION
--================================================

--[[ Called when the script is loaded
--[[ @param data table Script data
function script_load(data)
    log("Script loaded - OBS Zoom Pro v" .. VERSION)

    -- Load custom presets
    PresetManager:load(data)

    -- Load scene memory
    SceneMemory:load(data)

    -- Load bookmarks
    BookmarkManager:load(data)

    -- Register hotkeys
    register_hotkeys(data)

    -- Register bookmark hotkeys
    BookmarkManager:register_hotkeys(data)

    -- Register frontend event handler
    obs.obs_frontend_add_event_callback(on_frontend_event)

    -- Start API server if enabled
    local api_enabled = obs.obs_data_get_bool(data, "api_enabled")
    if api_enabled then
        local api_port = obs.obs_data_get_int(data, "api_port")
        APIServer:start(api_port)
    end
end

--[[ Called when the script is unloaded
function script_unload()
    log("Script unloaded - OBS Zoom Pro")

    -- Stop timer and cleanup
    stop_timer()
    unregister_hotkeys()
    source_manager_release()

    -- Stop API server
    APIServer:stop()

    -- Remove frontend event handler
    obs.obs_frontend_remove_event_callback(on_frontend_event)
end

--[[ Called when settings are updated
--[[ @param data table Settings data
function script_update(data)
    log("Settings updated")

    -- Update legacy settings
    debug_logs = obs.obs_data_get_bool(data, "debug_logging") or false
    settings.debug_logging = debug_logs
    settings.easing_type = obs.obs_data_get_string(data, "easing_type") or defaults.easing_type
    settings.smooth_time = obs.obs_data_get_double(data, "smooth_time") or defaults.smooth_time
    settings.max_speed = obs.obs_data_get_double(data, "max_speed") or defaults.max_speed

    -- Update M09 configuration
    update_config(data)

    -- Update API server settings
    local api_enabled = obs.obs_data_get_bool(data, "api_enabled")
    local api_port = obs.obs_data_get_int(data, "api_port")

    if api_enabled and not APIServer:is_enabled() then
        APIServer:start(api_port)
    elseif not api_enabled and APIServer:is_enabled() then
        APIServer:stop()
    elseif APIServer:is_enabled() and APIServer.port ~= api_port then
        APIServer:start(api_port)
    end
end

--[[ Called to save settings
--[[ @param data table Settings data to save
function script_save(data)
    log("Settings saved")

    -- Save custom presets
    PresetManager:persist(data)

    -- Save scene memory
    SceneMemory:persist(data)

    -- Save bookmarks
    BookmarkManager:persist(data)

    -- Save hotkey bindings
    save_hotkeys(data)

    -- Save bookmark hotkeys
    BookmarkManager:save_hotkeys(data)
end

--[[ Called to create the properties UI
--[[ @return obs.obs_properties_t Properties object
function script_properties()
    local props = obs.obs_properties_create()

    --==========================
    -- QUICK SETUP (always expanded)
    --==========================
    local grp_quick = obs.obs_properties_create()

    -- Source dropdown
    local src_list = obs.obs_properties_add_list(grp_quick, "source", "Zoom Source",
        obs.OBS_COMBO_TYPE_LIST, obs.OBS_COMBO_FORMAT_STRING)
    obs.obs_property_list_add_string(src_list, "-- Select Source --", "")

    -- Populate with available capture sources
    local sources = source_manager_get_available_sources()
    for _, src in ipairs(sources) do
        obs.obs_property_list_add_string(src_list, src.name, src.name)
    end

    -- Zoom Factor
    obs.obs_properties_add_float_slider(grp_quick, "zoom_value", "Zoom Factor", 1.0, 10.0, 0.1)

    -- Duration
    obs.obs_properties_add_float_slider(grp_quick, "zoom_duration", "Duration (s)", 0.05, 3.0, 0.05)

    obs.obs_properties_add_group(props, "quick_setup", "Ã¢Å¡Â¡ Quick Setup", obs.OBS_GROUP_NORMAL, grp_quick)

    --==========================
    -- ANIMATION (collapsed)
    --==========================
    local grp_anim = obs.obs_properties_create()

    -- Overshoot/Bounce
    obs.obs_properties_add_float_slider(grp_anim, "zoom_overshoot", "Bounce", 0.0, 1.0, 0.01)

    -- Easing Curve
    local p_easing = obs.obs_properties_add_list(grp_anim, "zoom_easing", "Easing Curve",
        obs.OBS_COMBO_TYPE_LIST, obs.OBS_COMBO_FORMAT_STRING)
    for _, name in ipairs(Easing.NAMES) do
        obs.obs_property_list_add_string(p_easing, name, name)
    end

    obs.obs_properties_add_group(props, "animation", "Ã°Å¸Å½Â¬ Animation", obs.OBS_GROUP_NORMAL, grp_anim)

    --==========================
    -- MOUSE FOLLOW (collapsed)
    --==========================
    local grp_follow = obs.obs_properties_create()

    obs.obs_properties_add_bool(grp_follow, "auto_follow", "Auto-Follow Mouse")
    obs.obs_properties_add_float_slider(grp_follow, "follow_smooth_time", "Smoothness", 0.01, 1.0, 0.01)
    obs.obs_properties_add_int_slider(grp_follow, "follow_dead_zone", "Dead Zone (px)", 0, 500, 1)

    obs.obs_properties_add_group(props, "follow", "Ã°Å¸Å½Â¯ Mouse Follow", obs.OBS_GROUP_NORMAL, grp_follow)

    --==========================
    -- ADVANCED (collapsed)
    --==========================
    local grp_adv = obs.obs_properties_create()
    obs.obs_properties_add_float_slider(grp_adv, "scroll_step", "Scroll Zoom Step", 0.1, 1.0, 0.05)
    obs.obs_properties_add_bool(grp_adv, "debug_logs", "Debug Logging")
    obs.obs_properties_add_group(props, "advanced", "Ã¢Å¡â„¢Ã¯Â¸Â Advanced", obs.OBS_GROUP_NORMAL, grp_adv)

    --==========================
    -- API SERVER (collapsed)
    --==========================
    local grp_api = obs.obs_properties_create()
    obs.obs_properties_add_bool(grp_api, "api_enabled", "Enable UDP API Server")
    obs.obs_properties_add_int(grp_api, "api_port", "API Port", 1024, 65535, 1)
    obs.obs_properties_add_group(props, "api_server", "Ã°Å¸Å’Â UDP API Server", obs.OBS_GROUP_NORMAL, grp_api)

    --==========================
    -- HELP (collapsed)
    --==========================
    local grp_help = obs.obs_properties_create()
    obs.obs_properties_add_text(grp_help, "help_text",
        "QUICK START:\n" ..
        "1. Select your capture source above\n" ..
        "2. Set hotkeys in OBS Settings Ã¢â€ â€™ Hotkeys\n" ..
        "   Ã¢â‚¬Â¢ 'Toggle Zoom to Mouse' Ã¢â‚¬â€ Main zoom\n" ..
        "   Ã¢â‚¬Â¢ 'Toggle Mouse Follow' Ã¢â‚¬â€ Enable/disable follow\n" ..
        "3. Press the hotkey to zoom!\n\n" ..
        "TIPS:\n" ..
        "Ã¢â‚¬Â¢ Zoom centers on mouse position\n" ..
        "Ã¢â‚¬Â¢ Enable Auto-Follow for smooth tracking\n" ..
        "Ã¢â‚¬Â¢ Adjust Dead Zone to reduce jitter",
        obs.OBS_TEXT_INFO)
    obs.obs_properties_add_group(props, "help", "Ã¢Ââ€œ Help", obs.OBS_GROUP_NORMAL, grp_help)

    return props
end

--[[ Called to set default values
--[[ @param data table Settings data
function script_defaults(data)
    obs.obs_data_set_default_string(data, "source", "")
    obs.obs_data_set_default_double(data, "zoom_value", 2.0)
    obs.obs_data_set_default_double(data, "zoom_duration", 0.6)
    obs.obs_data_set_default_double(data, "zoom_overshoot", 0.0)
    obs.obs_data_set_default_string(data, "zoom_easing", "Cubic.Out")
    obs.obs_data_set_default_bool(data, "auto_follow", true)
    obs.obs_data_set_default_double(data, "follow_smooth_time", 0.15)
    obs.obs_data_set_default_int(data, "follow_dead_zone", 5)
    obs.obs_data_set_default_double(data, "scroll_step", 0.25)
    obs.obs_data_set_default_bool(data, "debug_logs", false)
    obs.obs_data_set_default_bool(data, "api_enabled", false)
    obs.obs_data_set_default_int(data, "api_port", 12345)
end

--================================================
-- SCRIPT METADATA
--================================================
script_info = {
    name = "OBS Zoom Pro",
    version = VERSION,
    description = "Intelligent camera zoom functionality with smooth transitions and easing curves.",
    author = "OBS Zoom Pro Team"
}
)
        handle:close()
        if uname == 'Darwin' then
            is_macos = true
            is_linux = false
        end
    end

    return {
        WINDOWS = is_windows,
        LINUX = is_linux,
        MACOS = is_macos
    }
end

local platform = detect_platform()
local IS_WINDOWS = platform.WINDOWS
local IS_LINUX = platform.LINUX
local IS_MACOS = platform.MACOS

-- Log platform detection
log("Platform detected: " .. (jit and jit.os or "Unknown") .. (IS_WINDOWS and " (Full support)" or " (Basic support)"))

-- Virtual key codes (Lua constants instead of C #define)
local VK_LBUTTON = 0x01
local VK_RBUTTON = 0x02
local VK_MBUTTON = 0x04
local VK_CONTROL = 0x11
local VK_SHIFT = 0x10
local VK_MENU = 0x12  -- Alt

-- FFI declarations for Windows (only if FFI is available)


-- Cursor shape constants (Windows)
local CURSOR_ARROW = 1
local CURSOR_IBEAM = 2
local CURSOR_HAND = 3
local CURSOR_WAIT = 4

-- Module state
local Platform = {
    cursor_shape_available = IS_WINDOWS,
    last_mouse = { x = 0, y = 0 },
    last_click = false,
}

-- Get mouse position (cross-platform)
function Platform.get_mouse_pos()
    if IS_WINDOWS then
        local success, pt = pcall(function()
            local pt = ffi.new("POINT")
            if ffi.C.GetCursorPos(pt) ~= 0 then
                return { x = tonumber(pt.x), y = tonumber(pt.y) }
            end
            return nil
        end)
        if success and pt then
            return pt
        end
    elseif IS_LINUX then
        -- Linux: Use xdotool if available, fallback to X11
        local success, result = pcall(function()
            local handle = io.popen("xdotool getmouselocation 2>/dev/null || echo 'x:0 y:0'")
            if handle then
                local output = handle:read("*a")
                handle:close()
                local x, y = output:match("x:(%d+)%s+y:(%d+)")
                if x and y then
                    return { x = tonumber(x), y = tonumber(y) }
                end
            end
            return nil
        end)
        if success and result then
            return result
        end
    elseif IS_MACOS then
        -- macOS: Use osascript
        local success, result = pcall(function()
            local handle = io.popen(--[[osascript -e 'tell application "System Events" to get position of the mouse' 2>/dev/null || echo "0, 0"]])
            if handle then
                local output = handle:read("*a")
                handle:close()
                local x, y = output:match("(%d+),%s*(%d+)")
                if x and y then
                    return { x = tonumber(x), y = tonumber(y) }
                end
            end
            return nil
        end)
        if success and result then
            return result
        end
    end

    -- Fallback
    return { x = 0, y = 0 }
end

-- Check if left mouse button is clicked (Windows only, others return false)
function Platform.is_clicking()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x01) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if a modifier key is held (Windows only)
function Platform.is_key_held(vk_code)
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(vk_code) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if cursor is a pointer/hand (Windows only)
function Platform.is_cursor_pointer()
    if IS_WINDOWS then
        local success, result = pcall(function()
            local ci = ffi.new("CURSORINFO")
            ci.cbSize = ffi.sizeof("CURSORINFO")
            if ffi.C.GetCursorInfo(ci) ~= 0 then
                -- Check if hCursor is a hand pointer
                -- This is a simplified check; real implementation would compare cursor handles
                return ci.flags ~= 0  -- Simplified; actual implementation needs cursor handle comparison
            end
            return false
        end)
        return success and result or false
    end
    return false
end

-- Get cursor shape (Windows only, returns "arrow" for others)
function Platform.get_cursor_shape()
    if IS_WINDOWS then
        local success, result = pcall(function()
            local ci = ffi.new("CURSORINFO")
            ci.cbSize = ffi.sizeof("CURSORINFO")
            if ffi.C.GetCursorInfo(ci) ~= 0 and ci.hCursor ~= nil then
                local addr = tonumber(ffi.cast("uintptr_t", ci.hCursor))
                -- Common cursor IDs (these are typical values, may vary)
                -- IDC_ARROW = 32512, IDC_IBEAM = 32513, IDC_HAND = 32649
                -- We use address ranges as heuristic
                return "arrow"  -- Simplified; actual implementation would map handles
            end
            return "arrow"
        end)
        return success and result or "arrow"
    end
    return "arrow"
end

-- Check if Control key is held
function Platform.is_ctrl_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x11) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if Shift key is held
function Platform.is_shift_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x10) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if Alt key is held
function Platform.is_alt_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x12) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Convenience wrapper functions
function platform_get_mouse_pos()
    return Platform.get_mouse_pos()
end

function platform_is_clicking()
    return Platform.is_clicking()
end

function platform_is_cursor_pointer()
    return Platform.is_cursor_pointer()
end

function platform_cursor_shape_available()
    return Platform.cursor_shape_available
end

function platform_is_ctrl_held()
    return Platform.is_ctrl_held()
end

function platform_is_shift_held()
    return Platform.is_shift_held()
end

function platform_is_alt_held()
    return Platform.is_alt_held()
end

--================================================
-- MODULE: State Machine (M05)
--================================================
-- Manages zoom states and transitions
-- States: IDLE, ZOOMING_IN, ZOOMED_IN, ZOOMING_OUT, SCROLLING, JUMPING

local ZoomState = {
    IDLE         = "idle",
    ZOOMING_IN   = "zooming_in",
    ZOOMED_IN    = "zoomed_in",
    ZOOMING_OUT  = "zooming_out",
    SCROLLING    = "scrolling",    -- Scroll wheel mid-transition
    JUMPING      = "jumping",      -- Bookmark transition
}

local StateMachine = {
    state = ZoomState.IDLE,
    zoom_time = 0,          -- Animation progress (0 Ã¢â€ â€™ 1)
    zoom_level = 1.0,       -- Current zoom factor
    target_level = 1.0,     -- Target zoom factor
    start_crop = nil,       -- Crop at animation start {x, y, w, h}
    target_crop = nil,      -- Crop at animation end {x, y, w, h}
    following = false,      -- Mouse follow active

    -- Transition guards
    can_zoom_in = function(self)
        return self.state == ZoomState.IDLE
    end,

    can_zoom_out = function(self)
        return self.state == ZoomState.ZOOMED_IN
            or self.state == ZoomState.SCROLLING
    end,

    can_scroll = function(self)
        return self.state == ZoomState.ZOOMED_IN
            or self.state == ZoomState.IDLE
            or self.state == ZoomState.SCROLLING
    end,

    can_jump = function(self)
        return self.state ~= ZoomState.ZOOMING_IN
           and self.state ~= ZoomState.ZOOMING_OUT
           and self.state ~= ZoomState.JUMPING
    end,

    is_animating = function(self)
        return self.state == ZoomState.ZOOMING_IN
            or self.state == ZoomState.ZOOMING_OUT
            or self.state == ZoomState.SCROLLING
            or self.state == ZoomState.JUMPING
    end,

    is_zoomed = function(self)
        return self.state ~= ZoomState.IDLE
    end,
}

-- Transition to a new state
function StateMachine:transition(new_state, params)
    local old = self.state
    self.state = new_state
    self.zoom_time = 0

    if params then
        if params.start_crop then self.start_crop = params.start_crop end
        if params.target_crop then self.target_crop = params.target_crop end
        if params.target_level then self.target_level = params.target_level end
    end

    log("State: " .. old .. " Ã¢â€ â€™ " .. new_state)
end

-- Complete the current animation
function StateMachine:complete()
    if self.state == ZoomState.ZOOMING_IN
       or self.state == ZoomState.SCROLLING
       or self.state == ZoomState.JUMPING then
        self.zoom_level = self.target_level
        self.state = ZoomState.ZOOMED_IN
        self.zoom_time = 0
        log("State: " .. self.state .. " Ã¢â€ â€™ ZOOMED_IN (complete)")
    elseif self.state == ZoomState.ZOOMING_OUT then
        self.zoom_level = 1.0
        self.target_level = 1.0
        self.start_crop = nil
        self.target_crop = nil
        self.following = false
        self.state = ZoomState.IDLE
        self.zoom_time = 0
        log("State: ZOOMING_OUT Ã¢â€ â€™ IDLE (complete)")
    end
end

-- Reset to initial state
function StateMachine:reset()
    self.state = ZoomState.IDLE
    self.zoom_time = 0
    self.zoom_level = 1.0
    self.target_level = 1.0
    self.start_crop = nil
    self.target_crop = nil
    self.following = false
    log("StateMachine: Reset to IDLE")
end

-- Get current animation progress (0-1)
function StateMachine:get_progress()
    return clamp(0, 1, self.zoom_time)
end

-- Check if in a specific state
function StateMachine:is_state(state)
    return self.state == state
end

-- Get state name for display
function StateMachine:get_state_name()
    return self.state
end

-- Create a new state machine instance (for testing/isolation)
function StateMachine:new()
    local sm = {}
    setmetatable(sm, { __index = self })
    sm.state = ZoomState.IDLE
    sm.zoom_time = 0
    sm.zoom_level = 1.0
    sm.target_level = 1.0
    sm.start_crop = nil
    sm.target_crop = nil
    sm.following = false
    return sm
end

-- Global state machine instance
local SM = StateMachine:new()

--================================================
-- MODULE: Crop Filter Manager (M07)
--================================================
-- Manages the crop/pad filter used to simulate zoom
-- Creates, updates, and destroys the filter automatically

local FILTER_PREFIX = "[ZoomPro] "
local CROP_FILTER_NAME = FILTER_PREFIX .. "Crop"

local CropFilterManager = {
    filter = nil,           -- The crop filter source
    source = nil,           -- The parent source
    original_crop = nil,    -- Original crop values for restoration
    current_crop = { x = 0, y = 0, w = 0, h = 0 },
    initialized = false,
}

-- Create the crop filter on a source
function CropFilterManager:create(source)
    if not source then
        log("CropFilter: No source provided")
        return false
    end

    self:cleanup()  -- Clean up any existing filter
    self.source = source

    -- Check if our filter already exists
    local existing = obs.obs_source_get_filter_by_name(source, CROP_FILTER_NAME)
    if existing then
        log("CropFilter: Found existing filter")
        self.filter = existing
        self.initialized = true
        return true
    end

    -- Create new crop/pad filter
    local settings = obs.obs_data_create()
    obs.obs_data_set_int(settings, "left", 0)
    obs.obs_data_set_int(settings, "top", 0)
    obs.obs_data_set_int(settings, "right", 0)
    obs.obs_data_set_int(settings, "bottom", 0)
    obs.obs_data_set_bool(settings, "relative", false)  -- Absolute positioning

    self.filter = obs.obs_source_create_private(
        "crop_filter",      -- Filter type
        CROP_FILTER_NAME,   -- Filter name
        settings            -- Settings
    )

    obs.obs_data_release(settings)

    if not self.filter then
        log("CropFilter: Failed to create filter")
        return false
    end

    -- Add filter to source
    obs.obs_source_filter_add(source, self.filter)

    -- Store original crop (none)
    self.original_crop = { x = 0, y = 0, w = 0, h = 0 }

    self.initialized = true
    log("CropFilter: Created successfully")
    return true
end

-- Update the crop filter with new values
function CropFilterManager:update(x, y, w, h)
    if not self.filter or not self.initialized then
        return false
    end

    -- Store current crop
    self.current_crop = { x = x, y = y, w = w, h = h }

    -- Get filter settings
    local settings = obs.obs_source_get_settings(self.filter)
    if not settings then
        return false
    end

    -- Calculate crop values
    -- For crop_filter: left, top are absolute position
    -- right, bottom are width/height from right/bottom edge
    -- We need to convert our x, y, w, h to this format

    -- Get source dimensions
    local source_w = obs.obs_source_get_width(self.source)
    local source_h = obs.obs_source_get_height(self.source)

    if source_w == 0 or source_h == 0 then
        obs.obs_data_release(settings)
        return false
    end

    -- Set crop values
    -- left = x offset from left
    -- top = y offset from top
    -- right = source_w - (x + w) = remaining width on right
    -- bottom = source_h - (y + h) = remaining height on bottom
    local left = math.floor(x)
    local top = math.floor(y)
    local right = math.floor(source_w - (x + w))
    local bottom = math.floor(source_h - (y + h))

    -- Clamp to valid values
    left = math.max(0, left)
    top = math.max(0, top)
    right = math.max(0, right)
    bottom = math.max(0, bottom)

    obs.obs_data_set_int(settings, "left", left)
    obs.obs_data_set_int(settings, "top", top)
    obs.obs_data_set_int(settings, "right", right)
    obs.obs_data_set_int(settings, "bottom", bottom)

    -- Update the filter
    obs.obs_source_update(self.filter, settings)
    obs.obs_data_release(settings)

    return true
end

-- Get current crop values
function CropFilterManager:get_crop()
    return self.current_crop
end

-- Reset crop to original (no crop)
function CropFilterManager:reset()
    if not self.filter or not self.initialized then
        return false
    end

    local settings = obs.obs_source_get_settings(self.filter)
    if settings then
        obs.obs_data_set_int(settings, "left", 0)
        obs.obs_data_set_int(settings, "top", 0)
        obs.obs_data_set_int(settings, "right", 0)
        obs.obs_data_set_int(settings, "bottom", 0)
        obs.obs_source_update(self.filter, settings)
        obs.obs_data_release(settings)
    end

    self.current_crop = { x = 0, y = 0, w = 0, h = 0 }
    return true
end

-- Remove the filter and restore original state
function CropFilterManager:cleanup()
    if self.filter and self.source then
        -- Reset to no crop first
        self:reset()

        -- Remove filter from source
        obs.obs_source_filter_remove(self.source, self.filter)
        obs.obs_source_release(self.filter)
        self.filter = nil
        log("CropFilter: Removed from source")
    end

    self.source = nil
    self.original_crop = nil
    self.current_crop = { x = 0, y = 0, w = 0, h = 0 }
    self.initialized = false
end

-- Check if filter is ready
function CropFilterManager:is_ready()
    return self.initialized and self.filter ~= nil
end

-- Get source dimensions
function CropFilterManager:get_source_size()
    if not self.source then
        return 0, 0
    end
    return obs.obs_source_get_width(self.source), obs.obs_source_get_height(self.source)
end

-- Convenience wrapper functions
function crop_filter_create(source)
    return CropFilterManager:create(source)
end

function crop_filter_update(x, y, w, h)
    return CropFilterManager:update(x, y, w, h)
end

function crop_filter_reset()
    return CropFilterManager:reset()
end

function crop_filter_cleanup()
    return CropFilterManager:cleanup()
end

function crop_filter_is_ready()
    return CropFilterManager:is_ready()
end

function crop_filter_get_crop()
    return CropFilterManager:get_crop()
end

function crop_filter_get_source_size()
    return CropFilterManager:get_source_size()
end

--================================================
-- MODULE: Source Manager (M08)
--================================================
-- Handles finding sources in scenes, capturing transforms,
-- and managing source state for zoom operations

local SourceManager = {
    source = nil,           -- Current zoom source
    sceneitem = nil,        -- Scene item reference
    scene = nil,            -- Current scene
    original_transform = nil, -- Saved original transform
    source_name = "",       -- Source name for settings
    initialized = false,
}

-- Transform data structure
local TransformData = {
    pos = { x = 0, y = 0 },
    scale = { x = 1.0, y = 1.0 },
    rot = 0,
    bounds_type = 0,
    bounds = { x = 0, y = 0 },
    crop = { left = 0, top = 0, right = 0, bottom = 0 },
}

-- Find a source in a scene (BFS through groups)
function SourceManager:find_sceneitem(scene, source_name)
    if not scene or not source_name then
        return nil
    end

    local scene_source = obs.obs_scene_from_source(scene)
    if not scene_source then
        return nil
    end

    -- BFS queue
    local queue = {}
    table.insert(queue, scene_source)

    while #queue > 0 do
        local current_scene = table.remove(queue, 1)

        -- Iterate through items
        local items = obs.obs_scene_enum_items(current_scene)
        if items then
            for _, item in ipairs(items) do
                local item_source = obs.obs_sceneitem_get_source(item)
                if item_source then
                    local name = obs.obs_source_get_name(item_source)

                    -- Check if this is our target
                    if name == source_name then
                        obs.sceneitem_list_release(items)
                        return item
                    end

                    -- Check if this is a group (nested scene)
                    if obs.obs_source_get_type(item_source) == obs.OBS_SOURCE_TYPE_INPUT then
                        local id = obs.obs_source_get_id(item_source)
                        if id == "group" then
                            local group_scene = obs.obs_group_from_source(item_source)
                            if group_scene then
                                table.insert(queue, group_scene)
                            end
                        end
                    end
                end
            end
            obs.sceneitem_list_release(items)
        end
    end

    return nil
end

-- Capture the current transform of a scene item
function SourceManager:capture_transform(sceneitem)
    if not sceneitem then
        return nil
    end

    local transform = {}

    -- Position
    local pos = obs.vec2()
    obs.obs_sceneitem_get_pos(sceneitem, pos)
    transform.pos = { x = pos.x, y = pos.y }

    -- Scale
    local scale = obs.vec2()
    obs.obs_sceneitem_get_scale(sceneitem, scale)
    transform.scale = { x = scale.x, y = scale.y }

    -- Rotation
    transform.rot = obs.obs_sceneitem_get_rot(sceneitem)

    -- Bounds
    transform.bounds_type = obs.obs_sceneitem_get_bounds_type(sceneitem)
    local bounds = obs.vec2()
    obs.obs_sceneitem_get_bounds(sceneitem, bounds)
    transform.bounds = { x = bounds.x, y = bounds.y }

    -- Crop
    local crop = obs.obs_sceneitem_crop()
    obs.obs_sceneitem_get_crop(sceneitem, crop)
    transform.crop = {
        left = crop.left,
        top = crop.top,
        right = crop.right,
        bottom = crop.bottom
    }

    return transform
end

-- Restore a saved transform to a scene item
function SourceManager:restore_transform(sceneitem, transform)
    if not sceneitem or not transform then
        return false
    end

    -- Position
    local pos = obs.vec2()
    pos.x = transform.pos.x
    pos.y = transform.pos.y
    obs.obs_sceneitem_set_pos(sceneitem, pos)

    -- Scale
    local scale = obs.vec2()
    scale.x = transform.scale.x
    scale.y = transform.scale.y
    obs.obs_sceneitem_set_scale(sceneitem, scale)

    -- Rotation
    obs.obs_sceneitem_set_rot(sceneitem, transform.rot)

    -- Bounds
    obs.obs_sceneitem_set_bounds_type(sceneitem, transform.bounds_type)
    local bounds = obs.vec2()
    bounds.x = transform.bounds.x
    bounds.y = transform.bounds.y
    obs.obs_sceneitem_set_bounds(sceneitem, bounds)

    -- Crop
    local crop = obs.obs_sceneitem_crop()
    crop.left = transform.crop.left
    crop.top = transform.crop.top
    crop.right = transform.crop.right
    crop.bottom = transform.crop.bottom
    obs.obs_sceneitem_set_crop(sceneitem, crop)

    return true
end

-- Initialize with a source name
function SourceManager:init(source_name)
    self:release()  -- Clean up any existing state

    if not source_name or source_name == "" then
        log("SourceManager: No source name provided")
        return false
    end

    self.source_name = source_name

    -- Get current scene
    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then
        log("SourceManager: No current scene")
        return false
    end

    self.scene = scene_source

    -- Find the scene item
    self.sceneitem = self:find_sceneitem(scene_source, source_name)
    if not self.sceneitem then
        log("SourceManager: Source not found in scene: " .. source_name)
        obs.obs_source_release(scene_source)
        return false
    end

    -- Get the source
    self.source = obs.obs_sceneitem_get_source(self.sceneitem)
    if not self.source then
        log("SourceManager: Failed to get source from sceneitem")
        obs.obs_source_release(scene_source)
        return false
    end

    -- Capture original transform
    self.original_transform = self:capture_transform(self.sceneitem)

    -- Create crop filter
    if not crop_filter_create(self.source) then
        log("SourceManager: Failed to create crop filter")
        obs.obs_source_release(scene_source)
        return false
    end

    self.initialized = true
    log("SourceManager: Initialized with source: " .. source_name)

    obs.obs_source_release(scene_source)
    return true
end

-- Release all resources
function SourceManager:release()
    -- Clean up crop filter
    crop_filter_cleanup()

    -- Restore original transform if we have it
    if self.sceneitem and self.original_transform then
        self:restore_transform(self.sceneitem, self.original_transform)
        log("SourceManager: Restored original transform")
    end

    self.source = nil
    self.sceneitem = nil
    self.scene = nil
    self.original_transform = nil
    self.initialized = false

    log("SourceManager: Released")
end

-- Get source dimensions
function SourceManager:get_source_size()
    if not self.source then
        return 0, 0
    end
    return obs.obs_source_get_width(self.source), obs.obs_source_get_height(self.source)
end

-- Check if source is valid
function SourceManager:is_valid()
    return self.initialized and self.source ~= nil and self.sceneitem ~= nil
end

-- Get source info
function SourceManager:get_info()
    if not self:is_valid() then
        return nil
    end

    return {
        name = self.source_name,
        width = obs.obs_source_get_width(self.source),
        height = obs.obs_source_get_height(self.source),
    }
end

-- Get list of available capture sources
function SourceManager.get_available_sources()
    local sources = {}

    -- Get all sources
    local source_list = obs.obs_enum_sources()
    if source_list then
        for _, source in ipairs(source_list) do
            local source_id = obs.obs_source_get_id(source)
            local name = obs.obs_source_get_name(source)

            -- Filter for capture sources
            local is_capture = false
            if source_id == "monitor_capture" or      -- Display capture
               source_id == "window_capture" or       -- Window capture
               source_id == "game_capture" or         -- Game capture
               source_id == "xshm_input" or           -- Linux X11 capture
               source_id == "av_capture_input" then   -- macOS capture
                is_capture = true
            end

            if is_capture then
                table.insert(sources, {
                    name = name,
                    id = source_id,
                })
            end
        end
        obs.source_list_release(source_list)
    end

    return sources
end

-- Convenience wrapper functions
function source_manager_init(source_name)
    return SourceManager:init(source_name)
end

function source_manager_release()
    return SourceManager:release()
end

function source_manager_is_valid()
    return SourceManager:is_valid()
end

function source_manager_get_source()
    return SourceManager.source
end

function source_manager_get_sceneitem()
    return SourceManager.sceneitem
end

function source_manager_get_size()
    return SourceManager:get_source_size()
end

function source_manager_get_available_sources()
    return SourceManager.get_available_sources()
end

--================================================
-- MODULE: Camera Physics (M06)
--================================================
-- Handles camera position calculations, dead zones,
-- and SmoothDamp-based camera movement

local CameraPhysics = {
    -- Smoothed camera position
    pos = { x = 0, y = 0 },

    -- Velocities for SmoothDamp
    vel_x = { val = 0 },
    vel_y = { val = 0 },

    -- Dead zone state
    tracked_pos = { x = 0, y = 0 },
    dead_zone_active = false,

    -- Last camera position (for velocity calculation)
    last_pos = { x = 0, y = 0 },

    -- Monitor offset (for multi-monitor setups)
    monitor_offset = { x = 0, y = 0 },
}

-- Initialize camera tracking with starting position
function CameraPhysics:init(mouse_pos)
    if mouse_pos then
        self.pos.x = mouse_pos.x
        self.pos.y = mouse_pos.y
        self.tracked_pos.x = mouse_pos.x
        self.tracked_pos.y = mouse_pos.y
    end
    self.vel_x.val = 0
    self.vel_y.val = 0
    self.last_pos.x = self.pos.x
    self.last_pos.y = self.pos.y
end

-- Apply dead zone to mouse input
-- Returns the position the camera should track
function CameraPhysics:apply_dead_zone(mouse_pos, dead_zone_radius)
    if not mouse_pos then
        return self.tracked_pos
    end

    if dead_zone_radius <= 0 then
        self.tracked_pos.x = mouse_pos.x
        self.tracked_pos.y = mouse_pos.y
        return self.tracked_pos
    end

    -- Calculate distance from tracked position to mouse
    local dx = mouse_pos.x - self.tracked_pos.x
    local dy = mouse_pos.y - self.tracked_pos.y
    local dist = math.sqrt(dx * dx + dy * dy)

    if dist <= dead_zone_radius then
        -- Mouse is within dead zone, don't move tracked position
        self.dead_zone_active = true
        return self.tracked_pos
    end

    -- Mouse is outside dead zone
    -- Move tracked position so it stays exactly dead_zone_radius from mouse
    self.dead_zone_active = false
    local excess = dist - dead_zone_radius
    local nx = dx / dist  -- Normalized direction
    local ny = dy / dist

    self.tracked_pos.x = self.tracked_pos.x + nx * excess
    self.tracked_pos.y = self.tracked_pos.y + ny * excess

    return self.tracked_pos
end

-- Smooth the input position using SmoothDamp
function CameraPhysics:smooth_input(target_pos, smooth_time, dt)
    if not target_pos then
        return self.pos
    end

    local max_speed = 100000  -- Very high max speed for smooth camera

    self.pos.x = SmoothDamp(self.pos.x, target_pos.x, self.vel_x, smooth_time, max_speed, dt)
    self.pos.y = SmoothDamp(self.pos.y, target_pos.y, self.vel_y, smooth_time, max_speed, dt)

    return self.pos
end

-- Calculate the crop rectangle for a given zoom level and center position
function CameraPhysics:compute_crop(center_x, center_y, zoom_level, source_w, source_h)
    if zoom_level <= 1.0 then
        -- No zoom, return full source
        return {
            x = 0,
            y = 0,
            w = source_w,
            h = source_h,
        }
    end

    -- Calculate crop dimensions
    local crop_w = source_w / zoom_level
    local crop_h = source_h / zoom_level

    -- Center the crop on the target position
    local crop_x = center_x - crop_w / 2
    local crop_y = center_y - crop_h / 2

    -- Clamp to source bounds
    crop_x = clamp(0, source_w - crop_w, crop_x)
    crop_y = clamp(0, source_h - crop_h, crop_y)

    return {
        x = crop_x,
        y = crop_y,
        w = crop_w,
        h = crop_h,
    }
end

-- Calculate target crop for zoom animation
-- mouse_pos: current mouse position
-- zoom_level: target zoom level
-- source_w, source_h: source dimensions
-- monitor_offset: offset for multi-monitor (optional)
function CameraPhysics:get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
    if not mouse_pos then
        return nil
    end

    -- Apply monitor offset if provided
    local target_x = mouse_pos.x
    local target_y = mouse_pos.y

    if monitor_offset then
        target_x = target_x - monitor_offset.x
        target_y = target_y - monitor_offset.y
    end

    -- Clamp to source bounds
    target_x = clamp(0, source_w, target_x)
    target_y = clamp(0, source_h, target_y)

    return self:compute_crop(target_x, target_y, zoom_level, source_w, source_h)
end

-- Interpolate between two crop rectangles
function CameraPhysics:lerp_crop(start_crop, end_crop, t, easing_fn)
    if not start_crop or not end_crop then
        return nil
    end

    t = clamp(0, 1, t)

    -- Apply easing
    local eased_t = easing_fn and easing_fn(t) or t

    return {
        x = lerp(start_crop.x, end_crop.x, eased_t),
        y = lerp(start_crop.y, end_crop.y, eased_t),
        w = lerp(start_crop.w, end_crop.w, eased_t),
        h = lerp(start_crop.h, end_crop.h, eased_t),
    }
end

-- Get camera velocity (for motion blur)
function CameraPhysics:get_velocity()
    return {
        x = self.pos.x - self.last_pos.x,
        y = self.pos.y - self.last_pos.y,
    }
end

-- Update last position (call at end of frame)
function CameraPhysics:update_last_pos()
    self.last_pos.x = self.pos.x
    self.last_pos.y = self.pos.y
end

-- Set monitor offset
function CameraPhysics:set_monitor_offset(offset)
    self.monitor_offset = offset or { x = 0, y = 0 }
end

-- Reset camera state
function CameraPhysics:reset()
    self.pos = { x = 0, y = 0 }
    self.vel_x = { val = 0 }
    self.vel_y = { val = 0 }
    self.tracked_pos = { x = 0, y = 0 }
    self.dead_zone_active = false
    self.last_pos = { x = 0, y = 0 }
end

-- Convenience wrapper functions
function camera_physics_init(mouse_pos)
    return CameraPhysics:init(mouse_pos)
end

function camera_physics_apply_dead_zone(mouse_pos, dead_zone_radius)
    return CameraPhysics:apply_dead_zone(mouse_pos, dead_zone_radius)
end

function camera_physics_smooth_input(target_pos, smooth_time, dt)
    return CameraPhysics:smooth_input(target_pos, smooth_time, dt)
end

function camera_physics_compute_crop(center_x, center_y, zoom_level, source_w, source_h)
    return CameraPhysics:compute_crop(center_x, center_y, zoom_level, source_w, source_h)
end

function camera_physics_get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
    return CameraPhysics:get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
end

function camera_physics_lerp_crop(start_crop, end_crop, t, easing_fn)
    return CameraPhysics:lerp_crop(start_crop, end_crop, t, easing_fn)
end

function camera_physics_get_velocity()
    return CameraPhysics:get_velocity()
end

function camera_physics_update_last_pos()
    return CameraPhysics:update_last_pos()
end

function camera_physics_reset()
    return CameraPhysics:reset()
end

--================================================
-- MODULE: Timer & Main Loop (M09)
--================================================
-- Core integration module that handles frame-by-frame updates,
-- input processing, state machine updates, and output

-- Configuration (will be populated from settings)
local cfg = {
    source_name = "",
    zoom_value = 2.0,
    max_zoom = 10.0,
    zoom_duration = 0.6,
    zoom_overshoot = 0.0,
    zoom_easing = "Cubic.Out",

    auto_follow = true,
    follow_smooth_time = 0.15,
    follow_dead_zone = 5,

    debug_logs = false,
}

-- Timing
local last_tick_time = 0
local timer_running = false

-- Frame diff tracking (skip updates if nothing changed)
local last_output = { x = -1, y = -1, w = -1, h = -1 }

-- Original crop for zoom out
local original_crop = { x = 0, y = 0, w = 0, h = 0 }

-- Hotkey IDs
local hotkey_toggle_zoom = nil
local hotkey_toggle_follow = nil

-- Get reliable delta time
local function get_dt()
    local now = os.clock()
    local dt = now - last_tick_time
    last_tick_time = now
    return clamp(0.001, 0.1, dt)  -- Guard against freezes and div/zero
end

-- Start the timer
local function start_timer()
    if not timer_running then
        timer_running = true
        last_tick_time = os.clock()
        -- Use frame-synced interval
        local interval = 16  -- Default to ~60fps
        obs.timer_add(on_timer, interval)
        log("Timer: Started")
    end
end

-- Stop the timer
local function stop_timer()
    if timer_running then
        timer_running = false
        obs.timer_remove(on_timer)
        log("Timer: Stopped")
    end
end

-- Initialize mouse tracking
local function init_mouse_tracking(mouse_pos)
    camera_physics_init(mouse_pos)
    original_crop = {
        x = 0,
        y = 0,
        w = 0,
        h = 0,
    }
end

-- Main timer callback
function on_timer()
    local dt = get_dt()

    -- Guard: No valid source
    if not source_manager_is_valid() then
        return
    end

    --==========================
    -- 1. INPUT
    --==========================
    local raw_mouse = platform_get_mouse_pos()

    --==========================
    -- 2. STATE MACHINE UPDATE
    --==========================
    if SM:is_animating() then
        SM.zoom_time = SM.zoom_time + (dt / cfg.zoom_duration)

        -- Check for completion
        if SM.zoom_time >= 1.0 then
            SM:complete()

            -- Auto-enable follow after zoom in
            if SM.state == ZoomState.ZOOMED_IN and cfg.auto_follow then
                SM.following = true
            end

            -- Stop timer if idle
            if SM.state == ZoomState.IDLE then
                stop_timer()
            end
        end
    end

    --==========================
    -- 3. CAMERA POSITION
    --==========================
    local crop = nil
    local source_w, source_h = source_manager_get_size()

    if source_w == 0 or source_h == 0 then
        return
    end

    if SM:is_animating() then
        -- Animate between start and target crop
        local easing_fn = Easing.get(cfg.zoom_easing, cfg.zoom_overshoot)
        crop = camera_physics_lerp_crop(SM.start_crop, SM.target_crop, SM.zoom_time, easing_fn)
    elseif SM:is_zoomed() and SM.following then
        -- Follow mouse with dead zone and smoothing
        local tracked = camera_physics_apply_dead_zone(raw_mouse, cfg.follow_dead_zone)
        local smoothed = camera_physics_smooth_input(tracked, cfg.follow_smooth_time, dt)
        crop = camera_physics_compute_crop(smoothed.x, smoothed.y, SM.zoom_level, source_w, source_h)
        camera_physics_update_last_pos()
    elseif SM:is_zoomed() then
        -- Static zoom (not following)
        crop = camera_physics_get_target_crop(
            { x = SM.target_crop.x + SM.target_crop.w / 2, y = SM.target_crop.y + SM.target_crop.h / 2 },
            SM.zoom_level, source_w, source_h, nil
        )
    end

    --==========================
    -- 4. OUTPUT (Diff-based)
    --==========================
    if crop then
        local cx = math.floor(crop.x)
        local cy = math.floor(crop.y)
        local cw = math.floor(crop.w)
        local ch = math.floor(crop.h)

        if cx ~= last_output.x or cy ~= last_output.y or
           cw ~= last_output.w or ch ~= last_output.h then
            crop_filter_update(cx, cy, cw, ch)
            last_output.x = cx
            last_output.y = cy
            last_output.w = cw
            last_output.h = ch
        end
    end
end

--==========================
-- HOTKEY HANDLERS
--==========================

function on_toggle_zoom(pressed)
    if not pressed then return end

    if not source_manager_is_valid() then
        log("Toggle Zoom: No valid source")
        return
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        log("Toggle Zoom: Invalid source dimensions")
        return
    end

    if SM.state == ZoomState.IDLE then
        -- ZOOM IN
        local mouse = platform_get_mouse_pos()
        init_mouse_tracking(mouse)

        -- Store original crop
        original_crop = { x = 0, y = 0, w = source_w, h = source_h }

        -- Calculate target crop
        local target_crop = camera_physics_get_target_crop(mouse, cfg.zoom_value, source_w, source_h, nil)

        SM:transition(ZoomState.ZOOMING_IN, {
            start_crop = original_crop,
            target_crop = target_crop,
            target_level = cfg.zoom_value
        })

        start_timer()

    elseif SM.state == ZoomState.ZOOMED_IN then
        -- ZOOM OUT
        SM.following = false

        local current = crop_filter_get_crop()
        SM:transition(ZoomState.ZOOMING_OUT, {
            start_crop = current,
            target_crop = original_crop,
            target_level = 1.0
        })

        start_timer()
    end
    -- Ignore if already animating (guard against rapid presses)
end

function on_toggle_follow(pressed)
    if not pressed then return end
    if not SM:is_zoomed() then return end

    SM.following = not SM.following
    log("Follow: " .. tostring(SM.following))

    if SM.following and not timer_running then
        start_timer()
    end
end

--==========================
-- HOTKEY REGISTRATION
--==========================

local function register_hotkeys(settings)
    -- Toggle Zoom hotkey
    hotkey_toggle_zoom = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.toggle_zoom",
        "Toggle Zoom to Mouse",
        on_toggle_zoom
    )

    -- Toggle Follow hotkey
    hotkey_toggle_follow = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.toggle_follow",
        "Toggle Mouse Follow",
        on_toggle_follow
    )

    -- Load saved hotkey bindings
    local toggle_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.toggle_zoom")
    if toggle_array then
        obs.obs_hotkey_load(hotkey_toggle_zoom, toggle_array)
        obs.obs_data_array_release(toggle_array)
    end

    local follow_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.toggle_follow")
    if follow_array then
        obs.obs_hotkey_load(hotkey_toggle_follow, follow_array)
        obs.obs_data_array_release(follow_array)
    end

    -- Register scroll zoom hotkeys
    register_scroll_hotkeys(settings)

    log("Hotkeys: Registered")
end

local function save_hotkeys(settings)
    if hotkey_toggle_zoom then
        local array = obs.obs_hotkey_save(hotkey_toggle_zoom)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.toggle_zoom", array)
        obs.obs_data_array_release(array)
    end

    if hotkey_toggle_follow then
        local array = obs.obs_hotkey_save(hotkey_toggle_follow)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.toggle_follow", array)
        obs.obs_data_array_release(array)
    end

    -- Save scroll zoom hotkeys
    save_scroll_hotkeys(settings)
end

local function unregister_hotkeys()
    if hotkey_toggle_zoom then
        obs.obs_hotkey_unregister(hotkey_toggle_zoom)
        hotkey_toggle_zoom = nil
    end
    if hotkey_toggle_follow then
        obs.obs_hotkey_unregister(hotkey_toggle_follow)
        hotkey_toggle_follow = nil
    end
    -- Unregister scroll zoom hotkeys
    unregister_scroll_hotkeys()
    log("Hotkeys: Unregistered")
end

--==========================
-- SCENE EVENT HANDLERS
--==========================

function on_frontend_event(event)
    if event == obs.OBS_FRONTEND_EVENT_SCENE_CHANGED then
        -- Scene changed, re-acquire source
        log("Event: Scene changed")

        -- Handle scene memory
        scene_memory_on_scene_change()

        if cfg.source_name and cfg.source_name ~= "" then
            source_manager_release()
            source_manager_init(cfg.source_name)
        end
    elseif event == obs.OBS_FRONTEND_EVENT_EXIT then
        -- OBS is closing
        log("Event: OBS exiting")
        stop_timer()
        source_manager_release()
    end
end

--==========================
-- CONFIGURATION UPDATE
--==========================

local function update_config(settings)
    cfg.source_name = obs.obs_data_get_string(settings, "source") or ""
    cfg.zoom_value = obs.obs_data_get_double(settings, "zoom_value")
    cfg.zoom_duration = obs.obs_data_get_double(settings, "zoom_duration")
    cfg.zoom_overshoot = obs.obs_data_get_double(settings, "zoom_overshoot")
    cfg.zoom_easing = obs.obs_data_get_string(settings, "zoom_easing") or "Cubic.Out"

    cfg.auto_follow = obs.obs_data_get_bool(settings, "auto_follow")
    cfg.follow_smooth_time = obs.obs_data_get_double(settings, "follow_smooth_time")
    cfg.follow_dead_zone = obs.obs_data_get_int(settings, "follow_dead_zone")

    cfg.debug_logs = obs.obs_data_get_bool(settings, "debug_logs")
    debug_logs = cfg.debug_logs

    -- Update scroll zoom config
    update_scroll_config(settings)

    -- Check if source changed
    local current_source = source_manager_is_valid() and cfg.source_name
    if cfg.source_name ~= "" and cfg.source_name ~= current_source then
        -- Reset state and reinitialize
        SM:reset()
        stop_timer()
        source_manager_release()
        source_manager_init(cfg.source_name)
    end
end

--================================================
-- MODULE: Scroll Zoom (M10)
--================================================
-- Enables gradual zoom control via scroll wheel with modifier key
-- Provides dynamic zoom level adjustment during zoomed state

local ScrollZoom = {
    -- Hotkey IDs for scroll zoom
    hotkey_scroll_up = nil,
    hotkey_scroll_down = nil,

    -- Configuration (populated from settings)
    scroll_step = 0.25,
    scroll_modifier = "ctrl",  -- "ctrl", "alt", "shift"
}

-- Check if modifier key is held
local function is_modifier_held()
    if ScrollZoom.scroll_modifier == "ctrl" then
        return platform_is_ctrl_held()
    elseif ScrollZoom.scroll_modifier == "alt" then
        return platform_is_alt_held()
    elseif ScrollZoom.scroll_modifier == "shift" then
        return platform_is_shift_held()
    end
    return false
end

-- Handle scroll zoom in
function on_scroll_zoom_up(pressed)
    if not pressed then return end
    on_scroll_zoom(1)
end

-- Handle scroll zoom out
function on_scroll_zoom_down(pressed)
    if not pressed then return end
    on_scroll_zoom(-1)
end

-- Main scroll zoom handler
function on_scroll_zoom(direction)
    -- Check if we can scroll
    if not SM:can_scroll() then return end

    -- Check modifier (optional - can be configured)
    -- For now, we rely on OBS hotkey bindings which can include modifiers

    if not source_manager_is_valid() then
        log("Scroll Zoom: No valid source")
        return
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        return
    end

    -- Calculate new zoom level
    local step = ScrollZoom.scroll_step * direction  -- e.g., 0.25
    local new_level

    if SM.state == ZoomState.IDLE then
        -- Starting from unzoomed
        new_level = 1.0 + step
    else
        -- Already zoomed, adjust level
        new_level = SM.target_level + step
    end

    -- Clamp to valid range
    new_level = clamp(1.0, cfg.max_zoom, new_level)

    -- If we hit 1.0, fully zoom out
    if new_level <= 1.0 then
        if SM:is_zoomed() then
            -- Trigger full zoom out
            local current = crop_filter_get_crop()
            SM.following = false
            SM:transition(ZoomState.ZOOMING_OUT, {
                start_crop = current,
                target_crop = original_crop,
                target_level = 1.0
            })
            start_timer()
        end
        return
    end

    -- Get current mouse position
    local mouse = platform_get_mouse_pos()

    -- Calculate new target crop for new zoom level
    local target_crop = camera_physics_get_target_crop(mouse, new_level, source_w, source_h, nil)

    -- Get current crop as start
    local start_crop
    if SM:is_animating() then
        -- Use current interpolated crop
        start_crop = crop_filter_get_crop()
    elseif SM:is_zoomed() then
        -- Use current crop
        start_crop = crop_filter_get_crop()
    else
        -- Starting from unzoomed
        start_crop = { x = 0, y = 0, w = source_w, h = source_h }
        original_crop = start_crop
        camera_physics_init(mouse)
    end

    -- Transition to new zoom level
    if SM.state == ZoomState.IDLE then
        -- First scroll from unzoomed
        SM:transition(ZoomState.SCROLLING, {
            start_crop = start_crop,
            target_crop = target_crop,
            target_level = new_level
        })
    else
        -- Already zoomed, adjust level (interrupt current animation)
        SM:transition(ZoomState.SCROLLING, {
            start_crop = start_crop,
            target_crop = target_crop,
            target_level = new_level
        })
    end

    start_timer()
    log("Scroll Zoom: Level " .. string.format("%.2f", new_level))
end

-- Zoom to a specific level (for API calls)
function on_scroll_zoom_to(level)
    if not source_manager_is_valid() then return end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then return end

    level = clamp(1.0, cfg.max_zoom, level)

    if level <= 1.0 then
        -- Zoom out
        if SM:is_zoomed() then
            local current = crop_filter_get_crop()
            SM.following = false
            SM:transition(ZoomState.ZOOMING_OUT, {
                start_crop = current,
                target_crop = original_crop,
                target_level = 1.0
            })
            start_timer()
        end
        return
    end

    local mouse = platform_get_mouse_pos()
    local target_crop = camera_physics_get_target_crop(mouse, level, source_w, source_h, nil)

    local start_crop
    if SM:is_zoomed() then
        start_crop = crop_filter_get_crop()
    else
        start_crop = { x = 0, y = 0, w = source_w, h = source_h }
        original_crop = start_crop
        camera_physics_init(mouse)
    end

    SM:transition(ZoomState.SCROLLING, {
        start_crop = start_crop,
        target_crop = target_crop,
        target_level = level
    })

    start_timer()
end

-- Register scroll zoom hotkeys
local function register_scroll_hotkeys(settings)
    -- Scroll Up hotkey
    ScrollZoom.hotkey_scroll_up = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.scroll_up",
        "Zoom In (Scroll)",
        on_scroll_zoom_up
    )

    -- Scroll Down hotkey
    ScrollZoom.hotkey_scroll_down = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.scroll_down",
        "Zoom Out (Scroll)",
        on_scroll_zoom_down
    )

    -- Load saved bindings
    local up_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.scroll_up")
    if up_array then
        obs.obs_hotkey_load(ScrollZoom.hotkey_scroll_up, up_array)
        obs.obs_data_array_release(up_array)
    end

    local down_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.scroll_down")
    if down_array then
        obs.obs_hotkey_load(ScrollZoom.hotkey_scroll_down, down_array)
        obs.obs_data_array_release(down_array)
    end

    log("Scroll Zoom: Hotkeys registered")
end

-- Save scroll hotkey bindings
local function save_scroll_hotkeys(settings)
    if ScrollZoom.hotkey_scroll_up then
        local array = obs.obs_hotkey_save(ScrollZoom.hotkey_scroll_up)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.scroll_up", array)
        obs.obs_data_array_release(array)
    end

    if ScrollZoom.hotkey_scroll_down then
        local array = obs.obs_hotkey_save(ScrollZoom.hotkey_scroll_down)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.scroll_down", array)
        obs.obs_data_array_release(array)
    end
end

-- Unregister scroll hotkeys
local function unregister_scroll_hotkeys()
    if ScrollZoom.hotkey_scroll_up then
        obs.obs_hotkey_unregister(ScrollZoom.hotkey_scroll_up)
        ScrollZoom.hotkey_scroll_up = nil
    end
    if ScrollZoom.hotkey_scroll_down then
        obs.obs_hotkey_unregister(ScrollZoom.hotkey_scroll_down)
        ScrollZoom.hotkey_scroll_down = nil
    end
end

-- Update scroll zoom config
local function update_scroll_config(settings)
    ScrollZoom.scroll_step = obs.obs_data_get_double(settings, "scroll_step")
    ScrollZoom.scroll_modifier = obs.obs_data_get_string(settings, "scroll_modifier") or "ctrl"
end

--================================================
-- PLACEHOLDER: Future Modules
--================================================

-- M01: Configuration & Settings (TODO)
-- M05: Scene Manager (TODO)
-- M06: Source Manager (TODO)
-- M07: Crop/Zoom Controller (TODO)
-- M08: Motion Tracker (TODO)
-- M09: Face Detection (TODO)
-- M11: Audio Reactor (TODO)
-- M12: Transition Manager (TODO)
-- M13: Animation Controller (TODO)
-- M14: Preset Manager (TODO)
-- M15: Hotkey Manager (TODO)
-- M16: UI Components (TODO)
-- M17: Timer/Scheduler (TODO)
-- M18: State Machine (TODO)
-- M19: Performance Monitor (TODO)

--================================================
-- SCRIPT SETTINGS
--================================================
local settings = {}

-- Default settings
local defaults = {
    debug_logging = false,
    easing_type = "QuadInOut",
    smooth_time = 0.3,
    max_speed = 100.0
}

--================================================
-- MODULE: Preset Manager (M13)
--================================================
-- Manages built-in and custom animation presets

local PresetManager = {
    -- Built-in presets (read-only)
    built_in = {
        {
            name = "Smooth",
            duration = 0.8,
            overshoot = 0.0,
            smoothness = 0.25,
            easing = "Cubic.Out",
        },
        {
            name = "Bounce",
            duration = 0.6,
            overshoot = 0.35,
            smoothness = 0.15,
            easing = "Back.Out",
        },
        {
            name = "Snappy",
            duration = 0.3,
            overshoot = 0.0,
            smoothness = 0.05,
            easing = "Expo.Out",
        },
        {
            name = "Cinematic",
            duration = 1.2,
            overshoot = 0.05,
            smoothness = 0.4,
            easing = "Sine.Out",
        },
    },

    -- Custom user presets
    custom = {},

    -- Currently selected preset name
    current_preset = "Smooth",
}

-- Get all preset names (built-in + custom)
function PresetManager:get_all_names()
    local names = {}

    -- Add built-in presets
    for _, preset in ipairs(self.built_in) do
        table.insert(names, preset.name)
    end

    -- Add custom presets
    for name, _ in pairs(self.custom) do
        table.insert(names, name)
    end

    table.sort(names)
    return names
end

-- Get preset by name
function PresetManager:get_preset(name)
    -- Check built-in first
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            return preset
        end
    end

    -- Check custom
    if self.custom[name] then
        return self.custom[name]
    end

    -- Default to Smooth
    return self.built_in[1]
end

-- Apply preset to configuration
function PresetManager:apply_preset(name)
    local preset = self:get_preset(name)
    if not preset then
        log("Preset: Unknown preset: " .. name)
        return false
    end

    cfg.zoom_duration = preset.duration
    cfg.zoom_overshoot = preset.overshoot
    cfg.follow_smooth_time = preset.smoothness

    if preset.easing then
        cfg.zoom_easing = preset.easing
    end

    self.current_preset = name
    log("Preset: Applied '" .. name .. "'")
    return true
end

-- Save a custom preset
function PresetManager:save_preset(name, duration, overshoot, smoothness, easing)
    if not name or name == "" then
        return false
    end

    -- Check if it's a built-in preset (can't override)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            log("Preset: Cannot override built-in preset: " .. name)
            return false
        end
    end

    -- Save custom preset
    self.custom[name] = {
        name = name,
        duration = duration or cfg.zoom_duration,
        overshoot = overshoot or cfg.zoom_overshoot,
        smoothness = smoothness or cfg.follow_smooth_time,
        easing = easing or cfg.zoom_easing,
    }

    log("Preset: Saved custom preset '" .. name .. "'")
    return true
end

-- Delete a custom preset
function PresetManager:delete_preset(name)
    -- Check if it's a built-in preset (can't delete)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            log("Preset: Cannot delete built-in preset: " .. name)
            return false
        end
    end

    -- Delete custom preset
    if self.custom[name] then
        self.custom[name] = nil
        log("Preset: Deleted custom preset '" .. name .. "'")
        return true
    end

    return false
end

-- Check if a preset is built-in
function PresetManager:is_built_in(name)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            return true
        end
    end
    return false
end

-- Persist custom presets to settings
function PresetManager:persist(settings)
    local array = obs.obs_data_array_create()

    for name, preset in pairs(self.custom) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "name", name)
        obs.obs_data_set_double(item, "duration", preset.duration)
        obs.obs_data_set_double(item, "overshoot", preset.overshoot)
        obs.obs_data_set_double(item, "smoothness", preset.smoothness)
        obs.obs_data_set_string(item, "easing", preset.easing)
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "custom_presets", array)
    obs.obs_data_array_release(array)
end

-- Load custom presets from settings
function PresetManager:load(settings)
    self.custom = {}

    local array = obs.obs_data_get_array(settings, "custom_presets")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local name = obs.obs_data_get_string(item, "name")

        if name and name ~= "" then
            self.custom[name] = {
                name = name,
                duration = obs.obs_data_get_double(item, "duration"),
                overshoot = obs.obs_data_get_double(item, "overshoot"),
                smoothness = obs.obs_data_get_double(item, "smoothness"),
                easing = obs.obs_data_get_string(item, "easing"),
            }
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)
    log("Preset: Loaded " .. self:get_custom_count() .. " custom presets")
end

-- Get count of custom presets
function PresetManager:get_custom_count()
    local count = 0
    for _, _ in pairs(self.custom) do
        count = count + 1
    end
    return count
end

-- Get current preset name
function PresetManager:get_current_name()
    return self.current_preset
end

-- Set current preset name
function PresetManager:set_current_name(name)
    self.current_preset = name
end

-- Check if current preset is custom
function PresetManager:is_current_custom()
    return not self:is_built_in(self.current_preset)
end

-- Global convenience functions
function preset_get_all_names()
    return PresetManager:get_all_names()
end

function preset_apply(name)
    return PresetManager:apply_preset(name)
end

function preset_save(name, duration, overshoot, smoothness, easing)
    return PresetManager:save_preset(name, duration, overshoot, smoothness, easing)
end

function preset_delete(name)
    return PresetManager:delete_preset(name)
end

function preset_is_built_in(name)
    return PresetManager:is_built_in(name)
end

function preset_get_current()
    return PresetManager:get_current_name()
end

--================================================
-- MODULE: Auto Source Detection (M11)
--================================================
-- Automatically detects and selects the best zoom source on first run

local AutoSourceDetector = {
    -- Source type priorities (higher = more likely to be the main display)
    type_priorities = {
        ["monitor_capture"] = 100,     -- Display capture (highest priority)
        ["game_capture"] = 80,          -- Game capture
        ["window_capture"] = 60,        -- Window capture
        ["xshm_input"] = 40,           -- Linux X11 capture
        ["av_capture_input"] = 20,     -- macOS capture
    },

    -- Whether auto-detection has been run
    auto_detected = false,
}

-- Get all capture sources sorted by priority
function AutoSourceDetector:get_capture_sources()
    local sources = {}
    local source_list = obs.obs_enum_sources()

    if not source_list then
        return sources
    end

    for _, source in ipairs(source_list) do
        local source_id = obs.obs_source_get_id(source)
        local name = obs.obs_source_get_name(source)

        -- Check if it's a capture source
        local priority = self.type_priorities[source_id]
        if priority then
            table.insert(sources, {
                name = name,
                id = source_id,
                priority = priority,
            })
        end
    end

    obs.source_list_release(source_list)

    -- Sort by priority (highest first)
    table.sort(sources, function(a, b)
        return a.priority > b.priority
    end)

    return sources
end

-- Auto-detect the best source
function AutoSourceDetector:auto_detect()
    local sources = self:get_capture_sources()

    if #sources == 0 then
        log("AutoSource: No capture sources found")
        return nil
    end

    if #sources == 1 then
        -- Only one source, use it
        log("AutoSource: Found single source: " .. sources[1].name)
        return sources[1].name
    end

    -- Multiple sources - prioritize by type
    -- Prefer monitor_capture > game_capture > window_capture
    local best = sources[1]

    log("AutoSource: Found " .. #sources .. " sources, selecting: " .. best.name)
    return best.name
end

-- Get monitor geometry from a source (if available)
function AutoSourceDetector:get_monitor_geometry(source_name)
    local source = obs.obs_get_source_by_name(source_name)
    if not source then
        return nil
    end

    local settings = obs.obs_source_get_settings(source)
    if not settings then
        obs.obs_source_release(source)
        return nil
    end

    -- Try to get monitor info from settings
    local monitor = obs.obs_data_get_int(settings, "monitor")
    local x = obs.obs_data_get_int(settings, "x")
    local y = obs.obs_data_get_int(settings, "y")
    local width = obs.obs_data_get_int(settings, "width")
    local height = obs.obs_data_get_int(settings, "height")

    obs.obs_data_release(settings)
    obs.obs_source_release(source)

    -- Return geometry if available
    if monitor >= 0 or width > 0 then
        return {
            monitor = monitor,
            x = x,
            y = y,
            width = width or 1920,
            height = height or 1080,
        }
    end

    return nil
end

-- Check if we should auto-detect on first run
function AutoSourceDetector:should_auto_detect(settings)
    -- Check if source has ever been set
    local last_source = obs.obs_data_get_string(settings, "source")
    if last_source and last_source ~= "" then
        return false
    end

    -- Check if auto-detect has been done
    return not self.auto_detected
end

-- Run auto-detection and return the source name
function AutoSourceDetector:run(settings)
    local source_name = self:auto_detect()

    if source_name then
        -- Save the detected source
        obs.obs_data_set_string(settings, "source", source_name)
        self.auto_detected = true
    end

    return source_name
end

-- Global convenience functions
function auto_source_detect()
    return AutoSourceDetector:auto_detect()
end

function auto_source_should_detect(settings)
    return AutoSourceDetector:should_auto_detect(settings)
end

function auto_source_run(settings)
    return AutoSourceDetector:run(settings)
end

--================================================
-- MODULE: Scene Memory (M12)
--================================================
-- Remembers which zoom source to use for each OBS scene

local SceneMemory = {
    -- Scene to source mapping
    scene_source_map = {},

    -- Maximum number of mappings to store
    max_mappings = 50,
}

-- Get the current scene name
function SceneMemory:get_current_scene_name()
    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then
        return nil
    end

    local name = obs.obs_source_get_name(scene_source)
    obs.obs_source_release(scene_source)
    return name
end

-- Get the source to use for the current scene
function SceneMemory:get_source_for_current_scene()
    local scene_name = self:get_current_scene_name()
    if not scene_name then
        return nil
    end

    -- 1. Check explicit mapping for this scene
    if self.scene_source_map[scene_name] then
        return self.scene_source_map[scene_name]
    end

    -- 2. Fall back to global source from config
    return cfg.source_name
end

-- Set the source for a specific scene
function SceneMemory:set(scene_name, source_name)
    if not scene_name or scene_name == "" then
        return false
    end

    -- Check if we're at capacity
    local count = 0
    for _, _ in pairs(self.scene_source_map) do
        count = count + 1
    end

    if count >= self.max_mappings and not self.scene_source_map[scene_name] then
        log("SceneMemory: At capacity (" .. self.max_mappings .. "), cannot add: " .. scene_name)
        return false
    end

    self.scene_source_map[scene_name] = source_name
    log("SceneMemory: " .. scene_name .. " Ã¢â€ â€™ " .. source_name)
    return true
end

-- Remove a scene mapping
function SceneMemory:remove(scene_name)
    if self.scene_source_map[scene_name] then
        self.scene_source_map[scene_name] = nil
        log("SceneMemory: Removed mapping for " .. scene_name)
        return true
    end
    return false
end

-- Get all scene mappings
function SceneMemory:get_all()
    local mappings = {}
    for scene, source in pairs(self.scene_source_map) do
        table.insert(mappings, { scene = scene, source = source })
    end
    table.sort(mappings, function(a, b)
        return a.scene < b.scene
    end)
    return mappings
end

-- Check if a scene has a mapping
function SceneMemory:has_mapping(scene_name)
    return self.scene_source_map[scene_name] ~= nil
end

-- Persist mappings to settings
function SceneMemory:persist(settings)
    local array = obs.obs_data_array_create()

    for scene, source in pairs(self.scene_source_map) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "scene", scene)
        obs.obs_data_set_string(item, "source", source)
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "scene_source_map", array)
    obs.obs_data_array_release(array)
end

-- Load mappings from settings
function SceneMemory:load(settings)
    self.scene_source_map = {}

    local array = obs.obs_data_get_array(settings, "scene_source_map")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local scene = obs.obs_data_get_string(item, "scene")
        local source = obs.obs_data_get_string(item, "source")

        if scene and scene ~= "" and source and source ~= "" then
            self.scene_source_map[scene] = source
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)

    local count = 0
    for _, _ in pairs(self.scene_source_map) do count = count + 1 end
    log("SceneMemory: Loaded " .. count .. " scene mappings")
end

-- Handle scene change
function SceneMemory:on_scene_change()
    local scene_name = self:get_current_scene_name()
    if not scene_name then
        return
    end

    -- Get the source for this scene
    local source_name = self:get_source_for_current_scene()

    if source_name and source_name ~= "" then
        -- Check if source changed
        local current = source_manager_is_valid() and cfg.source_name

        if source_name ~= current then
            log("SceneMemory: Scene changed to " .. scene_name)

            -- Release current source
            source_manager_release()

            -- Initialize with new source
            cfg.source_name = source_name
            source_manager_init(source_name)
        end
    end
end

-- Global convenience functions
function scene_memory_get_source()
    return SceneMemory:get_source_for_current_scene()
end

function scene_memory_set(scene_name, source_name)
    return SceneMemory:set(scene_name, source_name)
end

function scene_memory_remove(scene_name)
    return SceneMemory:remove(scene_name)
end

function scene_memory_get_all()
    return SceneMemory:get_all()
end

function scene_memory_on_scene_change()
    return SceneMemory:on_scene_change()
end

--================================================
-- MODULE: Blur Manager (M14)
--================================================
-- Provides built-in blur effects without external plugins
-- Supports multiple strategies: shader, composite_blur plugin, or none

local BlurManager = {
    -- Current strategy: "shader", "composite_blur", "none"
    strategy = "none",

    -- Filter references
    zoom_blur_filter = nil,
    motion_blur_filter = nil,

    -- Settings references
    zoom_blur_settings = nil,
    motion_blur_settings = nil,

    -- State
    initialized = false,

    -- Configuration
    zoom_blur_enabled = false,
    zoom_blur_intensity = 5,
    zoom_blur_clear_radius = 150,
    motion_blur_enabled = false,
    motion_blur_intensity = 1.0,
}

-- Try to use custom shader (if effect files exist)
function BlurManager:try_shader_strategy(source)
    -- This would require .effect files in assets/shaders/
    -- For now, we'll use a simpler approach
    log("Blur: Shader strategy not implemented (requires effect files)")
    return false
end

-- Try to auto-create Composite Blur filters
function BlurManager:try_composite_blur_strategy(source)
    if not source then return false end

    -- Check if composite_blur filter type exists
    local test_filter = obs.obs_source_create_private("composite_blur", "__test_blur__", nil)
    if test_filter then
        obs.obs_source_release(test_filter)
    else
        log("Blur: Composite Blur plugin not available")
        return false
    end

    -- Create Zoom Blur filter
    local zs = obs.obs_data_create()
    obs.obs_data_set_double(zs, "radius", 0)
    obs.obs_data_set_int(zs, "blur_type", 2) -- Zoom type
    self.zoom_blur_filter = obs.obs_source_create_private(
        "composite_blur",
        FILTER_PREFIX .. "Zoom Blur",
        zs
    )

    if self.zoom_blur_filter then
        obs.obs_source_filter_add(source, self.zoom_blur_filter)
        self.zoom_blur_settings = zs
    else
        obs.obs_data_release(zs)
        return false
    end

    -- Create Motion Blur filter
    local ms = obs.obs_data_create()
    obs.obs_data_set_double(ms, "radius", 0)
    obs.obs_data_set_int(ms, "blur_type", 3) -- Motion/directional type
    self.motion_blur_filter = obs.obs_source_create_private(
        "composite_blur",
        FILTER_PREFIX .. "Motion Blur",
        ms
    )

    if self.motion_blur_filter then
        obs.obs_source_filter_add(source, self.motion_blur_filter)
        self.motion_blur_settings = ms
    else
        obs.obs_data_release(ms)
    end

    self.initialized = true
    return true
end

-- Initialize blur manager
function BlurManager:init(source)
    if not source then
        return false
    end

    self:cleanup()

    -- Try composite_blur strategy
    if self:try_composite_blur_strategy(source) then
        self.strategy = "composite_blur"
        log("Blur: Using Composite Blur plugin (auto-configured)")
        return true
    end

    -- No blur available
    self.strategy = "none"
    log("Blur: No blur backend available. Blur effects disabled.")
    return false
end

-- Update blur based on zoom state
function BlurManager:update(state_machine, crop, camera_velocity)
    if not self.initialized then return end
    if self.strategy == "none" then return end

    -- Zoom Blur: Active during zoom transitions
    if self.zoom_blur_enabled and self.zoom_blur_filter then
        local radius = 0

        if state_machine:is_animating() and
           (state_machine.state == ZoomState.ZOOMING_IN or
            state_machine.state == ZoomState.ZOOMING_OUT) then
            -- Bell curve: 0 at start Ã¢â€ â€™ peak at 50% Ã¢â€ â€™ 0 at end
            local t = clamp(0, 1, state_machine.zoom_time)
            local curve = math.sin(t * math.pi)
            radius = curve * curve * self.zoom_blur_intensity
        end

        self:set_zoom_blur(radius, crop)
    end

    -- Motion Blur: Active during camera panning (not during zoom transition)
    if self.motion_blur_enabled and self.motion_blur_filter then
        if not state_machine:is_animating() and state_machine:is_zoomed() and camera_velocity then
            local speed = math.sqrt(
                camera_velocity.x * camera_velocity.x +
                camera_velocity.y * camera_velocity.y
            )

            if speed > 1.0 then
                local radius = math.min(10, speed * self.motion_blur_intensity * 0.5)
                local angle = math.deg(math.atan2(camera_velocity.y, camera_velocity.x))
                self:set_motion_blur(radius, angle)
            else
                self:set_motion_blur(0, 0)
            end
        else
            self:set_motion_blur(0, 0)
        end
    end
end

-- Set zoom blur parameters
function BlurManager:set_zoom_blur(radius, crop)
    if self.strategy == "composite_blur" and self.zoom_blur_settings then
        obs.obs_data_set_double(self.zoom_blur_settings, "radius", radius)

        if crop then
            local cx = crop.x + (crop.w / 2)
            local cy = crop.y + (crop.h / 2)
            obs.obs_data_set_double(self.zoom_blur_settings, "center_x", cx)
            obs.obs_data_set_double(self.zoom_blur_settings, "center_y", cy)
        end

        obs.obs_data_set_double(self.zoom_blur_settings, "inactive_radius", self.zoom_blur_clear_radius)
        obs.obs_source_update(self.zoom_blur_filter, self.zoom_blur_settings)
    end
end

-- Set motion blur parameters
function BlurManager:set_motion_blur(radius, angle)
    if self.strategy == "composite_blur" and self.motion_blur_settings then
        obs.obs_data_set_double(self.motion_blur_settings, "radius", radius)
        obs.obs_data_set_double(self.motion_blur_settings, "angle", angle)
        obs.obs_source_update(self.motion_blur_filter, self.motion_blur_settings)
    end
end

-- Update configuration
function BlurManager:update_config(settings)
    self.zoom_blur_enabled = obs.obs_data_get_bool(settings, "zoom_blur_enabled")
    self.zoom_blur_intensity = obs.obs_data_get_double(settings, "zoom_blur_intensity")
    self.zoom_blur_clear_radius = obs.obs_data_get_double(settings, "zoom_blur_clear_radius")
    self.motion_blur_enabled = obs.obs_data_get_bool(settings, "motion_blur_enabled")
    self.motion_blur_intensity = obs.obs_data_get_double(settings, "motion_blur_intensity")
end

-- Cleanup filters
function BlurManager:cleanup()
    local source = source_manager_get_source()

    if self.zoom_blur_filter and source then
        obs.obs_source_filter_remove(source, self.zoom_blur_filter)
        obs.obs_source_release(self.zoom_blur_filter)
        self.zoom_blur_filter = nil
    end

    if self.motion_blur_filter and source then
        obs.obs_source_filter_remove(source, self.motion_blur_filter)
        obs.obs_source_release(self.motion_blur_filter)
        self.motion_blur_filter = nil
    end

    if self.zoom_blur_settings then
        obs.obs_data_release(self.zoom_blur_settings)
        self.zoom_blur_settings = nil
    end

    if self.motion_blur_settings then
        obs.obs_data_release(self.motion_blur_settings)
        self.motion_blur_settings = nil
    end

    self.initialized = false
    self.strategy = "none"
end

-- Check if blur is available
function BlurManager:is_available()
    return self.strategy ~= "none"
end

-- Global convenience functions
function blur_manager_init(source)
    return BlurManager:init(source)
end

function blur_manager_update(state_machine, crop, camera_velocity)
    return BlurManager:update(state_machine, crop, camera_velocity)
end

function blur_manager_update_config(settings)
    return BlurManager:update_config(settings)
end

function blur_manager_cleanup()
    return BlurManager:cleanup()
end

function blur_manager_is_available()
    return BlurManager:is_available()
end

--================================================
-- MODULE: Cursor Asset Manager (M16)
--================================================
-- Handles extracting and managing cursor image assets

local CursorAssets = {
    extracted = false,
    dir = nil,
}

-- Get the platform-specific asset directory
function CursorAssets:get_platform_dir()
    if IS_WINDOWS then
        local appdata = os.getenv("APPDATA")
        return appdata and (appdata .. "\\obs-studio\\obs-zoom-pro\\cursors") or nil
    elseif IS_LINUX then
        local home = os.getenv("HOME")
        return home and (home .. "/.config/obs-studio/obs-zoom-pro/cursors") or nil
    elseif IS_MACOS then
        local home = os.getenv("HOME")
        return home and (home .. "/Library/Application Support/obs-studio/obs-zoom-pro/cursors") or nil
    end
    -- Fallback for non-FFI environments
    return "cursors"
end

-- Ensure assets are extracted
function CursorAssets:ensure_extracted()
    if self.extracted then
        return self.dir
    end

    local dir = self:get_platform_dir()
    if not dir then
        log("CursorAssets: Could not determine asset directory")
        return nil
    end

    -- Create directory
    local cmd
    if IS_WINDOWS then
        cmd = 'mkdir "' .. dir .. '" 2>nul'
    else
        cmd = 'mkdir -p "' .. dir .. '"'
    end
    os.execute(cmd)

    -- Check if assets exist
    local sep = IS_WINDOWS and "\\" or "/"
    local arrow_path = dir .. sep .. "arrow.png"

    local f = io.open(arrow_path, "rb")
    if f then
        f:close()
        self.dir = dir
        self.extracted = true
        log("CursorAssets: Using existing assets from " .. dir)
        return dir
    end

    -- Try to copy from script directory
    local script_dir = get_script_directory()
    local assets_src = script_dir .. "assets" .. sep .. "cursors" .. sep

    local files = { "arrow.png", "pointer.png", "ibeam.png" }
    for _, filename in ipairs(files) do
        local src_path = assets_src .. filename
        local dst_path = dir .. sep .. filename

        local src = io.open(src_path, "rb")
        if src then
            local data = src:read("*a")
            src:close()

            local dst = io.open(dst_path, "wb")
            if dst then
                dst:write(data)
                dst:close()
                log("CursorAssets: Copied " .. filename)
            end
        end
    end

    self.dir = dir
    self.extracted = true
    return dir
end

-- Get the asset directory
function CursorAssets:get_dir()
    return self.dir
end

-- Check if assets are available
function CursorAssets:is_available()
    if not self.extracted then
        self:ensure_extracted()
    end
    return self.dir ~= nil
end

-- Get cursor image path
function CursorAssets:get_cursor_path(cursor_type)
    if not self:is_available() then
        return nil
    end

    local sep = IS_WINDOWS and "\\" or "/"
    local filename = (cursor_type or "arrow") .. ".png"
    return self.dir .. sep .. filename
end

-- Global convenience functions
function cursor_assets_ensure_extracted()
    return CursorAssets:ensure_extracted()
end

function cursor_assets_get_dir()
    return CursorAssets:get_dir()
end

function cursor_assets_is_available()
    return CursorAssets:is_available()
end

function cursor_assets_get_cursor_path(cursor_type)
    return CursorAssets:get_cursor_path(cursor_type)
end

--================================================
-- MODULE: Cursor Renderer (M15)
--================================================
-- Provides automatic cursor overlay rendering

local CursorRenderer = {
    enabled = false,
    source = nil,
    sceneitem = nil,

    -- Smoothed state
    pos = { x = 0, y = 0 },
    current_scale = 1.0,
    current_rot = 0,
    swap_pulse = 1.0,

    -- Velocities (SmoothDamp)
    vel_x = { val = 0 },
    vel_y = { val = 0 },
    vel_scale = { val = 0 },
    vel_rot = { val = 0 },
    vel_swap = { val = 0 },

    -- State
    was_pointer = false,
    initialized = false,

    -- Configuration
    cursor_scale = 1.0,
    cursor_click_scale = 0.78,
    cursor_smooth_time = 0.1,
    cursor_offset_x = -6,
    cursor_offset_y = -2,
    cursor_rotation_mode = "None",
    cursor_angle_offset = 0,
    cursor_tilt_strength = 0,
}

-- Initialize cursor renderer
function CursorRenderer:init()
    if not cfg.cursor_enabled then
        self.enabled = false
        return false
    end

    -- Ensure cursor assets are available
    local asset_dir = cursor_assets_ensure_extracted()
    if not asset_dir then
        log("CursorRenderer: Failed to extract cursor assets")
        self.enabled = false
        return false
    end

    -- Get or create the cursor image source
    local source_name = FILTER_PREFIX .. "Cursor"
    self.source = obs.obs_get_source_by_name(source_name)

    if not self.source then
        -- Create new image source
        local settings = obs.obs_data_create()
        local cursor_path = cursor_assets_get_cursor_path("arrow")
        if cursor_path then
            obs.obs_data_set_string(settings, "file", cursor_path)
        end
        self.source = obs.obs_source_create("image_source", source_name, settings, nil)
        obs.obs_data_release(settings)

        if not self.source then
            log("CursorRenderer: Failed to create image source")
            self.enabled = false
            return false
        end
    end

    -- Add to current scene
    self:add_to_scene()

    -- Initialize position
    local mouse = platform_get_mouse_pos()
    self.pos.x = mouse.x
    self.pos.y = mouse.y

    self.enabled = true
    self.initialized = true
    log("CursorRenderer: Initialized")
    return true
end

-- Add cursor source to scene
function CursorRenderer:add_to_scene()
    if not self.source then return false end

    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then return false end

    local scene = obs.obs_scene_from_source(scene_source)
    if not scene then
        obs.obs_source_release(scene_source)
        return false
    end

    -- Check if already in scene
    local source_name = obs.obs_source_get_name(self.source)
    self.sceneitem = obs.obs_scene_find_source(scene, source_name)

    if not self.sceneitem then
        -- Add to scene
        self.sceneitem = obs.obs_scene_add(scene, self.source)
        if self.sceneitem then
            -- Move to top (render last = on top)
            obs.obs_sceneitem_set_order(self.sceneitem, obs.OBS_ORDER_MOVE_TOP)
        end
    end

    obs.obs_source_release(scene_source)
    return true
end

-- Update cursor position and state
function CursorRenderer:update(dt, raw_mouse, camera_crop)
    if not self.enabled or not self.sceneitem then return end

    -- Smooth cursor position
    self.pos.x = SmoothDamp(self.pos.x, raw_mouse.x, self.vel_x, self.cursor_smooth_time, 100000, dt)
    self.pos.y = SmoothDamp(self.pos.y, raw_mouse.y, self.vel_y, self.cursor_smooth_time, 100000, dt)

    -- Snap when very close
    if math.abs(self.pos.x - raw_mouse.x) < 0.5 then
        self.pos.x = raw_mouse.x
        self.vel_x.val = 0
    end
    if math.abs(self.pos.y - raw_mouse.y) < 0.5 then
        self.pos.y = raw_mouse.y
        self.vel_y.val = 0
    end

    -- Cursor shape detection (Windows only)
    local is_pointer = false
    if platform_cursor_shape_available() then
        is_pointer = platform_is_cursor_pointer()
    end

    -- Swap cursor image if needed
    if is_pointer ~= self.was_pointer then
        local asset_dir = cursor_assets_get_dir()
        local sep = IS_WINDOWS and "\\" or "/"
        local new_file = is_pointer and (asset_dir .. sep .. "pointer.png") or (asset_dir .. sep .. "arrow.png")

        local s = obs.obs_source_get_settings(self.source)
        if s then
            obs.obs_data_set_string(s, "file", new_file)
            obs.obs_source_update(self.source, s)
            obs.obs_data_release(s)
        end

        -- Trigger swap pulse
        self.swap_pulse = 0.75
        self.vel_swap.val = 1
        self.was_pointer = is_pointer
    end

    self.swap_pulse = SmoothDamp(self.swap_pulse, 1.0, self.vel_swap, 0.12, 100000, dt)

    -- Click animation
    local is_clicking = platform_is_clicking()
    local target_scale = is_clicking and (self.cursor_scale * self.cursor_click_scale) or self.cursor_scale
    self.current_scale = SmoothDamp(self.current_scale, target_scale, self.vel_scale, 0.1, 100000, dt)

    -- Calculate position relative to zoom
    local zoom_factor = 1.0
    local crop_x, crop_y = 0, 0

    if camera_crop and SM:is_zoomed() then
        zoom_factor = source_manager_get_size() / camera_crop.w
        crop_x = camera_crop.x
        crop_y = camera_crop.y
    end

    local final_x = (self.pos.x - crop_x) * zoom_factor + (self.cursor_offset_x * zoom_factor)
    local final_y = (self.pos.y - crop_y) * zoom_factor + (self.cursor_offset_y * zoom_factor)

    -- Apply to scene item
    local pos = obs.vec2()
    pos.x = final_x
    pos.y = final_y
    obs.obs_sceneitem_set_pos(self.sceneitem, pos)

    local scale = obs.vec2()
    local s = self.current_scale * zoom_factor * self.swap_pulse
    scale.x = s
    scale.y = s
    obs.obs_sceneitem_set_scale(self.sceneitem, scale)

    -- Rotation
    local dynamic_rot = self:compute_rotation(dt)
    obs.obs_sceneitem_set_rot(self.sceneitem, dynamic_rot)
end

-- Compute rotation based on mode
function CursorRenderer:compute_rotation(dt)
    local vx = self.vel_x.val
    local vy = self.vel_y.val
    local speed = math.sqrt(vx * vx + vy * vy)

    if self.cursor_rotation_mode == "Directional" then
        if speed > 20 then
            local angle = math.atan2(vy, vx) * (180 / math.pi)
            local target = angle + self.cursor_angle_offset
            local diff = (target - self.current_rot + 180) % 360 - 180
            self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.05, 100000, dt)
        end
        return self.current_rot

    elseif self.cursor_rotation_mode == "Lean" then
        local lean = clamp(-40, 40, vx * 0.05 * self.cursor_tilt_strength) + self.cursor_angle_offset
        local diff = (lean - self.current_rot + 180) % 360 - 180
        self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.08, 100000, dt)
        return self.current_rot
    end

    -- "None" mode
    local diff = (self.cursor_angle_offset - self.current_rot + 180) % 360 - 180
    self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.15, 100000, dt)
    return self.current_rot
end

-- Update configuration
function CursorRenderer:update_config(settings)
    self.cursor_scale = obs.obs_data_get_double(settings, "cursor_scale")
    self.cursor_click_scale = obs.obs_data_get_double(settings, "cursor_click_scale")
    self.cursor_smooth_time = obs.obs_data_get_double(settings, "cursor_smooth_time")
    self.cursor_offset_x = obs.obs_data_get_int(settings, "cursor_offset_x")
    self.cursor_offset_y = obs.obs_data_get_int(settings, "cursor_offset_y")
    self.cursor_rotation_mode = obs.obs_data_get_string(settings, "cursor_rotation_mode") or "None"
    self.cursor_angle_offset = obs.obs_data_get_double(settings, "cursor_angle_offset")
    self.cursor_tilt_strength = obs.obs_data_get_double(settings, "cursor_tilt_strength")
end

-- Cleanup
function CursorRenderer:cleanup()
    if self.sceneitem then
        obs.obs_sceneitem_remove(self.sceneitem)
        self.sceneitem = nil
    end

    if self.source then
        local source_name = obs.obs_source_get_name(self.source)
        obs.obs_source_release(self.source)

        -- Remove from OBS source list
        local s = obs.obs_get_source_by_name(source_name)
        if s then
            obs.obs_source_remove(s)
            obs.obs_source_release(s)
        end
        self.source = nil
    end

    self.enabled = false
    self.initialized = false
end

-- Check if active
function CursorRenderer:is_active()
    return self.enabled and self.initialized
end

-- Global convenience functions
function cursor_renderer_init()
    return CursorRenderer:init()
end

function cursor_renderer_update(dt, raw_mouse, camera_crop)
    return CursorRenderer:update(dt, raw_mouse, camera_crop)
end

function cursor_renderer_update_config(settings)
    return CursorRenderer:update_config(settings)
end

function cursor_renderer_cleanup()
    return CursorRenderer:cleanup()
end

function cursor_renderer_is_active()
    return CursorRenderer:is_active()
end

--================================================
-- MODULE: Bookmark Manager (M17)
--================================================
-- Manages saved zoom positions (bookmarks)

local BookmarkManager = {
    -- Saved bookmarks: { name = { zoom_level, x, y, w, h, source } }
    bookmarks = {},

    -- Maximum bookmarks
    max_bookmarks = 20,

    -- Hotkey IDs
    hotkeys = {},
}

-- Save current zoom position as a bookmark
function BookmarkManager:save(name)
    if not name or name == "" then
        return false
    end

    -- Check limit
    local count = 0
    for _, _ in pairs(self.bookmarks) do count = count + 1 end

    if count >= self.max_bookmarks and not self.bookmarks[name] then
        log("Bookmark: Max bookmarks reached (" .. self.max_bookmarks .. ")")
        return false
    end

    -- Get current crop
    local crop = crop_filter_get_crop()
    if not crop then
        return false
    end

    -- Save bookmark
    self.bookmarks[name] = {
        zoom_level = SM.zoom_level,
        x = crop.x,
        y = crop.y,
        w = crop.w,
        h = crop.h,
        source = cfg.source_name,
    }

    log("Bookmark: Saved '" .. name .. "' (zoom=" .. string.format("%.2f", SM.zoom_level) .. ")")
    return true
end

-- Recall a bookmark
function BookmarkManager:recall(name)
    local bm = self.bookmarks[name]
    if not bm then
        log("Bookmark: Not found: " .. name)
        return false
    end

    if not SM:can_jump() then
        return false
    end

    if not source_manager_is_valid() then
        return false
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        return false
    end

    -- Get current crop as start
    local start_crop = crop_filter_get_crop() or { x = 0, y = 0, w = source_w, h = source_h }

    -- Set target
    local target_crop = {
        x = bm.x,
        y = bm.y,
        w = bm.w,
        h = bm.h,
    }

    -- Transition to bookmark
    SM:transition(ZoomState.JUMPING, {
        start_crop = start_crop,
        target_crop = target_crop,
        target_level = bm.zoom_level
    })

    start_timer()
    log("Bookmark: Recall '" .. name .. "'")
    return true
end

-- Delete a bookmark
function BookmarkManager:delete(name)
    if self.bookmarks[name] then
        self.bookmarks[name] = nil
        log("Bookmark: Deleted '" .. name .. "'")
        return true
    end
    return false
end

-- Rename a bookmark
function BookmarkManager:rename(old_name, new_name)
    if not self.bookmarks[old_name] then
        return false
    end

    if self.bookmarks[new_name] then
        return false
    end

    self.bookmarks[new_name] = self.bookmarks[old_name]
    self.bookmarks[old_name] = nil
    log("Bookmark: Renamed '" .. old_name .. "' to '" .. new_name .. "'")
    return true
end

-- Get all bookmark names
function BookmarkManager:get_names()
    local names = {}
    for k, _ in pairs(self.bookmarks) do
        table.insert(names, k)
    end
    table.sort(names)
    return names
end

-- Get bookmark info
function BookmarkManager:get(name)
    return self.bookmarks[name]
end

-- Persist bookmarks to settings
function BookmarkManager:persist(settings)
    local array = obs.obs_data_array_create()

    for name, bm in pairs(self.bookmarks) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "name", name)
        obs.obs_data_set_double(item, "zoom_level", bm.zoom_level)
        obs.obs_data_set_double(item, "x", bm.x)
        obs.obs_data_set_double(item, "y", bm.y)
        obs.obs_data_set_double(item, "w", bm.w)
        obs.obs_data_set_double(item, "h", bm.h)
        obs.obs_data_set_string(item, "source", bm.source or "")
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "zoom_bookmarks", array)
    obs.obs_data_array_release(array)
end

-- Load bookmarks from settings
function BookmarkManager:load(settings)
    self.bookmarks = {}

    local array = obs.obs_data_get_array(settings, "zoom_bookmarks")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local name = obs.obs_data_get_string(item, "name")

        if name and name ~= "" then
            self.bookmarks[name] = {
                zoom_level = obs.obs_data_get_double(item, "zoom_level"),
                x = obs.obs_data_get_double(item, "x"),
                y = obs.obs_data_get_double(item, "y"),
                w = obs.obs_data_get_double(item, "w"),
                h = obs.obs_data_get_double(item, "h"),
                source = obs.obs_data_get_string(item, "source"),
            }
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)

    local count = 0
    for _, _ in pairs(self.bookmarks) do count = count + 1 end
    log("Bookmark: Loaded " .. count .. " bookmarks")
end

-- Register bookmark hotkeys
function BookmarkManager:register_hotkeys(settings)
    for i = 1, 5 do
        self.hotkeys[i] = obs.obs_hotkey_register_frontend(
            "obs_zoom_pro.bookmark_" .. i,
            "Zoom to Bookmark " .. i,
            function(pressed)
                if not pressed then return end
                local names = self:get_names()
                if names[i] then
                    self:recall(names[i])
                end
            end
        )

        -- Load saved bindings
        local key = "obs_zoom_pro.hotkey.bookmark_" .. i
        local save_array = obs.obs_data_get_array(settings, key)
        if save_array then
            obs.obs_hotkey_load(self.hotkeys[i], save_array)
            obs.obs_data_array_release(save_array)
        end
    end
end

-- Save bookmark hotkeys
function BookmarkManager:save_hotkeys(settings)
    for i = 1, 5 do
        if self.hotkeys[i] then
            local save_array = obs.obs_hotkey_save(self.hotkeys[i])
            obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.bookmark_" .. i, save_array)
            obs.obs_data_array_release(save_array)
        end
    end
end

-- Global convenience functions
function bookmark_save(name)
    return BookmarkManager:save(name)
end

function bookmark_recall(name)
    return BookmarkManager:recall(name)
end

function bookmark_delete(name)
    return BookmarkManager:delete(name)
end

function bookmark_get_names()
    return BookmarkManager:get_names()
end

function bookmark_get(name)
    return BookmarkManager:get(name)
end

--================================================
-- MODULE: UDP API Server (M18)
--================================================
-- Provides external control via UDP for Stream Deck integration

local APIServer = {
    enabled = false,
    port = 12345,
    socket = nil,
}

-- Command handlers
local API_COMMANDS = {
    ZOOM_IN = function(args)
        local level = tonumber(args[1]) or cfg.zoom_value
        on_scroll_zoom_to(level)
        return "OK"
    end,

    ZOOM_OUT = function(args)
        if SM:is_zoomed() then
            on_toggle_zoom(true)
        end
        return "OK"
    end,

    ZOOM_SET = function(args)
        local level = tonumber(args[1])
        if not level then return "ERROR: Missing level" end
        on_scroll_zoom_to(level)
        return "OK"
    end,

    ZOOM_TOGGLE = function(args)
        on_toggle_zoom(true)
        return "OK"
    end,

    FOLLOW_ON = function(args)
        if SM:is_zoomed() then SM.following = true end
        return "OK"
    end,

    FOLLOW_OFF = function(args)
        SM.following = false
        return "OK"
    end,

    FOLLOW_TOGGLE = function(args)
        if SM:is_zoomed() then SM.following = not SM.following end
        return "OK"
    end,

    PRESET = function(args)
        local name = args[1]
        if not name then return "ERROR: Missing preset name" end
        local ok = preset_apply(name)
        return ok and "OK" or "ERROR: Unknown preset"
    end,

    BOOKMARK = function(args)
        local name = args[1]
        if not name then return "ERROR: Missing bookmark name" end
        local ok = bookmark_recall(name)
        return ok and "OK" or "ERROR: Bookmark not found"
    end,

    STATUS = function(args)
        local crop = crop_filter_get_crop()
        return string.format(
            '{"version":"%s","zoom_level":%.2f,"state":"%s","following":%s,"position":{"x":%.0f,"y":%.0f},"preset":"%s"}',
            VERSION,
            SM.zoom_level,
            SM.state,
            tostring(SM.following),
            crop and crop.x or 0,
            crop and crop.y or 0,
            cfg.zoom_preset or ""
        )
    end,

    HELP = function(args)
        return "Commands: ZOOM_IN [level], ZOOM_OUT, ZOOM_SET level, ZOOM_TOGGLE, FOLLOW_ON, FOLLOW_OFF, FOLLOW_TOGGLE, PRESET name, BOOKMARK name, STATUS"
    end,
}

-- Start the API server
function APIServer:start(port)
    self:stop()

    self.port = port or self.port

    -- Try to use luasocket if available
    local socket_ok, socket = pcall(require, "socket")
    if not socket_ok then
        log("API: Socket library not available")
        return false
    end

    -- Try UDP
    local udp, err = socket.udp()
    if not udp then
        log("API: Failed to create UDP socket: " .. tostring(err))
        return false
    end

    -- Set socket options
    udp:setoption("reuseaddr", true)
    udp:settimeout(0)  -- Non-blocking

    -- Bind to port
    local bind_ok, err = udp:setsockname("*", self.port)
    if not bind_ok then
        log("API: Failed to bind to port " .. self.port .. ": " .. tostring(err))
        udp:close()
        return false
    end

    self.socket = udp
    self.enabled = true

    -- Start polling timer
    obs.timer_add(function() self:poll() end, 50)  -- 20Hz polling

    log("API: Listening on port " .. self.port)
    return true
end

-- Stop the API server
function APIServer:stop()
    if self.socket then
        self.socket:close()
        self.socket = nil
    end
    self.enabled = false
    log("API: Stopped")
end

-- Poll for incoming commands
function APIServer:poll()
    if not self.enabled or not self.socket then
        return
    end

    repeat
        local data, err = self.socket:receivefrom()
        if data then
            local response = self:handle_command(data)
            if response then
                -- Note: UDP response requires sender address
                log("API: " .. data:gsub("%s+", " ") .. " Ã¢â€ â€™ " .. response)
            end
        elseif err ~= "timeout" then
            log("API: Error: " .. tostring(err))
        end
    until not data
end

-- Handle a command
function APIServer:handle_command(raw)
    -- Parse command
    local parts = {}
    for word in raw:gmatch("%S+") do
        table.insert(parts, word)
    end

    if #parts == 0 then
        return "ERROR: Empty command"
    end

    local cmd = parts[1]:upper()
    local args = {}
    for i = 2, #parts do
        table.insert(args, parts[i])
    end

    -- Look up handler
    local handler = API_COMMANDS[cmd]
    if handler then
        local ok, result = pcall(handler, args)
        if ok then
            return result
        else
            return "ERROR: " .. tostring(result)
        end
    end

    return "ERROR: Unknown command: " .. cmd
end

-- Check if enabled
function APIServer:is_enabled()
    return self.enabled
end

-- Global convenience functions
function api_start(port)
    return APIServer:start(port)
end

function api_stop()
    return APIServer:stop()
end

function api_is_enabled()
    return APIServer:is_enabled()
end

--================================================
-- OBS SCRIPT REGISTRATION
--================================================

--[[ Called when the script is loaded
--[[ @param data table Script data
function script_load(data)
    log("Script loaded - OBS Zoom Pro v" .. VERSION)

    -- Load custom presets
    PresetManager:load(data)

    -- Load scene memory
    SceneMemory:load(data)

    -- Load bookmarks
    BookmarkManager:load(data)

    -- Register hotkeys
    register_hotkeys(data)

    -- Register bookmark hotkeys
    BookmarkManager:register_hotkeys(data)

    -- Register frontend event handler
    obs.obs_frontend_add_event_callback(on_frontend_event)

    -- Start API server if enabled
    local api_enabled = obs.obs_data_get_bool(data, "api_enabled")
    if api_enabled then
        local api_port = obs.obs_data_get_int(data, "api_port")
        APIServer:start(api_port)
    end
end

--[[ Called when the script is unloaded
function script_unload()
    log("Script unloaded - OBS Zoom Pro")

    -- Stop timer and cleanup
    stop_timer()
    unregister_hotkeys()
    source_manager_release()

    -- Stop API server
    APIServer:stop()

    -- Remove frontend event handler
    obs.obs_frontend_remove_event_callback(on_frontend_event)
end

--[[ Called when settings are updated
--[[ @param data table Settings data
function script_update(data)
    log("Settings updated")

    -- Update legacy settings
    debug_logs = obs.obs_data_get_bool(data, "debug_logging") or false
    settings.debug_logging = debug_logs
    settings.easing_type = obs.obs_data_get_string(data, "easing_type") or defaults.easing_type
    settings.smooth_time = obs.obs_data_get_double(data, "smooth_time") or defaults.smooth_time
    settings.max_speed = obs.obs_data_get_double(data, "max_speed") or defaults.max_speed

    -- Update M09 configuration
    update_config(data)

    -- Update API server settings
    local api_enabled = obs.obs_data_get_bool(data, "api_enabled")
    local api_port = obs.obs_data_get_int(data, "api_port")

    if api_enabled and not APIServer:is_enabled() then
        APIServer:start(api_port)
    elseif not api_enabled and APIServer:is_enabled() then
        APIServer:stop()
    elseif APIServer:is_enabled() and APIServer.port ~= api_port then
        APIServer:start(api_port)
    end
end

--[[ Called to save settings
--[[ @param data table Settings data to save
function script_save(data)
    log("Settings saved")

    -- Save custom presets
    PresetManager:persist(data)

    -- Save scene memory
    SceneMemory:persist(data)

    -- Save bookmarks
    BookmarkManager:persist(data)

    -- Save hotkey bindings
    save_hotkeys(data)

    -- Save bookmark hotkeys
    BookmarkManager:save_hotkeys(data)
end

--[[ Called to create the properties UI
--[[ @return obs.obs_properties_t Properties object
function script_properties()
    local props = obs.obs_properties_create()

    --==========================
    -- QUICK SETUP (always expanded)
    --==========================
    local grp_quick = obs.obs_properties_create()

    -- Source dropdown
    local src_list = obs.obs_properties_add_list(grp_quick, "source", "Zoom Source",
        obs.OBS_COMBO_TYPE_LIST, obs.OBS_COMBO_FORMAT_STRING)
    obs.obs_property_list_add_string(src_list, "-- Select Source --", "")

    -- Populate with available capture sources
    local sources = source_manager_get_available_sources()
    for _, src in ipairs(sources) do
        obs.obs_property_list_add_string(src_list, src.name, src.name)
    end

    -- Zoom Factor
    obs.obs_properties_add_float_slider(grp_quick, "zoom_value", "Zoom Factor", 1.0, 10.0, 0.1)

    -- Duration
    obs.obs_properties_add_float_slider(grp_quick, "zoom_duration", "Duration (s)", 0.05, 3.0, 0.05)

    obs.obs_properties_add_group(props, "quick_setup", "Ã¢Å¡Â¡ Quick Setup", obs.OBS_GROUP_NORMAL, grp_quick)

    --==========================
    -- ANIMATION (collapsed)
    --==========================
    local grp_anim = obs.obs_properties_create()

    -- Overshoot/Bounce
    obs.obs_properties_add_float_slider(grp_anim, "zoom_overshoot", "Bounce", 0.0, 1.0, 0.01)

    -- Easing Curve
    local p_easing = obs.obs_properties_add_list(grp_anim, "zoom_easing", "Easing Curve",
        obs.OBS_COMBO_TYPE_LIST, obs.OBS_COMBO_FORMAT_STRING)
    for _, name in ipairs(Easing.NAMES) do
        obs.obs_property_list_add_string(p_easing, name, name)
    end

    obs.obs_properties_add_group(props, "animation", "Ã°Å¸Å½Â¬ Animation", obs.OBS_GROUP_NORMAL, grp_anim)

    --==========================
    -- MOUSE FOLLOW (collapsed)
    --==========================
    local grp_follow = obs.obs_properties_create()

    obs.obs_properties_add_bool(grp_follow, "auto_follow", "Auto-Follow Mouse")
    obs.obs_properties_add_float_slider(grp_follow, "follow_smooth_time", "Smoothness", 0.01, 1.0, 0.01)
    obs.obs_properties_add_int_slider(grp_follow, "follow_dead_zone", "Dead Zone (px)", 0, 500, 1)

    obs.obs_properties_add_group(props, "follow", "Ã°Å¸Å½Â¯ Mouse Follow", obs.OBS_GROUP_NORMAL, grp_follow)

    --==========================
    -- ADVANCED (collapsed)
    --==========================
    local grp_adv = obs.obs_properties_create()
    obs.obs_properties_add_float_slider(grp_adv, "scroll_step", "Scroll Zoom Step", 0.1, 1.0, 0.05)
    obs.obs_properties_add_bool(grp_adv, "debug_logs", "Debug Logging")
    obs.obs_properties_add_group(props, "advanced", "Ã¢Å¡â„¢Ã¯Â¸Â Advanced", obs.OBS_GROUP_NORMAL, grp_adv)

    --==========================
    -- API SERVER (collapsed)
    --==========================
    local grp_api = obs.obs_properties_create()
    obs.obs_properties_add_bool(grp_api, "api_enabled", "Enable UDP API Server")
    obs.obs_properties_add_int(grp_api, "api_port", "API Port", 1024, 65535, 1)
    obs.obs_properties_add_group(props, "api_server", "Ã°Å¸Å’Â UDP API Server", obs.OBS_GROUP_NORMAL, grp_api)

    --==========================
    -- HELP (collapsed)
    --==========================
    local grp_help = obs.obs_properties_create()
    obs.obs_properties_add_text(grp_help, "help_text",
        "QUICK START:\n" ..
        "1. Select your capture source above\n" ..
        "2. Set hotkeys in OBS Settings Ã¢â€ â€™ Hotkeys\n" ..
        "   Ã¢â‚¬Â¢ 'Toggle Zoom to Mouse' Ã¢â‚¬â€ Main zoom\n" ..
        "   Ã¢â‚¬Â¢ 'Toggle Mouse Follow' Ã¢â‚¬â€ Enable/disable follow\n" ..
        "3. Press the hotkey to zoom!\n\n" ..
        "TIPS:\n" ..
        "Ã¢â‚¬Â¢ Zoom centers on mouse position\n" ..
        "Ã¢â‚¬Â¢ Enable Auto-Follow for smooth tracking\n" ..
        "Ã¢â‚¬Â¢ Adjust Dead Zone to reduce jitter",
        obs.OBS_TEXT_INFO)
    obs.obs_properties_add_group(props, "help", "Ã¢Ââ€œ Help", obs.OBS_GROUP_NORMAL, grp_help)

    return props
end

--[[ Called to set default values
--[[ @param data table Settings data
function script_defaults(data)
    obs.obs_data_set_default_string(data, "source", "")
    obs.obs_data_set_default_double(data, "zoom_value", 2.0)
    obs.obs_data_set_default_double(data, "zoom_duration", 0.6)
    obs.obs_data_set_default_double(data, "zoom_overshoot", 0.0)
    obs.obs_data_set_default_string(data, "zoom_easing", "Cubic.Out")
    obs.obs_data_set_default_bool(data, "auto_follow", true)
    obs.obs_data_set_default_double(data, "follow_smooth_time", 0.15)
    obs.obs_data_set_default_int(data, "follow_dead_zone", 5)
    obs.obs_data_set_default_double(data, "scroll_step", 0.25)
    obs.obs_data_set_default_bool(data, "debug_logs", false)
    obs.obs_data_set_default_bool(data, "api_enabled", false)
    obs.obs_data_set_default_int(data, "api_port", 12345)
end

--================================================
-- SCRIPT METADATA
--================================================
script_info = {
    name = "OBS Zoom Pro",
    version = VERSION,
    description = "Intelligent camera zoom functionality with smooth transitions and easing curves.",
    author = "OBS Zoom Pro Team"
}
)
        handle:close()
        if uname == 'Darwin' then
            is_macos = true
        elseif uname == 'Linux' then
            is_linux = true
        end
    end

    return {
        WINDOWS = is_windows,
        LINUX = is_linux,
        MACOS = is_macos
    }
end

local platform = detect_platform()
local IS_WINDOWS = platform.WINDOWS
local IS_LINUX = platform.LINUX
local IS_MACOS = platform.MACOS

-- Log platform detection
local os_name = IS_WINDOWS and 'Windows' or (IS_LINUX and 'Linux' or (IS_MACOS and 'macOS' or 'Unknown'))
log("Platform detected: " .. os_name .. (IS_WINDOWS and " (Full support)" or " (Basic support)"))

-- Virtual key codes
local VK_LBUTTON = 0x01
local VK_RBUTTON = 0x02
local VK_MBUTTON = 0x04
local VK_CONTROL = 0x11
local VK_SHIFT = 0x10
local VK_MENU = 0x12  -- Alt

-- Module state
local Platform = {
    cursor_shape_available = false,  -- Disabled (requires FFI)
    last_mouse = { x = 0, y = 0 },
    last_click = false,
}

-- Get mouse position (cross-platform using command line)
function Platform.get_mouse_pos()
    if IS_WINDOWS then
        -- Windows: Use PowerShell to get mouse position
        local success, result = pcall(function()
            local handle = io.popen('powershell -Command "[System.Windows.Forms.Cursor]::Position.X, [System.Windows.Forms.Cursor]::Position.Y" 2>NUL')
            if handle then
                local output = handle:read('*a'):match('(%d+),(%d+)')
                handle:close()
                if output then
                    local x, y = output:match('(%d+),(%d+)')
                    return { x = tonumber(x), y = tonumber(y) }
                end
            end
            return nil
        end)
        if success and result then
            return result
        end
    elseif IS_LINUX then
        -- Linux: Use xdotool if available, fallback to X11
        local success, result = pcall(function()
            local handle = io.popen("xdotool getmouselocation 2>/dev/null || echo 'x:0 y:0'")
            if handle then
                local output = handle:read("*a")
                handle:close()
                local x, y = output:match("x:(%d+)%s+y:(%d+)")
                if x and y then
                    return { x = tonumber(x), y = tonumber(y) }
                end
            end
            return nil
        end)
        if success and result then
            return result
        end
    elseif IS_MACOS then
        -- macOS: Use osascript
        local success, result = pcall(function()
            local handle = io.popen(--[[osascript -e 'tell application "System Events" to get position of the mouse' 2>/dev/null || echo "0, 0"]])
            if handle then
                local output = handle:read("*a")
                handle:close()
                local x, y = output:match("(%d+),%s*(%d+)")
                if x and y then
                    return { x = tonumber(x), y = tonumber(y) }
                end
            end
            return nil
        end)
        if success and result then
            return result
        end
    end

    -- Fallback
    return { x = 0, y = 0 }
end

-- Check if left mouse button is clicked (Windows only, others return false)
function Platform.is_clicking()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x01) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if a modifier key is held (Windows only)
function Platform.is_key_held(vk_code)
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(vk_code) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if cursor is a pointer/hand (Windows only)
function Platform.is_cursor_pointer()
    if IS_WINDOWS then
        local success, result = pcall(function()
            local ci = ffi.new("CURSORINFO")
            ci.cbSize = ffi.sizeof("CURSORINFO")
            if ffi.C.GetCursorInfo(ci) ~= 0 then
                -- Check if hCursor is a hand pointer
                -- This is a simplified check; real implementation would compare cursor handles
                return ci.flags ~= 0  -- Simplified; actual implementation needs cursor handle comparison
            end
            return false
        end)
        return success and result or false
    end
    return false
end

-- Get cursor shape (Windows only, returns "arrow" for others)
function Platform.get_cursor_shape()
    if IS_WINDOWS then
        local success, result = pcall(function()
            local ci = ffi.new("CURSORINFO")
            ci.cbSize = ffi.sizeof("CURSORINFO")
            if ffi.C.GetCursorInfo(ci) ~= 0 and ci.hCursor ~= nil then
                local addr = tonumber(ffi.cast("uintptr_t", ci.hCursor))
                -- Common cursor IDs (these are typical values, may vary)
                -- IDC_ARROW = 32512, IDC_IBEAM = 32513, IDC_HAND = 32649
                -- We use address ranges as heuristic
                return "arrow"  -- Simplified; actual implementation would map handles
            end
            return "arrow"
        end)
        return success and result or "arrow"
    end
    return "arrow"
end

-- Check if Control key is held
function Platform.is_ctrl_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x11) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if Shift key is held
function Platform.is_shift_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x10) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if Alt key is held
function Platform.is_alt_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x12) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Convenience wrapper functions
function platform_get_mouse_pos()
    return Platform.get_mouse_pos()
end

function platform_is_clicking()
    return Platform.is_clicking()
end

function platform_is_cursor_pointer()
    return Platform.is_cursor_pointer()
end

function platform_cursor_shape_available()
    return Platform.cursor_shape_available
end

function platform_is_ctrl_held()
    return Platform.is_ctrl_held()
end

function platform_is_shift_held()
    return Platform.is_shift_held()
end

function platform_is_alt_held()
    return Platform.is_alt_held()
end

--================================================
-- MODULE: State Machine (M05)
--================================================
-- Manages zoom states and transitions
-- States: IDLE, ZOOMING_IN, ZOOMED_IN, ZOOMING_OUT, SCROLLING, JUMPING

local ZoomState = {
    IDLE         = "idle",
    ZOOMING_IN   = "zooming_in",
    ZOOMED_IN    = "zoomed_in",
    ZOOMING_OUT  = "zooming_out",
    SCROLLING    = "scrolling",    -- Scroll wheel mid-transition
    JUMPING      = "jumping",      -- Bookmark transition
}

local StateMachine = {
    state = ZoomState.IDLE,
    zoom_time = 0,          -- Animation progress (0 Ã¢â€ â€™ 1)
    zoom_level = 1.0,       -- Current zoom factor
    target_level = 1.0,     -- Target zoom factor
    start_crop = nil,       -- Crop at animation start {x, y, w, h}
    target_crop = nil,      -- Crop at animation end {x, y, w, h}
    following = false,      -- Mouse follow active

    -- Transition guards
    can_zoom_in = function(self)
        return self.state == ZoomState.IDLE
    end,

    can_zoom_out = function(self)
        return self.state == ZoomState.ZOOMED_IN
            or self.state == ZoomState.SCROLLING
    end,

    can_scroll = function(self)
        return self.state == ZoomState.ZOOMED_IN
            or self.state == ZoomState.IDLE
            or self.state == ZoomState.SCROLLING
    end,

    can_jump = function(self)
        return self.state ~= ZoomState.ZOOMING_IN
           and self.state ~= ZoomState.ZOOMING_OUT
           and self.state ~= ZoomState.JUMPING
    end,

    is_animating = function(self)
        return self.state == ZoomState.ZOOMING_IN
            or self.state == ZoomState.ZOOMING_OUT
            or self.state == ZoomState.SCROLLING
            or self.state == ZoomState.JUMPING
    end,

    is_zoomed = function(self)
        return self.state ~= ZoomState.IDLE
    end,
}

-- Transition to a new state
function StateMachine:transition(new_state, params)
    local old = self.state
    self.state = new_state
    self.zoom_time = 0

    if params then
        if params.start_crop then self.start_crop = params.start_crop end
        if params.target_crop then self.target_crop = params.target_crop end
        if params.target_level then self.target_level = params.target_level end
    end

    log("State: " .. old .. " Ã¢â€ â€™ " .. new_state)
end

-- Complete the current animation
function StateMachine:complete()
    if self.state == ZoomState.ZOOMING_IN
       or self.state == ZoomState.SCROLLING
       or self.state == ZoomState.JUMPING then
        self.zoom_level = self.target_level
        self.state = ZoomState.ZOOMED_IN
        self.zoom_time = 0
        log("State: " .. self.state .. " Ã¢â€ â€™ ZOOMED_IN (complete)")
    elseif self.state == ZoomState.ZOOMING_OUT then
        self.zoom_level = 1.0
        self.target_level = 1.0
        self.start_crop = nil
        self.target_crop = nil
        self.following = false
        self.state = ZoomState.IDLE
        self.zoom_time = 0
        log("State: ZOOMING_OUT Ã¢â€ â€™ IDLE (complete)")
    end
end

-- Reset to initial state
function StateMachine:reset()
    self.state = ZoomState.IDLE
    self.zoom_time = 0
    self.zoom_level = 1.0
    self.target_level = 1.0
    self.start_crop = nil
    self.target_crop = nil
    self.following = false
    log("StateMachine: Reset to IDLE")
end

-- Get current animation progress (0-1)
function StateMachine:get_progress()
    return clamp(0, 1, self.zoom_time)
end

-- Check if in a specific state
function StateMachine:is_state(state)
    return self.state == state
end

-- Get state name for display
function StateMachine:get_state_name()
    return self.state
end

-- Create a new state machine instance (for testing/isolation)
function StateMachine:new()
    local sm = {}
    setmetatable(sm, { __index = self })
    sm.state = ZoomState.IDLE
    sm.zoom_time = 0
    sm.zoom_level = 1.0
    sm.target_level = 1.0
    sm.start_crop = nil
    sm.target_crop = nil
    sm.following = false
    return sm
end

-- Global state machine instance
local SM = StateMachine:new()

--================================================
-- MODULE: Crop Filter Manager (M07)
--================================================
-- Manages the crop/pad filter used to simulate zoom
-- Creates, updates, and destroys the filter automatically

local FILTER_PREFIX = "[ZoomPro] "
local CROP_FILTER_NAME = FILTER_PREFIX .. "Crop"

local CropFilterManager = {
    filter = nil,           -- The crop filter source
    source = nil,           -- The parent source
    original_crop = nil,    -- Original crop values for restoration
    current_crop = { x = 0, y = 0, w = 0, h = 0 },
    initialized = false,
}

-- Create the crop filter on a source
function CropFilterManager:create(source)
    if not source then
        log("CropFilter: No source provided")
        return false
    end

    self:cleanup()  -- Clean up any existing filter
    self.source = source

    -- Check if our filter already exists
    local existing = obs.obs_source_get_filter_by_name(source, CROP_FILTER_NAME)
    if existing then
        log("CropFilter: Found existing filter")
        self.filter = existing
        self.initialized = true
        return true
    end

    -- Create new crop/pad filter
    local settings = obs.obs_data_create()
    obs.obs_data_set_int(settings, "left", 0)
    obs.obs_data_set_int(settings, "top", 0)
    obs.obs_data_set_int(settings, "right", 0)
    obs.obs_data_set_int(settings, "bottom", 0)
    obs.obs_data_set_bool(settings, "relative", false)  -- Absolute positioning

    self.filter = obs.obs_source_create_private(
        "crop_filter",      -- Filter type
        CROP_FILTER_NAME,   -- Filter name
        settings            -- Settings
    )

    obs.obs_data_release(settings)

    if not self.filter then
        log("CropFilter: Failed to create filter")
        return false
    end

    -- Add filter to source
    obs.obs_source_filter_add(source, self.filter)

    -- Store original crop (none)
    self.original_crop = { x = 0, y = 0, w = 0, h = 0 }

    self.initialized = true
    log("CropFilter: Created successfully")
    return true
end

-- Update the crop filter with new values
function CropFilterManager:update(x, y, w, h)
    if not self.filter or not self.initialized then
        return false
    end

    -- Store current crop
    self.current_crop = { x = x, y = y, w = w, h = h }

    -- Get filter settings
    local settings = obs.obs_source_get_settings(self.filter)
    if not settings then
        return false
    end

    -- Calculate crop values
    -- For crop_filter: left, top are absolute position
    -- right, bottom are width/height from right/bottom edge
    -- We need to convert our x, y, w, h to this format

    -- Get source dimensions
    local source_w = obs.obs_source_get_width(self.source)
    local source_h = obs.obs_source_get_height(self.source)

    if source_w == 0 or source_h == 0 then
        obs.obs_data_release(settings)
        return false
    end

    -- Set crop values
    -- left = x offset from left
    -- top = y offset from top
    -- right = source_w - (x + w) = remaining width on right
    -- bottom = source_h - (y + h) = remaining height on bottom
    local left = math.floor(x)
    local top = math.floor(y)
    local right = math.floor(source_w - (x + w))
    local bottom = math.floor(source_h - (y + h))

    -- Clamp to valid values
    left = math.max(0, left)
    top = math.max(0, top)
    right = math.max(0, right)
    bottom = math.max(0, bottom)

    obs.obs_data_set_int(settings, "left", left)
    obs.obs_data_set_int(settings, "top", top)
    obs.obs_data_set_int(settings, "right", right)
    obs.obs_data_set_int(settings, "bottom", bottom)

    -- Update the filter
    obs.obs_source_update(self.filter, settings)
    obs.obs_data_release(settings)

    return true
end

-- Get current crop values
function CropFilterManager:get_crop()
    return self.current_crop
end

-- Reset crop to original (no crop)
function CropFilterManager:reset()
    if not self.filter or not self.initialized then
        return false
    end

    local settings = obs.obs_source_get_settings(self.filter)
    if settings then
        obs.obs_data_set_int(settings, "left", 0)
        obs.obs_data_set_int(settings, "top", 0)
        obs.obs_data_set_int(settings, "right", 0)
        obs.obs_data_set_int(settings, "bottom", 0)
        obs.obs_source_update(self.filter, settings)
        obs.obs_data_release(settings)
    end

    self.current_crop = { x = 0, y = 0, w = 0, h = 0 }
    return true
end

-- Remove the filter and restore original state
function CropFilterManager:cleanup()
    if self.filter and self.source then
        -- Reset to no crop first
        self:reset()

        -- Remove filter from source
        obs.obs_source_filter_remove(self.source, self.filter)
        obs.obs_source_release(self.filter)
        self.filter = nil
        log("CropFilter: Removed from source")
    end

    self.source = nil
    self.original_crop = nil
    self.current_crop = { x = 0, y = 0, w = 0, h = 0 }
    self.initialized = false
end

-- Check if filter is ready
function CropFilterManager:is_ready()
    return self.initialized and self.filter ~= nil
end

-- Get source dimensions
function CropFilterManager:get_source_size()
    if not self.source then
        return 0, 0
    end
    return obs.obs_source_get_width(self.source), obs.obs_source_get_height(self.source)
end

-- Convenience wrapper functions
function crop_filter_create(source)
    return CropFilterManager:create(source)
end

function crop_filter_update(x, y, w, h)
    return CropFilterManager:update(x, y, w, h)
end

function crop_filter_reset()
    return CropFilterManager:reset()
end

function crop_filter_cleanup()
    return CropFilterManager:cleanup()
end

function crop_filter_is_ready()
    return CropFilterManager:is_ready()
end

function crop_filter_get_crop()
    return CropFilterManager:get_crop()
end

function crop_filter_get_source_size()
    return CropFilterManager:get_source_size()
end

--================================================
-- MODULE: Source Manager (M08)
--================================================
-- Handles finding sources in scenes, capturing transforms,
-- and managing source state for zoom operations

local SourceManager = {
    source = nil,           -- Current zoom source
    sceneitem = nil,        -- Scene item reference
    scene = nil,            -- Current scene
    original_transform = nil, -- Saved original transform
    source_name = "",       -- Source name for settings
    initialized = false,
}

-- Transform data structure
local TransformData = {
    pos = { x = 0, y = 0 },
    scale = { x = 1.0, y = 1.0 },
    rot = 0,
    bounds_type = 0,
    bounds = { x = 0, y = 0 },
    crop = { left = 0, top = 0, right = 0, bottom = 0 },
}

-- Find a source in a scene (BFS through groups)
function SourceManager:find_sceneitem(scene, source_name)
    if not scene or not source_name then
        return nil
    end

    local scene_source = obs.obs_scene_from_source(scene)
    if not scene_source then
        return nil
    end

    -- BFS queue
    local queue = {}
    table.insert(queue, scene_source)

    while #queue > 0 do
        local current_scene = table.remove(queue, 1)

        -- Iterate through items
        local items = obs.obs_scene_enum_items(current_scene)
        if items then
            for _, item in ipairs(items) do
                local item_source = obs.obs_sceneitem_get_source(item)
                if item_source then
                    local name = obs.obs_source_get_name(item_source)

                    -- Check if this is our target
                    if name == source_name then
                        obs.sceneitem_list_release(items)
                        return item
                    end

                    -- Check if this is a group (nested scene)
                    if obs.obs_source_get_type(item_source) == obs.OBS_SOURCE_TYPE_INPUT then
                        local id = obs.obs_source_get_id(item_source)
                        if id == "group" then
                            local group_scene = obs.obs_group_from_source(item_source)
                            if group_scene then
                                table.insert(queue, group_scene)
                            end
                        end
                    end
                end
            end
            obs.sceneitem_list_release(items)
        end
    end

    return nil
end

-- Capture the current transform of a scene item
function SourceManager:capture_transform(sceneitem)
    if not sceneitem then
        return nil
    end

    local transform = {}

    -- Position
    local pos = obs.vec2()
    obs.obs_sceneitem_get_pos(sceneitem, pos)
    transform.pos = { x = pos.x, y = pos.y }

    -- Scale
    local scale = obs.vec2()
    obs.obs_sceneitem_get_scale(sceneitem, scale)
    transform.scale = { x = scale.x, y = scale.y }

    -- Rotation
    transform.rot = obs.obs_sceneitem_get_rot(sceneitem)

    -- Bounds
    transform.bounds_type = obs.obs_sceneitem_get_bounds_type(sceneitem)
    local bounds = obs.vec2()
    obs.obs_sceneitem_get_bounds(sceneitem, bounds)
    transform.bounds = { x = bounds.x, y = bounds.y }

    -- Crop
    local crop = obs.obs_sceneitem_crop()
    obs.obs_sceneitem_get_crop(sceneitem, crop)
    transform.crop = {
        left = crop.left,
        top = crop.top,
        right = crop.right,
        bottom = crop.bottom
    }

    return transform
end

-- Restore a saved transform to a scene item
function SourceManager:restore_transform(sceneitem, transform)
    if not sceneitem or not transform then
        return false
    end

    -- Position
    local pos = obs.vec2()
    pos.x = transform.pos.x
    pos.y = transform.pos.y
    obs.obs_sceneitem_set_pos(sceneitem, pos)

    -- Scale
    local scale = obs.vec2()
    scale.x = transform.scale.x
    scale.y = transform.scale.y
    obs.obs_sceneitem_set_scale(sceneitem, scale)

    -- Rotation
    obs.obs_sceneitem_set_rot(sceneitem, transform.rot)

    -- Bounds
    obs.obs_sceneitem_set_bounds_type(sceneitem, transform.bounds_type)
    local bounds = obs.vec2()
    bounds.x = transform.bounds.x
    bounds.y = transform.bounds.y
    obs.obs_sceneitem_set_bounds(sceneitem, bounds)

    -- Crop
    local crop = obs.obs_sceneitem_crop()
    crop.left = transform.crop.left
    crop.top = transform.crop.top
    crop.right = transform.crop.right
    crop.bottom = transform.crop.bottom
    obs.obs_sceneitem_set_crop(sceneitem, crop)

    return true
end

-- Initialize with a source name
function SourceManager:init(source_name)
    self:release()  -- Clean up any existing state

    if not source_name or source_name == "" then
        log("SourceManager: No source name provided")
        return false
    end

    self.source_name = source_name

    -- Get current scene
    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then
        log("SourceManager: No current scene")
        return false
    end

    self.scene = scene_source

    -- Find the scene item
    self.sceneitem = self:find_sceneitem(scene_source, source_name)
    if not self.sceneitem then
        log("SourceManager: Source not found in scene: " .. source_name)
        obs.obs_source_release(scene_source)
        return false
    end

    -- Get the source
    self.source = obs.obs_sceneitem_get_source(self.sceneitem)
    if not self.source then
        log("SourceManager: Failed to get source from sceneitem")
        obs.obs_source_release(scene_source)
        return false
    end

    -- Capture original transform
    self.original_transform = self:capture_transform(self.sceneitem)

    -- Create crop filter
    if not crop_filter_create(self.source) then
        log("SourceManager: Failed to create crop filter")
        obs.obs_source_release(scene_source)
        return false
    end

    self.initialized = true
    log("SourceManager: Initialized with source: " .. source_name)

    obs.obs_source_release(scene_source)
    return true
end

-- Release all resources
function SourceManager:release()
    -- Clean up crop filter
    crop_filter_cleanup()

    -- Restore original transform if we have it
    if self.sceneitem and self.original_transform then
        self:restore_transform(self.sceneitem, self.original_transform)
        log("SourceManager: Restored original transform")
    end

    self.source = nil
    self.sceneitem = nil
    self.scene = nil
    self.original_transform = nil
    self.initialized = false

    log("SourceManager: Released")
end

-- Get source dimensions
function SourceManager:get_source_size()
    if not self.source then
        return 0, 0
    end
    return obs.obs_source_get_width(self.source), obs.obs_source_get_height(self.source)
end

-- Check if source is valid
function SourceManager:is_valid()
    return self.initialized and self.source ~= nil and self.sceneitem ~= nil
end

-- Get source info
function SourceManager:get_info()
    if not self:is_valid() then
        return nil
    end

    return {
        name = self.source_name,
        width = obs.obs_source_get_width(self.source),
        height = obs.obs_source_get_height(self.source),
    }
end

-- Get list of available capture sources
function SourceManager.get_available_sources()
    local sources = {}

    -- Get all sources
    local source_list = obs.obs_enum_sources()
    if source_list then
        for _, source in ipairs(source_list) do
            local source_id = obs.obs_source_get_id(source)
            local name = obs.obs_source_get_name(source)

            -- Filter for capture sources
            local is_capture = false
            if source_id == "monitor_capture" or      -- Display capture
               source_id == "window_capture" or       -- Window capture
               source_id == "game_capture" or         -- Game capture
               source_id == "xshm_input" or           -- Linux X11 capture
               source_id == "av_capture_input" then   -- macOS capture
                is_capture = true
            end

            if is_capture then
                table.insert(sources, {
                    name = name,
                    id = source_id,
                })
            end
        end
        obs.source_list_release(source_list)
    end

    return sources
end

-- Convenience wrapper functions
function source_manager_init(source_name)
    return SourceManager:init(source_name)
end

function source_manager_release()
    return SourceManager:release()
end

function source_manager_is_valid()
    return SourceManager:is_valid()
end

function source_manager_get_source()
    return SourceManager.source
end

function source_manager_get_sceneitem()
    return SourceManager.sceneitem
end

function source_manager_get_size()
    return SourceManager:get_source_size()
end

function source_manager_get_available_sources()
    return SourceManager.get_available_sources()
end

--================================================
-- MODULE: Camera Physics (M06)
--================================================
-- Handles camera position calculations, dead zones,
-- and SmoothDamp-based camera movement

local CameraPhysics = {
    -- Smoothed camera position
    pos = { x = 0, y = 0 },

    -- Velocities for SmoothDamp
    vel_x = { val = 0 },
    vel_y = { val = 0 },

    -- Dead zone state
    tracked_pos = { x = 0, y = 0 },
    dead_zone_active = false,

    -- Last camera position (for velocity calculation)
    last_pos = { x = 0, y = 0 },

    -- Monitor offset (for multi-monitor setups)
    monitor_offset = { x = 0, y = 0 },
}

-- Initialize camera tracking with starting position
function CameraPhysics:init(mouse_pos)
    if mouse_pos then
        self.pos.x = mouse_pos.x
        self.pos.y = mouse_pos.y
        self.tracked_pos.x = mouse_pos.x
        self.tracked_pos.y = mouse_pos.y
    end
    self.vel_x.val = 0
    self.vel_y.val = 0
    self.last_pos.x = self.pos.x
    self.last_pos.y = self.pos.y
end

-- Apply dead zone to mouse input
-- Returns the position the camera should track
function CameraPhysics:apply_dead_zone(mouse_pos, dead_zone_radius)
    if not mouse_pos then
        return self.tracked_pos
    end

    if dead_zone_radius <= 0 then
        self.tracked_pos.x = mouse_pos.x
        self.tracked_pos.y = mouse_pos.y
        return self.tracked_pos
    end

    -- Calculate distance from tracked position to mouse
    local dx = mouse_pos.x - self.tracked_pos.x
    local dy = mouse_pos.y - self.tracked_pos.y
    local dist = math.sqrt(dx * dx + dy * dy)

    if dist <= dead_zone_radius then
        -- Mouse is within dead zone, don't move tracked position
        self.dead_zone_active = true
        return self.tracked_pos
    end

    -- Mouse is outside dead zone
    -- Move tracked position so it stays exactly dead_zone_radius from mouse
    self.dead_zone_active = false
    local excess = dist - dead_zone_radius
    local nx = dx / dist  -- Normalized direction
    local ny = dy / dist

    self.tracked_pos.x = self.tracked_pos.x + nx * excess
    self.tracked_pos.y = self.tracked_pos.y + ny * excess

    return self.tracked_pos
end

-- Smooth the input position using SmoothDamp
function CameraPhysics:smooth_input(target_pos, smooth_time, dt)
    if not target_pos then
        return self.pos
    end

    local max_speed = 100000  -- Very high max speed for smooth camera

    self.pos.x = SmoothDamp(self.pos.x, target_pos.x, self.vel_x, smooth_time, max_speed, dt)
    self.pos.y = SmoothDamp(self.pos.y, target_pos.y, self.vel_y, smooth_time, max_speed, dt)

    return self.pos
end

-- Calculate the crop rectangle for a given zoom level and center position
function CameraPhysics:compute_crop(center_x, center_y, zoom_level, source_w, source_h)
    if zoom_level <= 1.0 then
        -- No zoom, return full source
        return {
            x = 0,
            y = 0,
            w = source_w,
            h = source_h,
        }
    end

    -- Calculate crop dimensions
    local crop_w = source_w / zoom_level
    local crop_h = source_h / zoom_level

    -- Center the crop on the target position
    local crop_x = center_x - crop_w / 2
    local crop_y = center_y - crop_h / 2

    -- Clamp to source bounds
    crop_x = clamp(0, source_w - crop_w, crop_x)
    crop_y = clamp(0, source_h - crop_h, crop_y)

    return {
        x = crop_x,
        y = crop_y,
        w = crop_w,
        h = crop_h,
    }
end

-- Calculate target crop for zoom animation
-- mouse_pos: current mouse position
-- zoom_level: target zoom level
-- source_w, source_h: source dimensions
-- monitor_offset: offset for multi-monitor (optional)
function CameraPhysics:get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
    if not mouse_pos then
        return nil
    end

    -- Apply monitor offset if provided
    local target_x = mouse_pos.x
    local target_y = mouse_pos.y

    if monitor_offset then
        target_x = target_x - monitor_offset.x
        target_y = target_y - monitor_offset.y
    end

    -- Clamp to source bounds
    target_x = clamp(0, source_w, target_x)
    target_y = clamp(0, source_h, target_y)

    return self:compute_crop(target_x, target_y, zoom_level, source_w, source_h)
end

-- Interpolate between two crop rectangles
function CameraPhysics:lerp_crop(start_crop, end_crop, t, easing_fn)
    if not start_crop or not end_crop then
        return nil
    end

    t = clamp(0, 1, t)

    -- Apply easing
    local eased_t = easing_fn and easing_fn(t) or t

    return {
        x = lerp(start_crop.x, end_crop.x, eased_t),
        y = lerp(start_crop.y, end_crop.y, eased_t),
        w = lerp(start_crop.w, end_crop.w, eased_t),
        h = lerp(start_crop.h, end_crop.h, eased_t),
    }
end

-- Get camera velocity (for motion blur)
function CameraPhysics:get_velocity()
    return {
        x = self.pos.x - self.last_pos.x,
        y = self.pos.y - self.last_pos.y,
    }
end

-- Update last position (call at end of frame)
function CameraPhysics:update_last_pos()
    self.last_pos.x = self.pos.x
    self.last_pos.y = self.pos.y
end

-- Set monitor offset
function CameraPhysics:set_monitor_offset(offset)
    self.monitor_offset = offset or { x = 0, y = 0 }
end

-- Reset camera state
function CameraPhysics:reset()
    self.pos = { x = 0, y = 0 }
    self.vel_x = { val = 0 }
    self.vel_y = { val = 0 }
    self.tracked_pos = { x = 0, y = 0 }
    self.dead_zone_active = false
    self.last_pos = { x = 0, y = 0 }
end

-- Convenience wrapper functions
function camera_physics_init(mouse_pos)
    return CameraPhysics:init(mouse_pos)
end

function camera_physics_apply_dead_zone(mouse_pos, dead_zone_radius)
    return CameraPhysics:apply_dead_zone(mouse_pos, dead_zone_radius)
end

function camera_physics_smooth_input(target_pos, smooth_time, dt)
    return CameraPhysics:smooth_input(target_pos, smooth_time, dt)
end

function camera_physics_compute_crop(center_x, center_y, zoom_level, source_w, source_h)
    return CameraPhysics:compute_crop(center_x, center_y, zoom_level, source_w, source_h)
end

function camera_physics_get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
    return CameraPhysics:get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
end

function camera_physics_lerp_crop(start_crop, end_crop, t, easing_fn)
    return CameraPhysics:lerp_crop(start_crop, end_crop, t, easing_fn)
end

function camera_physics_get_velocity()
    return CameraPhysics:get_velocity()
end

function camera_physics_update_last_pos()
    return CameraPhysics:update_last_pos()
end

function camera_physics_reset()
    return CameraPhysics:reset()
end

--================================================
-- MODULE: Timer & Main Loop (M09)
--================================================
-- Core integration module that handles frame-by-frame updates,
-- input processing, state machine updates, and output

-- Configuration (will be populated from settings)
local cfg = {
    source_name = "",
    zoom_value = 2.0,
    max_zoom = 10.0,
    zoom_duration = 0.6,
    zoom_overshoot = 0.0,
    zoom_easing = "Cubic.Out",

    auto_follow = true,
    follow_smooth_time = 0.15,
    follow_dead_zone = 5,

    debug_logs = false,
}

-- Timing
local last_tick_time = 0
local timer_running = false

-- Frame diff tracking (skip updates if nothing changed)
local last_output = { x = -1, y = -1, w = -1, h = -1 }

-- Original crop for zoom out
local original_crop = { x = 0, y = 0, w = 0, h = 0 }

-- Hotkey IDs
local hotkey_toggle_zoom = nil
local hotkey_toggle_follow = nil

-- Get reliable delta time
local function get_dt()
    local now = os.clock()
    local dt = now - last_tick_time
    last_tick_time = now
    return clamp(0.001, 0.1, dt)  -- Guard against freezes and div/zero
end

-- Start the timer
local function start_timer()
    if not timer_running then
        timer_running = true
        last_tick_time = os.clock()
        -- Use frame-synced interval
        local interval = 16  -- Default to ~60fps
        obs.timer_add(on_timer, interval)
        log("Timer: Started")
    end
end

-- Stop the timer
local function stop_timer()
    if timer_running then
        timer_running = false
        obs.timer_remove(on_timer)
        log("Timer: Stopped")
    end
end

-- Initialize mouse tracking
local function init_mouse_tracking(mouse_pos)
    camera_physics_init(mouse_pos)
    original_crop = {
        x = 0,
        y = 0,
        w = 0,
        h = 0,
    }
end

-- Main timer callback
function on_timer()
    local dt = get_dt()

    -- Guard: No valid source
    if not source_manager_is_valid() then
        return
    end

    --==========================
    -- 1. INPUT
    --==========================
    local raw_mouse = platform_get_mouse_pos()

    --==========================
    -- 2. STATE MACHINE UPDATE
    --==========================
    if SM:is_animating() then
        SM.zoom_time = SM.zoom_time + (dt / cfg.zoom_duration)

        -- Check for completion
        if SM.zoom_time >= 1.0 then
            SM:complete()

            -- Auto-enable follow after zoom in
            if SM.state == ZoomState.ZOOMED_IN and cfg.auto_follow then
                SM.following = true
            end

            -- Stop timer if idle
            if SM.state == ZoomState.IDLE then
                stop_timer()
            end
        end
    end

    --==========================
    -- 3. CAMERA POSITION
    --==========================
    local crop = nil
    local source_w, source_h = source_manager_get_size()

    if source_w == 0 or source_h == 0 then
        return
    end

    if SM:is_animating() then
        -- Animate between start and target crop
        local easing_fn = Easing.get(cfg.zoom_easing, cfg.zoom_overshoot)
        crop = camera_physics_lerp_crop(SM.start_crop, SM.target_crop, SM.zoom_time, easing_fn)
    elseif SM:is_zoomed() and SM.following then
        -- Follow mouse with dead zone and smoothing
        local tracked = camera_physics_apply_dead_zone(raw_mouse, cfg.follow_dead_zone)
        local smoothed = camera_physics_smooth_input(tracked, cfg.follow_smooth_time, dt)
        crop = camera_physics_compute_crop(smoothed.x, smoothed.y, SM.zoom_level, source_w, source_h)
        camera_physics_update_last_pos()
    elseif SM:is_zoomed() then
        -- Static zoom (not following)
        crop = camera_physics_get_target_crop(
            { x = SM.target_crop.x + SM.target_crop.w / 2, y = SM.target_crop.y + SM.target_crop.h / 2 },
            SM.zoom_level, source_w, source_h, nil
        )
    end

    --==========================
    -- 4. OUTPUT (Diff-based)
    --==========================
    if crop then
        local cx = math.floor(crop.x)
        local cy = math.floor(crop.y)
        local cw = math.floor(crop.w)
        local ch = math.floor(crop.h)

        if cx ~= last_output.x or cy ~= last_output.y or
           cw ~= last_output.w or ch ~= last_output.h then
            crop_filter_update(cx, cy, cw, ch)
            last_output.x = cx
            last_output.y = cy
            last_output.w = cw
            last_output.h = ch
        end
    end
end

--==========================
-- HOTKEY HANDLERS
--==========================

function on_toggle_zoom(pressed)
    if not pressed then return end

    if not source_manager_is_valid() then
        log("Toggle Zoom: No valid source")
        return
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        log("Toggle Zoom: Invalid source dimensions")
        return
    end

    if SM.state == ZoomState.IDLE then
        -- ZOOM IN
        local mouse = platform_get_mouse_pos()
        init_mouse_tracking(mouse)

        -- Store original crop
        original_crop = { x = 0, y = 0, w = source_w, h = source_h }

        -- Calculate target crop
        local target_crop = camera_physics_get_target_crop(mouse, cfg.zoom_value, source_w, source_h, nil)

        SM:transition(ZoomState.ZOOMING_IN, {
            start_crop = original_crop,
            target_crop = target_crop,
            target_level = cfg.zoom_value
        })

        start_timer()

    elseif SM.state == ZoomState.ZOOMED_IN then
        -- ZOOM OUT
        SM.following = false

        local current = crop_filter_get_crop()
        SM:transition(ZoomState.ZOOMING_OUT, {
            start_crop = current,
            target_crop = original_crop,
            target_level = 1.0
        })

        start_timer()
    end
    -- Ignore if already animating (guard against rapid presses)
end

function on_toggle_follow(pressed)
    if not pressed then return end
    if not SM:is_zoomed() then return end

    SM.following = not SM.following
    log("Follow: " .. tostring(SM.following))

    if SM.following and not timer_running then
        start_timer()
    end
end

--==========================
-- HOTKEY REGISTRATION
--==========================

local function register_hotkeys(settings)
    -- Toggle Zoom hotkey
    hotkey_toggle_zoom = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.toggle_zoom",
        "Toggle Zoom to Mouse",
        on_toggle_zoom
    )

    -- Toggle Follow hotkey
    hotkey_toggle_follow = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.toggle_follow",
        "Toggle Mouse Follow",
        on_toggle_follow
    )

    -- Load saved hotkey bindings
    local toggle_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.toggle_zoom")
    if toggle_array then
        obs.obs_hotkey_load(hotkey_toggle_zoom, toggle_array)
        obs.obs_data_array_release(toggle_array)
    end

    local follow_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.toggle_follow")
    if follow_array then
        obs.obs_hotkey_load(hotkey_toggle_follow, follow_array)
        obs.obs_data_array_release(follow_array)
    end

    -- Register scroll zoom hotkeys
    register_scroll_hotkeys(settings)

    log("Hotkeys: Registered")
end

local function save_hotkeys(settings)
    if hotkey_toggle_zoom then
        local array = obs.obs_hotkey_save(hotkey_toggle_zoom)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.toggle_zoom", array)
        obs.obs_data_array_release(array)
    end

    if hotkey_toggle_follow then
        local array = obs.obs_hotkey_save(hotkey_toggle_follow)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.toggle_follow", array)
        obs.obs_data_array_release(array)
    end

    -- Save scroll zoom hotkeys
    save_scroll_hotkeys(settings)
end

local function unregister_hotkeys()
    if hotkey_toggle_zoom then
        obs.obs_hotkey_unregister(hotkey_toggle_zoom)
        hotkey_toggle_zoom = nil
    end
    if hotkey_toggle_follow then
        obs.obs_hotkey_unregister(hotkey_toggle_follow)
        hotkey_toggle_follow = nil
    end
    -- Unregister scroll zoom hotkeys
    unregister_scroll_hotkeys()
    log("Hotkeys: Unregistered")
end

--==========================
-- SCENE EVENT HANDLERS
--==========================

function on_frontend_event(event)
    if event == obs.OBS_FRONTEND_EVENT_SCENE_CHANGED then
        -- Scene changed, re-acquire source
        log("Event: Scene changed")

        -- Handle scene memory
        scene_memory_on_scene_change()

        if cfg.source_name and cfg.source_name ~= "" then
            source_manager_release()
            source_manager_init(cfg.source_name)
        end
    elseif event == obs.OBS_FRONTEND_EVENT_EXIT then
        -- OBS is closing
        log("Event: OBS exiting")
        stop_timer()
        source_manager_release()
    end
end

--==========================
-- CONFIGURATION UPDATE
--==========================

local function update_config(settings)
    cfg.source_name = obs.obs_data_get_string(settings, "source") or ""
    cfg.zoom_value = obs.obs_data_get_double(settings, "zoom_value")
    cfg.zoom_duration = obs.obs_data_get_double(settings, "zoom_duration")
    cfg.zoom_overshoot = obs.obs_data_get_double(settings, "zoom_overshoot")
    cfg.zoom_easing = obs.obs_data_get_string(settings, "zoom_easing") or "Cubic.Out"

    cfg.auto_follow = obs.obs_data_get_bool(settings, "auto_follow")
    cfg.follow_smooth_time = obs.obs_data_get_double(settings, "follow_smooth_time")
    cfg.follow_dead_zone = obs.obs_data_get_int(settings, "follow_dead_zone")

    cfg.debug_logs = obs.obs_data_get_bool(settings, "debug_logs")
    debug_logs = cfg.debug_logs

    -- Update scroll zoom config
    update_scroll_config(settings)

    -- Check if source changed
    local current_source = source_manager_is_valid() and cfg.source_name
    if cfg.source_name ~= "" and cfg.source_name ~= current_source then
        -- Reset state and reinitialize
        SM:reset()
        stop_timer()
        source_manager_release()
        source_manager_init(cfg.source_name)
    end
end

--================================================
-- MODULE: Scroll Zoom (M10)
--================================================
-- Enables gradual zoom control via scroll wheel with modifier key
-- Provides dynamic zoom level adjustment during zoomed state

local ScrollZoom = {
    -- Hotkey IDs for scroll zoom
    hotkey_scroll_up = nil,
    hotkey_scroll_down = nil,

    -- Configuration (populated from settings)
    scroll_step = 0.25,
    scroll_modifier = "ctrl",  -- "ctrl", "alt", "shift"
}

-- Check if modifier key is held
local function is_modifier_held()
    if ScrollZoom.scroll_modifier == "ctrl" then
        return platform_is_ctrl_held()
    elseif ScrollZoom.scroll_modifier == "alt" then
        return platform_is_alt_held()
    elseif ScrollZoom.scroll_modifier == "shift" then
        return platform_is_shift_held()
    end
    return false
end

-- Handle scroll zoom in
function on_scroll_zoom_up(pressed)
    if not pressed then return end
    on_scroll_zoom(1)
end

-- Handle scroll zoom out
function on_scroll_zoom_down(pressed)
    if not pressed then return end
    on_scroll_zoom(-1)
end

-- Main scroll zoom handler
function on_scroll_zoom(direction)
    -- Check if we can scroll
    if not SM:can_scroll() then return end

    -- Check modifier (optional - can be configured)
    -- For now, we rely on OBS hotkey bindings which can include modifiers

    if not source_manager_is_valid() then
        log("Scroll Zoom: No valid source")
        return
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        return
    end

    -- Calculate new zoom level
    local step = ScrollZoom.scroll_step * direction  -- e.g., 0.25
    local new_level

    if SM.state == ZoomState.IDLE then
        -- Starting from unzoomed
        new_level = 1.0 + step
    else
        -- Already zoomed, adjust level
        new_level = SM.target_level + step
    end

    -- Clamp to valid range
    new_level = clamp(1.0, cfg.max_zoom, new_level)

    -- If we hit 1.0, fully zoom out
    if new_level <= 1.0 then
        if SM:is_zoomed() then
            -- Trigger full zoom out
            local current = crop_filter_get_crop()
            SM.following = false
            SM:transition(ZoomState.ZOOMING_OUT, {
                start_crop = current,
                target_crop = original_crop,
                target_level = 1.0
            })
            start_timer()
        end
        return
    end

    -- Get current mouse position
    local mouse = platform_get_mouse_pos()

    -- Calculate new target crop for new zoom level
    local target_crop = camera_physics_get_target_crop(mouse, new_level, source_w, source_h, nil)

    -- Get current crop as start
    local start_crop
    if SM:is_animating() then
        -- Use current interpolated crop
        start_crop = crop_filter_get_crop()
    elseif SM:is_zoomed() then
        -- Use current crop
        start_crop = crop_filter_get_crop()
    else
        -- Starting from unzoomed
        start_crop = { x = 0, y = 0, w = source_w, h = source_h }
        original_crop = start_crop
        camera_physics_init(mouse)
    end

    -- Transition to new zoom level
    if SM.state == ZoomState.IDLE then
        -- First scroll from unzoomed
        SM:transition(ZoomState.SCROLLING, {
            start_crop = start_crop,
            target_crop = target_crop,
            target_level = new_level
        })
    else
        -- Already zoomed, adjust level (interrupt current animation)
        SM:transition(ZoomState.SCROLLING, {
            start_crop = start_crop,
            target_crop = target_crop,
            target_level = new_level
        })
    end

    start_timer()
    log("Scroll Zoom: Level " .. string.format("%.2f", new_level))
end

-- Zoom to a specific level (for API calls)
function on_scroll_zoom_to(level)
    if not source_manager_is_valid() then return end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then return end

    level = clamp(1.0, cfg.max_zoom, level)

    if level <= 1.0 then
        -- Zoom out
        if SM:is_zoomed() then
            local current = crop_filter_get_crop()
            SM.following = false
            SM:transition(ZoomState.ZOOMING_OUT, {
                start_crop = current,
                target_crop = original_crop,
                target_level = 1.0
            })
            start_timer()
        end
        return
    end

    local mouse = platform_get_mouse_pos()
    local target_crop = camera_physics_get_target_crop(mouse, level, source_w, source_h, nil)

    local start_crop
    if SM:is_zoomed() then
        start_crop = crop_filter_get_crop()
    else
        start_crop = { x = 0, y = 0, w = source_w, h = source_h }
        original_crop = start_crop
        camera_physics_init(mouse)
    end

    SM:transition(ZoomState.SCROLLING, {
        start_crop = start_crop,
        target_crop = target_crop,
        target_level = level
    })

    start_timer()
end

-- Register scroll zoom hotkeys
local function register_scroll_hotkeys(settings)
    -- Scroll Up hotkey
    ScrollZoom.hotkey_scroll_up = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.scroll_up",
        "Zoom In (Scroll)",
        on_scroll_zoom_up
    )

    -- Scroll Down hotkey
    ScrollZoom.hotkey_scroll_down = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.scroll_down",
        "Zoom Out (Scroll)",
        on_scroll_zoom_down
    )

    -- Load saved bindings
    local up_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.scroll_up")
    if up_array then
        obs.obs_hotkey_load(ScrollZoom.hotkey_scroll_up, up_array)
        obs.obs_data_array_release(up_array)
    end

    local down_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.scroll_down")
    if down_array then
        obs.obs_hotkey_load(ScrollZoom.hotkey_scroll_down, down_array)
        obs.obs_data_array_release(down_array)
    end

    log("Scroll Zoom: Hotkeys registered")
end

-- Save scroll hotkey bindings
local function save_scroll_hotkeys(settings)
    if ScrollZoom.hotkey_scroll_up then
        local array = obs.obs_hotkey_save(ScrollZoom.hotkey_scroll_up)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.scroll_up", array)
        obs.obs_data_array_release(array)
    end

    if ScrollZoom.hotkey_scroll_down then
        local array = obs.obs_hotkey_save(ScrollZoom.hotkey_scroll_down)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.scroll_down", array)
        obs.obs_data_array_release(array)
    end
end

-- Unregister scroll hotkeys
local function unregister_scroll_hotkeys()
    if ScrollZoom.hotkey_scroll_up then
        obs.obs_hotkey_unregister(ScrollZoom.hotkey_scroll_up)
        ScrollZoom.hotkey_scroll_up = nil
    end
    if ScrollZoom.hotkey_scroll_down then
        obs.obs_hotkey_unregister(ScrollZoom.hotkey_scroll_down)
        ScrollZoom.hotkey_scroll_down = nil
    end
end

-- Update scroll zoom config
local function update_scroll_config(settings)
    ScrollZoom.scroll_step = obs.obs_data_get_double(settings, "scroll_step")
    ScrollZoom.scroll_modifier = obs.obs_data_get_string(settings, "scroll_modifier") or "ctrl"
end

--================================================
-- PLACEHOLDER: Future Modules
--================================================

-- M01: Configuration & Settings (TODO)
-- M05: Scene Manager (TODO)
-- M06: Source Manager (TODO)
-- M07: Crop/Zoom Controller (TODO)
-- M08: Motion Tracker (TODO)
-- M09: Face Detection (TODO)
-- M11: Audio Reactor (TODO)
-- M12: Transition Manager (TODO)
-- M13: Animation Controller (TODO)
-- M14: Preset Manager (TODO)
-- M15: Hotkey Manager (TODO)
-- M16: UI Components (TODO)
-- M17: Timer/Scheduler (TODO)
-- M18: State Machine (TODO)
-- M19: Performance Monitor (TODO)

--================================================
-- SCRIPT SETTINGS
--================================================
local settings = {}

-- Default settings
local defaults = {
    debug_logging = false,
    easing_type = "QuadInOut",
    smooth_time = 0.3,
    max_speed = 100.0
}

--================================================
-- MODULE: Preset Manager (M13)
--================================================
-- Manages built-in and custom animation presets

local PresetManager = {
    -- Built-in presets (read-only)
    built_in = {
        {
            name = "Smooth",
            duration = 0.8,
            overshoot = 0.0,
            smoothness = 0.25,
            easing = "Cubic.Out",
        },
        {
            name = "Bounce",
            duration = 0.6,
            overshoot = 0.35,
            smoothness = 0.15,
            easing = "Back.Out",
        },
        {
            name = "Snappy",
            duration = 0.3,
            overshoot = 0.0,
            smoothness = 0.05,
            easing = "Expo.Out",
        },
        {
            name = "Cinematic",
            duration = 1.2,
            overshoot = 0.05,
            smoothness = 0.4,
            easing = "Sine.Out",
        },
    },

    -- Custom user presets
    custom = {},

    -- Currently selected preset name
    current_preset = "Smooth",
}

-- Get all preset names (built-in + custom)
function PresetManager:get_all_names()
    local names = {}

    -- Add built-in presets
    for _, preset in ipairs(self.built_in) do
        table.insert(names, preset.name)
    end

    -- Add custom presets
    for name, _ in pairs(self.custom) do
        table.insert(names, name)
    end

    table.sort(names)
    return names
end

-- Get preset by name
function PresetManager:get_preset(name)
    -- Check built-in first
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            return preset
        end
    end

    -- Check custom
    if self.custom[name] then
        return self.custom[name]
    end

    -- Default to Smooth
    return self.built_in[1]
end

-- Apply preset to configuration
function PresetManager:apply_preset(name)
    local preset = self:get_preset(name)
    if not preset then
        log("Preset: Unknown preset: " .. name)
        return false
    end

    cfg.zoom_duration = preset.duration
    cfg.zoom_overshoot = preset.overshoot
    cfg.follow_smooth_time = preset.smoothness

    if preset.easing then
        cfg.zoom_easing = preset.easing
    end

    self.current_preset = name
    log("Preset: Applied '" .. name .. "'")
    return true
end

-- Save a custom preset
function PresetManager:save_preset(name, duration, overshoot, smoothness, easing)
    if not name or name == "" then
        return false
    end

    -- Check if it's a built-in preset (can't override)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            log("Preset: Cannot override built-in preset: " .. name)
            return false
        end
    end

    -- Save custom preset
    self.custom[name] = {
        name = name,
        duration = duration or cfg.zoom_duration,
        overshoot = overshoot or cfg.zoom_overshoot,
        smoothness = smoothness or cfg.follow_smooth_time,
        easing = easing or cfg.zoom_easing,
    }

    log("Preset: Saved custom preset '" .. name .. "'")
    return true
end

-- Delete a custom preset
function PresetManager:delete_preset(name)
    -- Check if it's a built-in preset (can't delete)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            log("Preset: Cannot delete built-in preset: " .. name)
            return false
        end
    end

    -- Delete custom preset
    if self.custom[name] then
        self.custom[name] = nil
        log("Preset: Deleted custom preset '" .. name .. "'")
        return true
    end

    return false
end

-- Check if a preset is built-in
function PresetManager:is_built_in(name)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            return true
        end
    end
    return false
end

-- Persist custom presets to settings
function PresetManager:persist(settings)
    local array = obs.obs_data_array_create()

    for name, preset in pairs(self.custom) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "name", name)
        obs.obs_data_set_double(item, "duration", preset.duration)
        obs.obs_data_set_double(item, "overshoot", preset.overshoot)
        obs.obs_data_set_double(item, "smoothness", preset.smoothness)
        obs.obs_data_set_string(item, "easing", preset.easing)
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "custom_presets", array)
    obs.obs_data_array_release(array)
end

-- Load custom presets from settings
function PresetManager:load(settings)
    self.custom = {}

    local array = obs.obs_data_get_array(settings, "custom_presets")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local name = obs.obs_data_get_string(item, "name")

        if name and name ~= "" then
            self.custom[name] = {
                name = name,
                duration = obs.obs_data_get_double(item, "duration"),
                overshoot = obs.obs_data_get_double(item, "overshoot"),
                smoothness = obs.obs_data_get_double(item, "smoothness"),
                easing = obs.obs_data_get_string(item, "easing"),
            }
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)
    log("Preset: Loaded " .. self:get_custom_count() .. " custom presets")
end

-- Get count of custom presets
function PresetManager:get_custom_count()
    local count = 0
    for _, _ in pairs(self.custom) do
        count = count + 1
    end
    return count
end

-- Get current preset name
function PresetManager:get_current_name()
    return self.current_preset
end

-- Set current preset name
function PresetManager:set_current_name(name)
    self.current_preset = name
end

-- Check if current preset is custom
function PresetManager:is_current_custom()
    return not self:is_built_in(self.current_preset)
end

-- Global convenience functions
function preset_get_all_names()
    return PresetManager:get_all_names()
end

function preset_apply(name)
    return PresetManager:apply_preset(name)
end

function preset_save(name, duration, overshoot, smoothness, easing)
    return PresetManager:save_preset(name, duration, overshoot, smoothness, easing)
end

function preset_delete(name)
    return PresetManager:delete_preset(name)
end

function preset_is_built_in(name)
    return PresetManager:is_built_in(name)
end

function preset_get_current()
    return PresetManager:get_current_name()
end

--================================================
-- MODULE: Auto Source Detection (M11)
--================================================
-- Automatically detects and selects the best zoom source on first run

local AutoSourceDetector = {
    -- Source type priorities (higher = more likely to be the main display)
    type_priorities = {
        ["monitor_capture"] = 100,     -- Display capture (highest priority)
        ["game_capture"] = 80,          -- Game capture
        ["window_capture"] = 60,        -- Window capture
        ["xshm_input"] = 40,           -- Linux X11 capture
        ["av_capture_input"] = 20,     -- macOS capture
    },

    -- Whether auto-detection has been run
    auto_detected = false,
}

-- Get all capture sources sorted by priority
function AutoSourceDetector:get_capture_sources()
    local sources = {}
    local source_list = obs.obs_enum_sources()

    if not source_list then
        return sources
    end

    for _, source in ipairs(source_list) do
        local source_id = obs.obs_source_get_id(source)
        local name = obs.obs_source_get_name(source)

        -- Check if it's a capture source
        local priority = self.type_priorities[source_id]
        if priority then
            table.insert(sources, {
                name = name,
                id = source_id,
                priority = priority,
            })
        end
    end

    obs.source_list_release(source_list)

    -- Sort by priority (highest first)
    table.sort(sources, function(a, b)
        return a.priority > b.priority
    end)

    return sources
end

-- Auto-detect the best source
function AutoSourceDetector:auto_detect()
    local sources = self:get_capture_sources()

    if #sources == 0 then
        log("AutoSource: No capture sources found")
        return nil
    end

    if #sources == 1 then
        -- Only one source, use it
        log("AutoSource: Found single source: " .. sources[1].name)
        return sources[1].name
    end

    -- Multiple sources - prioritize by type
    -- Prefer monitor_capture > game_capture > window_capture
    local best = sources[1]

    log("AutoSource: Found " .. #sources .. " sources, selecting: " .. best.name)
    return best.name
end

-- Get monitor geometry from a source (if available)
function AutoSourceDetector:get_monitor_geometry(source_name)
    local source = obs.obs_get_source_by_name(source_name)
    if not source then
        return nil
    end

    local settings = obs.obs_source_get_settings(source)
    if not settings then
        obs.obs_source_release(source)
        return nil
    end

    -- Try to get monitor info from settings
    local monitor = obs.obs_data_get_int(settings, "monitor")
    local x = obs.obs_data_get_int(settings, "x")
    local y = obs.obs_data_get_int(settings, "y")
    local width = obs.obs_data_get_int(settings, "width")
    local height = obs.obs_data_get_int(settings, "height")

    obs.obs_data_release(settings)
    obs.obs_source_release(source)

    -- Return geometry if available
    if monitor >= 0 or width > 0 then
        return {
            monitor = monitor,
            x = x,
            y = y,
            width = width or 1920,
            height = height or 1080,
        }
    end

    return nil
end

-- Check if we should auto-detect on first run
function AutoSourceDetector:should_auto_detect(settings)
    -- Check if source has ever been set
    local last_source = obs.obs_data_get_string(settings, "source")
    if last_source and last_source ~= "" then
        return false
    end

    -- Check if auto-detect has been done
    return not self.auto_detected
end

-- Run auto-detection and return the source name
function AutoSourceDetector:run(settings)
    local source_name = self:auto_detect()

    if source_name then
        -- Save the detected source
        obs.obs_data_set_string(settings, "source", source_name)
        self.auto_detected = true
    end

    return source_name
end

-- Global convenience functions
function auto_source_detect()
    return AutoSourceDetector:auto_detect()
end

function auto_source_should_detect(settings)
    return AutoSourceDetector:should_auto_detect(settings)
end

function auto_source_run(settings)
    return AutoSourceDetector:run(settings)
end

--================================================
-- MODULE: Scene Memory (M12)
--================================================
-- Remembers which zoom source to use for each OBS scene

local SceneMemory = {
    -- Scene to source mapping
    scene_source_map = {},

    -- Maximum number of mappings to store
    max_mappings = 50,
}

-- Get the current scene name
function SceneMemory:get_current_scene_name()
    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then
        return nil
    end

    local name = obs.obs_source_get_name(scene_source)
    obs.obs_source_release(scene_source)
    return name
end

-- Get the source to use for the current scene
function SceneMemory:get_source_for_current_scene()
    local scene_name = self:get_current_scene_name()
    if not scene_name then
        return nil
    end

    -- 1. Check explicit mapping for this scene
    if self.scene_source_map[scene_name] then
        return self.scene_source_map[scene_name]
    end

    -- 2. Fall back to global source from config
    return cfg.source_name
end

-- Set the source for a specific scene
function SceneMemory:set(scene_name, source_name)
    if not scene_name or scene_name == "" then
        return false
    end

    -- Check if we're at capacity
    local count = 0
    for _, _ in pairs(self.scene_source_map) do
        count = count + 1
    end

    if count >= self.max_mappings and not self.scene_source_map[scene_name] then
        log("SceneMemory: At capacity (" .. self.max_mappings .. "), cannot add: " .. scene_name)
        return false
    end

    self.scene_source_map[scene_name] = source_name
    log("SceneMemory: " .. scene_name .. " Ã¢â€ â€™ " .. source_name)
    return true
end

-- Remove a scene mapping
function SceneMemory:remove(scene_name)
    if self.scene_source_map[scene_name] then
        self.scene_source_map[scene_name] = nil
        log("SceneMemory: Removed mapping for " .. scene_name)
        return true
    end
    return false
end

-- Get all scene mappings
function SceneMemory:get_all()
    local mappings = {}
    for scene, source in pairs(self.scene_source_map) do
        table.insert(mappings, { scene = scene, source = source })
    end
    table.sort(mappings, function(a, b)
        return a.scene < b.scene
    end)
    return mappings
end

-- Check if a scene has a mapping
function SceneMemory:has_mapping(scene_name)
    return self.scene_source_map[scene_name] ~= nil
end

-- Persist mappings to settings
function SceneMemory:persist(settings)
    local array = obs.obs_data_array_create()

    for scene, source in pairs(self.scene_source_map) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "scene", scene)
        obs.obs_data_set_string(item, "source", source)
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "scene_source_map", array)
    obs.obs_data_array_release(array)
end

-- Load mappings from settings
function SceneMemory:load(settings)
    self.scene_source_map = {}

    local array = obs.obs_data_get_array(settings, "scene_source_map")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local scene = obs.obs_data_get_string(item, "scene")
        local source = obs.obs_data_get_string(item, "source")

        if scene and scene ~= "" and source and source ~= "" then
            self.scene_source_map[scene] = source
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)

    local count = 0
    for _, _ in pairs(self.scene_source_map) do count = count + 1 end
    log("SceneMemory: Loaded " .. count .. " scene mappings")
end

-- Handle scene change
function SceneMemory:on_scene_change()
    local scene_name = self:get_current_scene_name()
    if not scene_name then
        return
    end

    -- Get the source for this scene
    local source_name = self:get_source_for_current_scene()

    if source_name and source_name ~= "" then
        -- Check if source changed
        local current = source_manager_is_valid() and cfg.source_name

        if source_name ~= current then
            log("SceneMemory: Scene changed to " .. scene_name)

            -- Release current source
            source_manager_release()

            -- Initialize with new source
            cfg.source_name = source_name
            source_manager_init(source_name)
        end
    end
end

-- Global convenience functions
function scene_memory_get_source()
    return SceneMemory:get_source_for_current_scene()
end

function scene_memory_set(scene_name, source_name)
    return SceneMemory:set(scene_name, source_name)
end

function scene_memory_remove(scene_name)
    return SceneMemory:remove(scene_name)
end

function scene_memory_get_all()
    return SceneMemory:get_all()
end

function scene_memory_on_scene_change()
    return SceneMemory:on_scene_change()
end

--================================================
-- MODULE: Blur Manager (M14)
--================================================
-- Provides built-in blur effects without external plugins
-- Supports multiple strategies: shader, composite_blur plugin, or none

local BlurManager = {
    -- Current strategy: "shader", "composite_blur", "none"
    strategy = "none",

    -- Filter references
    zoom_blur_filter = nil,
    motion_blur_filter = nil,

    -- Settings references
    zoom_blur_settings = nil,
    motion_blur_settings = nil,

    -- State
    initialized = false,

    -- Configuration
    zoom_blur_enabled = false,
    zoom_blur_intensity = 5,
    zoom_blur_clear_radius = 150,
    motion_blur_enabled = false,
    motion_blur_intensity = 1.0,
}

-- Try to use custom shader (if effect files exist)
function BlurManager:try_shader_strategy(source)
    -- This would require .effect files in assets/shaders/
    -- For now, we'll use a simpler approach
    log("Blur: Shader strategy not implemented (requires effect files)")
    return false
end

-- Try to auto-create Composite Blur filters
function BlurManager:try_composite_blur_strategy(source)
    if not source then return false end

    -- Check if composite_blur filter type exists
    local test_filter = obs.obs_source_create_private("composite_blur", "__test_blur__", nil)
    if test_filter then
        obs.obs_source_release(test_filter)
    else
        log("Blur: Composite Blur plugin not available")
        return false
    end

    -- Create Zoom Blur filter
    local zs = obs.obs_data_create()
    obs.obs_data_set_double(zs, "radius", 0)
    obs.obs_data_set_int(zs, "blur_type", 2) -- Zoom type
    self.zoom_blur_filter = obs.obs_source_create_private(
        "composite_blur",
        FILTER_PREFIX .. "Zoom Blur",
        zs
    )

    if self.zoom_blur_filter then
        obs.obs_source_filter_add(source, self.zoom_blur_filter)
        self.zoom_blur_settings = zs
    else
        obs.obs_data_release(zs)
        return false
    end

    -- Create Motion Blur filter
    local ms = obs.obs_data_create()
    obs.obs_data_set_double(ms, "radius", 0)
    obs.obs_data_set_int(ms, "blur_type", 3) -- Motion/directional type
    self.motion_blur_filter = obs.obs_source_create_private(
        "composite_blur",
        FILTER_PREFIX .. "Motion Blur",
        ms
    )

    if self.motion_blur_filter then
        obs.obs_source_filter_add(source, self.motion_blur_filter)
        self.motion_blur_settings = ms
    else
        obs.obs_data_release(ms)
    end

    self.initialized = true
    return true
end

-- Initialize blur manager
function BlurManager:init(source)
    if not source then
        return false
    end

    self:cleanup()

    -- Try composite_blur strategy
    if self:try_composite_blur_strategy(source) then
        self.strategy = "composite_blur"
        log("Blur: Using Composite Blur plugin (auto-configured)")
        return true
    end

    -- No blur available
    self.strategy = "none"
    log("Blur: No blur backend available. Blur effects disabled.")
    return false
end

-- Update blur based on zoom state
function BlurManager:update(state_machine, crop, camera_velocity)
    if not self.initialized then return end
    if self.strategy == "none" then return end

    -- Zoom Blur: Active during zoom transitions
    if self.zoom_blur_enabled and self.zoom_blur_filter then
        local radius = 0

        if state_machine:is_animating() and
           (state_machine.state == ZoomState.ZOOMING_IN or
            state_machine.state == ZoomState.ZOOMING_OUT) then
            -- Bell curve: 0 at start Ã¢â€ â€™ peak at 50% Ã¢â€ â€™ 0 at end
            local t = clamp(0, 1, state_machine.zoom_time)
            local curve = math.sin(t * math.pi)
            radius = curve * curve * self.zoom_blur_intensity
        end

        self:set_zoom_blur(radius, crop)
    end

    -- Motion Blur: Active during camera panning (not during zoom transition)
    if self.motion_blur_enabled and self.motion_blur_filter then
        if not state_machine:is_animating() and state_machine:is_zoomed() and camera_velocity then
            local speed = math.sqrt(
                camera_velocity.x * camera_velocity.x +
                camera_velocity.y * camera_velocity.y
            )

            if speed > 1.0 then
                local radius = math.min(10, speed * self.motion_blur_intensity * 0.5)
                local angle = math.deg(math.atan2(camera_velocity.y, camera_velocity.x))
                self:set_motion_blur(radius, angle)
            else
                self:set_motion_blur(0, 0)
            end
        else
            self:set_motion_blur(0, 0)
        end
    end
end

-- Set zoom blur parameters
function BlurManager:set_zoom_blur(radius, crop)
    if self.strategy == "composite_blur" and self.zoom_blur_settings then
        obs.obs_data_set_double(self.zoom_blur_settings, "radius", radius)

        if crop then
            local cx = crop.x + (crop.w / 2)
            local cy = crop.y + (crop.h / 2)
            obs.obs_data_set_double(self.zoom_blur_settings, "center_x", cx)
            obs.obs_data_set_double(self.zoom_blur_settings, "center_y", cy)
        end

        obs.obs_data_set_double(self.zoom_blur_settings, "inactive_radius", self.zoom_blur_clear_radius)
        obs.obs_source_update(self.zoom_blur_filter, self.zoom_blur_settings)
    end
end

-- Set motion blur parameters
function BlurManager:set_motion_blur(radius, angle)
    if self.strategy == "composite_blur" and self.motion_blur_settings then
        obs.obs_data_set_double(self.motion_blur_settings, "radius", radius)
        obs.obs_data_set_double(self.motion_blur_settings, "angle", angle)
        obs.obs_source_update(self.motion_blur_filter, self.motion_blur_settings)
    end
end

-- Update configuration
function BlurManager:update_config(settings)
    self.zoom_blur_enabled = obs.obs_data_get_bool(settings, "zoom_blur_enabled")
    self.zoom_blur_intensity = obs.obs_data_get_double(settings, "zoom_blur_intensity")
    self.zoom_blur_clear_radius = obs.obs_data_get_double(settings, "zoom_blur_clear_radius")
    self.motion_blur_enabled = obs.obs_data_get_bool(settings, "motion_blur_enabled")
    self.motion_blur_intensity = obs.obs_data_get_double(settings, "motion_blur_intensity")
end

-- Cleanup filters
function BlurManager:cleanup()
    local source = source_manager_get_source()

    if self.zoom_blur_filter and source then
        obs.obs_source_filter_remove(source, self.zoom_blur_filter)
        obs.obs_source_release(self.zoom_blur_filter)
        self.zoom_blur_filter = nil
    end

    if self.motion_blur_filter and source then
        obs.obs_source_filter_remove(source, self.motion_blur_filter)
        obs.obs_source_release(self.motion_blur_filter)
        self.motion_blur_filter = nil
    end

    if self.zoom_blur_settings then
        obs.obs_data_release(self.zoom_blur_settings)
        self.zoom_blur_settings = nil
    end

    if self.motion_blur_settings then
        obs.obs_data_release(self.motion_blur_settings)
        self.motion_blur_settings = nil
    end

    self.initialized = false
    self.strategy = "none"
end

-- Check if blur is available
function BlurManager:is_available()
    return self.strategy ~= "none"
end

-- Global convenience functions
function blur_manager_init(source)
    return BlurManager:init(source)
end

function blur_manager_update(state_machine, crop, camera_velocity)
    return BlurManager:update(state_machine, crop, camera_velocity)
end

function blur_manager_update_config(settings)
    return BlurManager:update_config(settings)
end

function blur_manager_cleanup()
    return BlurManager:cleanup()
end

function blur_manager_is_available()
    return BlurManager:is_available()
end

--================================================
-- MODULE: Cursor Asset Manager (M16)
--================================================
-- Handles extracting and managing cursor image assets

local CursorAssets = {
    extracted = false,
    dir = nil,
}

-- Get the platform-specific asset directory
function CursorAssets:get_platform_dir()
    if IS_WINDOWS then
        local appdata = os.getenv("APPDATA")
        return appdata and (appdata .. "\\obs-studio\\obs-zoom-pro\\cursors") or nil
    elseif IS_LINUX then
        local home = os.getenv("HOME")
        return home and (home .. "/.config/obs-studio/obs-zoom-pro/cursors") or nil
    elseif IS_MACOS then
        local home = os.getenv("HOME")
        return home and (home .. "/Library/Application Support/obs-studio/obs-zoom-pro/cursors") or nil
    end
    -- Fallback for non-FFI environments
    return "cursors"
end

-- Ensure assets are extracted
function CursorAssets:ensure_extracted()
    if self.extracted then
        return self.dir
    end

    local dir = self:get_platform_dir()
    if not dir then
        log("CursorAssets: Could not determine asset directory")
        return nil
    end

    -- Create directory
    local cmd
    if IS_WINDOWS then
        cmd = 'mkdir "' .. dir .. '" 2>nul'
    else
        cmd = 'mkdir -p "' .. dir .. '"'
    end
    os.execute(cmd)

    -- Check if assets exist
    local sep = IS_WINDOWS and "\\" or "/"
    local arrow_path = dir .. sep .. "arrow.png"

    local f = io.open(arrow_path, "rb")
    if f then
        f:close()
        self.dir = dir
        self.extracted = true
        log("CursorAssets: Using existing assets from " .. dir)
        return dir
    end

    -- Try to copy from script directory
    local script_dir = get_script_directory()
    local assets_src = script_dir .. "assets" .. sep .. "cursors" .. sep

    local files = { "arrow.png", "pointer.png", "ibeam.png" }
    for _, filename in ipairs(files) do
        local src_path = assets_src .. filename
        local dst_path = dir .. sep .. filename

        local src = io.open(src_path, "rb")
        if src then
            local data = src:read("*a")
            src:close()

            local dst = io.open(dst_path, "wb")
            if dst then
                dst:write(data)
                dst:close()
                log("CursorAssets: Copied " .. filename)
            end
        end
    end

    self.dir = dir
    self.extracted = true
    return dir
end

-- Get the asset directory
function CursorAssets:get_dir()
    return self.dir
end

-- Check if assets are available
function CursorAssets:is_available()
    if not self.extracted then
        self:ensure_extracted()
    end
    return self.dir ~= nil
end

-- Get cursor image path
function CursorAssets:get_cursor_path(cursor_type)
    if not self:is_available() then
        return nil
    end

    local sep = IS_WINDOWS and "\\" or "/"
    local filename = (cursor_type or "arrow") .. ".png"
    return self.dir .. sep .. filename
end

-- Global convenience functions
function cursor_assets_ensure_extracted()
    return CursorAssets:ensure_extracted()
end

function cursor_assets_get_dir()
    return CursorAssets:get_dir()
end

function cursor_assets_is_available()
    return CursorAssets:is_available()
end

function cursor_assets_get_cursor_path(cursor_type)
    return CursorAssets:get_cursor_path(cursor_type)
end

--================================================
-- MODULE: Cursor Renderer (M15)
--================================================
-- Provides automatic cursor overlay rendering

local CursorRenderer = {
    enabled = false,
    source = nil,
    sceneitem = nil,

    -- Smoothed state
    pos = { x = 0, y = 0 },
    current_scale = 1.0,
    current_rot = 0,
    swap_pulse = 1.0,

    -- Velocities (SmoothDamp)
    vel_x = { val = 0 },
    vel_y = { val = 0 },
    vel_scale = { val = 0 },
    vel_rot = { val = 0 },
    vel_swap = { val = 0 },

    -- State
    was_pointer = false,
    initialized = false,

    -- Configuration
    cursor_scale = 1.0,
    cursor_click_scale = 0.78,
    cursor_smooth_time = 0.1,
    cursor_offset_x = -6,
    cursor_offset_y = -2,
    cursor_rotation_mode = "None",
    cursor_angle_offset = 0,
    cursor_tilt_strength = 0,
}

-- Initialize cursor renderer
function CursorRenderer:init()
    if not cfg.cursor_enabled then
        self.enabled = false
        return false
    end

    -- Ensure cursor assets are available
    local asset_dir = cursor_assets_ensure_extracted()
    if not asset_dir then
        log("CursorRenderer: Failed to extract cursor assets")
        self.enabled = false
        return false
    end

    -- Get or create the cursor image source
    local source_name = FILTER_PREFIX .. "Cursor"
    self.source = obs.obs_get_source_by_name(source_name)

    if not self.source then
        -- Create new image source
        local settings = obs.obs_data_create()
        local cursor_path = cursor_assets_get_cursor_path("arrow")
        if cursor_path then
            obs.obs_data_set_string(settings, "file", cursor_path)
        end
        self.source = obs.obs_source_create("image_source", source_name, settings, nil)
        obs.obs_data_release(settings)

        if not self.source then
            log("CursorRenderer: Failed to create image source")
            self.enabled = false
            return false
        end
    end

    -- Add to current scene
    self:add_to_scene()

    -- Initialize position
    local mouse = platform_get_mouse_pos()
    self.pos.x = mouse.x
    self.pos.y = mouse.y

    self.enabled = true
    self.initialized = true
    log("CursorRenderer: Initialized")
    return true
end

-- Add cursor source to scene
function CursorRenderer:add_to_scene()
    if not self.source then return false end

    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then return false end

    local scene = obs.obs_scene_from_source(scene_source)
    if not scene then
        obs.obs_source_release(scene_source)
        return false
    end

    -- Check if already in scene
    local source_name = obs.obs_source_get_name(self.source)
    self.sceneitem = obs.obs_scene_find_source(scene, source_name)

    if not self.sceneitem then
        -- Add to scene
        self.sceneitem = obs.obs_scene_add(scene, self.source)
        if self.sceneitem then
            -- Move to top (render last = on top)
            obs.obs_sceneitem_set_order(self.sceneitem, obs.OBS_ORDER_MOVE_TOP)
        end
    end

    obs.obs_source_release(scene_source)
    return true
end

-- Update cursor position and state
function CursorRenderer:update(dt, raw_mouse, camera_crop)
    if not self.enabled or not self.sceneitem then return end

    -- Smooth cursor position
    self.pos.x = SmoothDamp(self.pos.x, raw_mouse.x, self.vel_x, self.cursor_smooth_time, 100000, dt)
    self.pos.y = SmoothDamp(self.pos.y, raw_mouse.y, self.vel_y, self.cursor_smooth_time, 100000, dt)

    -- Snap when very close
    if math.abs(self.pos.x - raw_mouse.x) < 0.5 then
        self.pos.x = raw_mouse.x
        self.vel_x.val = 0
    end
    if math.abs(self.pos.y - raw_mouse.y) < 0.5 then
        self.pos.y = raw_mouse.y
        self.vel_y.val = 0
    end

    -- Cursor shape detection (Windows only)
    local is_pointer = false
    if platform_cursor_shape_available() then
        is_pointer = platform_is_cursor_pointer()
    end

    -- Swap cursor image if needed
    if is_pointer ~= self.was_pointer then
        local asset_dir = cursor_assets_get_dir()
        local sep = IS_WINDOWS and "\\" or "/"
        local new_file = is_pointer and (asset_dir .. sep .. "pointer.png") or (asset_dir .. sep .. "arrow.png")

        local s = obs.obs_source_get_settings(self.source)
        if s then
            obs.obs_data_set_string(s, "file", new_file)
            obs.obs_source_update(self.source, s)
            obs.obs_data_release(s)
        end

        -- Trigger swap pulse
        self.swap_pulse = 0.75
        self.vel_swap.val = 1
        self.was_pointer = is_pointer
    end

    self.swap_pulse = SmoothDamp(self.swap_pulse, 1.0, self.vel_swap, 0.12, 100000, dt)

    -- Click animation
    local is_clicking = platform_is_clicking()
    local target_scale = is_clicking and (self.cursor_scale * self.cursor_click_scale) or self.cursor_scale
    self.current_scale = SmoothDamp(self.current_scale, target_scale, self.vel_scale, 0.1, 100000, dt)

    -- Calculate position relative to zoom
    local zoom_factor = 1.0
    local crop_x, crop_y = 0, 0

    if camera_crop and SM:is_zoomed() then
        zoom_factor = source_manager_get_size() / camera_crop.w
        crop_x = camera_crop.x
        crop_y = camera_crop.y
    end

    local final_x = (self.pos.x - crop_x) * zoom_factor + (self.cursor_offset_x * zoom_factor)
    local final_y = (self.pos.y - crop_y) * zoom_factor + (self.cursor_offset_y * zoom_factor)

    -- Apply to scene item
    local pos = obs.vec2()
    pos.x = final_x
    pos.y = final_y
    obs.obs_sceneitem_set_pos(self.sceneitem, pos)

    local scale = obs.vec2()
    local s = self.current_scale * zoom_factor * self.swap_pulse
    scale.x = s
    scale.y = s
    obs.obs_sceneitem_set_scale(self.sceneitem, scale)

    -- Rotation
    local dynamic_rot = self:compute_rotation(dt)
    obs.obs_sceneitem_set_rot(self.sceneitem, dynamic_rot)
end

-- Compute rotation based on mode
function CursorRenderer:compute_rotation(dt)
    local vx = self.vel_x.val
    local vy = self.vel_y.val
    local speed = math.sqrt(vx * vx + vy * vy)

    if self.cursor_rotation_mode == "Directional" then
        if speed > 20 then
            local angle = math.atan2(vy, vx) * (180 / math.pi)
            local target = angle + self.cursor_angle_offset
            local diff = (target - self.current_rot + 180) % 360 - 180
            self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.05, 100000, dt)
        end
        return self.current_rot

    elseif self.cursor_rotation_mode == "Lean" then
        local lean = clamp(-40, 40, vx * 0.05 * self.cursor_tilt_strength) + self.cursor_angle_offset
        local diff = (lean - self.current_rot + 180) % 360 - 180
        self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.08, 100000, dt)
        return self.current_rot
    end

    -- "None" mode
    local diff = (self.cursor_angle_offset - self.current_rot + 180) % 360 - 180
    self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.15, 100000, dt)
    return self.current_rot
end

-- Update configuration
function CursorRenderer:update_config(settings)
    self.cursor_scale = obs.obs_data_get_double(settings, "cursor_scale")
    self.cursor_click_scale = obs.obs_data_get_double(settings, "cursor_click_scale")
    self.cursor_smooth_time = obs.obs_data_get_double(settings, "cursor_smooth_time")
    self.cursor_offset_x = obs.obs_data_get_int(settings, "cursor_offset_x")
    self.cursor_offset_y = obs.obs_data_get_int(settings, "cursor_offset_y")
    self.cursor_rotation_mode = obs.obs_data_get_string(settings, "cursor_rotation_mode") or "None"
    self.cursor_angle_offset = obs.obs_data_get_double(settings, "cursor_angle_offset")
    self.cursor_tilt_strength = obs.obs_data_get_double(settings, "cursor_tilt_strength")
end

-- Cleanup
function CursorRenderer:cleanup()
    if self.sceneitem then
        obs.obs_sceneitem_remove(self.sceneitem)
        self.sceneitem = nil
    end

    if self.source then
        local source_name = obs.obs_source_get_name(self.source)
        obs.obs_source_release(self.source)

        -- Remove from OBS source list
        local s = obs.obs_get_source_by_name(source_name)
        if s then
            obs.obs_source_remove(s)
            obs.obs_source_release(s)
        end
        self.source = nil
    end

    self.enabled = false
    self.initialized = false
end

-- Check if active
function CursorRenderer:is_active()
    return self.enabled and self.initialized
end

-- Global convenience functions
function cursor_renderer_init()
    return CursorRenderer:init()
end

function cursor_renderer_update(dt, raw_mouse, camera_crop)
    return CursorRenderer:update(dt, raw_mouse, camera_crop)
end

function cursor_renderer_update_config(settings)
    return CursorRenderer:update_config(settings)
end

function cursor_renderer_cleanup()
    return CursorRenderer:cleanup()
end

function cursor_renderer_is_active()
    return CursorRenderer:is_active()
end

--================================================
-- MODULE: Bookmark Manager (M17)
--================================================
-- Manages saved zoom positions (bookmarks)

local BookmarkManager = {
    -- Saved bookmarks: { name = { zoom_level, x, y, w, h, source } }
    bookmarks = {},

    -- Maximum bookmarks
    max_bookmarks = 20,

    -- Hotkey IDs
    hotkeys = {},
}

-- Save current zoom position as a bookmark
function BookmarkManager:save(name)
    if not name or name == "" then
        return false
    end

    -- Check limit
    local count = 0
    for _, _ in pairs(self.bookmarks) do count = count + 1 end

    if count >= self.max_bookmarks and not self.bookmarks[name] then
        log("Bookmark: Max bookmarks reached (" .. self.max_bookmarks .. ")")
        return false
    end

    -- Get current crop
    local crop = crop_filter_get_crop()
    if not crop then
        return false
    end

    -- Save bookmark
    self.bookmarks[name] = {
        zoom_level = SM.zoom_level,
        x = crop.x,
        y = crop.y,
        w = crop.w,
        h = crop.h,
        source = cfg.source_name,
    }

    log("Bookmark: Saved '" .. name .. "' (zoom=" .. string.format("%.2f", SM.zoom_level) .. ")")
    return true
end

-- Recall a bookmark
function BookmarkManager:recall(name)
    local bm = self.bookmarks[name]
    if not bm then
        log("Bookmark: Not found: " .. name)
        return false
    end

    if not SM:can_jump() then
        return false
    end

    if not source_manager_is_valid() then
        return false
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        return false
    end

    -- Get current crop as start
    local start_crop = crop_filter_get_crop() or { x = 0, y = 0, w = source_w, h = source_h }

    -- Set target
    local target_crop = {
        x = bm.x,
        y = bm.y,
        w = bm.w,
        h = bm.h,
    }

    -- Transition to bookmark
    SM:transition(ZoomState.JUMPING, {
        start_crop = start_crop,
        target_crop = target_crop,
        target_level = bm.zoom_level
    })

    start_timer()
    log("Bookmark: Recall '" .. name .. "'")
    return true
end

-- Delete a bookmark
function BookmarkManager:delete(name)
    if self.bookmarks[name] then
        self.bookmarks[name] = nil
        log("Bookmark: Deleted '" .. name .. "'")
        return true
    end
    return false
end

-- Rename a bookmark
function BookmarkManager:rename(old_name, new_name)
    if not self.bookmarks[old_name] then
        return false
    end

    if self.bookmarks[new_name] then
        return false
    end

    self.bookmarks[new_name] = self.bookmarks[old_name]
    self.bookmarks[old_name] = nil
    log("Bookmark: Renamed '" .. old_name .. "' to '" .. new_name .. "'")
    return true
end

-- Get all bookmark names
function BookmarkManager:get_names()
    local names = {}
    for k, _ in pairs(self.bookmarks) do
        table.insert(names, k)
    end
    table.sort(names)
    return names
end

-- Get bookmark info
function BookmarkManager:get(name)
    return self.bookmarks[name]
end

-- Persist bookmarks to settings
function BookmarkManager:persist(settings)
    local array = obs.obs_data_array_create()

    for name, bm in pairs(self.bookmarks) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "name", name)
        obs.obs_data_set_double(item, "zoom_level", bm.zoom_level)
        obs.obs_data_set_double(item, "x", bm.x)
        obs.obs_data_set_double(item, "y", bm.y)
        obs.obs_data_set_double(item, "w", bm.w)
        obs.obs_data_set_double(item, "h", bm.h)
        obs.obs_data_set_string(item, "source", bm.source or "")
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "zoom_bookmarks", array)
    obs.obs_data_array_release(array)
end

-- Load bookmarks from settings
function BookmarkManager:load(settings)
    self.bookmarks = {}

    local array = obs.obs_data_get_array(settings, "zoom_bookmarks")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local name = obs.obs_data_get_string(item, "name")

        if name and name ~= "" then
            self.bookmarks[name] = {
                zoom_level = obs.obs_data_get_double(item, "zoom_level"),
                x = obs.obs_data_get_double(item, "x"),
                y = obs.obs_data_get_double(item, "y"),
                w = obs.obs_data_get_double(item, "w"),
                h = obs.obs_data_get_double(item, "h"),
                source = obs.obs_data_get_string(item, "source"),
            }
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)

    local count = 0
    for _, _ in pairs(self.bookmarks) do count = count + 1 end
    log("Bookmark: Loaded " .. count .. " bookmarks")
end

-- Register bookmark hotkeys
function BookmarkManager:register_hotkeys(settings)
    for i = 1, 5 do
        self.hotkeys[i] = obs.obs_hotkey_register_frontend(
            "obs_zoom_pro.bookmark_" .. i,
            "Zoom to Bookmark " .. i,
            function(pressed)
                if not pressed then return end
                local names = self:get_names()
                if names[i] then
                    self:recall(names[i])
                end
            end
        )

        -- Load saved bindings
        local key = "obs_zoom_pro.hotkey.bookmark_" .. i
        local save_array = obs.obs_data_get_array(settings, key)
        if save_array then
            obs.obs_hotkey_load(self.hotkeys[i], save_array)
            obs.obs_data_array_release(save_array)
        end
    end
end

-- Save bookmark hotkeys
function BookmarkManager:save_hotkeys(settings)
    for i = 1, 5 do
        if self.hotkeys[i] then
            local save_array = obs.obs_hotkey_save(self.hotkeys[i])
            obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.bookmark_" .. i, save_array)
            obs.obs_data_array_release(save_array)
        end
    end
end

-- Global convenience functions
function bookmark_save(name)
    return BookmarkManager:save(name)
end

function bookmark_recall(name)
    return BookmarkManager:recall(name)
end

function bookmark_delete(name)
    return BookmarkManager:delete(name)
end

function bookmark_get_names()
    return BookmarkManager:get_names()
end

function bookmark_get(name)
    return BookmarkManager:get(name)
end

--================================================
-- MODULE: UDP API Server (M18)
--================================================
-- Provides external control via UDP for Stream Deck integration

local APIServer = {
    enabled = false,
    port = 12345,
    socket = nil,
}

-- Command handlers
local API_COMMANDS = {
    ZOOM_IN = function(args)
        local level = tonumber(args[1]) or cfg.zoom_value
        on_scroll_zoom_to(level)
        return "OK"
    end,

    ZOOM_OUT = function(args)
        if SM:is_zoomed() then
            on_toggle_zoom(true)
        end
        return "OK"
    end,

    ZOOM_SET = function(args)
        local level = tonumber(args[1])
        if not level then return "ERROR: Missing level" end
        on_scroll_zoom_to(level)
        return "OK"
    end,

    ZOOM_TOGGLE = function(args)
        on_toggle_zoom(true)
        return "OK"
    end,

    FOLLOW_ON = function(args)
        if SM:is_zoomed() then SM.following = true end
        return "OK"
    end,

    FOLLOW_OFF = function(args)
        SM.following = false
        return "OK"
    end,

    FOLLOW_TOGGLE = function(args)
        if SM:is_zoomed() then SM.following = not SM.following end
        return "OK"
    end,

    PRESET = function(args)
        local name = args[1]
        if not name then return "ERROR: Missing preset name" end
        local ok = preset_apply(name)
        return ok and "OK" or "ERROR: Unknown preset"
    end,

    BOOKMARK = function(args)
        local name = args[1]
        if not name then return "ERROR: Missing bookmark name" end
        local ok = bookmark_recall(name)
        return ok and "OK" or "ERROR: Bookmark not found"
    end,

    STATUS = function(args)
        local crop = crop_filter_get_crop()
        return string.format(
            '{"version":"%s","zoom_level":%.2f,"state":"%s","following":%s,"position":{"x":%.0f,"y":%.0f},"preset":"%s"}',
            VERSION,
            SM.zoom_level,
            SM.state,
            tostring(SM.following),
            crop and crop.x or 0,
            crop and crop.y or 0,
            cfg.zoom_preset or ""
        )
    end,

    HELP = function(args)
        return "Commands: ZOOM_IN [level], ZOOM_OUT, ZOOM_SET level, ZOOM_TOGGLE, FOLLOW_ON, FOLLOW_OFF, FOLLOW_TOGGLE, PRESET name, BOOKMARK name, STATUS"
    end,
}

-- Start the API server
function APIServer:start(port)
    self:stop()

    self.port = port or self.port

    -- Try to use luasocket if available
    local socket_ok, socket = pcall(require, "socket")
    if not socket_ok then
        log("API: Socket library not available")
        return false
    end

    -- Try UDP
    local udp, err = socket.udp()
    if not udp then
        log("API: Failed to create UDP socket: " .. tostring(err))
        return false
    end

    -- Set socket options
    udp:setoption("reuseaddr", true)
    udp:settimeout(0)  -- Non-blocking

    -- Bind to port
    local bind_ok, err = udp:setsockname("*", self.port)
    if not bind_ok then
        log("API: Failed to bind to port " .. self.port .. ": " .. tostring(err))
        udp:close()
        return false
    end

    self.socket = udp
    self.enabled = true

    -- Start polling timer
    obs.timer_add(function() self:poll() end, 50)  -- 20Hz polling

    log("API: Listening on port " .. self.port)
    return true
end

-- Stop the API server
function APIServer:stop()
    if self.socket then
        self.socket:close()
        self.socket = nil
    end
    self.enabled = false
    log("API: Stopped")
end

-- Poll for incoming commands
function APIServer:poll()
    if not self.enabled or not self.socket then
        return
    end

    repeat
        local data, err = self.socket:receivefrom()
        if data then
            local response = self:handle_command(data)
            if response then
                -- Note: UDP response requires sender address
                log("API: " .. data:gsub("%s+", " ") .. " Ã¢â€ â€™ " .. response)
            end
        elseif err ~= "timeout" then
            log("API: Error: " .. tostring(err))
        end
    until not data
end

-- Handle a command
function APIServer:handle_command(raw)
    -- Parse command
    local parts = {}
    for word in raw:gmatch("%S+") do
        table.insert(parts, word)
    end

    if #parts == 0 then
        return "ERROR: Empty command"
    end

    local cmd = parts[1]:upper()
    local args = {}
    for i = 2, #parts do
        table.insert(args, parts[i])
    end

    -- Look up handler
    local handler = API_COMMANDS[cmd]
    if handler then
        local ok, result = pcall(handler, args)
        if ok then
            return result
        else
            return "ERROR: " .. tostring(result)
        end
    end

    return "ERROR: Unknown command: " .. cmd
end

-- Check if enabled
function APIServer:is_enabled()
    return self.enabled
end

-- Global convenience functions
function api_start(port)
    return APIServer:start(port)
end

function api_stop()
    return APIServer:stop()
end

function api_is_enabled()
    return APIServer:is_enabled()
end

--================================================
-- OBS SCRIPT REGISTRATION
--================================================

--[[ Called when the script is loaded
--[[ @param data table Script data
function script_load(data)
    log("Script loaded - OBS Zoom Pro v" .. VERSION)

    -- Load custom presets
    PresetManager:load(data)

    -- Load scene memory
    SceneMemory:load(data)

    -- Load bookmarks
    BookmarkManager:load(data)

    -- Register hotkeys
    register_hotkeys(data)

    -- Register bookmark hotkeys
    BookmarkManager:register_hotkeys(data)

    -- Register frontend event handler
    obs.obs_frontend_add_event_callback(on_frontend_event)

    -- Start API server if enabled
    local api_enabled = obs.obs_data_get_bool(data, "api_enabled")
    if api_enabled then
        local api_port = obs.obs_data_get_int(data, "api_port")
        APIServer:start(api_port)
    end
end

--[[ Called when the script is unloaded
function script_unload()
    log("Script unloaded - OBS Zoom Pro")

    -- Stop timer and cleanup
    stop_timer()
    unregister_hotkeys()
    source_manager_release()

    -- Stop API server
    APIServer:stop()

    -- Remove frontend event handler
    obs.obs_frontend_remove_event_callback(on_frontend_event)
end

--[[ Called when settings are updated
--[[ @param data table Settings data
function script_update(data)
    log("Settings updated")

    -- Update legacy settings
    debug_logs = obs.obs_data_get_bool(data, "debug_logging") or false
    settings.debug_logging = debug_logs
    settings.easing_type = obs.obs_data_get_string(data, "easing_type") or defaults.easing_type
    settings.smooth_time = obs.obs_data_get_double(data, "smooth_time") or defaults.smooth_time
    settings.max_speed = obs.obs_data_get_double(data, "max_speed") or defaults.max_speed

    -- Update M09 configuration
    update_config(data)

    -- Update API server settings
    local api_enabled = obs.obs_data_get_bool(data, "api_enabled")
    local api_port = obs.obs_data_get_int(data, "api_port")

    if api_enabled and not APIServer:is_enabled() then
        APIServer:start(api_port)
    elseif not api_enabled and APIServer:is_enabled() then
        APIServer:stop()
    elseif APIServer:is_enabled() and APIServer.port ~= api_port then
        APIServer:start(api_port)
    end
end

--[[ Called to save settings
--[[ @param data table Settings data to save
function script_save(data)
    log("Settings saved")

    -- Save custom presets
    PresetManager:persist(data)

    -- Save scene memory
    SceneMemory:persist(data)

    -- Save bookmarks
    BookmarkManager:persist(data)

    -- Save hotkey bindings
    save_hotkeys(data)

    -- Save bookmark hotkeys
    BookmarkManager:save_hotkeys(data)
end

--[[ Called to create the properties UI
--[[ @return obs.obs_properties_t Properties object
function script_properties()
    local props = obs.obs_properties_create()

    --==========================
    -- QUICK SETUP (always expanded)
    --==========================
    local grp_quick = obs.obs_properties_create()

    -- Source dropdown
    local src_list = obs.obs_properties_add_list(grp_quick, "source", "Zoom Source",
        obs.OBS_COMBO_TYPE_LIST, obs.OBS_COMBO_FORMAT_STRING)
    obs.obs_property_list_add_string(src_list, "-- Select Source --", "")

    -- Populate with available capture sources
    local sources = source_manager_get_available_sources()
    for _, src in ipairs(sources) do
        obs.obs_property_list_add_string(src_list, src.name, src.name)
    end

    -- Zoom Factor
    obs.obs_properties_add_float_slider(grp_quick, "zoom_value", "Zoom Factor", 1.0, 10.0, 0.1)

    -- Duration
    obs.obs_properties_add_float_slider(grp_quick, "zoom_duration", "Duration (s)", 0.05, 3.0, 0.05)

    obs.obs_properties_add_group(props, "quick_setup", "Ã¢Å¡Â¡ Quick Setup", obs.OBS_GROUP_NORMAL, grp_quick)

    --==========================
    -- ANIMATION (collapsed)
    --==========================
    local grp_anim = obs.obs_properties_create()

    -- Overshoot/Bounce
    obs.obs_properties_add_float_slider(grp_anim, "zoom_overshoot", "Bounce", 0.0, 1.0, 0.01)

    -- Easing Curve
    local p_easing = obs.obs_properties_add_list(grp_anim, "zoom_easing", "Easing Curve",
        obs.OBS_COMBO_TYPE_LIST, obs.OBS_COMBO_FORMAT_STRING)
    for _, name in ipairs(Easing.NAMES) do
        obs.obs_property_list_add_string(p_easing, name, name)
    end

    obs.obs_properties_add_group(props, "animation", "Ã°Å¸Å½Â¬ Animation", obs.OBS_GROUP_NORMAL, grp_anim)

    --==========================
    -- MOUSE FOLLOW (collapsed)
    --==========================
    local grp_follow = obs.obs_properties_create()

    obs.obs_properties_add_bool(grp_follow, "auto_follow", "Auto-Follow Mouse")
    obs.obs_properties_add_float_slider(grp_follow, "follow_smooth_time", "Smoothness", 0.01, 1.0, 0.01)
    obs.obs_properties_add_int_slider(grp_follow, "follow_dead_zone", "Dead Zone (px)", 0, 500, 1)

    obs.obs_properties_add_group(props, "follow", "Ã°Å¸Å½Â¯ Mouse Follow", obs.OBS_GROUP_NORMAL, grp_follow)

    --==========================
    -- ADVANCED (collapsed)
    --==========================
    local grp_adv = obs.obs_properties_create()
    obs.obs_properties_add_float_slider(grp_adv, "scroll_step", "Scroll Zoom Step", 0.1, 1.0, 0.05)
    obs.obs_properties_add_bool(grp_adv, "debug_logs", "Debug Logging")
    obs.obs_properties_add_group(props, "advanced", "Ã¢Å¡â„¢Ã¯Â¸Â Advanced", obs.OBS_GROUP_NORMAL, grp_adv)

    --==========================
    -- API SERVER (collapsed)
    --==========================
    local grp_api = obs.obs_properties_create()
    obs.obs_properties_add_bool(grp_api, "api_enabled", "Enable UDP API Server")
    obs.obs_properties_add_int(grp_api, "api_port", "API Port", 1024, 65535, 1)
    obs.obs_properties_add_group(props, "api_server", "Ã°Å¸Å’Â UDP API Server", obs.OBS_GROUP_NORMAL, grp_api)

    --==========================
    -- HELP (collapsed)
    --==========================
    local grp_help = obs.obs_properties_create()
    obs.obs_properties_add_text(grp_help, "help_text",
        "QUICK START:\n" ..
        "1. Select your capture source above\n" ..
        "2. Set hotkeys in OBS Settings Ã¢â€ â€™ Hotkeys\n" ..
        "   Ã¢â‚¬Â¢ 'Toggle Zoom to Mouse' Ã¢â‚¬â€ Main zoom\n" ..
        "   Ã¢â‚¬Â¢ 'Toggle Mouse Follow' Ã¢â‚¬â€ Enable/disable follow\n" ..
        "3. Press the hotkey to zoom!\n\n" ..
        "TIPS:\n" ..
        "Ã¢â‚¬Â¢ Zoom centers on mouse position\n" ..
        "Ã¢â‚¬Â¢ Enable Auto-Follow for smooth tracking\n" ..
        "Ã¢â‚¬Â¢ Adjust Dead Zone to reduce jitter",
        obs.OBS_TEXT_INFO)
    obs.obs_properties_add_group(props, "help", "Ã¢Ââ€œ Help", obs.OBS_GROUP_NORMAL, grp_help)

    return props
end

--[[ Called to set default values
--[[ @param data table Settings data
function script_defaults(data)
    obs.obs_data_set_default_string(data, "source", "")
    obs.obs_data_set_default_double(data, "zoom_value", 2.0)
    obs.obs_data_set_default_double(data, "zoom_duration", 0.6)
    obs.obs_data_set_default_double(data, "zoom_overshoot", 0.0)
    obs.obs_data_set_default_string(data, "zoom_easing", "Cubic.Out")
    obs.obs_data_set_default_bool(data, "auto_follow", true)
    obs.obs_data_set_default_double(data, "follow_smooth_time", 0.15)
    obs.obs_data_set_default_int(data, "follow_dead_zone", 5)
    obs.obs_data_set_default_double(data, "scroll_step", 0.25)
    obs.obs_data_set_default_bool(data, "debug_logs", false)
    obs.obs_data_set_default_bool(data, "api_enabled", false)
    obs.obs_data_set_default_int(data, "api_port", 12345)
end

--================================================
-- SCRIPT METADATA
--================================================
script_info = {
    name = "OBS Zoom Pro",
    version = VERSION,
    description = "Intelligent camera zoom functionality with smooth transitions and easing curves.",
    author = "OBS Zoom Pro Team"
}
)
        handle:close()
        if uname == 'Darwin' then
            is_macos = true
            is_linux = false
        end
    end

    return {
        WINDOWS = is_windows,
        LINUX = is_linux,
        MACOS = is_macos
    }
end

local platform = detect_platform()
local IS_WINDOWS = platform.WINDOWS
local IS_LINUX = platform.LINUX
local IS_MACOS = platform.MACOS

-- Log platform detection
log("Platform detected: " .. (jit and jit.os or "Unknown") .. (IS_WINDOWS and " (Full support)" or " (Basic support)"))

-- Virtual key codes (Lua constants instead of C #define)
local VK_LBUTTON = 0x01
local VK_RBUTTON = 0x02
local VK_MBUTTON = 0x04
local VK_CONTROL = 0x11
local VK_SHIFT = 0x10
local VK_MENU = 0x12  -- Alt

-- FFI declarations for Windows (only if FFI is available)


-- Cursor shape constants (Windows)
local CURSOR_ARROW = 1
local CURSOR_IBEAM = 2
local CURSOR_HAND = 3
local CURSOR_WAIT = 4

-- Module state
local Platform = {
    cursor_shape_available = IS_WINDOWS,
    last_mouse = { x = 0, y = 0 },
    last_click = false,
}

-- Get mouse position (cross-platform)
function Platform.get_mouse_pos()
    if IS_WINDOWS then
        local success, pt = pcall(function()
            local pt = ffi.new("POINT")
            if ffi.C.GetCursorPos(pt) ~= 0 then
                return { x = tonumber(pt.x), y = tonumber(pt.y) }
            end
            return nil
        end)
        if success and pt then
            return pt
        end
    elseif IS_LINUX then
        -- Linux: Use xdotool if available, fallback to X11
        local success, result = pcall(function()
            local handle = io.popen("xdotool getmouselocation 2>/dev/null || echo 'x:0 y:0'")
            if handle then
                local output = handle:read("*a")
                handle:close()
                local x, y = output:match("x:(%d+)%s+y:(%d+)")
                if x and y then
                    return { x = tonumber(x), y = tonumber(y) }
                end
            end
            return nil
        end)
        if success and result then
            return result
        end
    elseif IS_MACOS then
        -- macOS: Use osascript
        local success, result = pcall(function()
            local handle = io.popen(--[[osascript -e 'tell application "System Events" to get position of the mouse' 2>/dev/null || echo "0, 0"]])
            if handle then
                local output = handle:read("*a")
                handle:close()
                local x, y = output:match("(%d+),%s*(%d+)")
                if x and y then
                    return { x = tonumber(x), y = tonumber(y) }
                end
            end
            return nil
        end)
        if success and result then
            return result
        end
    end

    -- Fallback
    return { x = 0, y = 0 }
end

-- Check if left mouse button is clicked (Windows only, others return false)
function Platform.is_clicking()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x01) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if a modifier key is held (Windows only)
function Platform.is_key_held(vk_code)
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(vk_code) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if cursor is a pointer/hand (Windows only)
function Platform.is_cursor_pointer()
    if IS_WINDOWS then
        local success, result = pcall(function()
            local ci = ffi.new("CURSORINFO")
            ci.cbSize = ffi.sizeof("CURSORINFO")
            if ffi.C.GetCursorInfo(ci) ~= 0 then
                -- Check if hCursor is a hand pointer
                -- This is a simplified check; real implementation would compare cursor handles
                return ci.flags ~= 0  -- Simplified; actual implementation needs cursor handle comparison
            end
            return false
        end)
        return success and result or false
    end
    return false
end

-- Get cursor shape (Windows only, returns "arrow" for others)
function Platform.get_cursor_shape()
    if IS_WINDOWS then
        local success, result = pcall(function()
            local ci = ffi.new("CURSORINFO")
            ci.cbSize = ffi.sizeof("CURSORINFO")
            if ffi.C.GetCursorInfo(ci) ~= 0 and ci.hCursor ~= nil then
                local addr = tonumber(ffi.cast("uintptr_t", ci.hCursor))
                -- Common cursor IDs (these are typical values, may vary)
                -- IDC_ARROW = 32512, IDC_IBEAM = 32513, IDC_HAND = 32649
                -- We use address ranges as heuristic
                return "arrow"  -- Simplified; actual implementation would map handles
            end
            return "arrow"
        end)
        return success and result or "arrow"
    end
    return "arrow"
end

-- Check if Control key is held
function Platform.is_ctrl_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x11) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if Shift key is held
function Platform.is_shift_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x10) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if Alt key is held
function Platform.is_alt_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x12) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Convenience wrapper functions
function platform_get_mouse_pos()
    return Platform.get_mouse_pos()
end

function platform_is_clicking()
    return Platform.is_clicking()
end

function platform_is_cursor_pointer()
    return Platform.is_cursor_pointer()
end

function platform_cursor_shape_available()
    return Platform.cursor_shape_available
end

function platform_is_ctrl_held()
    return Platform.is_ctrl_held()
end

function platform_is_shift_held()
    return Platform.is_shift_held()
end

function platform_is_alt_held()
    return Platform.is_alt_held()
end

--================================================
-- MODULE: State Machine (M05)
--================================================
-- Manages zoom states and transitions
-- States: IDLE, ZOOMING_IN, ZOOMED_IN, ZOOMING_OUT, SCROLLING, JUMPING

local ZoomState = {
    IDLE         = "idle",
    ZOOMING_IN   = "zooming_in",
    ZOOMED_IN    = "zoomed_in",
    ZOOMING_OUT  = "zooming_out",
    SCROLLING    = "scrolling",    -- Scroll wheel mid-transition
    JUMPING      = "jumping",      -- Bookmark transition
}

local StateMachine = {
    state = ZoomState.IDLE,
    zoom_time = 0,          -- Animation progress (0 Ã¢â€ â€™ 1)
    zoom_level = 1.0,       -- Current zoom factor
    target_level = 1.0,     -- Target zoom factor
    start_crop = nil,       -- Crop at animation start {x, y, w, h}
    target_crop = nil,      -- Crop at animation end {x, y, w, h}
    following = false,      -- Mouse follow active

    -- Transition guards
    can_zoom_in = function(self)
        return self.state == ZoomState.IDLE
    end,

    can_zoom_out = function(self)
        return self.state == ZoomState.ZOOMED_IN
            or self.state == ZoomState.SCROLLING
    end,

    can_scroll = function(self)
        return self.state == ZoomState.ZOOMED_IN
            or self.state == ZoomState.IDLE
            or self.state == ZoomState.SCROLLING
    end,

    can_jump = function(self)
        return self.state ~= ZoomState.ZOOMING_IN
           and self.state ~= ZoomState.ZOOMING_OUT
           and self.state ~= ZoomState.JUMPING
    end,

    is_animating = function(self)
        return self.state == ZoomState.ZOOMING_IN
            or self.state == ZoomState.ZOOMING_OUT
            or self.state == ZoomState.SCROLLING
            or self.state == ZoomState.JUMPING
    end,

    is_zoomed = function(self)
        return self.state ~= ZoomState.IDLE
    end,
}

-- Transition to a new state
function StateMachine:transition(new_state, params)
    local old = self.state
    self.state = new_state
    self.zoom_time = 0

    if params then
        if params.start_crop then self.start_crop = params.start_crop end
        if params.target_crop then self.target_crop = params.target_crop end
        if params.target_level then self.target_level = params.target_level end
    end

    log("State: " .. old .. " Ã¢â€ â€™ " .. new_state)
end

-- Complete the current animation
function StateMachine:complete()
    if self.state == ZoomState.ZOOMING_IN
       or self.state == ZoomState.SCROLLING
       or self.state == ZoomState.JUMPING then
        self.zoom_level = self.target_level
        self.state = ZoomState.ZOOMED_IN
        self.zoom_time = 0
        log("State: " .. self.state .. " Ã¢â€ â€™ ZOOMED_IN (complete)")
    elseif self.state == ZoomState.ZOOMING_OUT then
        self.zoom_level = 1.0
        self.target_level = 1.0
        self.start_crop = nil
        self.target_crop = nil
        self.following = false
        self.state = ZoomState.IDLE
        self.zoom_time = 0
        log("State: ZOOMING_OUT Ã¢â€ â€™ IDLE (complete)")
    end
end

-- Reset to initial state
function StateMachine:reset()
    self.state = ZoomState.IDLE
    self.zoom_time = 0
    self.zoom_level = 1.0
    self.target_level = 1.0
    self.start_crop = nil
    self.target_crop = nil
    self.following = false
    log("StateMachine: Reset to IDLE")
end

-- Get current animation progress (0-1)
function StateMachine:get_progress()
    return clamp(0, 1, self.zoom_time)
end

-- Check if in a specific state
function StateMachine:is_state(state)
    return self.state == state
end

-- Get state name for display
function StateMachine:get_state_name()
    return self.state
end

-- Create a new state machine instance (for testing/isolation)
function StateMachine:new()
    local sm = {}
    setmetatable(sm, { __index = self })
    sm.state = ZoomState.IDLE
    sm.zoom_time = 0
    sm.zoom_level = 1.0
    sm.target_level = 1.0
    sm.start_crop = nil
    sm.target_crop = nil
    sm.following = false
    return sm
end

-- Global state machine instance
local SM = StateMachine:new()

--================================================
-- MODULE: Crop Filter Manager (M07)
--================================================
-- Manages the crop/pad filter used to simulate zoom
-- Creates, updates, and destroys the filter automatically

local FILTER_PREFIX = "[ZoomPro] "
local CROP_FILTER_NAME = FILTER_PREFIX .. "Crop"

local CropFilterManager = {
    filter = nil,           -- The crop filter source
    source = nil,           -- The parent source
    original_crop = nil,    -- Original crop values for restoration
    current_crop = { x = 0, y = 0, w = 0, h = 0 },
    initialized = false,
}

-- Create the crop filter on a source
function CropFilterManager:create(source)
    if not source then
        log("CropFilter: No source provided")
        return false
    end

    self:cleanup()  -- Clean up any existing filter
    self.source = source

    -- Check if our filter already exists
    local existing = obs.obs_source_get_filter_by_name(source, CROP_FILTER_NAME)
    if existing then
        log("CropFilter: Found existing filter")
        self.filter = existing
        self.initialized = true
        return true
    end

    -- Create new crop/pad filter
    local settings = obs.obs_data_create()
    obs.obs_data_set_int(settings, "left", 0)
    obs.obs_data_set_int(settings, "top", 0)
    obs.obs_data_set_int(settings, "right", 0)
    obs.obs_data_set_int(settings, "bottom", 0)
    obs.obs_data_set_bool(settings, "relative", false)  -- Absolute positioning

    self.filter = obs.obs_source_create_private(
        "crop_filter",      -- Filter type
        CROP_FILTER_NAME,   -- Filter name
        settings            -- Settings
    )

    obs.obs_data_release(settings)

    if not self.filter then
        log("CropFilter: Failed to create filter")
        return false
    end

    -- Add filter to source
    obs.obs_source_filter_add(source, self.filter)

    -- Store original crop (none)
    self.original_crop = { x = 0, y = 0, w = 0, h = 0 }

    self.initialized = true
    log("CropFilter: Created successfully")
    return true
end

-- Update the crop filter with new values
function CropFilterManager:update(x, y, w, h)
    if not self.filter or not self.initialized then
        return false
    end

    -- Store current crop
    self.current_crop = { x = x, y = y, w = w, h = h }

    -- Get filter settings
    local settings = obs.obs_source_get_settings(self.filter)
    if not settings then
        return false
    end

    -- Calculate crop values
    -- For crop_filter: left, top are absolute position
    -- right, bottom are width/height from right/bottom edge
    -- We need to convert our x, y, w, h to this format

    -- Get source dimensions
    local source_w = obs.obs_source_get_width(self.source)
    local source_h = obs.obs_source_get_height(self.source)

    if source_w == 0 or source_h == 0 then
        obs.obs_data_release(settings)
        return false
    end

    -- Set crop values
    -- left = x offset from left
    -- top = y offset from top
    -- right = source_w - (x + w) = remaining width on right
    -- bottom = source_h - (y + h) = remaining height on bottom
    local left = math.floor(x)
    local top = math.floor(y)
    local right = math.floor(source_w - (x + w))
    local bottom = math.floor(source_h - (y + h))

    -- Clamp to valid values
    left = math.max(0, left)
    top = math.max(0, top)
    right = math.max(0, right)
    bottom = math.max(0, bottom)

    obs.obs_data_set_int(settings, "left", left)
    obs.obs_data_set_int(settings, "top", top)
    obs.obs_data_set_int(settings, "right", right)
    obs.obs_data_set_int(settings, "bottom", bottom)

    -- Update the filter
    obs.obs_source_update(self.filter, settings)
    obs.obs_data_release(settings)

    return true
end

-- Get current crop values
function CropFilterManager:get_crop()
    return self.current_crop
end

-- Reset crop to original (no crop)
function CropFilterManager:reset()
    if not self.filter or not self.initialized then
        return false
    end

    local settings = obs.obs_source_get_settings(self.filter)
    if settings then
        obs.obs_data_set_int(settings, "left", 0)
        obs.obs_data_set_int(settings, "top", 0)
        obs.obs_data_set_int(settings, "right", 0)
        obs.obs_data_set_int(settings, "bottom", 0)
        obs.obs_source_update(self.filter, settings)
        obs.obs_data_release(settings)
    end

    self.current_crop = { x = 0, y = 0, w = 0, h = 0 }
    return true
end

-- Remove the filter and restore original state
function CropFilterManager:cleanup()
    if self.filter and self.source then
        -- Reset to no crop first
        self:reset()

        -- Remove filter from source
        obs.obs_source_filter_remove(self.source, self.filter)
        obs.obs_source_release(self.filter)
        self.filter = nil
        log("CropFilter: Removed from source")
    end

    self.source = nil
    self.original_crop = nil
    self.current_crop = { x = 0, y = 0, w = 0, h = 0 }
    self.initialized = false
end

-- Check if filter is ready
function CropFilterManager:is_ready()
    return self.initialized and self.filter ~= nil
end

-- Get source dimensions
function CropFilterManager:get_source_size()
    if not self.source then
        return 0, 0
    end
    return obs.obs_source_get_width(self.source), obs.obs_source_get_height(self.source)
end

-- Convenience wrapper functions
function crop_filter_create(source)
    return CropFilterManager:create(source)
end

function crop_filter_update(x, y, w, h)
    return CropFilterManager:update(x, y, w, h)
end

function crop_filter_reset()
    return CropFilterManager:reset()
end

function crop_filter_cleanup()
    return CropFilterManager:cleanup()
end

function crop_filter_is_ready()
    return CropFilterManager:is_ready()
end

function crop_filter_get_crop()
    return CropFilterManager:get_crop()
end

function crop_filter_get_source_size()
    return CropFilterManager:get_source_size()
end

--================================================
-- MODULE: Source Manager (M08)
--================================================
-- Handles finding sources in scenes, capturing transforms,
-- and managing source state for zoom operations

local SourceManager = {
    source = nil,           -- Current zoom source
    sceneitem = nil,        -- Scene item reference
    scene = nil,            -- Current scene
    original_transform = nil, -- Saved original transform
    source_name = "",       -- Source name for settings
    initialized = false,
}

-- Transform data structure
local TransformData = {
    pos = { x = 0, y = 0 },
    scale = { x = 1.0, y = 1.0 },
    rot = 0,
    bounds_type = 0,
    bounds = { x = 0, y = 0 },
    crop = { left = 0, top = 0, right = 0, bottom = 0 },
}

-- Find a source in a scene (BFS through groups)
function SourceManager:find_sceneitem(scene, source_name)
    if not scene or not source_name then
        return nil
    end

    local scene_source = obs.obs_scene_from_source(scene)
    if not scene_source then
        return nil
    end

    -- BFS queue
    local queue = {}
    table.insert(queue, scene_source)

    while #queue > 0 do
        local current_scene = table.remove(queue, 1)

        -- Iterate through items
        local items = obs.obs_scene_enum_items(current_scene)
        if items then
            for _, item in ipairs(items) do
                local item_source = obs.obs_sceneitem_get_source(item)
                if item_source then
                    local name = obs.obs_source_get_name(item_source)

                    -- Check if this is our target
                    if name == source_name then
                        obs.sceneitem_list_release(items)
                        return item
                    end

                    -- Check if this is a group (nested scene)
                    if obs.obs_source_get_type(item_source) == obs.OBS_SOURCE_TYPE_INPUT then
                        local id = obs.obs_source_get_id(item_source)
                        if id == "group" then
                            local group_scene = obs.obs_group_from_source(item_source)
                            if group_scene then
                                table.insert(queue, group_scene)
                            end
                        end
                    end
                end
            end
            obs.sceneitem_list_release(items)
        end
    end

    return nil
end

-- Capture the current transform of a scene item
function SourceManager:capture_transform(sceneitem)
    if not sceneitem then
        return nil
    end

    local transform = {}

    -- Position
    local pos = obs.vec2()
    obs.obs_sceneitem_get_pos(sceneitem, pos)
    transform.pos = { x = pos.x, y = pos.y }

    -- Scale
    local scale = obs.vec2()
    obs.obs_sceneitem_get_scale(sceneitem, scale)
    transform.scale = { x = scale.x, y = scale.y }

    -- Rotation
    transform.rot = obs.obs_sceneitem_get_rot(sceneitem)

    -- Bounds
    transform.bounds_type = obs.obs_sceneitem_get_bounds_type(sceneitem)
    local bounds = obs.vec2()
    obs.obs_sceneitem_get_bounds(sceneitem, bounds)
    transform.bounds = { x = bounds.x, y = bounds.y }

    -- Crop
    local crop = obs.obs_sceneitem_crop()
    obs.obs_sceneitem_get_crop(sceneitem, crop)
    transform.crop = {
        left = crop.left,
        top = crop.top,
        right = crop.right,
        bottom = crop.bottom
    }

    return transform
end

-- Restore a saved transform to a scene item
function SourceManager:restore_transform(sceneitem, transform)
    if not sceneitem or not transform then
        return false
    end

    -- Position
    local pos = obs.vec2()
    pos.x = transform.pos.x
    pos.y = transform.pos.y
    obs.obs_sceneitem_set_pos(sceneitem, pos)

    -- Scale
    local scale = obs.vec2()
    scale.x = transform.scale.x
    scale.y = transform.scale.y
    obs.obs_sceneitem_set_scale(sceneitem, scale)

    -- Rotation
    obs.obs_sceneitem_set_rot(sceneitem, transform.rot)

    -- Bounds
    obs.obs_sceneitem_set_bounds_type(sceneitem, transform.bounds_type)
    local bounds = obs.vec2()
    bounds.x = transform.bounds.x
    bounds.y = transform.bounds.y
    obs.obs_sceneitem_set_bounds(sceneitem, bounds)

    -- Crop
    local crop = obs.obs_sceneitem_crop()
    crop.left = transform.crop.left
    crop.top = transform.crop.top
    crop.right = transform.crop.right
    crop.bottom = transform.crop.bottom
    obs.obs_sceneitem_set_crop(sceneitem, crop)

    return true
end

-- Initialize with a source name
function SourceManager:init(source_name)
    self:release()  -- Clean up any existing state

    if not source_name or source_name == "" then
        log("SourceManager: No source name provided")
        return false
    end

    self.source_name = source_name

    -- Get current scene
    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then
        log("SourceManager: No current scene")
        return false
    end

    self.scene = scene_source

    -- Find the scene item
    self.sceneitem = self:find_sceneitem(scene_source, source_name)
    if not self.sceneitem then
        log("SourceManager: Source not found in scene: " .. source_name)
        obs.obs_source_release(scene_source)
        return false
    end

    -- Get the source
    self.source = obs.obs_sceneitem_get_source(self.sceneitem)
    if not self.source then
        log("SourceManager: Failed to get source from sceneitem")
        obs.obs_source_release(scene_source)
        return false
    end

    -- Capture original transform
    self.original_transform = self:capture_transform(self.sceneitem)

    -- Create crop filter
    if not crop_filter_create(self.source) then
        log("SourceManager: Failed to create crop filter")
        obs.obs_source_release(scene_source)
        return false
    end

    self.initialized = true
    log("SourceManager: Initialized with source: " .. source_name)

    obs.obs_source_release(scene_source)
    return true
end

-- Release all resources
function SourceManager:release()
    -- Clean up crop filter
    crop_filter_cleanup()

    -- Restore original transform if we have it
    if self.sceneitem and self.original_transform then
        self:restore_transform(self.sceneitem, self.original_transform)
        log("SourceManager: Restored original transform")
    end

    self.source = nil
    self.sceneitem = nil
    self.scene = nil
    self.original_transform = nil
    self.initialized = false

    log("SourceManager: Released")
end

-- Get source dimensions
function SourceManager:get_source_size()
    if not self.source then
        return 0, 0
    end
    return obs.obs_source_get_width(self.source), obs.obs_source_get_height(self.source)
end

-- Check if source is valid
function SourceManager:is_valid()
    return self.initialized and self.source ~= nil and self.sceneitem ~= nil
end

-- Get source info
function SourceManager:get_info()
    if not self:is_valid() then
        return nil
    end

    return {
        name = self.source_name,
        width = obs.obs_source_get_width(self.source),
        height = obs.obs_source_get_height(self.source),
    }
end

-- Get list of available capture sources
function SourceManager.get_available_sources()
    local sources = {}

    -- Get all sources
    local source_list = obs.obs_enum_sources()
    if source_list then
        for _, source in ipairs(source_list) do
            local source_id = obs.obs_source_get_id(source)
            local name = obs.obs_source_get_name(source)

            -- Filter for capture sources
            local is_capture = false
            if source_id == "monitor_capture" or      -- Display capture
               source_id == "window_capture" or       -- Window capture
               source_id == "game_capture" or         -- Game capture
               source_id == "xshm_input" or           -- Linux X11 capture
               source_id == "av_capture_input" then   -- macOS capture
                is_capture = true
            end

            if is_capture then
                table.insert(sources, {
                    name = name,
                    id = source_id,
                })
            end
        end
        obs.source_list_release(source_list)
    end

    return sources
end

-- Convenience wrapper functions
function source_manager_init(source_name)
    return SourceManager:init(source_name)
end

function source_manager_release()
    return SourceManager:release()
end

function source_manager_is_valid()
    return SourceManager:is_valid()
end

function source_manager_get_source()
    return SourceManager.source
end

function source_manager_get_sceneitem()
    return SourceManager.sceneitem
end

function source_manager_get_size()
    return SourceManager:get_source_size()
end

function source_manager_get_available_sources()
    return SourceManager.get_available_sources()
end

--================================================
-- MODULE: Camera Physics (M06)
--================================================
-- Handles camera position calculations, dead zones,
-- and SmoothDamp-based camera movement

local CameraPhysics = {
    -- Smoothed camera position
    pos = { x = 0, y = 0 },

    -- Velocities for SmoothDamp
    vel_x = { val = 0 },
    vel_y = { val = 0 },

    -- Dead zone state
    tracked_pos = { x = 0, y = 0 },
    dead_zone_active = false,

    -- Last camera position (for velocity calculation)
    last_pos = { x = 0, y = 0 },

    -- Monitor offset (for multi-monitor setups)
    monitor_offset = { x = 0, y = 0 },
}

-- Initialize camera tracking with starting position
function CameraPhysics:init(mouse_pos)
    if mouse_pos then
        self.pos.x = mouse_pos.x
        self.pos.y = mouse_pos.y
        self.tracked_pos.x = mouse_pos.x
        self.tracked_pos.y = mouse_pos.y
    end
    self.vel_x.val = 0
    self.vel_y.val = 0
    self.last_pos.x = self.pos.x
    self.last_pos.y = self.pos.y
end

-- Apply dead zone to mouse input
-- Returns the position the camera should track
function CameraPhysics:apply_dead_zone(mouse_pos, dead_zone_radius)
    if not mouse_pos then
        return self.tracked_pos
    end

    if dead_zone_radius <= 0 then
        self.tracked_pos.x = mouse_pos.x
        self.tracked_pos.y = mouse_pos.y
        return self.tracked_pos
    end

    -- Calculate distance from tracked position to mouse
    local dx = mouse_pos.x - self.tracked_pos.x
    local dy = mouse_pos.y - self.tracked_pos.y
    local dist = math.sqrt(dx * dx + dy * dy)

    if dist <= dead_zone_radius then
        -- Mouse is within dead zone, don't move tracked position
        self.dead_zone_active = true
        return self.tracked_pos
    end

    -- Mouse is outside dead zone
    -- Move tracked position so it stays exactly dead_zone_radius from mouse
    self.dead_zone_active = false
    local excess = dist - dead_zone_radius
    local nx = dx / dist  -- Normalized direction
    local ny = dy / dist

    self.tracked_pos.x = self.tracked_pos.x + nx * excess
    self.tracked_pos.y = self.tracked_pos.y + ny * excess

    return self.tracked_pos
end

-- Smooth the input position using SmoothDamp
function CameraPhysics:smooth_input(target_pos, smooth_time, dt)
    if not target_pos then
        return self.pos
    end

    local max_speed = 100000  -- Very high max speed for smooth camera

    self.pos.x = SmoothDamp(self.pos.x, target_pos.x, self.vel_x, smooth_time, max_speed, dt)
    self.pos.y = SmoothDamp(self.pos.y, target_pos.y, self.vel_y, smooth_time, max_speed, dt)

    return self.pos
end

-- Calculate the crop rectangle for a given zoom level and center position
function CameraPhysics:compute_crop(center_x, center_y, zoom_level, source_w, source_h)
    if zoom_level <= 1.0 then
        -- No zoom, return full source
        return {
            x = 0,
            y = 0,
            w = source_w,
            h = source_h,
        }
    end

    -- Calculate crop dimensions
    local crop_w = source_w / zoom_level
    local crop_h = source_h / zoom_level

    -- Center the crop on the target position
    local crop_x = center_x - crop_w / 2
    local crop_y = center_y - crop_h / 2

    -- Clamp to source bounds
    crop_x = clamp(0, source_w - crop_w, crop_x)
    crop_y = clamp(0, source_h - crop_h, crop_y)

    return {
        x = crop_x,
        y = crop_y,
        w = crop_w,
        h = crop_h,
    }
end

-- Calculate target crop for zoom animation
-- mouse_pos: current mouse position
-- zoom_level: target zoom level
-- source_w, source_h: source dimensions
-- monitor_offset: offset for multi-monitor (optional)
function CameraPhysics:get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
    if not mouse_pos then
        return nil
    end

    -- Apply monitor offset if provided
    local target_x = mouse_pos.x
    local target_y = mouse_pos.y

    if monitor_offset then
        target_x = target_x - monitor_offset.x
        target_y = target_y - monitor_offset.y
    end

    -- Clamp to source bounds
    target_x = clamp(0, source_w, target_x)
    target_y = clamp(0, source_h, target_y)

    return self:compute_crop(target_x, target_y, zoom_level, source_w, source_h)
end

-- Interpolate between two crop rectangles
function CameraPhysics:lerp_crop(start_crop, end_crop, t, easing_fn)
    if not start_crop or not end_crop then
        return nil
    end

    t = clamp(0, 1, t)

    -- Apply easing
    local eased_t = easing_fn and easing_fn(t) or t

    return {
        x = lerp(start_crop.x, end_crop.x, eased_t),
        y = lerp(start_crop.y, end_crop.y, eased_t),
        w = lerp(start_crop.w, end_crop.w, eased_t),
        h = lerp(start_crop.h, end_crop.h, eased_t),
    }
end

-- Get camera velocity (for motion blur)
function CameraPhysics:get_velocity()
    return {
        x = self.pos.x - self.last_pos.x,
        y = self.pos.y - self.last_pos.y,
    }
end

-- Update last position (call at end of frame)
function CameraPhysics:update_last_pos()
    self.last_pos.x = self.pos.x
    self.last_pos.y = self.pos.y
end

-- Set monitor offset
function CameraPhysics:set_monitor_offset(offset)
    self.monitor_offset = offset or { x = 0, y = 0 }
end

-- Reset camera state
function CameraPhysics:reset()
    self.pos = { x = 0, y = 0 }
    self.vel_x = { val = 0 }
    self.vel_y = { val = 0 }
    self.tracked_pos = { x = 0, y = 0 }
    self.dead_zone_active = false
    self.last_pos = { x = 0, y = 0 }
end

-- Convenience wrapper functions
function camera_physics_init(mouse_pos)
    return CameraPhysics:init(mouse_pos)
end

function camera_physics_apply_dead_zone(mouse_pos, dead_zone_radius)
    return CameraPhysics:apply_dead_zone(mouse_pos, dead_zone_radius)
end

function camera_physics_smooth_input(target_pos, smooth_time, dt)
    return CameraPhysics:smooth_input(target_pos, smooth_time, dt)
end

function camera_physics_compute_crop(center_x, center_y, zoom_level, source_w, source_h)
    return CameraPhysics:compute_crop(center_x, center_y, zoom_level, source_w, source_h)
end

function camera_physics_get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
    return CameraPhysics:get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
end

function camera_physics_lerp_crop(start_crop, end_crop, t, easing_fn)
    return CameraPhysics:lerp_crop(start_crop, end_crop, t, easing_fn)
end

function camera_physics_get_velocity()
    return CameraPhysics:get_velocity()
end

function camera_physics_update_last_pos()
    return CameraPhysics:update_last_pos()
end

function camera_physics_reset()
    return CameraPhysics:reset()
end

--================================================
-- MODULE: Timer & Main Loop (M09)
--================================================
-- Core integration module that handles frame-by-frame updates,
-- input processing, state machine updates, and output

-- Configuration (will be populated from settings)
local cfg = {
    source_name = "",
    zoom_value = 2.0,
    max_zoom = 10.0,
    zoom_duration = 0.6,
    zoom_overshoot = 0.0,
    zoom_easing = "Cubic.Out",

    auto_follow = true,
    follow_smooth_time = 0.15,
    follow_dead_zone = 5,

    debug_logs = false,
}

-- Timing
local last_tick_time = 0
local timer_running = false

-- Frame diff tracking (skip updates if nothing changed)
local last_output = { x = -1, y = -1, w = -1, h = -1 }

-- Original crop for zoom out
local original_crop = { x = 0, y = 0, w = 0, h = 0 }

-- Hotkey IDs
local hotkey_toggle_zoom = nil
local hotkey_toggle_follow = nil

-- Get reliable delta time
local function get_dt()
    local now = os.clock()
    local dt = now - last_tick_time
    last_tick_time = now
    return clamp(0.001, 0.1, dt)  -- Guard against freezes and div/zero
end

-- Start the timer
local function start_timer()
    if not timer_running then
        timer_running = true
        last_tick_time = os.clock()
        -- Use frame-synced interval
        local interval = 16  -- Default to ~60fps
        obs.timer_add(on_timer, interval)
        log("Timer: Started")
    end
end

-- Stop the timer
local function stop_timer()
    if timer_running then
        timer_running = false
        obs.timer_remove(on_timer)
        log("Timer: Stopped")
    end
end

-- Initialize mouse tracking
local function init_mouse_tracking(mouse_pos)
    camera_physics_init(mouse_pos)
    original_crop = {
        x = 0,
        y = 0,
        w = 0,
        h = 0,
    }
end

-- Main timer callback
function on_timer()
    local dt = get_dt()

    -- Guard: No valid source
    if not source_manager_is_valid() then
        return
    end

    --==========================
    -- 1. INPUT
    --==========================
    local raw_mouse = platform_get_mouse_pos()

    --==========================
    -- 2. STATE MACHINE UPDATE
    --==========================
    if SM:is_animating() then
        SM.zoom_time = SM.zoom_time + (dt / cfg.zoom_duration)

        -- Check for completion
        if SM.zoom_time >= 1.0 then
            SM:complete()

            -- Auto-enable follow after zoom in
            if SM.state == ZoomState.ZOOMED_IN and cfg.auto_follow then
                SM.following = true
            end

            -- Stop timer if idle
            if SM.state == ZoomState.IDLE then
                stop_timer()
            end
        end
    end

    --==========================
    -- 3. CAMERA POSITION
    --==========================
    local crop = nil
    local source_w, source_h = source_manager_get_size()

    if source_w == 0 or source_h == 0 then
        return
    end

    if SM:is_animating() then
        -- Animate between start and target crop
        local easing_fn = Easing.get(cfg.zoom_easing, cfg.zoom_overshoot)
        crop = camera_physics_lerp_crop(SM.start_crop, SM.target_crop, SM.zoom_time, easing_fn)
    elseif SM:is_zoomed() and SM.following then
        -- Follow mouse with dead zone and smoothing
        local tracked = camera_physics_apply_dead_zone(raw_mouse, cfg.follow_dead_zone)
        local smoothed = camera_physics_smooth_input(tracked, cfg.follow_smooth_time, dt)
        crop = camera_physics_compute_crop(smoothed.x, smoothed.y, SM.zoom_level, source_w, source_h)
        camera_physics_update_last_pos()
    elseif SM:is_zoomed() then
        -- Static zoom (not following)
        crop = camera_physics_get_target_crop(
            { x = SM.target_crop.x + SM.target_crop.w / 2, y = SM.target_crop.y + SM.target_crop.h / 2 },
            SM.zoom_level, source_w, source_h, nil
        )
    end

    --==========================
    -- 4. OUTPUT (Diff-based)
    --==========================
    if crop then
        local cx = math.floor(crop.x)
        local cy = math.floor(crop.y)
        local cw = math.floor(crop.w)
        local ch = math.floor(crop.h)

        if cx ~= last_output.x or cy ~= last_output.y or
           cw ~= last_output.w or ch ~= last_output.h then
            crop_filter_update(cx, cy, cw, ch)
            last_output.x = cx
            last_output.y = cy
            last_output.w = cw
            last_output.h = ch
        end
    end
end

--==========================
-- HOTKEY HANDLERS
--==========================

function on_toggle_zoom(pressed)
    if not pressed then return end

    if not source_manager_is_valid() then
        log("Toggle Zoom: No valid source")
        return
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        log("Toggle Zoom: Invalid source dimensions")
        return
    end

    if SM.state == ZoomState.IDLE then
        -- ZOOM IN
        local mouse = platform_get_mouse_pos()
        init_mouse_tracking(mouse)

        -- Store original crop
        original_crop = { x = 0, y = 0, w = source_w, h = source_h }

        -- Calculate target crop
        local target_crop = camera_physics_get_target_crop(mouse, cfg.zoom_value, source_w, source_h, nil)

        SM:transition(ZoomState.ZOOMING_IN, {
            start_crop = original_crop,
            target_crop = target_crop,
            target_level = cfg.zoom_value
        })

        start_timer()

    elseif SM.state == ZoomState.ZOOMED_IN then
        -- ZOOM OUT
        SM.following = false

        local current = crop_filter_get_crop()
        SM:transition(ZoomState.ZOOMING_OUT, {
            start_crop = current,
            target_crop = original_crop,
            target_level = 1.0
        })

        start_timer()
    end
    -- Ignore if already animating (guard against rapid presses)
end

function on_toggle_follow(pressed)
    if not pressed then return end
    if not SM:is_zoomed() then return end

    SM.following = not SM.following
    log("Follow: " .. tostring(SM.following))

    if SM.following and not timer_running then
        start_timer()
    end
end

--==========================
-- HOTKEY REGISTRATION
--==========================

local function register_hotkeys(settings)
    -- Toggle Zoom hotkey
    hotkey_toggle_zoom = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.toggle_zoom",
        "Toggle Zoom to Mouse",
        on_toggle_zoom
    )

    -- Toggle Follow hotkey
    hotkey_toggle_follow = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.toggle_follow",
        "Toggle Mouse Follow",
        on_toggle_follow
    )

    -- Load saved hotkey bindings
    local toggle_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.toggle_zoom")
    if toggle_array then
        obs.obs_hotkey_load(hotkey_toggle_zoom, toggle_array)
        obs.obs_data_array_release(toggle_array)
    end

    local follow_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.toggle_follow")
    if follow_array then
        obs.obs_hotkey_load(hotkey_toggle_follow, follow_array)
        obs.obs_data_array_release(follow_array)
    end

    -- Register scroll zoom hotkeys
    register_scroll_hotkeys(settings)

    log("Hotkeys: Registered")
end

local function save_hotkeys(settings)
    if hotkey_toggle_zoom then
        local array = obs.obs_hotkey_save(hotkey_toggle_zoom)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.toggle_zoom", array)
        obs.obs_data_array_release(array)
    end

    if hotkey_toggle_follow then
        local array = obs.obs_hotkey_save(hotkey_toggle_follow)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.toggle_follow", array)
        obs.obs_data_array_release(array)
    end

    -- Save scroll zoom hotkeys
    save_scroll_hotkeys(settings)
end

local function unregister_hotkeys()
    if hotkey_toggle_zoom then
        obs.obs_hotkey_unregister(hotkey_toggle_zoom)
        hotkey_toggle_zoom = nil
    end
    if hotkey_toggle_follow then
        obs.obs_hotkey_unregister(hotkey_toggle_follow)
        hotkey_toggle_follow = nil
    end
    -- Unregister scroll zoom hotkeys
    unregister_scroll_hotkeys()
    log("Hotkeys: Unregistered")
end

--==========================
-- SCENE EVENT HANDLERS
--==========================

function on_frontend_event(event)
    if event == obs.OBS_FRONTEND_EVENT_SCENE_CHANGED then
        -- Scene changed, re-acquire source
        log("Event: Scene changed")

        -- Handle scene memory
        scene_memory_on_scene_change()

        if cfg.source_name and cfg.source_name ~= "" then
            source_manager_release()
            source_manager_init(cfg.source_name)
        end
    elseif event == obs.OBS_FRONTEND_EVENT_EXIT then
        -- OBS is closing
        log("Event: OBS exiting")
        stop_timer()
        source_manager_release()
    end
end

--==========================
-- CONFIGURATION UPDATE
--==========================

local function update_config(settings)
    cfg.source_name = obs.obs_data_get_string(settings, "source") or ""
    cfg.zoom_value = obs.obs_data_get_double(settings, "zoom_value")
    cfg.zoom_duration = obs.obs_data_get_double(settings, "zoom_duration")
    cfg.zoom_overshoot = obs.obs_data_get_double(settings, "zoom_overshoot")
    cfg.zoom_easing = obs.obs_data_get_string(settings, "zoom_easing") or "Cubic.Out"

    cfg.auto_follow = obs.obs_data_get_bool(settings, "auto_follow")
    cfg.follow_smooth_time = obs.obs_data_get_double(settings, "follow_smooth_time")
    cfg.follow_dead_zone = obs.obs_data_get_int(settings, "follow_dead_zone")

    cfg.debug_logs = obs.obs_data_get_bool(settings, "debug_logs")
    debug_logs = cfg.debug_logs

    -- Update scroll zoom config
    update_scroll_config(settings)

    -- Check if source changed
    local current_source = source_manager_is_valid() and cfg.source_name
    if cfg.source_name ~= "" and cfg.source_name ~= current_source then
        -- Reset state and reinitialize
        SM:reset()
        stop_timer()
        source_manager_release()
        source_manager_init(cfg.source_name)
    end
end

--================================================
-- MODULE: Scroll Zoom (M10)
--================================================
-- Enables gradual zoom control via scroll wheel with modifier key
-- Provides dynamic zoom level adjustment during zoomed state

local ScrollZoom = {
    -- Hotkey IDs for scroll zoom
    hotkey_scroll_up = nil,
    hotkey_scroll_down = nil,

    -- Configuration (populated from settings)
    scroll_step = 0.25,
    scroll_modifier = "ctrl",  -- "ctrl", "alt", "shift"
}

-- Check if modifier key is held
local function is_modifier_held()
    if ScrollZoom.scroll_modifier == "ctrl" then
        return platform_is_ctrl_held()
    elseif ScrollZoom.scroll_modifier == "alt" then
        return platform_is_alt_held()
    elseif ScrollZoom.scroll_modifier == "shift" then
        return platform_is_shift_held()
    end
    return false
end

-- Handle scroll zoom in
function on_scroll_zoom_up(pressed)
    if not pressed then return end
    on_scroll_zoom(1)
end

-- Handle scroll zoom out
function on_scroll_zoom_down(pressed)
    if not pressed then return end
    on_scroll_zoom(-1)
end

-- Main scroll zoom handler
function on_scroll_zoom(direction)
    -- Check if we can scroll
    if not SM:can_scroll() then return end

    -- Check modifier (optional - can be configured)
    -- For now, we rely on OBS hotkey bindings which can include modifiers

    if not source_manager_is_valid() then
        log("Scroll Zoom: No valid source")
        return
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        return
    end

    -- Calculate new zoom level
    local step = ScrollZoom.scroll_step * direction  -- e.g., 0.25
    local new_level

    if SM.state == ZoomState.IDLE then
        -- Starting from unzoomed
        new_level = 1.0 + step
    else
        -- Already zoomed, adjust level
        new_level = SM.target_level + step
    end

    -- Clamp to valid range
    new_level = clamp(1.0, cfg.max_zoom, new_level)

    -- If we hit 1.0, fully zoom out
    if new_level <= 1.0 then
        if SM:is_zoomed() then
            -- Trigger full zoom out
            local current = crop_filter_get_crop()
            SM.following = false
            SM:transition(ZoomState.ZOOMING_OUT, {
                start_crop = current,
                target_crop = original_crop,
                target_level = 1.0
            })
            start_timer()
        end
        return
    end

    -- Get current mouse position
    local mouse = platform_get_mouse_pos()

    -- Calculate new target crop for new zoom level
    local target_crop = camera_physics_get_target_crop(mouse, new_level, source_w, source_h, nil)

    -- Get current crop as start
    local start_crop
    if SM:is_animating() then
        -- Use current interpolated crop
        start_crop = crop_filter_get_crop()
    elseif SM:is_zoomed() then
        -- Use current crop
        start_crop = crop_filter_get_crop()
    else
        -- Starting from unzoomed
        start_crop = { x = 0, y = 0, w = source_w, h = source_h }
        original_crop = start_crop
        camera_physics_init(mouse)
    end

    -- Transition to new zoom level
    if SM.state == ZoomState.IDLE then
        -- First scroll from unzoomed
        SM:transition(ZoomState.SCROLLING, {
            start_crop = start_crop,
            target_crop = target_crop,
            target_level = new_level
        })
    else
        -- Already zoomed, adjust level (interrupt current animation)
        SM:transition(ZoomState.SCROLLING, {
            start_crop = start_crop,
            target_crop = target_crop,
            target_level = new_level
        })
    end

    start_timer()
    log("Scroll Zoom: Level " .. string.format("%.2f", new_level))
end

-- Zoom to a specific level (for API calls)
function on_scroll_zoom_to(level)
    if not source_manager_is_valid() then return end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then return end

    level = clamp(1.0, cfg.max_zoom, level)

    if level <= 1.0 then
        -- Zoom out
        if SM:is_zoomed() then
            local current = crop_filter_get_crop()
            SM.following = false
            SM:transition(ZoomState.ZOOMING_OUT, {
                start_crop = current,
                target_crop = original_crop,
                target_level = 1.0
            })
            start_timer()
        end
        return
    end

    local mouse = platform_get_mouse_pos()
    local target_crop = camera_physics_get_target_crop(mouse, level, source_w, source_h, nil)

    local start_crop
    if SM:is_zoomed() then
        start_crop = crop_filter_get_crop()
    else
        start_crop = { x = 0, y = 0, w = source_w, h = source_h }
        original_crop = start_crop
        camera_physics_init(mouse)
    end

    SM:transition(ZoomState.SCROLLING, {
        start_crop = start_crop,
        target_crop = target_crop,
        target_level = level
    })

    start_timer()
end

-- Register scroll zoom hotkeys
local function register_scroll_hotkeys(settings)
    -- Scroll Up hotkey
    ScrollZoom.hotkey_scroll_up = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.scroll_up",
        "Zoom In (Scroll)",
        on_scroll_zoom_up
    )

    -- Scroll Down hotkey
    ScrollZoom.hotkey_scroll_down = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.scroll_down",
        "Zoom Out (Scroll)",
        on_scroll_zoom_down
    )

    -- Load saved bindings
    local up_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.scroll_up")
    if up_array then
        obs.obs_hotkey_load(ScrollZoom.hotkey_scroll_up, up_array)
        obs.obs_data_array_release(up_array)
    end

    local down_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.scroll_down")
    if down_array then
        obs.obs_hotkey_load(ScrollZoom.hotkey_scroll_down, down_array)
        obs.obs_data_array_release(down_array)
    end

    log("Scroll Zoom: Hotkeys registered")
end

-- Save scroll hotkey bindings
local function save_scroll_hotkeys(settings)
    if ScrollZoom.hotkey_scroll_up then
        local array = obs.obs_hotkey_save(ScrollZoom.hotkey_scroll_up)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.scroll_up", array)
        obs.obs_data_array_release(array)
    end

    if ScrollZoom.hotkey_scroll_down then
        local array = obs.obs_hotkey_save(ScrollZoom.hotkey_scroll_down)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.scroll_down", array)
        obs.obs_data_array_release(array)
    end
end

-- Unregister scroll hotkeys
local function unregister_scroll_hotkeys()
    if ScrollZoom.hotkey_scroll_up then
        obs.obs_hotkey_unregister(ScrollZoom.hotkey_scroll_up)
        ScrollZoom.hotkey_scroll_up = nil
    end
    if ScrollZoom.hotkey_scroll_down then
        obs.obs_hotkey_unregister(ScrollZoom.hotkey_scroll_down)
        ScrollZoom.hotkey_scroll_down = nil
    end
end

-- Update scroll zoom config
local function update_scroll_config(settings)
    ScrollZoom.scroll_step = obs.obs_data_get_double(settings, "scroll_step")
    ScrollZoom.scroll_modifier = obs.obs_data_get_string(settings, "scroll_modifier") or "ctrl"
end

--================================================
-- PLACEHOLDER: Future Modules
--================================================

-- M01: Configuration & Settings (TODO)
-- M05: Scene Manager (TODO)
-- M06: Source Manager (TODO)
-- M07: Crop/Zoom Controller (TODO)
-- M08: Motion Tracker (TODO)
-- M09: Face Detection (TODO)
-- M11: Audio Reactor (TODO)
-- M12: Transition Manager (TODO)
-- M13: Animation Controller (TODO)
-- M14: Preset Manager (TODO)
-- M15: Hotkey Manager (TODO)
-- M16: UI Components (TODO)
-- M17: Timer/Scheduler (TODO)
-- M18: State Machine (TODO)
-- M19: Performance Monitor (TODO)

--================================================
-- SCRIPT SETTINGS
--================================================
local settings = {}

-- Default settings
local defaults = {
    debug_logging = false,
    easing_type = "QuadInOut",
    smooth_time = 0.3,
    max_speed = 100.0
}

--================================================
-- MODULE: Preset Manager (M13)
--================================================
-- Manages built-in and custom animation presets

local PresetManager = {
    -- Built-in presets (read-only)
    built_in = {
        {
            name = "Smooth",
            duration = 0.8,
            overshoot = 0.0,
            smoothness = 0.25,
            easing = "Cubic.Out",
        },
        {
            name = "Bounce",
            duration = 0.6,
            overshoot = 0.35,
            smoothness = 0.15,
            easing = "Back.Out",
        },
        {
            name = "Snappy",
            duration = 0.3,
            overshoot = 0.0,
            smoothness = 0.05,
            easing = "Expo.Out",
        },
        {
            name = "Cinematic",
            duration = 1.2,
            overshoot = 0.05,
            smoothness = 0.4,
            easing = "Sine.Out",
        },
    },

    -- Custom user presets
    custom = {},

    -- Currently selected preset name
    current_preset = "Smooth",
}

-- Get all preset names (built-in + custom)
function PresetManager:get_all_names()
    local names = {}

    -- Add built-in presets
    for _, preset in ipairs(self.built_in) do
        table.insert(names, preset.name)
    end

    -- Add custom presets
    for name, _ in pairs(self.custom) do
        table.insert(names, name)
    end

    table.sort(names)
    return names
end

-- Get preset by name
function PresetManager:get_preset(name)
    -- Check built-in first
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            return preset
        end
    end

    -- Check custom
    if self.custom[name] then
        return self.custom[name]
    end

    -- Default to Smooth
    return self.built_in[1]
end

-- Apply preset to configuration
function PresetManager:apply_preset(name)
    local preset = self:get_preset(name)
    if not preset then
        log("Preset: Unknown preset: " .. name)
        return false
    end

    cfg.zoom_duration = preset.duration
    cfg.zoom_overshoot = preset.overshoot
    cfg.follow_smooth_time = preset.smoothness

    if preset.easing then
        cfg.zoom_easing = preset.easing
    end

    self.current_preset = name
    log("Preset: Applied '" .. name .. "'")
    return true
end

-- Save a custom preset
function PresetManager:save_preset(name, duration, overshoot, smoothness, easing)
    if not name or name == "" then
        return false
    end

    -- Check if it's a built-in preset (can't override)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            log("Preset: Cannot override built-in preset: " .. name)
            return false
        end
    end

    -- Save custom preset
    self.custom[name] = {
        name = name,
        duration = duration or cfg.zoom_duration,
        overshoot = overshoot or cfg.zoom_overshoot,
        smoothness = smoothness or cfg.follow_smooth_time,
        easing = easing or cfg.zoom_easing,
    }

    log("Preset: Saved custom preset '" .. name .. "'")
    return true
end

-- Delete a custom preset
function PresetManager:delete_preset(name)
    -- Check if it's a built-in preset (can't delete)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            log("Preset: Cannot delete built-in preset: " .. name)
            return false
        end
    end

    -- Delete custom preset
    if self.custom[name] then
        self.custom[name] = nil
        log("Preset: Deleted custom preset '" .. name .. "'")
        return true
    end

    return false
end

-- Check if a preset is built-in
function PresetManager:is_built_in(name)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            return true
        end
    end
    return false
end

-- Persist custom presets to settings
function PresetManager:persist(settings)
    local array = obs.obs_data_array_create()

    for name, preset in pairs(self.custom) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "name", name)
        obs.obs_data_set_double(item, "duration", preset.duration)
        obs.obs_data_set_double(item, "overshoot", preset.overshoot)
        obs.obs_data_set_double(item, "smoothness", preset.smoothness)
        obs.obs_data_set_string(item, "easing", preset.easing)
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "custom_presets", array)
    obs.obs_data_array_release(array)
end

-- Load custom presets from settings
function PresetManager:load(settings)
    self.custom = {}

    local array = obs.obs_data_get_array(settings, "custom_presets")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local name = obs.obs_data_get_string(item, "name")

        if name and name ~= "" then
            self.custom[name] = {
                name = name,
                duration = obs.obs_data_get_double(item, "duration"),
                overshoot = obs.obs_data_get_double(item, "overshoot"),
                smoothness = obs.obs_data_get_double(item, "smoothness"),
                easing = obs.obs_data_get_string(item, "easing"),
            }
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)
    log("Preset: Loaded " .. self:get_custom_count() .. " custom presets")
end

-- Get count of custom presets
function PresetManager:get_custom_count()
    local count = 0
    for _, _ in pairs(self.custom) do
        count = count + 1
    end
    return count
end

-- Get current preset name
function PresetManager:get_current_name()
    return self.current_preset
end

-- Set current preset name
function PresetManager:set_current_name(name)
    self.current_preset = name
end

-- Check if current preset is custom
function PresetManager:is_current_custom()
    return not self:is_built_in(self.current_preset)
end

-- Global convenience functions
function preset_get_all_names()
    return PresetManager:get_all_names()
end

function preset_apply(name)
    return PresetManager:apply_preset(name)
end

function preset_save(name, duration, overshoot, smoothness, easing)
    return PresetManager:save_preset(name, duration, overshoot, smoothness, easing)
end

function preset_delete(name)
    return PresetManager:delete_preset(name)
end

function preset_is_built_in(name)
    return PresetManager:is_built_in(name)
end

function preset_get_current()
    return PresetManager:get_current_name()
end

--================================================
-- MODULE: Auto Source Detection (M11)
--================================================
-- Automatically detects and selects the best zoom source on first run

local AutoSourceDetector = {
    -- Source type priorities (higher = more likely to be the main display)
    type_priorities = {
        ["monitor_capture"] = 100,     -- Display capture (highest priority)
        ["game_capture"] = 80,          -- Game capture
        ["window_capture"] = 60,        -- Window capture
        ["xshm_input"] = 40,           -- Linux X11 capture
        ["av_capture_input"] = 20,     -- macOS capture
    },

    -- Whether auto-detection has been run
    auto_detected = false,
}

-- Get all capture sources sorted by priority
function AutoSourceDetector:get_capture_sources()
    local sources = {}
    local source_list = obs.obs_enum_sources()

    if not source_list then
        return sources
    end

    for _, source in ipairs(source_list) do
        local source_id = obs.obs_source_get_id(source)
        local name = obs.obs_source_get_name(source)

        -- Check if it's a capture source
        local priority = self.type_priorities[source_id]
        if priority then
            table.insert(sources, {
                name = name,
                id = source_id,
                priority = priority,
            })
        end
    end

    obs.source_list_release(source_list)

    -- Sort by priority (highest first)
    table.sort(sources, function(a, b)
        return a.priority > b.priority
    end)

    return sources
end

-- Auto-detect the best source
function AutoSourceDetector:auto_detect()
    local sources = self:get_capture_sources()

    if #sources == 0 then
        log("AutoSource: No capture sources found")
        return nil
    end

    if #sources == 1 then
        -- Only one source, use it
        log("AutoSource: Found single source: " .. sources[1].name)
        return sources[1].name
    end

    -- Multiple sources - prioritize by type
    -- Prefer monitor_capture > game_capture > window_capture
    local best = sources[1]

    log("AutoSource: Found " .. #sources .. " sources, selecting: " .. best.name)
    return best.name
end

-- Get monitor geometry from a source (if available)
function AutoSourceDetector:get_monitor_geometry(source_name)
    local source = obs.obs_get_source_by_name(source_name)
    if not source then
        return nil
    end

    local settings = obs.obs_source_get_settings(source)
    if not settings then
        obs.obs_source_release(source)
        return nil
    end

    -- Try to get monitor info from settings
    local monitor = obs.obs_data_get_int(settings, "monitor")
    local x = obs.obs_data_get_int(settings, "x")
    local y = obs.obs_data_get_int(settings, "y")
    local width = obs.obs_data_get_int(settings, "width")
    local height = obs.obs_data_get_int(settings, "height")

    obs.obs_data_release(settings)
    obs.obs_source_release(source)

    -- Return geometry if available
    if monitor >= 0 or width > 0 then
        return {
            monitor = monitor,
            x = x,
            y = y,
            width = width or 1920,
            height = height or 1080,
        }
    end

    return nil
end

-- Check if we should auto-detect on first run
function AutoSourceDetector:should_auto_detect(settings)
    -- Check if source has ever been set
    local last_source = obs.obs_data_get_string(settings, "source")
    if last_source and last_source ~= "" then
        return false
    end

    -- Check if auto-detect has been done
    return not self.auto_detected
end

-- Run auto-detection and return the source name
function AutoSourceDetector:run(settings)
    local source_name = self:auto_detect()

    if source_name then
        -- Save the detected source
        obs.obs_data_set_string(settings, "source", source_name)
        self.auto_detected = true
    end

    return source_name
end

-- Global convenience functions
function auto_source_detect()
    return AutoSourceDetector:auto_detect()
end

function auto_source_should_detect(settings)
    return AutoSourceDetector:should_auto_detect(settings)
end

function auto_source_run(settings)
    return AutoSourceDetector:run(settings)
end

--================================================
-- MODULE: Scene Memory (M12)
--================================================
-- Remembers which zoom source to use for each OBS scene

local SceneMemory = {
    -- Scene to source mapping
    scene_source_map = {},

    -- Maximum number of mappings to store
    max_mappings = 50,
}

-- Get the current scene name
function SceneMemory:get_current_scene_name()
    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then
        return nil
    end

    local name = obs.obs_source_get_name(scene_source)
    obs.obs_source_release(scene_source)
    return name
end

-- Get the source to use for the current scene
function SceneMemory:get_source_for_current_scene()
    local scene_name = self:get_current_scene_name()
    if not scene_name then
        return nil
    end

    -- 1. Check explicit mapping for this scene
    if self.scene_source_map[scene_name] then
        return self.scene_source_map[scene_name]
    end

    -- 2. Fall back to global source from config
    return cfg.source_name
end

-- Set the source for a specific scene
function SceneMemory:set(scene_name, source_name)
    if not scene_name or scene_name == "" then
        return false
    end

    -- Check if we're at capacity
    local count = 0
    for _, _ in pairs(self.scene_source_map) do
        count = count + 1
    end

    if count >= self.max_mappings and not self.scene_source_map[scene_name] then
        log("SceneMemory: At capacity (" .. self.max_mappings .. "), cannot add: " .. scene_name)
        return false
    end

    self.scene_source_map[scene_name] = source_name
    log("SceneMemory: " .. scene_name .. " Ã¢â€ â€™ " .. source_name)
    return true
end

-- Remove a scene mapping
function SceneMemory:remove(scene_name)
    if self.scene_source_map[scene_name] then
        self.scene_source_map[scene_name] = nil
        log("SceneMemory: Removed mapping for " .. scene_name)
        return true
    end
    return false
end

-- Get all scene mappings
function SceneMemory:get_all()
    local mappings = {}
    for scene, source in pairs(self.scene_source_map) do
        table.insert(mappings, { scene = scene, source = source })
    end
    table.sort(mappings, function(a, b)
        return a.scene < b.scene
    end)
    return mappings
end

-- Check if a scene has a mapping
function SceneMemory:has_mapping(scene_name)
    return self.scene_source_map[scene_name] ~= nil
end

-- Persist mappings to settings
function SceneMemory:persist(settings)
    local array = obs.obs_data_array_create()

    for scene, source in pairs(self.scene_source_map) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "scene", scene)
        obs.obs_data_set_string(item, "source", source)
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "scene_source_map", array)
    obs.obs_data_array_release(array)
end

-- Load mappings from settings
function SceneMemory:load(settings)
    self.scene_source_map = {}

    local array = obs.obs_data_get_array(settings, "scene_source_map")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local scene = obs.obs_data_get_string(item, "scene")
        local source = obs.obs_data_get_string(item, "source")

        if scene and scene ~= "" and source and source ~= "" then
            self.scene_source_map[scene] = source
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)

    local count = 0
    for _, _ in pairs(self.scene_source_map) do count = count + 1 end
    log("SceneMemory: Loaded " .. count .. " scene mappings")
end

-- Handle scene change
function SceneMemory:on_scene_change()
    local scene_name = self:get_current_scene_name()
    if not scene_name then
        return
    end

    -- Get the source for this scene
    local source_name = self:get_source_for_current_scene()

    if source_name and source_name ~= "" then
        -- Check if source changed
        local current = source_manager_is_valid() and cfg.source_name

        if source_name ~= current then
            log("SceneMemory: Scene changed to " .. scene_name)

            -- Release current source
            source_manager_release()

            -- Initialize with new source
            cfg.source_name = source_name
            source_manager_init(source_name)
        end
    end
end

-- Global convenience functions
function scene_memory_get_source()
    return SceneMemory:get_source_for_current_scene()
end

function scene_memory_set(scene_name, source_name)
    return SceneMemory:set(scene_name, source_name)
end

function scene_memory_remove(scene_name)
    return SceneMemory:remove(scene_name)
end

function scene_memory_get_all()
    return SceneMemory:get_all()
end

function scene_memory_on_scene_change()
    return SceneMemory:on_scene_change()
end

--================================================
-- MODULE: Blur Manager (M14)
--================================================
-- Provides built-in blur effects without external plugins
-- Supports multiple strategies: shader, composite_blur plugin, or none

local BlurManager = {
    -- Current strategy: "shader", "composite_blur", "none"
    strategy = "none",

    -- Filter references
    zoom_blur_filter = nil,
    motion_blur_filter = nil,

    -- Settings references
    zoom_blur_settings = nil,
    motion_blur_settings = nil,

    -- State
    initialized = false,

    -- Configuration
    zoom_blur_enabled = false,
    zoom_blur_intensity = 5,
    zoom_blur_clear_radius = 150,
    motion_blur_enabled = false,
    motion_blur_intensity = 1.0,
}

-- Try to use custom shader (if effect files exist)
function BlurManager:try_shader_strategy(source)
    -- This would require .effect files in assets/shaders/
    -- For now, we'll use a simpler approach
    log("Blur: Shader strategy not implemented (requires effect files)")
    return false
end

-- Try to auto-create Composite Blur filters
function BlurManager:try_composite_blur_strategy(source)
    if not source then return false end

    -- Check if composite_blur filter type exists
    local test_filter = obs.obs_source_create_private("composite_blur", "__test_blur__", nil)
    if test_filter then
        obs.obs_source_release(test_filter)
    else
        log("Blur: Composite Blur plugin not available")
        return false
    end

    -- Create Zoom Blur filter
    local zs = obs.obs_data_create()
    obs.obs_data_set_double(zs, "radius", 0)
    obs.obs_data_set_int(zs, "blur_type", 2) -- Zoom type
    self.zoom_blur_filter = obs.obs_source_create_private(
        "composite_blur",
        FILTER_PREFIX .. "Zoom Blur",
        zs
    )

    if self.zoom_blur_filter then
        obs.obs_source_filter_add(source, self.zoom_blur_filter)
        self.zoom_blur_settings = zs
    else
        obs.obs_data_release(zs)
        return false
    end

    -- Create Motion Blur filter
    local ms = obs.obs_data_create()
    obs.obs_data_set_double(ms, "radius", 0)
    obs.obs_data_set_int(ms, "blur_type", 3) -- Motion/directional type
    self.motion_blur_filter = obs.obs_source_create_private(
        "composite_blur",
        FILTER_PREFIX .. "Motion Blur",
        ms
    )

    if self.motion_blur_filter then
        obs.obs_source_filter_add(source, self.motion_blur_filter)
        self.motion_blur_settings = ms
    else
        obs.obs_data_release(ms)
    end

    self.initialized = true
    return true
end

-- Initialize blur manager
function BlurManager:init(source)
    if not source then
        return false
    end

    self:cleanup()

    -- Try composite_blur strategy
    if self:try_composite_blur_strategy(source) then
        self.strategy = "composite_blur"
        log("Blur: Using Composite Blur plugin (auto-configured)")
        return true
    end

    -- No blur available
    self.strategy = "none"
    log("Blur: No blur backend available. Blur effects disabled.")
    return false
end

-- Update blur based on zoom state
function BlurManager:update(state_machine, crop, camera_velocity)
    if not self.initialized then return end
    if self.strategy == "none" then return end

    -- Zoom Blur: Active during zoom transitions
    if self.zoom_blur_enabled and self.zoom_blur_filter then
        local radius = 0

        if state_machine:is_animating() and
           (state_machine.state == ZoomState.ZOOMING_IN or
            state_machine.state == ZoomState.ZOOMING_OUT) then
            -- Bell curve: 0 at start Ã¢â€ â€™ peak at 50% Ã¢â€ â€™ 0 at end
            local t = clamp(0, 1, state_machine.zoom_time)
            local curve = math.sin(t * math.pi)
            radius = curve * curve * self.zoom_blur_intensity
        end

        self:set_zoom_blur(radius, crop)
    end

    -- Motion Blur: Active during camera panning (not during zoom transition)
    if self.motion_blur_enabled and self.motion_blur_filter then
        if not state_machine:is_animating() and state_machine:is_zoomed() and camera_velocity then
            local speed = math.sqrt(
                camera_velocity.x * camera_velocity.x +
                camera_velocity.y * camera_velocity.y
            )

            if speed > 1.0 then
                local radius = math.min(10, speed * self.motion_blur_intensity * 0.5)
                local angle = math.deg(math.atan2(camera_velocity.y, camera_velocity.x))
                self:set_motion_blur(radius, angle)
            else
                self:set_motion_blur(0, 0)
            end
        else
            self:set_motion_blur(0, 0)
        end
    end
end

-- Set zoom blur parameters
function BlurManager:set_zoom_blur(radius, crop)
    if self.strategy == "composite_blur" and self.zoom_blur_settings then
        obs.obs_data_set_double(self.zoom_blur_settings, "radius", radius)

        if crop then
            local cx = crop.x + (crop.w / 2)
            local cy = crop.y + (crop.h / 2)
            obs.obs_data_set_double(self.zoom_blur_settings, "center_x", cx)
            obs.obs_data_set_double(self.zoom_blur_settings, "center_y", cy)
        end

        obs.obs_data_set_double(self.zoom_blur_settings, "inactive_radius", self.zoom_blur_clear_radius)
        obs.obs_source_update(self.zoom_blur_filter, self.zoom_blur_settings)
    end
end

-- Set motion blur parameters
function BlurManager:set_motion_blur(radius, angle)
    if self.strategy == "composite_blur" and self.motion_blur_settings then
        obs.obs_data_set_double(self.motion_blur_settings, "radius", radius)
        obs.obs_data_set_double(self.motion_blur_settings, "angle", angle)
        obs.obs_source_update(self.motion_blur_filter, self.motion_blur_settings)
    end
end

-- Update configuration
function BlurManager:update_config(settings)
    self.zoom_blur_enabled = obs.obs_data_get_bool(settings, "zoom_blur_enabled")
    self.zoom_blur_intensity = obs.obs_data_get_double(settings, "zoom_blur_intensity")
    self.zoom_blur_clear_radius = obs.obs_data_get_double(settings, "zoom_blur_clear_radius")
    self.motion_blur_enabled = obs.obs_data_get_bool(settings, "motion_blur_enabled")
    self.motion_blur_intensity = obs.obs_data_get_double(settings, "motion_blur_intensity")
end

-- Cleanup filters
function BlurManager:cleanup()
    local source = source_manager_get_source()

    if self.zoom_blur_filter and source then
        obs.obs_source_filter_remove(source, self.zoom_blur_filter)
        obs.obs_source_release(self.zoom_blur_filter)
        self.zoom_blur_filter = nil
    end

    if self.motion_blur_filter and source then
        obs.obs_source_filter_remove(source, self.motion_blur_filter)
        obs.obs_source_release(self.motion_blur_filter)
        self.motion_blur_filter = nil
    end

    if self.zoom_blur_settings then
        obs.obs_data_release(self.zoom_blur_settings)
        self.zoom_blur_settings = nil
    end

    if self.motion_blur_settings then
        obs.obs_data_release(self.motion_blur_settings)
        self.motion_blur_settings = nil
    end

    self.initialized = false
    self.strategy = "none"
end

-- Check if blur is available
function BlurManager:is_available()
    return self.strategy ~= "none"
end

-- Global convenience functions
function blur_manager_init(source)
    return BlurManager:init(source)
end

function blur_manager_update(state_machine, crop, camera_velocity)
    return BlurManager:update(state_machine, crop, camera_velocity)
end

function blur_manager_update_config(settings)
    return BlurManager:update_config(settings)
end

function blur_manager_cleanup()
    return BlurManager:cleanup()
end

function blur_manager_is_available()
    return BlurManager:is_available()
end

--================================================
-- MODULE: Cursor Asset Manager (M16)
--================================================
-- Handles extracting and managing cursor image assets

local CursorAssets = {
    extracted = false,
    dir = nil,
}

-- Get the platform-specific asset directory
function CursorAssets:get_platform_dir()
    if IS_WINDOWS then
        local appdata = os.getenv("APPDATA")
        return appdata and (appdata .. "\\obs-studio\\obs-zoom-pro\\cursors") or nil
    elseif IS_LINUX then
        local home = os.getenv("HOME")
        return home and (home .. "/.config/obs-studio/obs-zoom-pro/cursors") or nil
    elseif IS_MACOS then
        local home = os.getenv("HOME")
        return home and (home .. "/Library/Application Support/obs-studio/obs-zoom-pro/cursors") or nil
    end
    -- Fallback for non-FFI environments
    return "cursors"
end

-- Ensure assets are extracted
function CursorAssets:ensure_extracted()
    if self.extracted then
        return self.dir
    end

    local dir = self:get_platform_dir()
    if not dir then
        log("CursorAssets: Could not determine asset directory")
        return nil
    end

    -- Create directory
    local cmd
    if IS_WINDOWS then
        cmd = 'mkdir "' .. dir .. '" 2>nul'
    else
        cmd = 'mkdir -p "' .. dir .. '"'
    end
    os.execute(cmd)

    -- Check if assets exist
    local sep = IS_WINDOWS and "\\" or "/"
    local arrow_path = dir .. sep .. "arrow.png"

    local f = io.open(arrow_path, "rb")
    if f then
        f:close()
        self.dir = dir
        self.extracted = true
        log("CursorAssets: Using existing assets from " .. dir)
        return dir
    end

    -- Try to copy from script directory
    local script_dir = get_script_directory()
    local assets_src = script_dir .. "assets" .. sep .. "cursors" .. sep

    local files = { "arrow.png", "pointer.png", "ibeam.png" }
    for _, filename in ipairs(files) do
        local src_path = assets_src .. filename
        local dst_path = dir .. sep .. filename

        local src = io.open(src_path, "rb")
        if src then
            local data = src:read("*a")
            src:close()

            local dst = io.open(dst_path, "wb")
            if dst then
                dst:write(data)
                dst:close()
                log("CursorAssets: Copied " .. filename)
            end
        end
    end

    self.dir = dir
    self.extracted = true
    return dir
end

-- Get the asset directory
function CursorAssets:get_dir()
    return self.dir
end

-- Check if assets are available
function CursorAssets:is_available()
    if not self.extracted then
        self:ensure_extracted()
    end
    return self.dir ~= nil
end

-- Get cursor image path
function CursorAssets:get_cursor_path(cursor_type)
    if not self:is_available() then
        return nil
    end

    local sep = IS_WINDOWS and "\\" or "/"
    local filename = (cursor_type or "arrow") .. ".png"
    return self.dir .. sep .. filename
end

-- Global convenience functions
function cursor_assets_ensure_extracted()
    return CursorAssets:ensure_extracted()
end

function cursor_assets_get_dir()
    return CursorAssets:get_dir()
end

function cursor_assets_is_available()
    return CursorAssets:is_available()
end

function cursor_assets_get_cursor_path(cursor_type)
    return CursorAssets:get_cursor_path(cursor_type)
end

--================================================
-- MODULE: Cursor Renderer (M15)
--================================================
-- Provides automatic cursor overlay rendering

local CursorRenderer = {
    enabled = false,
    source = nil,
    sceneitem = nil,

    -- Smoothed state
    pos = { x = 0, y = 0 },
    current_scale = 1.0,
    current_rot = 0,
    swap_pulse = 1.0,

    -- Velocities (SmoothDamp)
    vel_x = { val = 0 },
    vel_y = { val = 0 },
    vel_scale = { val = 0 },
    vel_rot = { val = 0 },
    vel_swap = { val = 0 },

    -- State
    was_pointer = false,
    initialized = false,

    -- Configuration
    cursor_scale = 1.0,
    cursor_click_scale = 0.78,
    cursor_smooth_time = 0.1,
    cursor_offset_x = -6,
    cursor_offset_y = -2,
    cursor_rotation_mode = "None",
    cursor_angle_offset = 0,
    cursor_tilt_strength = 0,
}

-- Initialize cursor renderer
function CursorRenderer:init()
    if not cfg.cursor_enabled then
        self.enabled = false
        return false
    end

    -- Ensure cursor assets are available
    local asset_dir = cursor_assets_ensure_extracted()
    if not asset_dir then
        log("CursorRenderer: Failed to extract cursor assets")
        self.enabled = false
        return false
    end

    -- Get or create the cursor image source
    local source_name = FILTER_PREFIX .. "Cursor"
    self.source = obs.obs_get_source_by_name(source_name)

    if not self.source then
        -- Create new image source
        local settings = obs.obs_data_create()
        local cursor_path = cursor_assets_get_cursor_path("arrow")
        if cursor_path then
            obs.obs_data_set_string(settings, "file", cursor_path)
        end
        self.source = obs.obs_source_create("image_source", source_name, settings, nil)
        obs.obs_data_release(settings)

        if not self.source then
            log("CursorRenderer: Failed to create image source")
            self.enabled = false
            return false
        end
    end

    -- Add to current scene
    self:add_to_scene()

    -- Initialize position
    local mouse = platform_get_mouse_pos()
    self.pos.x = mouse.x
    self.pos.y = mouse.y

    self.enabled = true
    self.initialized = true
    log("CursorRenderer: Initialized")
    return true
end

-- Add cursor source to scene
function CursorRenderer:add_to_scene()
    if not self.source then return false end

    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then return false end

    local scene = obs.obs_scene_from_source(scene_source)
    if not scene then
        obs.obs_source_release(scene_source)
        return false
    end

    -- Check if already in scene
    local source_name = obs.obs_source_get_name(self.source)
    self.sceneitem = obs.obs_scene_find_source(scene, source_name)

    if not self.sceneitem then
        -- Add to scene
        self.sceneitem = obs.obs_scene_add(scene, self.source)
        if self.sceneitem then
            -- Move to top (render last = on top)
            obs.obs_sceneitem_set_order(self.sceneitem, obs.OBS_ORDER_MOVE_TOP)
        end
    end

    obs.obs_source_release(scene_source)
    return true
end

-- Update cursor position and state
function CursorRenderer:update(dt, raw_mouse, camera_crop)
    if not self.enabled or not self.sceneitem then return end

    -- Smooth cursor position
    self.pos.x = SmoothDamp(self.pos.x, raw_mouse.x, self.vel_x, self.cursor_smooth_time, 100000, dt)
    self.pos.y = SmoothDamp(self.pos.y, raw_mouse.y, self.vel_y, self.cursor_smooth_time, 100000, dt)

    -- Snap when very close
    if math.abs(self.pos.x - raw_mouse.x) < 0.5 then
        self.pos.x = raw_mouse.x
        self.vel_x.val = 0
    end
    if math.abs(self.pos.y - raw_mouse.y) < 0.5 then
        self.pos.y = raw_mouse.y
        self.vel_y.val = 0
    end

    -- Cursor shape detection (Windows only)
    local is_pointer = false
    if platform_cursor_shape_available() then
        is_pointer = platform_is_cursor_pointer()
    end

    -- Swap cursor image if needed
    if is_pointer ~= self.was_pointer then
        local asset_dir = cursor_assets_get_dir()
        local sep = IS_WINDOWS and "\\" or "/"
        local new_file = is_pointer and (asset_dir .. sep .. "pointer.png") or (asset_dir .. sep .. "arrow.png")

        local s = obs.obs_source_get_settings(self.source)
        if s then
            obs.obs_data_set_string(s, "file", new_file)
            obs.obs_source_update(self.source, s)
            obs.obs_data_release(s)
        end

        -- Trigger swap pulse
        self.swap_pulse = 0.75
        self.vel_swap.val = 1
        self.was_pointer = is_pointer
    end

    self.swap_pulse = SmoothDamp(self.swap_pulse, 1.0, self.vel_swap, 0.12, 100000, dt)

    -- Click animation
    local is_clicking = platform_is_clicking()
    local target_scale = is_clicking and (self.cursor_scale * self.cursor_click_scale) or self.cursor_scale
    self.current_scale = SmoothDamp(self.current_scale, target_scale, self.vel_scale, 0.1, 100000, dt)

    -- Calculate position relative to zoom
    local zoom_factor = 1.0
    local crop_x, crop_y = 0, 0

    if camera_crop and SM:is_zoomed() then
        zoom_factor = source_manager_get_size() / camera_crop.w
        crop_x = camera_crop.x
        crop_y = camera_crop.y
    end

    local final_x = (self.pos.x - crop_x) * zoom_factor + (self.cursor_offset_x * zoom_factor)
    local final_y = (self.pos.y - crop_y) * zoom_factor + (self.cursor_offset_y * zoom_factor)

    -- Apply to scene item
    local pos = obs.vec2()
    pos.x = final_x
    pos.y = final_y
    obs.obs_sceneitem_set_pos(self.sceneitem, pos)

    local scale = obs.vec2()
    local s = self.current_scale * zoom_factor * self.swap_pulse
    scale.x = s
    scale.y = s
    obs.obs_sceneitem_set_scale(self.sceneitem, scale)

    -- Rotation
    local dynamic_rot = self:compute_rotation(dt)
    obs.obs_sceneitem_set_rot(self.sceneitem, dynamic_rot)
end

-- Compute rotation based on mode
function CursorRenderer:compute_rotation(dt)
    local vx = self.vel_x.val
    local vy = self.vel_y.val
    local speed = math.sqrt(vx * vx + vy * vy)

    if self.cursor_rotation_mode == "Directional" then
        if speed > 20 then
            local angle = math.atan2(vy, vx) * (180 / math.pi)
            local target = angle + self.cursor_angle_offset
            local diff = (target - self.current_rot + 180) % 360 - 180
            self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.05, 100000, dt)
        end
        return self.current_rot

    elseif self.cursor_rotation_mode == "Lean" then
        local lean = clamp(-40, 40, vx * 0.05 * self.cursor_tilt_strength) + self.cursor_angle_offset
        local diff = (lean - self.current_rot + 180) % 360 - 180
        self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.08, 100000, dt)
        return self.current_rot
    end

    -- "None" mode
    local diff = (self.cursor_angle_offset - self.current_rot + 180) % 360 - 180
    self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.15, 100000, dt)
    return self.current_rot
end

-- Update configuration
function CursorRenderer:update_config(settings)
    self.cursor_scale = obs.obs_data_get_double(settings, "cursor_scale")
    self.cursor_click_scale = obs.obs_data_get_double(settings, "cursor_click_scale")
    self.cursor_smooth_time = obs.obs_data_get_double(settings, "cursor_smooth_time")
    self.cursor_offset_x = obs.obs_data_get_int(settings, "cursor_offset_x")
    self.cursor_offset_y = obs.obs_data_get_int(settings, "cursor_offset_y")
    self.cursor_rotation_mode = obs.obs_data_get_string(settings, "cursor_rotation_mode") or "None"
    self.cursor_angle_offset = obs.obs_data_get_double(settings, "cursor_angle_offset")
    self.cursor_tilt_strength = obs.obs_data_get_double(settings, "cursor_tilt_strength")
end

-- Cleanup
function CursorRenderer:cleanup()
    if self.sceneitem then
        obs.obs_sceneitem_remove(self.sceneitem)
        self.sceneitem = nil
    end

    if self.source then
        local source_name = obs.obs_source_get_name(self.source)
        obs.obs_source_release(self.source)

        -- Remove from OBS source list
        local s = obs.obs_get_source_by_name(source_name)
        if s then
            obs.obs_source_remove(s)
            obs.obs_source_release(s)
        end
        self.source = nil
    end

    self.enabled = false
    self.initialized = false
end

-- Check if active
function CursorRenderer:is_active()
    return self.enabled and self.initialized
end

-- Global convenience functions
function cursor_renderer_init()
    return CursorRenderer:init()
end

function cursor_renderer_update(dt, raw_mouse, camera_crop)
    return CursorRenderer:update(dt, raw_mouse, camera_crop)
end

function cursor_renderer_update_config(settings)
    return CursorRenderer:update_config(settings)
end

function cursor_renderer_cleanup()
    return CursorRenderer:cleanup()
end

function cursor_renderer_is_active()
    return CursorRenderer:is_active()
end

--================================================
-- MODULE: Bookmark Manager (M17)
--================================================
-- Manages saved zoom positions (bookmarks)

local BookmarkManager = {
    -- Saved bookmarks: { name = { zoom_level, x, y, w, h, source } }
    bookmarks = {},

    -- Maximum bookmarks
    max_bookmarks = 20,

    -- Hotkey IDs
    hotkeys = {},
}

-- Save current zoom position as a bookmark
function BookmarkManager:save(name)
    if not name or name == "" then
        return false
    end

    -- Check limit
    local count = 0
    for _, _ in pairs(self.bookmarks) do count = count + 1 end

    if count >= self.max_bookmarks and not self.bookmarks[name] then
        log("Bookmark: Max bookmarks reached (" .. self.max_bookmarks .. ")")
        return false
    end

    -- Get current crop
    local crop = crop_filter_get_crop()
    if not crop then
        return false
    end

    -- Save bookmark
    self.bookmarks[name] = {
        zoom_level = SM.zoom_level,
        x = crop.x,
        y = crop.y,
        w = crop.w,
        h = crop.h,
        source = cfg.source_name,
    }

    log("Bookmark: Saved '" .. name .. "' (zoom=" .. string.format("%.2f", SM.zoom_level) .. ")")
    return true
end

-- Recall a bookmark
function BookmarkManager:recall(name)
    local bm = self.bookmarks[name]
    if not bm then
        log("Bookmark: Not found: " .. name)
        return false
    end

    if not SM:can_jump() then
        return false
    end

    if not source_manager_is_valid() then
        return false
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        return false
    end

    -- Get current crop as start
    local start_crop = crop_filter_get_crop() or { x = 0, y = 0, w = source_w, h = source_h }

    -- Set target
    local target_crop = {
        x = bm.x,
        y = bm.y,
        w = bm.w,
        h = bm.h,
    }

    -- Transition to bookmark
    SM:transition(ZoomState.JUMPING, {
        start_crop = start_crop,
        target_crop = target_crop,
        target_level = bm.zoom_level
    })

    start_timer()
    log("Bookmark: Recall '" .. name .. "'")
    return true
end

-- Delete a bookmark
function BookmarkManager:delete(name)
    if self.bookmarks[name] then
        self.bookmarks[name] = nil
        log("Bookmark: Deleted '" .. name .. "'")
        return true
    end
    return false
end

-- Rename a bookmark
function BookmarkManager:rename(old_name, new_name)
    if not self.bookmarks[old_name] then
        return false
    end

    if self.bookmarks[new_name] then
        return false
    end

    self.bookmarks[new_name] = self.bookmarks[old_name]
    self.bookmarks[old_name] = nil
    log("Bookmark: Renamed '" .. old_name .. "' to '" .. new_name .. "'")
    return true
end

-- Get all bookmark names
function BookmarkManager:get_names()
    local names = {}
    for k, _ in pairs(self.bookmarks) do
        table.insert(names, k)
    end
    table.sort(names)
    return names
end

-- Get bookmark info
function BookmarkManager:get(name)
    return self.bookmarks[name]
end

-- Persist bookmarks to settings
function BookmarkManager:persist(settings)
    local array = obs.obs_data_array_create()

    for name, bm in pairs(self.bookmarks) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "name", name)
        obs.obs_data_set_double(item, "zoom_level", bm.zoom_level)
        obs.obs_data_set_double(item, "x", bm.x)
        obs.obs_data_set_double(item, "y", bm.y)
        obs.obs_data_set_double(item, "w", bm.w)
        obs.obs_data_set_double(item, "h", bm.h)
        obs.obs_data_set_string(item, "source", bm.source or "")
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "zoom_bookmarks", array)
    obs.obs_data_array_release(array)
end

-- Load bookmarks from settings
function BookmarkManager:load(settings)
    self.bookmarks = {}

    local array = obs.obs_data_get_array(settings, "zoom_bookmarks")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local name = obs.obs_data_get_string(item, "name")

        if name and name ~= "" then
            self.bookmarks[name] = {
                zoom_level = obs.obs_data_get_double(item, "zoom_level"),
                x = obs.obs_data_get_double(item, "x"),
                y = obs.obs_data_get_double(item, "y"),
                w = obs.obs_data_get_double(item, "w"),
                h = obs.obs_data_get_double(item, "h"),
                source = obs.obs_data_get_string(item, "source"),
            }
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)

    local count = 0
    for _, _ in pairs(self.bookmarks) do count = count + 1 end
    log("Bookmark: Loaded " .. count .. " bookmarks")
end

-- Register bookmark hotkeys
function BookmarkManager:register_hotkeys(settings)
    for i = 1, 5 do
        self.hotkeys[i] = obs.obs_hotkey_register_frontend(
            "obs_zoom_pro.bookmark_" .. i,
            "Zoom to Bookmark " .. i,
            function(pressed)
                if not pressed then return end
                local names = self:get_names()
                if names[i] then
                    self:recall(names[i])
                end
            end
        )

        -- Load saved bindings
        local key = "obs_zoom_pro.hotkey.bookmark_" .. i
        local save_array = obs.obs_data_get_array(settings, key)
        if save_array then
            obs.obs_hotkey_load(self.hotkeys[i], save_array)
            obs.obs_data_array_release(save_array)
        end
    end
end

-- Save bookmark hotkeys
function BookmarkManager:save_hotkeys(settings)
    for i = 1, 5 do
        if self.hotkeys[i] then
            local save_array = obs.obs_hotkey_save(self.hotkeys[i])
            obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.bookmark_" .. i, save_array)
            obs.obs_data_array_release(save_array)
        end
    end
end

-- Global convenience functions
function bookmark_save(name)
    return BookmarkManager:save(name)
end

function bookmark_recall(name)
    return BookmarkManager:recall(name)
end

function bookmark_delete(name)
    return BookmarkManager:delete(name)
end

function bookmark_get_names()
    return BookmarkManager:get_names()
end

function bookmark_get(name)
    return BookmarkManager:get(name)
end

--================================================
-- MODULE: UDP API Server (M18)
--================================================
-- Provides external control via UDP for Stream Deck integration

local APIServer = {
    enabled = false,
    port = 12345,
    socket = nil,
}

-- Command handlers
local API_COMMANDS = {
    ZOOM_IN = function(args)
        local level = tonumber(args[1]) or cfg.zoom_value
        on_scroll_zoom_to(level)
        return "OK"
    end,

    ZOOM_OUT = function(args)
        if SM:is_zoomed() then
            on_toggle_zoom(true)
        end
        return "OK"
    end,

    ZOOM_SET = function(args)
        local level = tonumber(args[1])
        if not level then return "ERROR: Missing level" end
        on_scroll_zoom_to(level)
        return "OK"
    end,

    ZOOM_TOGGLE = function(args)
        on_toggle_zoom(true)
        return "OK"
    end,

    FOLLOW_ON = function(args)
        if SM:is_zoomed() then SM.following = true end
        return "OK"
    end,

    FOLLOW_OFF = function(args)
        SM.following = false
        return "OK"
    end,

    FOLLOW_TOGGLE = function(args)
        if SM:is_zoomed() then SM.following = not SM.following end
        return "OK"
    end,

    PRESET = function(args)
        local name = args[1]
        if not name then return "ERROR: Missing preset name" end
        local ok = preset_apply(name)
        return ok and "OK" or "ERROR: Unknown preset"
    end,

    BOOKMARK = function(args)
        local name = args[1]
        if not name then return "ERROR: Missing bookmark name" end
        local ok = bookmark_recall(name)
        return ok and "OK" or "ERROR: Bookmark not found"
    end,

    STATUS = function(args)
        local crop = crop_filter_get_crop()
        return string.format(
            '{"version":"%s","zoom_level":%.2f,"state":"%s","following":%s,"position":{"x":%.0f,"y":%.0f},"preset":"%s"}',
            VERSION,
            SM.zoom_level,
            SM.state,
            tostring(SM.following),
            crop and crop.x or 0,
            crop and crop.y or 0,
            cfg.zoom_preset or ""
        )
    end,

    HELP = function(args)
        return "Commands: ZOOM_IN [level], ZOOM_OUT, ZOOM_SET level, ZOOM_TOGGLE, FOLLOW_ON, FOLLOW_OFF, FOLLOW_TOGGLE, PRESET name, BOOKMARK name, STATUS"
    end,
}

-- Start the API server
function APIServer:start(port)
    self:stop()

    self.port = port or self.port

    -- Try to use luasocket if available
    local socket_ok, socket = pcall(require, "socket")
    if not socket_ok then
        log("API: Socket library not available")
        return false
    end

    -- Try UDP
    local udp, err = socket.udp()
    if not udp then
        log("API: Failed to create UDP socket: " .. tostring(err))
        return false
    end

    -- Set socket options
    udp:setoption("reuseaddr", true)
    udp:settimeout(0)  -- Non-blocking

    -- Bind to port
    local bind_ok, err = udp:setsockname("*", self.port)
    if not bind_ok then
        log("API: Failed to bind to port " .. self.port .. ": " .. tostring(err))
        udp:close()
        return false
    end

    self.socket = udp
    self.enabled = true

    -- Start polling timer
    obs.timer_add(function() self:poll() end, 50)  -- 20Hz polling

    log("API: Listening on port " .. self.port)
    return true
end

-- Stop the API server
function APIServer:stop()
    if self.socket then
        self.socket:close()
        self.socket = nil
    end
    self.enabled = false
    log("API: Stopped")
end

-- Poll for incoming commands
function APIServer:poll()
    if not self.enabled or not self.socket then
        return
    end

    repeat
        local data, err = self.socket:receivefrom()
        if data then
            local response = self:handle_command(data)
            if response then
                -- Note: UDP response requires sender address
                log("API: " .. data:gsub("%s+", " ") .. " Ã¢â€ â€™ " .. response)
            end
        elseif err ~= "timeout" then
            log("API: Error: " .. tostring(err))
        end
    until not data
end

-- Handle a command
function APIServer:handle_command(raw)
    -- Parse command
    local parts = {}
    for word in raw:gmatch("%S+") do
        table.insert(parts, word)
    end

    if #parts == 0 then
        return "ERROR: Empty command"
    end

    local cmd = parts[1]:upper()
    local args = {}
    for i = 2, #parts do
        table.insert(args, parts[i])
    end

    -- Look up handler
    local handler = API_COMMANDS[cmd]
    if handler then
        local ok, result = pcall(handler, args)
        if ok then
            return result
        else
            return "ERROR: " .. tostring(result)
        end
    end

    return "ERROR: Unknown command: " .. cmd
end

-- Check if enabled
function APIServer:is_enabled()
    return self.enabled
end

-- Global convenience functions
function api_start(port)
    return APIServer:start(port)
end

function api_stop()
    return APIServer:stop()
end

function api_is_enabled()
    return APIServer:is_enabled()
end

--================================================
-- OBS SCRIPT REGISTRATION
--================================================

--[[ Called when the script is loaded
--[[ @param data table Script data
function script_load(data)
    log("Script loaded - OBS Zoom Pro v" .. VERSION)

    -- Load custom presets
    PresetManager:load(data)

    -- Load scene memory
    SceneMemory:load(data)

    -- Load bookmarks
    BookmarkManager:load(data)

    -- Register hotkeys
    register_hotkeys(data)

    -- Register bookmark hotkeys
    BookmarkManager:register_hotkeys(data)

    -- Register frontend event handler
    obs.obs_frontend_add_event_callback(on_frontend_event)

    -- Start API server if enabled
    local api_enabled = obs.obs_data_get_bool(data, "api_enabled")
    if api_enabled then
        local api_port = obs.obs_data_get_int(data, "api_port")
        APIServer:start(api_port)
    end
end

--[[ Called when the script is unloaded
function script_unload()
    log("Script unloaded - OBS Zoom Pro")

    -- Stop timer and cleanup
    stop_timer()
    unregister_hotkeys()
    source_manager_release()

    -- Stop API server
    APIServer:stop()

    -- Remove frontend event handler
    obs.obs_frontend_remove_event_callback(on_frontend_event)
end

--[[ Called when settings are updated
--[[ @param data table Settings data
function script_update(data)
    log("Settings updated")

    -- Update legacy settings
    debug_logs = obs.obs_data_get_bool(data, "debug_logging") or false
    settings.debug_logging = debug_logs
    settings.easing_type = obs.obs_data_get_string(data, "easing_type") or defaults.easing_type
    settings.smooth_time = obs.obs_data_get_double(data, "smooth_time") or defaults.smooth_time
    settings.max_speed = obs.obs_data_get_double(data, "max_speed") or defaults.max_speed

    -- Update M09 configuration
    update_config(data)

    -- Update API server settings
    local api_enabled = obs.obs_data_get_bool(data, "api_enabled")
    local api_port = obs.obs_data_get_int(data, "api_port")

    if api_enabled and not APIServer:is_enabled() then
        APIServer:start(api_port)
    elseif not api_enabled and APIServer:is_enabled() then
        APIServer:stop()
    elseif APIServer:is_enabled() and APIServer.port ~= api_port then
        APIServer:start(api_port)
    end
end

--[[ Called to save settings
--[[ @param data table Settings data to save
function script_save(data)
    log("Settings saved")

    -- Save custom presets
    PresetManager:persist(data)

    -- Save scene memory
    SceneMemory:persist(data)

    -- Save bookmarks
    BookmarkManager:persist(data)

    -- Save hotkey bindings
    save_hotkeys(data)

    -- Save bookmark hotkeys
    BookmarkManager:save_hotkeys(data)
end

--[[ Called to create the properties UI
--[[ @return obs.obs_properties_t Properties object
function script_properties()
    local props = obs.obs_properties_create()

    --==========================
    -- QUICK SETUP (always expanded)
    --==========================
    local grp_quick = obs.obs_properties_create()

    -- Source dropdown
    local src_list = obs.obs_properties_add_list(grp_quick, "source", "Zoom Source",
        obs.OBS_COMBO_TYPE_LIST, obs.OBS_COMBO_FORMAT_STRING)
    obs.obs_property_list_add_string(src_list, "-- Select Source --", "")

    -- Populate with available capture sources
    local sources = source_manager_get_available_sources()
    for _, src in ipairs(sources) do
        obs.obs_property_list_add_string(src_list, src.name, src.name)
    end

    -- Zoom Factor
    obs.obs_properties_add_float_slider(grp_quick, "zoom_value", "Zoom Factor", 1.0, 10.0, 0.1)

    -- Duration
    obs.obs_properties_add_float_slider(grp_quick, "zoom_duration", "Duration (s)", 0.05, 3.0, 0.05)

    obs.obs_properties_add_group(props, "quick_setup", "Ã¢Å¡Â¡ Quick Setup", obs.OBS_GROUP_NORMAL, grp_quick)

    --==========================
    -- ANIMATION (collapsed)
    --==========================
    local grp_anim = obs.obs_properties_create()

    -- Overshoot/Bounce
    obs.obs_properties_add_float_slider(grp_anim, "zoom_overshoot", "Bounce", 0.0, 1.0, 0.01)

    -- Easing Curve
    local p_easing = obs.obs_properties_add_list(grp_anim, "zoom_easing", "Easing Curve",
        obs.OBS_COMBO_TYPE_LIST, obs.OBS_COMBO_FORMAT_STRING)
    for _, name in ipairs(Easing.NAMES) do
        obs.obs_property_list_add_string(p_easing, name, name)
    end

    obs.obs_properties_add_group(props, "animation", "Ã°Å¸Å½Â¬ Animation", obs.OBS_GROUP_NORMAL, grp_anim)

    --==========================
    -- MOUSE FOLLOW (collapsed)
    --==========================
    local grp_follow = obs.obs_properties_create()

    obs.obs_properties_add_bool(grp_follow, "auto_follow", "Auto-Follow Mouse")
    obs.obs_properties_add_float_slider(grp_follow, "follow_smooth_time", "Smoothness", 0.01, 1.0, 0.01)
    obs.obs_properties_add_int_slider(grp_follow, "follow_dead_zone", "Dead Zone (px)", 0, 500, 1)

    obs.obs_properties_add_group(props, "follow", "Ã°Å¸Å½Â¯ Mouse Follow", obs.OBS_GROUP_NORMAL, grp_follow)

    --==========================
    -- ADVANCED (collapsed)
    --==========================
    local grp_adv = obs.obs_properties_create()
    obs.obs_properties_add_float_slider(grp_adv, "scroll_step", "Scroll Zoom Step", 0.1, 1.0, 0.05)
    obs.obs_properties_add_bool(grp_adv, "debug_logs", "Debug Logging")
    obs.obs_properties_add_group(props, "advanced", "Ã¢Å¡â„¢Ã¯Â¸Â Advanced", obs.OBS_GROUP_NORMAL, grp_adv)

    --==========================
    -- API SERVER (collapsed)
    --==========================
    local grp_api = obs.obs_properties_create()
    obs.obs_properties_add_bool(grp_api, "api_enabled", "Enable UDP API Server")
    obs.obs_properties_add_int(grp_api, "api_port", "API Port", 1024, 65535, 1)
    obs.obs_properties_add_group(props, "api_server", "Ã°Å¸Å’Â UDP API Server", obs.OBS_GROUP_NORMAL, grp_api)

    --==========================
    -- HELP (collapsed)
    --==========================
    local grp_help = obs.obs_properties_create()
    obs.obs_properties_add_text(grp_help, "help_text",
        "QUICK START:\n" ..
        "1. Select your capture source above\n" ..
        "2. Set hotkeys in OBS Settings Ã¢â€ â€™ Hotkeys\n" ..
        "   Ã¢â‚¬Â¢ 'Toggle Zoom to Mouse' Ã¢â‚¬â€ Main zoom\n" ..
        "   Ã¢â‚¬Â¢ 'Toggle Mouse Follow' Ã¢â‚¬â€ Enable/disable follow\n" ..
        "3. Press the hotkey to zoom!\n\n" ..
        "TIPS:\n" ..
        "Ã¢â‚¬Â¢ Zoom centers on mouse position\n" ..
        "Ã¢â‚¬Â¢ Enable Auto-Follow for smooth tracking\n" ..
        "Ã¢â‚¬Â¢ Adjust Dead Zone to reduce jitter",
        obs.OBS_TEXT_INFO)
    obs.obs_properties_add_group(props, "help", "Ã¢Ââ€œ Help", obs.OBS_GROUP_NORMAL, grp_help)

    return props
end

--[[ Called to set default values
--[[ @param data table Settings data
function script_defaults(data)
    obs.obs_data_set_default_string(data, "source", "")
    obs.obs_data_set_default_double(data, "zoom_value", 2.0)
    obs.obs_data_set_default_double(data, "zoom_duration", 0.6)
    obs.obs_data_set_default_double(data, "zoom_overshoot", 0.0)
    obs.obs_data_set_default_string(data, "zoom_easing", "Cubic.Out")
    obs.obs_data_set_default_bool(data, "auto_follow", true)
    obs.obs_data_set_default_double(data, "follow_smooth_time", 0.15)
    obs.obs_data_set_default_int(data, "follow_dead_zone", 5)
    obs.obs_data_set_default_double(data, "scroll_step", 0.25)
    obs.obs_data_set_default_bool(data, "debug_logs", false)
    obs.obs_data_set_default_bool(data, "api_enabled", false)
    obs.obs_data_set_default_int(data, "api_port", 12345)
end

--================================================
-- SCRIPT METADATA
--================================================
script_info = {
    name = "OBS Zoom Pro",
    version = VERSION,
    description = "Intelligent camera zoom functionality with smooth transitions and easing curves.",
    author = "OBS Zoom Pro Team"
}
)

local platform = detect_platform()
local IS_WINDOWS = platform.WINDOWS
local IS_LINUX = platform.LINUX
local IS_MACOS = platform.MACOS

-- Log platform detection
log("Platform detected: " .. (jit and jit.os or "Unknown") .. (IS_WINDOWS and " (Full support)" or " (Basic support)"))

-- Virtual key codes (Lua constants instead of C #define)
local VK_LBUTTON = 0x01
local VK_RBUTTON = 0x02
local VK_MBUTTON = 0x04
local VK_CONTROL = 0x11
local VK_SHIFT = 0x10
local VK_MENU = 0x12  -- Alt

-- FFI declarations for Windows (only if FFI is available)


-- Cursor shape constants (Windows)
local CURSOR_ARROW = 1
local CURSOR_IBEAM = 2
local CURSOR_HAND = 3
local CURSOR_WAIT = 4

-- Module state
local Platform = {
    cursor_shape_available = IS_WINDOWS,
    last_mouse = { x = 0, y = 0 },
    last_click = false,
}

-- Get mouse position (cross-platform)
function Platform.get_mouse_pos()
    if IS_WINDOWS then
        local success, pt = pcall(function()
            local pt = ffi.new("POINT")
            if ffi.C.GetCursorPos(pt) ~= 0 then
                return { x = tonumber(pt.x), y = tonumber(pt.y) }
            end
            return nil
        end)
        if success and pt then
            return pt
        end
    elseif IS_LINUX then
        -- Linux: Use xdotool if available, fallback to X11
        local success, result = pcall(function()
            local handle = io.popen("xdotool getmouselocation 2>/dev/null || echo 'x:0 y:0'")
            if handle then
                local output = handle:read("*a")
                handle:close()
                local x, y = output:match("x:(%d+)%s+y:(%d+)")
                if x and y then
                    return { x = tonumber(x), y = tonumber(y) }
                end
            end
            return nil
        end)
        if success and result then
            return result
        end
    elseif IS_MACOS then
        -- macOS: Use osascript
        local success, result = pcall(function()
            local handle = io.popen(--[[osascript -e 'tell application "System Events" to get position of the mouse' 2>/dev/null || echo "0, 0"]])
            if handle then
                local output = handle:read("*a")
                handle:close()
                local x, y = output:match("(%d+),%s*(%d+)")
                if x and y then
                    return { x = tonumber(x), y = tonumber(y) }
                end
            end
            return nil
        end)
        if success and result then
            return result
        end
    end

    -- Fallback
    return { x = 0, y = 0 }
end

-- Check if left mouse button is clicked (Windows only, others return false)
function Platform.is_clicking()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x01) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if a modifier key is held (Windows only)
function Platform.is_key_held(vk_code)
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(vk_code) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if cursor is a pointer/hand (Windows only)
function Platform.is_cursor_pointer()
    if IS_WINDOWS then
        local success, result = pcall(function()
            local ci = ffi.new("CURSORINFO")
            ci.cbSize = ffi.sizeof("CURSORINFO")
            if ffi.C.GetCursorInfo(ci) ~= 0 then
                -- Check if hCursor is a hand pointer
                -- This is a simplified check; real implementation would compare cursor handles
                return ci.flags ~= 0  -- Simplified; actual implementation needs cursor handle comparison
            end
            return false
        end)
        return success and result or false
    end
    return false
end

-- Get cursor shape (Windows only, returns "arrow" for others)
function Platform.get_cursor_shape()
    if IS_WINDOWS then
        local success, result = pcall(function()
            local ci = ffi.new("CURSORINFO")
            ci.cbSize = ffi.sizeof("CURSORINFO")
            if ffi.C.GetCursorInfo(ci) ~= 0 and ci.hCursor ~= nil then
                local addr = tonumber(ffi.cast("uintptr_t", ci.hCursor))
                -- Common cursor IDs (these are typical values, may vary)
                -- IDC_ARROW = 32512, IDC_IBEAM = 32513, IDC_HAND = 32649
                -- We use address ranges as heuristic
                return "arrow"  -- Simplified; actual implementation would map handles
            end
            return "arrow"
        end)
        return success and result or "arrow"
    end
    return "arrow"
end

-- Check if Control key is held
function Platform.is_ctrl_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x11) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if Shift key is held
function Platform.is_shift_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x10) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if Alt key is held
function Platform.is_alt_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x12) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Convenience wrapper functions
function platform_get_mouse_pos()
    return Platform.get_mouse_pos()
end

function platform_is_clicking()
    return Platform.is_clicking()
end

function platform_is_cursor_pointer()
    return Platform.is_cursor_pointer()
end

function platform_cursor_shape_available()
    return Platform.cursor_shape_available
end

function platform_is_ctrl_held()
    return Platform.is_ctrl_held()
end

function platform_is_shift_held()
    return Platform.is_shift_held()
end

function platform_is_alt_held()
    return Platform.is_alt_held()
end

--================================================
-- MODULE: State Machine (M05)
--================================================
-- Manages zoom states and transitions
-- States: IDLE, ZOOMING_IN, ZOOMED_IN, ZOOMING_OUT, SCROLLING, JUMPING

local ZoomState = {
    IDLE         = "idle",
    ZOOMING_IN   = "zooming_in",
    ZOOMED_IN    = "zoomed_in",
    ZOOMING_OUT  = "zooming_out",
    SCROLLING    = "scrolling",    -- Scroll wheel mid-transition
    JUMPING      = "jumping",      -- Bookmark transition
}

local StateMachine = {
    state = ZoomState.IDLE,
    zoom_time = 0,          -- Animation progress (0 Ã¢â€ â€™ 1)
    zoom_level = 1.0,       -- Current zoom factor
    target_level = 1.0,     -- Target zoom factor
    start_crop = nil,       -- Crop at animation start {x, y, w, h}
    target_crop = nil,      -- Crop at animation end {x, y, w, h}
    following = false,      -- Mouse follow active

    -- Transition guards
    can_zoom_in = function(self)
        return self.state == ZoomState.IDLE
    end,

    can_zoom_out = function(self)
        return self.state == ZoomState.ZOOMED_IN
            or self.state == ZoomState.SCROLLING
    end,

    can_scroll = function(self)
        return self.state == ZoomState.ZOOMED_IN
            or self.state == ZoomState.IDLE
            or self.state == ZoomState.SCROLLING
    end,

    can_jump = function(self)
        return self.state ~= ZoomState.ZOOMING_IN
           and self.state ~= ZoomState.ZOOMING_OUT
           and self.state ~= ZoomState.JUMPING
    end,

    is_animating = function(self)
        return self.state == ZoomState.ZOOMING_IN
            or self.state == ZoomState.ZOOMING_OUT
            or self.state == ZoomState.SCROLLING
            or self.state == ZoomState.JUMPING
    end,

    is_zoomed = function(self)
        return self.state ~= ZoomState.IDLE
    end,
}

-- Transition to a new state
function StateMachine:transition(new_state, params)
    local old = self.state
    self.state = new_state
    self.zoom_time = 0

    if params then
        if params.start_crop then self.start_crop = params.start_crop end
        if params.target_crop then self.target_crop = params.target_crop end
        if params.target_level then self.target_level = params.target_level end
    end

    log("State: " .. old .. " Ã¢â€ â€™ " .. new_state)
end

-- Complete the current animation
function StateMachine:complete()
    if self.state == ZoomState.ZOOMING_IN
       or self.state == ZoomState.SCROLLING
       or self.state == ZoomState.JUMPING then
        self.zoom_level = self.target_level
        self.state = ZoomState.ZOOMED_IN
        self.zoom_time = 0
        log("State: " .. self.state .. " Ã¢â€ â€™ ZOOMED_IN (complete)")
    elseif self.state == ZoomState.ZOOMING_OUT then
        self.zoom_level = 1.0
        self.target_level = 1.0
        self.start_crop = nil
        self.target_crop = nil
        self.following = false
        self.state = ZoomState.IDLE
        self.zoom_time = 0
        log("State: ZOOMING_OUT Ã¢â€ â€™ IDLE (complete)")
    end
end

-- Reset to initial state
function StateMachine:reset()
    self.state = ZoomState.IDLE
    self.zoom_time = 0
    self.zoom_level = 1.0
    self.target_level = 1.0
    self.start_crop = nil
    self.target_crop = nil
    self.following = false
    log("StateMachine: Reset to IDLE")
end

-- Get current animation progress (0-1)
function StateMachine:get_progress()
    return clamp(0, 1, self.zoom_time)
end

-- Check if in a specific state
function StateMachine:is_state(state)
    return self.state == state
end

-- Get state name for display
function StateMachine:get_state_name()
    return self.state
end

-- Create a new state machine instance (for testing/isolation)
function StateMachine:new()
    local sm = {}
    setmetatable(sm, { __index = self })
    sm.state = ZoomState.IDLE
    sm.zoom_time = 0
    sm.zoom_level = 1.0
    sm.target_level = 1.0
    sm.start_crop = nil
    sm.target_crop = nil
    sm.following = false
    return sm
end

-- Global state machine instance
local SM = StateMachine:new()

--================================================
-- MODULE: Crop Filter Manager (M07)
--================================================
-- Manages the crop/pad filter used to simulate zoom
-- Creates, updates, and destroys the filter automatically

local FILTER_PREFIX = "[ZoomPro] "
local CROP_FILTER_NAME = FILTER_PREFIX .. "Crop"

local CropFilterManager = {
    filter = nil,           -- The crop filter source
    source = nil,           -- The parent source
    original_crop = nil,    -- Original crop values for restoration
    current_crop = { x = 0, y = 0, w = 0, h = 0 },
    initialized = false,
}

-- Create the crop filter on a source
function CropFilterManager:create(source)
    if not source then
        log("CropFilter: No source provided")
        return false
    end

    self:cleanup()  -- Clean up any existing filter
    self.source = source

    -- Check if our filter already exists
    local existing = obs.obs_source_get_filter_by_name(source, CROP_FILTER_NAME)
    if existing then
        log("CropFilter: Found existing filter")
        self.filter = existing
        self.initialized = true
        return true
    end

    -- Create new crop/pad filter
    local settings = obs.obs_data_create()
    obs.obs_data_set_int(settings, "left", 0)
    obs.obs_data_set_int(settings, "top", 0)
    obs.obs_data_set_int(settings, "right", 0)
    obs.obs_data_set_int(settings, "bottom", 0)
    obs.obs_data_set_bool(settings, "relative", false)  -- Absolute positioning

    self.filter = obs.obs_source_create_private(
        "crop_filter",      -- Filter type
        CROP_FILTER_NAME,   -- Filter name
        settings            -- Settings
    )

    obs.obs_data_release(settings)

    if not self.filter then
        log("CropFilter: Failed to create filter")
        return false
    end

    -- Add filter to source
    obs.obs_source_filter_add(source, self.filter)

    -- Store original crop (none)
    self.original_crop = { x = 0, y = 0, w = 0, h = 0 }

    self.initialized = true
    log("CropFilter: Created successfully")
    return true
end

-- Update the crop filter with new values
function CropFilterManager:update(x, y, w, h)
    if not self.filter or not self.initialized then
        return false
    end

    -- Store current crop
    self.current_crop = { x = x, y = y, w = w, h = h }

    -- Get filter settings
    local settings = obs.obs_source_get_settings(self.filter)
    if not settings then
        return false
    end

    -- Calculate crop values
    -- For crop_filter: left, top are absolute position
    -- right, bottom are width/height from right/bottom edge
    -- We need to convert our x, y, w, h to this format

    -- Get source dimensions
    local source_w = obs.obs_source_get_width(self.source)
    local source_h = obs.obs_source_get_height(self.source)

    if source_w == 0 or source_h == 0 then
        obs.obs_data_release(settings)
        return false
    end

    -- Set crop values
    -- left = x offset from left
    -- top = y offset from top
    -- right = source_w - (x + w) = remaining width on right
    -- bottom = source_h - (y + h) = remaining height on bottom
    local left = math.floor(x)
    local top = math.floor(y)
    local right = math.floor(source_w - (x + w))
    local bottom = math.floor(source_h - (y + h))

    -- Clamp to valid values
    left = math.max(0, left)
    top = math.max(0, top)
    right = math.max(0, right)
    bottom = math.max(0, bottom)

    obs.obs_data_set_int(settings, "left", left)
    obs.obs_data_set_int(settings, "top", top)
    obs.obs_data_set_int(settings, "right", right)
    obs.obs_data_set_int(settings, "bottom", bottom)

    -- Update the filter
    obs.obs_source_update(self.filter, settings)
    obs.obs_data_release(settings)

    return true
end

-- Get current crop values
function CropFilterManager:get_crop()
    return self.current_crop
end

-- Reset crop to original (no crop)
function CropFilterManager:reset()
    if not self.filter or not self.initialized then
        return false
    end

    local settings = obs.obs_source_get_settings(self.filter)
    if settings then
        obs.obs_data_set_int(settings, "left", 0)
        obs.obs_data_set_int(settings, "top", 0)
        obs.obs_data_set_int(settings, "right", 0)
        obs.obs_data_set_int(settings, "bottom", 0)
        obs.obs_source_update(self.filter, settings)
        obs.obs_data_release(settings)
    end

    self.current_crop = { x = 0, y = 0, w = 0, h = 0 }
    return true
end

-- Remove the filter and restore original state
function CropFilterManager:cleanup()
    if self.filter and self.source then
        -- Reset to no crop first
        self:reset()

        -- Remove filter from source
        obs.obs_source_filter_remove(self.source, self.filter)
        obs.obs_source_release(self.filter)
        self.filter = nil
        log("CropFilter: Removed from source")
    end

    self.source = nil
    self.original_crop = nil
    self.current_crop = { x = 0, y = 0, w = 0, h = 0 }
    self.initialized = false
end

-- Check if filter is ready
function CropFilterManager:is_ready()
    return self.initialized and self.filter ~= nil
end

-- Get source dimensions
function CropFilterManager:get_source_size()
    if not self.source then
        return 0, 0
    end
    return obs.obs_source_get_width(self.source), obs.obs_source_get_height(self.source)
end

-- Convenience wrapper functions
function crop_filter_create(source)
    return CropFilterManager:create(source)
end

function crop_filter_update(x, y, w, h)
    return CropFilterManager:update(x, y, w, h)
end

function crop_filter_reset()
    return CropFilterManager:reset()
end

function crop_filter_cleanup()
    return CropFilterManager:cleanup()
end

function crop_filter_is_ready()
    return CropFilterManager:is_ready()
end

function crop_filter_get_crop()
    return CropFilterManager:get_crop()
end

function crop_filter_get_source_size()
    return CropFilterManager:get_source_size()
end

--================================================
-- MODULE: Source Manager (M08)
--================================================
-- Handles finding sources in scenes, capturing transforms,
-- and managing source state for zoom operations

local SourceManager = {
    source = nil,           -- Current zoom source
    sceneitem = nil,        -- Scene item reference
    scene = nil,            -- Current scene
    original_transform = nil, -- Saved original transform
    source_name = "",       -- Source name for settings
    initialized = false,
}

-- Transform data structure
local TransformData = {
    pos = { x = 0, y = 0 },
    scale = { x = 1.0, y = 1.0 },
    rot = 0,
    bounds_type = 0,
    bounds = { x = 0, y = 0 },
    crop = { left = 0, top = 0, right = 0, bottom = 0 },
}

-- Find a source in a scene (BFS through groups)
function SourceManager:find_sceneitem(scene, source_name)
    if not scene or not source_name then
        return nil
    end

    local scene_source = obs.obs_scene_from_source(scene)
    if not scene_source then
        return nil
    end

    -- BFS queue
    local queue = {}
    table.insert(queue, scene_source)

    while #queue > 0 do
        local current_scene = table.remove(queue, 1)

        -- Iterate through items
        local items = obs.obs_scene_enum_items(current_scene)
        if items then
            for _, item in ipairs(items) do
                local item_source = obs.obs_sceneitem_get_source(item)
                if item_source then
                    local name = obs.obs_source_get_name(item_source)

                    -- Check if this is our target
                    if name == source_name then
                        obs.sceneitem_list_release(items)
                        return item
                    end

                    -- Check if this is a group (nested scene)
                    if obs.obs_source_get_type(item_source) == obs.OBS_SOURCE_TYPE_INPUT then
                        local id = obs.obs_source_get_id(item_source)
                        if id == "group" then
                            local group_scene = obs.obs_group_from_source(item_source)
                            if group_scene then
                                table.insert(queue, group_scene)
                            end
                        end
                    end
                end
            end
            obs.sceneitem_list_release(items)
        end
    end

    return nil
end

-- Capture the current transform of a scene item
function SourceManager:capture_transform(sceneitem)
    if not sceneitem then
        return nil
    end

    local transform = {}

    -- Position
    local pos = obs.vec2()
    obs.obs_sceneitem_get_pos(sceneitem, pos)
    transform.pos = { x = pos.x, y = pos.y }

    -- Scale
    local scale = obs.vec2()
    obs.obs_sceneitem_get_scale(sceneitem, scale)
    transform.scale = { x = scale.x, y = scale.y }

    -- Rotation
    transform.rot = obs.obs_sceneitem_get_rot(sceneitem)

    -- Bounds
    transform.bounds_type = obs.obs_sceneitem_get_bounds_type(sceneitem)
    local bounds = obs.vec2()
    obs.obs_sceneitem_get_bounds(sceneitem, bounds)
    transform.bounds = { x = bounds.x, y = bounds.y }

    -- Crop
    local crop = obs.obs_sceneitem_crop()
    obs.obs_sceneitem_get_crop(sceneitem, crop)
    transform.crop = {
        left = crop.left,
        top = crop.top,
        right = crop.right,
        bottom = crop.bottom
    }

    return transform
end

-- Restore a saved transform to a scene item
function SourceManager:restore_transform(sceneitem, transform)
    if not sceneitem or not transform then
        return false
    end

    -- Position
    local pos = obs.vec2()
    pos.x = transform.pos.x
    pos.y = transform.pos.y
    obs.obs_sceneitem_set_pos(sceneitem, pos)

    -- Scale
    local scale = obs.vec2()
    scale.x = transform.scale.x
    scale.y = transform.scale.y
    obs.obs_sceneitem_set_scale(sceneitem, scale)

    -- Rotation
    obs.obs_sceneitem_set_rot(sceneitem, transform.rot)

    -- Bounds
    obs.obs_sceneitem_set_bounds_type(sceneitem, transform.bounds_type)
    local bounds = obs.vec2()
    bounds.x = transform.bounds.x
    bounds.y = transform.bounds.y
    obs.obs_sceneitem_set_bounds(sceneitem, bounds)

    -- Crop
    local crop = obs.obs_sceneitem_crop()
    crop.left = transform.crop.left
    crop.top = transform.crop.top
    crop.right = transform.crop.right
    crop.bottom = transform.crop.bottom
    obs.obs_sceneitem_set_crop(sceneitem, crop)

    return true
end

-- Initialize with a source name
function SourceManager:init(source_name)
    self:release()  -- Clean up any existing state

    if not source_name or source_name == "" then
        log("SourceManager: No source name provided")
        return false
    end

    self.source_name = source_name

    -- Get current scene
    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then
        log("SourceManager: No current scene")
        return false
    end

    self.scene = scene_source

    -- Find the scene item
    self.sceneitem = self:find_sceneitem(scene_source, source_name)
    if not self.sceneitem then
        log("SourceManager: Source not found in scene: " .. source_name)
        obs.obs_source_release(scene_source)
        return false
    end

    -- Get the source
    self.source = obs.obs_sceneitem_get_source(self.sceneitem)
    if not self.source then
        log("SourceManager: Failed to get source from sceneitem")
        obs.obs_source_release(scene_source)
        return false
    end

    -- Capture original transform
    self.original_transform = self:capture_transform(self.sceneitem)

    -- Create crop filter
    if not crop_filter_create(self.source) then
        log("SourceManager: Failed to create crop filter")
        obs.obs_source_release(scene_source)
        return false
    end

    self.initialized = true
    log("SourceManager: Initialized with source: " .. source_name)

    obs.obs_source_release(scene_source)
    return true
end

-- Release all resources
function SourceManager:release()
    -- Clean up crop filter
    crop_filter_cleanup()

    -- Restore original transform if we have it
    if self.sceneitem and self.original_transform then
        self:restore_transform(self.sceneitem, self.original_transform)
        log("SourceManager: Restored original transform")
    end

    self.source = nil
    self.sceneitem = nil
    self.scene = nil
    self.original_transform = nil
    self.initialized = false

    log("SourceManager: Released")
end

-- Get source dimensions
function SourceManager:get_source_size()
    if not self.source then
        return 0, 0
    end
    return obs.obs_source_get_width(self.source), obs.obs_source_get_height(self.source)
end

-- Check if source is valid
function SourceManager:is_valid()
    return self.initialized and self.source ~= nil and self.sceneitem ~= nil
end

-- Get source info
function SourceManager:get_info()
    if not self:is_valid() then
        return nil
    end

    return {
        name = self.source_name,
        width = obs.obs_source_get_width(self.source),
        height = obs.obs_source_get_height(self.source),
    }
end

-- Get list of available capture sources
function SourceManager.get_available_sources()
    local sources = {}

    -- Get all sources
    local source_list = obs.obs_enum_sources()
    if source_list then
        for _, source in ipairs(source_list) do
            local source_id = obs.obs_source_get_id(source)
            local name = obs.obs_source_get_name(source)

            -- Filter for capture sources
            local is_capture = false
            if source_id == "monitor_capture" or      -- Display capture
               source_id == "window_capture" or       -- Window capture
               source_id == "game_capture" or         -- Game capture
               source_id == "xshm_input" or           -- Linux X11 capture
               source_id == "av_capture_input" then   -- macOS capture
                is_capture = true
            end

            if is_capture then
                table.insert(sources, {
                    name = name,
                    id = source_id,
                })
            end
        end
        obs.source_list_release(source_list)
    end

    return sources
end

-- Convenience wrapper functions
function source_manager_init(source_name)
    return SourceManager:init(source_name)
end

function source_manager_release()
    return SourceManager:release()
end

function source_manager_is_valid()
    return SourceManager:is_valid()
end

function source_manager_get_source()
    return SourceManager.source
end

function source_manager_get_sceneitem()
    return SourceManager.sceneitem
end

function source_manager_get_size()
    return SourceManager:get_source_size()
end

function source_manager_get_available_sources()
    return SourceManager.get_available_sources()
end

--================================================
-- MODULE: Camera Physics (M06)
--================================================
-- Handles camera position calculations, dead zones,
-- and SmoothDamp-based camera movement

local CameraPhysics = {
    -- Smoothed camera position
    pos = { x = 0, y = 0 },

    -- Velocities for SmoothDamp
    vel_x = { val = 0 },
    vel_y = { val = 0 },

    -- Dead zone state
    tracked_pos = { x = 0, y = 0 },
    dead_zone_active = false,

    -- Last camera position (for velocity calculation)
    last_pos = { x = 0, y = 0 },

    -- Monitor offset (for multi-monitor setups)
    monitor_offset = { x = 0, y = 0 },
}

-- Initialize camera tracking with starting position
function CameraPhysics:init(mouse_pos)
    if mouse_pos then
        self.pos.x = mouse_pos.x
        self.pos.y = mouse_pos.y
        self.tracked_pos.x = mouse_pos.x
        self.tracked_pos.y = mouse_pos.y
    end
    self.vel_x.val = 0
    self.vel_y.val = 0
    self.last_pos.x = self.pos.x
    self.last_pos.y = self.pos.y
end

-- Apply dead zone to mouse input
-- Returns the position the camera should track
function CameraPhysics:apply_dead_zone(mouse_pos, dead_zone_radius)
    if not mouse_pos then
        return self.tracked_pos
    end

    if dead_zone_radius <= 0 then
        self.tracked_pos.x = mouse_pos.x
        self.tracked_pos.y = mouse_pos.y
        return self.tracked_pos
    end

    -- Calculate distance from tracked position to mouse
    local dx = mouse_pos.x - self.tracked_pos.x
    local dy = mouse_pos.y - self.tracked_pos.y
    local dist = math.sqrt(dx * dx + dy * dy)

    if dist <= dead_zone_radius then
        -- Mouse is within dead zone, don't move tracked position
        self.dead_zone_active = true
        return self.tracked_pos
    end

    -- Mouse is outside dead zone
    -- Move tracked position so it stays exactly dead_zone_radius from mouse
    self.dead_zone_active = false
    local excess = dist - dead_zone_radius
    local nx = dx / dist  -- Normalized direction
    local ny = dy / dist

    self.tracked_pos.x = self.tracked_pos.x + nx * excess
    self.tracked_pos.y = self.tracked_pos.y + ny * excess

    return self.tracked_pos
end

-- Smooth the input position using SmoothDamp
function CameraPhysics:smooth_input(target_pos, smooth_time, dt)
    if not target_pos then
        return self.pos
    end

    local max_speed = 100000  -- Very high max speed for smooth camera

    self.pos.x = SmoothDamp(self.pos.x, target_pos.x, self.vel_x, smooth_time, max_speed, dt)
    self.pos.y = SmoothDamp(self.pos.y, target_pos.y, self.vel_y, smooth_time, max_speed, dt)

    return self.pos
end

-- Calculate the crop rectangle for a given zoom level and center position
function CameraPhysics:compute_crop(center_x, center_y, zoom_level, source_w, source_h)
    if zoom_level <= 1.0 then
        -- No zoom, return full source
        return {
            x = 0,
            y = 0,
            w = source_w,
            h = source_h,
        }
    end

    -- Calculate crop dimensions
    local crop_w = source_w / zoom_level
    local crop_h = source_h / zoom_level

    -- Center the crop on the target position
    local crop_x = center_x - crop_w / 2
    local crop_y = center_y - crop_h / 2

    -- Clamp to source bounds
    crop_x = clamp(0, source_w - crop_w, crop_x)
    crop_y = clamp(0, source_h - crop_h, crop_y)

    return {
        x = crop_x,
        y = crop_y,
        w = crop_w,
        h = crop_h,
    }
end

-- Calculate target crop for zoom animation
-- mouse_pos: current mouse position
-- zoom_level: target zoom level
-- source_w, source_h: source dimensions
-- monitor_offset: offset for multi-monitor (optional)
function CameraPhysics:get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
    if not mouse_pos then
        return nil
    end

    -- Apply monitor offset if provided
    local target_x = mouse_pos.x
    local target_y = mouse_pos.y

    if monitor_offset then
        target_x = target_x - monitor_offset.x
        target_y = target_y - monitor_offset.y
    end

    -- Clamp to source bounds
    target_x = clamp(0, source_w, target_x)
    target_y = clamp(0, source_h, target_y)

    return self:compute_crop(target_x, target_y, zoom_level, source_w, source_h)
end

-- Interpolate between two crop rectangles
function CameraPhysics:lerp_crop(start_crop, end_crop, t, easing_fn)
    if not start_crop or not end_crop then
        return nil
    end

    t = clamp(0, 1, t)

    -- Apply easing
    local eased_t = easing_fn and easing_fn(t) or t

    return {
        x = lerp(start_crop.x, end_crop.x, eased_t),
        y = lerp(start_crop.y, end_crop.y, eased_t),
        w = lerp(start_crop.w, end_crop.w, eased_t),
        h = lerp(start_crop.h, end_crop.h, eased_t),
    }
end

-- Get camera velocity (for motion blur)
function CameraPhysics:get_velocity()
    return {
        x = self.pos.x - self.last_pos.x,
        y = self.pos.y - self.last_pos.y,
    }
end

-- Update last position (call at end of frame)
function CameraPhysics:update_last_pos()
    self.last_pos.x = self.pos.x
    self.last_pos.y = self.pos.y
end

-- Set monitor offset
function CameraPhysics:set_monitor_offset(offset)
    self.monitor_offset = offset or { x = 0, y = 0 }
end

-- Reset camera state
function CameraPhysics:reset()
    self.pos = { x = 0, y = 0 }
    self.vel_x = { val = 0 }
    self.vel_y = { val = 0 }
    self.tracked_pos = { x = 0, y = 0 }
    self.dead_zone_active = false
    self.last_pos = { x = 0, y = 0 }
end

-- Convenience wrapper functions
function camera_physics_init(mouse_pos)
    return CameraPhysics:init(mouse_pos)
end

function camera_physics_apply_dead_zone(mouse_pos, dead_zone_radius)
    return CameraPhysics:apply_dead_zone(mouse_pos, dead_zone_radius)
end

function camera_physics_smooth_input(target_pos, smooth_time, dt)
    return CameraPhysics:smooth_input(target_pos, smooth_time, dt)
end

function camera_physics_compute_crop(center_x, center_y, zoom_level, source_w, source_h)
    return CameraPhysics:compute_crop(center_x, center_y, zoom_level, source_w, source_h)
end

function camera_physics_get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
    return CameraPhysics:get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
end

function camera_physics_lerp_crop(start_crop, end_crop, t, easing_fn)
    return CameraPhysics:lerp_crop(start_crop, end_crop, t, easing_fn)
end

function camera_physics_get_velocity()
    return CameraPhysics:get_velocity()
end

function camera_physics_update_last_pos()
    return CameraPhysics:update_last_pos()
end

function camera_physics_reset()
    return CameraPhysics:reset()
end

--================================================
-- MODULE: Timer & Main Loop (M09)
--================================================
-- Core integration module that handles frame-by-frame updates,
-- input processing, state machine updates, and output

-- Configuration (will be populated from settings)
local cfg = {
    source_name = "",
    zoom_value = 2.0,
    max_zoom = 10.0,
    zoom_duration = 0.6,
    zoom_overshoot = 0.0,
    zoom_easing = "Cubic.Out",

    auto_follow = true,
    follow_smooth_time = 0.15,
    follow_dead_zone = 5,

    debug_logs = false,
}

-- Timing
local last_tick_time = 0
local timer_running = false

-- Frame diff tracking (skip updates if nothing changed)
local last_output = { x = -1, y = -1, w = -1, h = -1 }

-- Original crop for zoom out
local original_crop = { x = 0, y = 0, w = 0, h = 0 }

-- Hotkey IDs
local hotkey_toggle_zoom = nil
local hotkey_toggle_follow = nil

-- Get reliable delta time
local function get_dt()
    local now = os.clock()
    local dt = now - last_tick_time
    last_tick_time = now
    return clamp(0.001, 0.1, dt)  -- Guard against freezes and div/zero
end

-- Start the timer
local function start_timer()
    if not timer_running then
        timer_running = true
        last_tick_time = os.clock()
        -- Use frame-synced interval
        local interval = 16  -- Default to ~60fps
        obs.timer_add(on_timer, interval)
        log("Timer: Started")
    end
end

-- Stop the timer
local function stop_timer()
    if timer_running then
        timer_running = false
        obs.timer_remove(on_timer)
        log("Timer: Stopped")
    end
end

-- Initialize mouse tracking
local function init_mouse_tracking(mouse_pos)
    camera_physics_init(mouse_pos)
    original_crop = {
        x = 0,
        y = 0,
        w = 0,
        h = 0,
    }
end

-- Main timer callback
function on_timer()
    local dt = get_dt()

    -- Guard: No valid source
    if not source_manager_is_valid() then
        return
    end

    --==========================
    -- 1. INPUT
    --==========================
    local raw_mouse = platform_get_mouse_pos()

    --==========================
    -- 2. STATE MACHINE UPDATE
    --==========================
    if SM:is_animating() then
        SM.zoom_time = SM.zoom_time + (dt / cfg.zoom_duration)

        -- Check for completion
        if SM.zoom_time >= 1.0 then
            SM:complete()

            -- Auto-enable follow after zoom in
            if SM.state == ZoomState.ZOOMED_IN and cfg.auto_follow then
                SM.following = true
            end

            -- Stop timer if idle
            if SM.state == ZoomState.IDLE then
                stop_timer()
            end
        end
    end

    --==========================
    -- 3. CAMERA POSITION
    --==========================
    local crop = nil
    local source_w, source_h = source_manager_get_size()

    if source_w == 0 or source_h == 0 then
        return
    end

    if SM:is_animating() then
        -- Animate between start and target crop
        local easing_fn = Easing.get(cfg.zoom_easing, cfg.zoom_overshoot)
        crop = camera_physics_lerp_crop(SM.start_crop, SM.target_crop, SM.zoom_time, easing_fn)
    elseif SM:is_zoomed() and SM.following then
        -- Follow mouse with dead zone and smoothing
        local tracked = camera_physics_apply_dead_zone(raw_mouse, cfg.follow_dead_zone)
        local smoothed = camera_physics_smooth_input(tracked, cfg.follow_smooth_time, dt)
        crop = camera_physics_compute_crop(smoothed.x, smoothed.y, SM.zoom_level, source_w, source_h)
        camera_physics_update_last_pos()
    elseif SM:is_zoomed() then
        -- Static zoom (not following)
        crop = camera_physics_get_target_crop(
            { x = SM.target_crop.x + SM.target_crop.w / 2, y = SM.target_crop.y + SM.target_crop.h / 2 },
            SM.zoom_level, source_w, source_h, nil
        )
    end

    --==========================
    -- 4. OUTPUT (Diff-based)
    --==========================
    if crop then
        local cx = math.floor(crop.x)
        local cy = math.floor(crop.y)
        local cw = math.floor(crop.w)
        local ch = math.floor(crop.h)

        if cx ~= last_output.x or cy ~= last_output.y or
           cw ~= last_output.w or ch ~= last_output.h then
            crop_filter_update(cx, cy, cw, ch)
            last_output.x = cx
            last_output.y = cy
            last_output.w = cw
            last_output.h = ch
        end
    end
end

--==========================
-- HOTKEY HANDLERS
--==========================

function on_toggle_zoom(pressed)
    if not pressed then return end

    if not source_manager_is_valid() then
        log("Toggle Zoom: No valid source")
        return
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        log("Toggle Zoom: Invalid source dimensions")
        return
    end

    if SM.state == ZoomState.IDLE then
        -- ZOOM IN
        local mouse = platform_get_mouse_pos()
        init_mouse_tracking(mouse)

        -- Store original crop
        original_crop = { x = 0, y = 0, w = source_w, h = source_h }

        -- Calculate target crop
        local target_crop = camera_physics_get_target_crop(mouse, cfg.zoom_value, source_w, source_h, nil)

        SM:transition(ZoomState.ZOOMING_IN, {
            start_crop = original_crop,
            target_crop = target_crop,
            target_level = cfg.zoom_value
        })

        start_timer()

    elseif SM.state == ZoomState.ZOOMED_IN then
        -- ZOOM OUT
        SM.following = false

        local current = crop_filter_get_crop()
        SM:transition(ZoomState.ZOOMING_OUT, {
            start_crop = current,
            target_crop = original_crop,
            target_level = 1.0
        })

        start_timer()
    end
    -- Ignore if already animating (guard against rapid presses)
end

function on_toggle_follow(pressed)
    if not pressed then return end
    if not SM:is_zoomed() then return end

    SM.following = not SM.following
    log("Follow: " .. tostring(SM.following))

    if SM.following and not timer_running then
        start_timer()
    end
end

--==========================
-- HOTKEY REGISTRATION
--==========================

local function register_hotkeys(settings)
    -- Toggle Zoom hotkey
    hotkey_toggle_zoom = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.toggle_zoom",
        "Toggle Zoom to Mouse",
        on_toggle_zoom
    )

    -- Toggle Follow hotkey
    hotkey_toggle_follow = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.toggle_follow",
        "Toggle Mouse Follow",
        on_toggle_follow
    )

    -- Load saved hotkey bindings
    local toggle_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.toggle_zoom")
    if toggle_array then
        obs.obs_hotkey_load(hotkey_toggle_zoom, toggle_array)
        obs.obs_data_array_release(toggle_array)
    end

    local follow_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.toggle_follow")
    if follow_array then
        obs.obs_hotkey_load(hotkey_toggle_follow, follow_array)
        obs.obs_data_array_release(follow_array)
    end

    -- Register scroll zoom hotkeys
    register_scroll_hotkeys(settings)

    log("Hotkeys: Registered")
end

local function save_hotkeys(settings)
    if hotkey_toggle_zoom then
        local array = obs.obs_hotkey_save(hotkey_toggle_zoom)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.toggle_zoom", array)
        obs.obs_data_array_release(array)
    end

    if hotkey_toggle_follow then
        local array = obs.obs_hotkey_save(hotkey_toggle_follow)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.toggle_follow", array)
        obs.obs_data_array_release(array)
    end

    -- Save scroll zoom hotkeys
    save_scroll_hotkeys(settings)
end

local function unregister_hotkeys()
    if hotkey_toggle_zoom then
        obs.obs_hotkey_unregister(hotkey_toggle_zoom)
        hotkey_toggle_zoom = nil
    end
    if hotkey_toggle_follow then
        obs.obs_hotkey_unregister(hotkey_toggle_follow)
        hotkey_toggle_follow = nil
    end
    -- Unregister scroll zoom hotkeys
    unregister_scroll_hotkeys()
    log("Hotkeys: Unregistered")
end

--==========================
-- SCENE EVENT HANDLERS
--==========================

function on_frontend_event(event)
    if event == obs.OBS_FRONTEND_EVENT_SCENE_CHANGED then
        -- Scene changed, re-acquire source
        log("Event: Scene changed")

        -- Handle scene memory
        scene_memory_on_scene_change()

        if cfg.source_name and cfg.source_name ~= "" then
            source_manager_release()
            source_manager_init(cfg.source_name)
        end
    elseif event == obs.OBS_FRONTEND_EVENT_EXIT then
        -- OBS is closing
        log("Event: OBS exiting")
        stop_timer()
        source_manager_release()
    end
end

--==========================
-- CONFIGURATION UPDATE
--==========================

local function update_config(settings)
    cfg.source_name = obs.obs_data_get_string(settings, "source") or ""
    cfg.zoom_value = obs.obs_data_get_double(settings, "zoom_value")
    cfg.zoom_duration = obs.obs_data_get_double(settings, "zoom_duration")
    cfg.zoom_overshoot = obs.obs_data_get_double(settings, "zoom_overshoot")
    cfg.zoom_easing = obs.obs_data_get_string(settings, "zoom_easing") or "Cubic.Out"

    cfg.auto_follow = obs.obs_data_get_bool(settings, "auto_follow")
    cfg.follow_smooth_time = obs.obs_data_get_double(settings, "follow_smooth_time")
    cfg.follow_dead_zone = obs.obs_data_get_int(settings, "follow_dead_zone")

    cfg.debug_logs = obs.obs_data_get_bool(settings, "debug_logs")
    debug_logs = cfg.debug_logs

    -- Update scroll zoom config
    update_scroll_config(settings)

    -- Check if source changed
    local current_source = source_manager_is_valid() and cfg.source_name
    if cfg.source_name ~= "" and cfg.source_name ~= current_source then
        -- Reset state and reinitialize
        SM:reset()
        stop_timer()
        source_manager_release()
        source_manager_init(cfg.source_name)
    end
end

--================================================
-- MODULE: Scroll Zoom (M10)
--================================================
-- Enables gradual zoom control via scroll wheel with modifier key
-- Provides dynamic zoom level adjustment during zoomed state

local ScrollZoom = {
    -- Hotkey IDs for scroll zoom
    hotkey_scroll_up = nil,
    hotkey_scroll_down = nil,

    -- Configuration (populated from settings)
    scroll_step = 0.25,
    scroll_modifier = "ctrl",  -- "ctrl", "alt", "shift"
}

-- Check if modifier key is held
local function is_modifier_held()
    if ScrollZoom.scroll_modifier == "ctrl" then
        return platform_is_ctrl_held()
    elseif ScrollZoom.scroll_modifier == "alt" then
        return platform_is_alt_held()
    elseif ScrollZoom.scroll_modifier == "shift" then
        return platform_is_shift_held()
    end
    return false
end

-- Handle scroll zoom in
function on_scroll_zoom_up(pressed)
    if not pressed then return end
    on_scroll_zoom(1)
end

-- Handle scroll zoom out
function on_scroll_zoom_down(pressed)
    if not pressed then return end
    on_scroll_zoom(-1)
end

-- Main scroll zoom handler
function on_scroll_zoom(direction)
    -- Check if we can scroll
    if not SM:can_scroll() then return end

    -- Check modifier (optional - can be configured)
    -- For now, we rely on OBS hotkey bindings which can include modifiers

    if not source_manager_is_valid() then
        log("Scroll Zoom: No valid source")
        return
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        return
    end

    -- Calculate new zoom level
    local step = ScrollZoom.scroll_step * direction  -- e.g., 0.25
    local new_level

    if SM.state == ZoomState.IDLE then
        -- Starting from unzoomed
        new_level = 1.0 + step
    else
        -- Already zoomed, adjust level
        new_level = SM.target_level + step
    end

    -- Clamp to valid range
    new_level = clamp(1.0, cfg.max_zoom, new_level)

    -- If we hit 1.0, fully zoom out
    if new_level <= 1.0 then
        if SM:is_zoomed() then
            -- Trigger full zoom out
            local current = crop_filter_get_crop()
            SM.following = false
            SM:transition(ZoomState.ZOOMING_OUT, {
                start_crop = current,
                target_crop = original_crop,
                target_level = 1.0
            })
            start_timer()
        end
        return
    end

    -- Get current mouse position
    local mouse = platform_get_mouse_pos()

    -- Calculate new target crop for new zoom level
    local target_crop = camera_physics_get_target_crop(mouse, new_level, source_w, source_h, nil)

    -- Get current crop as start
    local start_crop
    if SM:is_animating() then
        -- Use current interpolated crop
        start_crop = crop_filter_get_crop()
    elseif SM:is_zoomed() then
        -- Use current crop
        start_crop = crop_filter_get_crop()
    else
        -- Starting from unzoomed
        start_crop = { x = 0, y = 0, w = source_w, h = source_h }
        original_crop = start_crop
        camera_physics_init(mouse)
    end

    -- Transition to new zoom level
    if SM.state == ZoomState.IDLE then
        -- First scroll from unzoomed
        SM:transition(ZoomState.SCROLLING, {
            start_crop = start_crop,
            target_crop = target_crop,
            target_level = new_level
        })
    else
        -- Already zoomed, adjust level (interrupt current animation)
        SM:transition(ZoomState.SCROLLING, {
            start_crop = start_crop,
            target_crop = target_crop,
            target_level = new_level
        })
    end

    start_timer()
    log("Scroll Zoom: Level " .. string.format("%.2f", new_level))
end

-- Zoom to a specific level (for API calls)
function on_scroll_zoom_to(level)
    if not source_manager_is_valid() then return end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then return end

    level = clamp(1.0, cfg.max_zoom, level)

    if level <= 1.0 then
        -- Zoom out
        if SM:is_zoomed() then
            local current = crop_filter_get_crop()
            SM.following = false
            SM:transition(ZoomState.ZOOMING_OUT, {
                start_crop = current,
                target_crop = original_crop,
                target_level = 1.0
            })
            start_timer()
        end
        return
    end

    local mouse = platform_get_mouse_pos()
    local target_crop = camera_physics_get_target_crop(mouse, level, source_w, source_h, nil)

    local start_crop
    if SM:is_zoomed() then
        start_crop = crop_filter_get_crop()
    else
        start_crop = { x = 0, y = 0, w = source_w, h = source_h }
        original_crop = start_crop
        camera_physics_init(mouse)
    end

    SM:transition(ZoomState.SCROLLING, {
        start_crop = start_crop,
        target_crop = target_crop,
        target_level = level
    })

    start_timer()
end

-- Register scroll zoom hotkeys
local function register_scroll_hotkeys(settings)
    -- Scroll Up hotkey
    ScrollZoom.hotkey_scroll_up = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.scroll_up",
        "Zoom In (Scroll)",
        on_scroll_zoom_up
    )

    -- Scroll Down hotkey
    ScrollZoom.hotkey_scroll_down = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.scroll_down",
        "Zoom Out (Scroll)",
        on_scroll_zoom_down
    )

    -- Load saved bindings
    local up_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.scroll_up")
    if up_array then
        obs.obs_hotkey_load(ScrollZoom.hotkey_scroll_up, up_array)
        obs.obs_data_array_release(up_array)
    end

    local down_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.scroll_down")
    if down_array then
        obs.obs_hotkey_load(ScrollZoom.hotkey_scroll_down, down_array)
        obs.obs_data_array_release(down_array)
    end

    log("Scroll Zoom: Hotkeys registered")
end

-- Save scroll hotkey bindings
local function save_scroll_hotkeys(settings)
    if ScrollZoom.hotkey_scroll_up then
        local array = obs.obs_hotkey_save(ScrollZoom.hotkey_scroll_up)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.scroll_up", array)
        obs.obs_data_array_release(array)
    end

    if ScrollZoom.hotkey_scroll_down then
        local array = obs.obs_hotkey_save(ScrollZoom.hotkey_scroll_down)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.scroll_down", array)
        obs.obs_data_array_release(array)
    end
end

-- Unregister scroll hotkeys
local function unregister_scroll_hotkeys()
    if ScrollZoom.hotkey_scroll_up then
        obs.obs_hotkey_unregister(ScrollZoom.hotkey_scroll_up)
        ScrollZoom.hotkey_scroll_up = nil
    end
    if ScrollZoom.hotkey_scroll_down then
        obs.obs_hotkey_unregister(ScrollZoom.hotkey_scroll_down)
        ScrollZoom.hotkey_scroll_down = nil
    end
end

-- Update scroll zoom config
local function update_scroll_config(settings)
    ScrollZoom.scroll_step = obs.obs_data_get_double(settings, "scroll_step")
    ScrollZoom.scroll_modifier = obs.obs_data_get_string(settings, "scroll_modifier") or "ctrl"
end

--================================================
-- PLACEHOLDER: Future Modules
--================================================

-- M01: Configuration & Settings (TODO)
-- M05: Scene Manager (TODO)
-- M06: Source Manager (TODO)
-- M07: Crop/Zoom Controller (TODO)
-- M08: Motion Tracker (TODO)
-- M09: Face Detection (TODO)
-- M11: Audio Reactor (TODO)
-- M12: Transition Manager (TODO)
-- M13: Animation Controller (TODO)
-- M14: Preset Manager (TODO)
-- M15: Hotkey Manager (TODO)
-- M16: UI Components (TODO)
-- M17: Timer/Scheduler (TODO)
-- M18: State Machine (TODO)
-- M19: Performance Monitor (TODO)

--================================================
-- SCRIPT SETTINGS
--================================================
local settings = {}

-- Default settings
local defaults = {
    debug_logging = false,
    easing_type = "QuadInOut",
    smooth_time = 0.3,
    max_speed = 100.0
}

--================================================
-- MODULE: Preset Manager (M13)
--================================================
-- Manages built-in and custom animation presets

local PresetManager = {
    -- Built-in presets (read-only)
    built_in = {
        {
            name = "Smooth",
            duration = 0.8,
            overshoot = 0.0,
            smoothness = 0.25,
            easing = "Cubic.Out",
        },
        {
            name = "Bounce",
            duration = 0.6,
            overshoot = 0.35,
            smoothness = 0.15,
            easing = "Back.Out",
        },
        {
            name = "Snappy",
            duration = 0.3,
            overshoot = 0.0,
            smoothness = 0.05,
            easing = "Expo.Out",
        },
        {
            name = "Cinematic",
            duration = 1.2,
            overshoot = 0.05,
            smoothness = 0.4,
            easing = "Sine.Out",
        },
    },

    -- Custom user presets
    custom = {},

    -- Currently selected preset name
    current_preset = "Smooth",
}

-- Get all preset names (built-in + custom)
function PresetManager:get_all_names()
    local names = {}

    -- Add built-in presets
    for _, preset in ipairs(self.built_in) do
        table.insert(names, preset.name)
    end

    -- Add custom presets
    for name, _ in pairs(self.custom) do
        table.insert(names, name)
    end

    table.sort(names)
    return names
end

-- Get preset by name
function PresetManager:get_preset(name)
    -- Check built-in first
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            return preset
        end
    end

    -- Check custom
    if self.custom[name] then
        return self.custom[name]
    end

    -- Default to Smooth
    return self.built_in[1]
end

-- Apply preset to configuration
function PresetManager:apply_preset(name)
    local preset = self:get_preset(name)
    if not preset then
        log("Preset: Unknown preset: " .. name)
        return false
    end

    cfg.zoom_duration = preset.duration
    cfg.zoom_overshoot = preset.overshoot
    cfg.follow_smooth_time = preset.smoothness

    if preset.easing then
        cfg.zoom_easing = preset.easing
    end

    self.current_preset = name
    log("Preset: Applied '" .. name .. "'")
    return true
end

-- Save a custom preset
function PresetManager:save_preset(name, duration, overshoot, smoothness, easing)
    if not name or name == "" then
        return false
    end

    -- Check if it's a built-in preset (can't override)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            log("Preset: Cannot override built-in preset: " .. name)
            return false
        end
    end

    -- Save custom preset
    self.custom[name] = {
        name = name,
        duration = duration or cfg.zoom_duration,
        overshoot = overshoot or cfg.zoom_overshoot,
        smoothness = smoothness or cfg.follow_smooth_time,
        easing = easing or cfg.zoom_easing,
    }

    log("Preset: Saved custom preset '" .. name .. "'")
    return true
end

-- Delete a custom preset
function PresetManager:delete_preset(name)
    -- Check if it's a built-in preset (can't delete)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            log("Preset: Cannot delete built-in preset: " .. name)
            return false
        end
    end

    -- Delete custom preset
    if self.custom[name] then
        self.custom[name] = nil
        log("Preset: Deleted custom preset '" .. name .. "'")
        return true
    end

    return false
end

-- Check if a preset is built-in
function PresetManager:is_built_in(name)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            return true
        end
    end
    return false
end

-- Persist custom presets to settings
function PresetManager:persist(settings)
    local array = obs.obs_data_array_create()

    for name, preset in pairs(self.custom) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "name", name)
        obs.obs_data_set_double(item, "duration", preset.duration)
        obs.obs_data_set_double(item, "overshoot", preset.overshoot)
        obs.obs_data_set_double(item, "smoothness", preset.smoothness)
        obs.obs_data_set_string(item, "easing", preset.easing)
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "custom_presets", array)
    obs.obs_data_array_release(array)
end

-- Load custom presets from settings
function PresetManager:load(settings)
    self.custom = {}

    local array = obs.obs_data_get_array(settings, "custom_presets")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local name = obs.obs_data_get_string(item, "name")

        if name and name ~= "" then
            self.custom[name] = {
                name = name,
                duration = obs.obs_data_get_double(item, "duration"),
                overshoot = obs.obs_data_get_double(item, "overshoot"),
                smoothness = obs.obs_data_get_double(item, "smoothness"),
                easing = obs.obs_data_get_string(item, "easing"),
            }
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)
    log("Preset: Loaded " .. self:get_custom_count() .. " custom presets")
end

-- Get count of custom presets
function PresetManager:get_custom_count()
    local count = 0
    for _, _ in pairs(self.custom) do
        count = count + 1
    end
    return count
end

-- Get current preset name
function PresetManager:get_current_name()
    return self.current_preset
end

-- Set current preset name
function PresetManager:set_current_name(name)
    self.current_preset = name
end

-- Check if current preset is custom
function PresetManager:is_current_custom()
    return not self:is_built_in(self.current_preset)
end

-- Global convenience functions
function preset_get_all_names()
    return PresetManager:get_all_names()
end

function preset_apply(name)
    return PresetManager:apply_preset(name)
end

function preset_save(name, duration, overshoot, smoothness, easing)
    return PresetManager:save_preset(name, duration, overshoot, smoothness, easing)
end

function preset_delete(name)
    return PresetManager:delete_preset(name)
end

function preset_is_built_in(name)
    return PresetManager:is_built_in(name)
end

function preset_get_current()
    return PresetManager:get_current_name()
end

--================================================
-- MODULE: Auto Source Detection (M11)
--================================================
-- Automatically detects and selects the best zoom source on first run

local AutoSourceDetector = {
    -- Source type priorities (higher = more likely to be the main display)
    type_priorities = {
        ["monitor_capture"] = 100,     -- Display capture (highest priority)
        ["game_capture"] = 80,          -- Game capture
        ["window_capture"] = 60,        -- Window capture
        ["xshm_input"] = 40,           -- Linux X11 capture
        ["av_capture_input"] = 20,     -- macOS capture
    },

    -- Whether auto-detection has been run
    auto_detected = false,
}

-- Get all capture sources sorted by priority
function AutoSourceDetector:get_capture_sources()
    local sources = {}
    local source_list = obs.obs_enum_sources()

    if not source_list then
        return sources
    end

    for _, source in ipairs(source_list) do
        local source_id = obs.obs_source_get_id(source)
        local name = obs.obs_source_get_name(source)

        -- Check if it's a capture source
        local priority = self.type_priorities[source_id]
        if priority then
            table.insert(sources, {
                name = name,
                id = source_id,
                priority = priority,
            })
        end
    end

    obs.source_list_release(source_list)

    -- Sort by priority (highest first)
    table.sort(sources, function(a, b)
        return a.priority > b.priority
    end)

    return sources
end

-- Auto-detect the best source
function AutoSourceDetector:auto_detect()
    local sources = self:get_capture_sources()

    if #sources == 0 then
        log("AutoSource: No capture sources found")
        return nil
    end

    if #sources == 1 then
        -- Only one source, use it
        log("AutoSource: Found single source: " .. sources[1].name)
        return sources[1].name
    end

    -- Multiple sources - prioritize by type
    -- Prefer monitor_capture > game_capture > window_capture
    local best = sources[1]

    log("AutoSource: Found " .. #sources .. " sources, selecting: " .. best.name)
    return best.name
end

-- Get monitor geometry from a source (if available)
function AutoSourceDetector:get_monitor_geometry(source_name)
    local source = obs.obs_get_source_by_name(source_name)
    if not source then
        return nil
    end

    local settings = obs.obs_source_get_settings(source)
    if not settings then
        obs.obs_source_release(source)
        return nil
    end

    -- Try to get monitor info from settings
    local monitor = obs.obs_data_get_int(settings, "monitor")
    local x = obs.obs_data_get_int(settings, "x")
    local y = obs.obs_data_get_int(settings, "y")
    local width = obs.obs_data_get_int(settings, "width")
    local height = obs.obs_data_get_int(settings, "height")

    obs.obs_data_release(settings)
    obs.obs_source_release(source)

    -- Return geometry if available
    if monitor >= 0 or width > 0 then
        return {
            monitor = monitor,
            x = x,
            y = y,
            width = width or 1920,
            height = height or 1080,
        }
    end

    return nil
end

-- Check if we should auto-detect on first run
function AutoSourceDetector:should_auto_detect(settings)
    -- Check if source has ever been set
    local last_source = obs.obs_data_get_string(settings, "source")
    if last_source and last_source ~= "" then
        return false
    end

    -- Check if auto-detect has been done
    return not self.auto_detected
end

-- Run auto-detection and return the source name
function AutoSourceDetector:run(settings)
    local source_name = self:auto_detect()

    if source_name then
        -- Save the detected source
        obs.obs_data_set_string(settings, "source", source_name)
        self.auto_detected = true
    end

    return source_name
end

-- Global convenience functions
function auto_source_detect()
    return AutoSourceDetector:auto_detect()
end

function auto_source_should_detect(settings)
    return AutoSourceDetector:should_auto_detect(settings)
end

function auto_source_run(settings)
    return AutoSourceDetector:run(settings)
end

--================================================
-- MODULE: Scene Memory (M12)
--================================================
-- Remembers which zoom source to use for each OBS scene

local SceneMemory = {
    -- Scene to source mapping
    scene_source_map = {},

    -- Maximum number of mappings to store
    max_mappings = 50,
}

-- Get the current scene name
function SceneMemory:get_current_scene_name()
    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then
        return nil
    end

    local name = obs.obs_source_get_name(scene_source)
    obs.obs_source_release(scene_source)
    return name
end

-- Get the source to use for the current scene
function SceneMemory:get_source_for_current_scene()
    local scene_name = self:get_current_scene_name()
    if not scene_name then
        return nil
    end

    -- 1. Check explicit mapping for this scene
    if self.scene_source_map[scene_name] then
        return self.scene_source_map[scene_name]
    end

    -- 2. Fall back to global source from config
    return cfg.source_name
end

-- Set the source for a specific scene
function SceneMemory:set(scene_name, source_name)
    if not scene_name or scene_name == "" then
        return false
    end

    -- Check if we're at capacity
    local count = 0
    for _, _ in pairs(self.scene_source_map) do
        count = count + 1
    end

    if count >= self.max_mappings and not self.scene_source_map[scene_name] then
        log("SceneMemory: At capacity (" .. self.max_mappings .. "), cannot add: " .. scene_name)
        return false
    end

    self.scene_source_map[scene_name] = source_name
    log("SceneMemory: " .. scene_name .. " Ã¢â€ â€™ " .. source_name)
    return true
end

-- Remove a scene mapping
function SceneMemory:remove(scene_name)
    if self.scene_source_map[scene_name] then
        self.scene_source_map[scene_name] = nil
        log("SceneMemory: Removed mapping for " .. scene_name)
        return true
    end
    return false
end

-- Get all scene mappings
function SceneMemory:get_all()
    local mappings = {}
    for scene, source in pairs(self.scene_source_map) do
        table.insert(mappings, { scene = scene, source = source })
    end
    table.sort(mappings, function(a, b)
        return a.scene < b.scene
    end)
    return mappings
end

-- Check if a scene has a mapping
function SceneMemory:has_mapping(scene_name)
    return self.scene_source_map[scene_name] ~= nil
end

-- Persist mappings to settings
function SceneMemory:persist(settings)
    local array = obs.obs_data_array_create()

    for scene, source in pairs(self.scene_source_map) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "scene", scene)
        obs.obs_data_set_string(item, "source", source)
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "scene_source_map", array)
    obs.obs_data_array_release(array)
end

-- Load mappings from settings
function SceneMemory:load(settings)
    self.scene_source_map = {}

    local array = obs.obs_data_get_array(settings, "scene_source_map")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local scene = obs.obs_data_get_string(item, "scene")
        local source = obs.obs_data_get_string(item, "source")

        if scene and scene ~= "" and source and source ~= "" then
            self.scene_source_map[scene] = source
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)

    local count = 0
    for _, _ in pairs(self.scene_source_map) do count = count + 1 end
    log("SceneMemory: Loaded " .. count .. " scene mappings")
end

-- Handle scene change
function SceneMemory:on_scene_change()
    local scene_name = self:get_current_scene_name()
    if not scene_name then
        return
    end

    -- Get the source for this scene
    local source_name = self:get_source_for_current_scene()

    if source_name and source_name ~= "" then
        -- Check if source changed
        local current = source_manager_is_valid() and cfg.source_name

        if source_name ~= current then
            log("SceneMemory: Scene changed to " .. scene_name)

            -- Release current source
            source_manager_release()

            -- Initialize with new source
            cfg.source_name = source_name
            source_manager_init(source_name)
        end
    end
end

-- Global convenience functions
function scene_memory_get_source()
    return SceneMemory:get_source_for_current_scene()
end

function scene_memory_set(scene_name, source_name)
    return SceneMemory:set(scene_name, source_name)
end

function scene_memory_remove(scene_name)
    return SceneMemory:remove(scene_name)
end

function scene_memory_get_all()
    return SceneMemory:get_all()
end

function scene_memory_on_scene_change()
    return SceneMemory:on_scene_change()
end

--================================================
-- MODULE: Blur Manager (M14)
--================================================
-- Provides built-in blur effects without external plugins
-- Supports multiple strategies: shader, composite_blur plugin, or none

local BlurManager = {
    -- Current strategy: "shader", "composite_blur", "none"
    strategy = "none",

    -- Filter references
    zoom_blur_filter = nil,
    motion_blur_filter = nil,

    -- Settings references
    zoom_blur_settings = nil,
    motion_blur_settings = nil,

    -- State
    initialized = false,

    -- Configuration
    zoom_blur_enabled = false,
    zoom_blur_intensity = 5,
    zoom_blur_clear_radius = 150,
    motion_blur_enabled = false,
    motion_blur_intensity = 1.0,
}

-- Try to use custom shader (if effect files exist)
function BlurManager:try_shader_strategy(source)
    -- This would require .effect files in assets/shaders/
    -- For now, we'll use a simpler approach
    log("Blur: Shader strategy not implemented (requires effect files)")
    return false
end

-- Try to auto-create Composite Blur filters
function BlurManager:try_composite_blur_strategy(source)
    if not source then return false end

    -- Check if composite_blur filter type exists
    local test_filter = obs.obs_source_create_private("composite_blur", "__test_blur__", nil)
    if test_filter then
        obs.obs_source_release(test_filter)
    else
        log("Blur: Composite Blur plugin not available")
        return false
    end

    -- Create Zoom Blur filter
    local zs = obs.obs_data_create()
    obs.obs_data_set_double(zs, "radius", 0)
    obs.obs_data_set_int(zs, "blur_type", 2) -- Zoom type
    self.zoom_blur_filter = obs.obs_source_create_private(
        "composite_blur",
        FILTER_PREFIX .. "Zoom Blur",
        zs
    )

    if self.zoom_blur_filter then
        obs.obs_source_filter_add(source, self.zoom_blur_filter)
        self.zoom_blur_settings = zs
    else
        obs.obs_data_release(zs)
        return false
    end

    -- Create Motion Blur filter
    local ms = obs.obs_data_create()
    obs.obs_data_set_double(ms, "radius", 0)
    obs.obs_data_set_int(ms, "blur_type", 3) -- Motion/directional type
    self.motion_blur_filter = obs.obs_source_create_private(
        "composite_blur",
        FILTER_PREFIX .. "Motion Blur",
        ms
    )

    if self.motion_blur_filter then
        obs.obs_source_filter_add(source, self.motion_blur_filter)
        self.motion_blur_settings = ms
    else
        obs.obs_data_release(ms)
    end

    self.initialized = true
    return true
end

-- Initialize blur manager
function BlurManager:init(source)
    if not source then
        return false
    end

    self:cleanup()

    -- Try composite_blur strategy
    if self:try_composite_blur_strategy(source) then
        self.strategy = "composite_blur"
        log("Blur: Using Composite Blur plugin (auto-configured)")
        return true
    end

    -- No blur available
    self.strategy = "none"
    log("Blur: No blur backend available. Blur effects disabled.")
    return false
end

-- Update blur based on zoom state
function BlurManager:update(state_machine, crop, camera_velocity)
    if not self.initialized then return end
    if self.strategy == "none" then return end

    -- Zoom Blur: Active during zoom transitions
    if self.zoom_blur_enabled and self.zoom_blur_filter then
        local radius = 0

        if state_machine:is_animating() and
           (state_machine.state == ZoomState.ZOOMING_IN or
            state_machine.state == ZoomState.ZOOMING_OUT) then
            -- Bell curve: 0 at start Ã¢â€ â€™ peak at 50% Ã¢â€ â€™ 0 at end
            local t = clamp(0, 1, state_machine.zoom_time)
            local curve = math.sin(t * math.pi)
            radius = curve * curve * self.zoom_blur_intensity
        end

        self:set_zoom_blur(radius, crop)
    end

    -- Motion Blur: Active during camera panning (not during zoom transition)
    if self.motion_blur_enabled and self.motion_blur_filter then
        if not state_machine:is_animating() and state_machine:is_zoomed() and camera_velocity then
            local speed = math.sqrt(
                camera_velocity.x * camera_velocity.x +
                camera_velocity.y * camera_velocity.y
            )

            if speed > 1.0 then
                local radius = math.min(10, speed * self.motion_blur_intensity * 0.5)
                local angle = math.deg(math.atan2(camera_velocity.y, camera_velocity.x))
                self:set_motion_blur(radius, angle)
            else
                self:set_motion_blur(0, 0)
            end
        else
            self:set_motion_blur(0, 0)
        end
    end
end

-- Set zoom blur parameters
function BlurManager:set_zoom_blur(radius, crop)
    if self.strategy == "composite_blur" and self.zoom_blur_settings then
        obs.obs_data_set_double(self.zoom_blur_settings, "radius", radius)

        if crop then
            local cx = crop.x + (crop.w / 2)
            local cy = crop.y + (crop.h / 2)
            obs.obs_data_set_double(self.zoom_blur_settings, "center_x", cx)
            obs.obs_data_set_double(self.zoom_blur_settings, "center_y", cy)
        end

        obs.obs_data_set_double(self.zoom_blur_settings, "inactive_radius", self.zoom_blur_clear_radius)
        obs.obs_source_update(self.zoom_blur_filter, self.zoom_blur_settings)
    end
end

-- Set motion blur parameters
function BlurManager:set_motion_blur(radius, angle)
    if self.strategy == "composite_blur" and self.motion_blur_settings then
        obs.obs_data_set_double(self.motion_blur_settings, "radius", radius)
        obs.obs_data_set_double(self.motion_blur_settings, "angle", angle)
        obs.obs_source_update(self.motion_blur_filter, self.motion_blur_settings)
    end
end

-- Update configuration
function BlurManager:update_config(settings)
    self.zoom_blur_enabled = obs.obs_data_get_bool(settings, "zoom_blur_enabled")
    self.zoom_blur_intensity = obs.obs_data_get_double(settings, "zoom_blur_intensity")
    self.zoom_blur_clear_radius = obs.obs_data_get_double(settings, "zoom_blur_clear_radius")
    self.motion_blur_enabled = obs.obs_data_get_bool(settings, "motion_blur_enabled")
    self.motion_blur_intensity = obs.obs_data_get_double(settings, "motion_blur_intensity")
end

-- Cleanup filters
function BlurManager:cleanup()
    local source = source_manager_get_source()

    if self.zoom_blur_filter and source then
        obs.obs_source_filter_remove(source, self.zoom_blur_filter)
        obs.obs_source_release(self.zoom_blur_filter)
        self.zoom_blur_filter = nil
    end

    if self.motion_blur_filter and source then
        obs.obs_source_filter_remove(source, self.motion_blur_filter)
        obs.obs_source_release(self.motion_blur_filter)
        self.motion_blur_filter = nil
    end

    if self.zoom_blur_settings then
        obs.obs_data_release(self.zoom_blur_settings)
        self.zoom_blur_settings = nil
    end

    if self.motion_blur_settings then
        obs.obs_data_release(self.motion_blur_settings)
        self.motion_blur_settings = nil
    end

    self.initialized = false
    self.strategy = "none"
end

-- Check if blur is available
function BlurManager:is_available()
    return self.strategy ~= "none"
end

-- Global convenience functions
function blur_manager_init(source)
    return BlurManager:init(source)
end

function blur_manager_update(state_machine, crop, camera_velocity)
    return BlurManager:update(state_machine, crop, camera_velocity)
end

function blur_manager_update_config(settings)
    return BlurManager:update_config(settings)
end

function blur_manager_cleanup()
    return BlurManager:cleanup()
end

function blur_manager_is_available()
    return BlurManager:is_available()
end

--================================================
-- MODULE: Cursor Asset Manager (M16)
--================================================
-- Handles extracting and managing cursor image assets

local CursorAssets = {
    extracted = false,
    dir = nil,
}

-- Get the platform-specific asset directory
function CursorAssets:get_platform_dir()
    if IS_WINDOWS then
        local appdata = os.getenv("APPDATA")
        return appdata and (appdata .. "\\obs-studio\\obs-zoom-pro\\cursors") or nil
    elseif IS_LINUX then
        local home = os.getenv("HOME")
        return home and (home .. "/.config/obs-studio/obs-zoom-pro/cursors") or nil
    elseif IS_MACOS then
        local home = os.getenv("HOME")
        return home and (home .. "/Library/Application Support/obs-studio/obs-zoom-pro/cursors") or nil
    end
    -- Fallback for non-FFI environments
    return "cursors"
end

-- Ensure assets are extracted
function CursorAssets:ensure_extracted()
    if self.extracted then
        return self.dir
    end

    local dir = self:get_platform_dir()
    if not dir then
        log("CursorAssets: Could not determine asset directory")
        return nil
    end

    -- Create directory
    local cmd
    if IS_WINDOWS then
        cmd = 'mkdir "' .. dir .. '" 2>nul'
    else
        cmd = 'mkdir -p "' .. dir .. '"'
    end
    os.execute(cmd)

    -- Check if assets exist
    local sep = IS_WINDOWS and "\\" or "/"
    local arrow_path = dir .. sep .. "arrow.png"

    local f = io.open(arrow_path, "rb")
    if f then
        f:close()
        self.dir = dir
        self.extracted = true
        log("CursorAssets: Using existing assets from " .. dir)
        return dir
    end

    -- Try to copy from script directory
    local script_dir = get_script_directory()
    local assets_src = script_dir .. "assets" .. sep .. "cursors" .. sep

    local files = { "arrow.png", "pointer.png", "ibeam.png" }
    for _, filename in ipairs(files) do
        local src_path = assets_src .. filename
        local dst_path = dir .. sep .. filename

        local src = io.open(src_path, "rb")
        if src then
            local data = src:read("*a")
            src:close()

            local dst = io.open(dst_path, "wb")
            if dst then
                dst:write(data)
                dst:close()
                log("CursorAssets: Copied " .. filename)
            end
        end
    end

    self.dir = dir
    self.extracted = true
    return dir
end

-- Get the asset directory
function CursorAssets:get_dir()
    return self.dir
end

-- Check if assets are available
function CursorAssets:is_available()
    if not self.extracted then
        self:ensure_extracted()
    end
    return self.dir ~= nil
end

-- Get cursor image path
function CursorAssets:get_cursor_path(cursor_type)
    if not self:is_available() then
        return nil
    end

    local sep = IS_WINDOWS and "\\" or "/"
    local filename = (cursor_type or "arrow") .. ".png"
    return self.dir .. sep .. filename
end

-- Global convenience functions
function cursor_assets_ensure_extracted()
    return CursorAssets:ensure_extracted()
end

function cursor_assets_get_dir()
    return CursorAssets:get_dir()
end

function cursor_assets_is_available()
    return CursorAssets:is_available()
end

function cursor_assets_get_cursor_path(cursor_type)
    return CursorAssets:get_cursor_path(cursor_type)
end

--================================================
-- MODULE: Cursor Renderer (M15)
--================================================
-- Provides automatic cursor overlay rendering

local CursorRenderer = {
    enabled = false,
    source = nil,
    sceneitem = nil,

    -- Smoothed state
    pos = { x = 0, y = 0 },
    current_scale = 1.0,
    current_rot = 0,
    swap_pulse = 1.0,

    -- Velocities (SmoothDamp)
    vel_x = { val = 0 },
    vel_y = { val = 0 },
    vel_scale = { val = 0 },
    vel_rot = { val = 0 },
    vel_swap = { val = 0 },

    -- State
    was_pointer = false,
    initialized = false,

    -- Configuration
    cursor_scale = 1.0,
    cursor_click_scale = 0.78,
    cursor_smooth_time = 0.1,
    cursor_offset_x = -6,
    cursor_offset_y = -2,
    cursor_rotation_mode = "None",
    cursor_angle_offset = 0,
    cursor_tilt_strength = 0,
}

-- Initialize cursor renderer
function CursorRenderer:init()
    if not cfg.cursor_enabled then
        self.enabled = false
        return false
    end

    -- Ensure cursor assets are available
    local asset_dir = cursor_assets_ensure_extracted()
    if not asset_dir then
        log("CursorRenderer: Failed to extract cursor assets")
        self.enabled = false
        return false
    end

    -- Get or create the cursor image source
    local source_name = FILTER_PREFIX .. "Cursor"
    self.source = obs.obs_get_source_by_name(source_name)

    if not self.source then
        -- Create new image source
        local settings = obs.obs_data_create()
        local cursor_path = cursor_assets_get_cursor_path("arrow")
        if cursor_path then
            obs.obs_data_set_string(settings, "file", cursor_path)
        end
        self.source = obs.obs_source_create("image_source", source_name, settings, nil)
        obs.obs_data_release(settings)

        if not self.source then
            log("CursorRenderer: Failed to create image source")
            self.enabled = false
            return false
        end
    end

    -- Add to current scene
    self:add_to_scene()

    -- Initialize position
    local mouse = platform_get_mouse_pos()
    self.pos.x = mouse.x
    self.pos.y = mouse.y

    self.enabled = true
    self.initialized = true
    log("CursorRenderer: Initialized")
    return true
end

-- Add cursor source to scene
function CursorRenderer:add_to_scene()
    if not self.source then return false end

    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then return false end

    local scene = obs.obs_scene_from_source(scene_source)
    if not scene then
        obs.obs_source_release(scene_source)
        return false
    end

    -- Check if already in scene
    local source_name = obs.obs_source_get_name(self.source)
    self.sceneitem = obs.obs_scene_find_source(scene, source_name)

    if not self.sceneitem then
        -- Add to scene
        self.sceneitem = obs.obs_scene_add(scene, self.source)
        if self.sceneitem then
            -- Move to top (render last = on top)
            obs.obs_sceneitem_set_order(self.sceneitem, obs.OBS_ORDER_MOVE_TOP)
        end
    end

    obs.obs_source_release(scene_source)
    return true
end

-- Update cursor position and state
function CursorRenderer:update(dt, raw_mouse, camera_crop)
    if not self.enabled or not self.sceneitem then return end

    -- Smooth cursor position
    self.pos.x = SmoothDamp(self.pos.x, raw_mouse.x, self.vel_x, self.cursor_smooth_time, 100000, dt)
    self.pos.y = SmoothDamp(self.pos.y, raw_mouse.y, self.vel_y, self.cursor_smooth_time, 100000, dt)

    -- Snap when very close
    if math.abs(self.pos.x - raw_mouse.x) < 0.5 then
        self.pos.x = raw_mouse.x
        self.vel_x.val = 0
    end
    if math.abs(self.pos.y - raw_mouse.y) < 0.5 then
        self.pos.y = raw_mouse.y
        self.vel_y.val = 0
    end

    -- Cursor shape detection (Windows only)
    local is_pointer = false
    if platform_cursor_shape_available() then
        is_pointer = platform_is_cursor_pointer()
    end

    -- Swap cursor image if needed
    if is_pointer ~= self.was_pointer then
        local asset_dir = cursor_assets_get_dir()
        local sep = IS_WINDOWS and "\\" or "/"
        local new_file = is_pointer and (asset_dir .. sep .. "pointer.png") or (asset_dir .. sep .. "arrow.png")

        local s = obs.obs_source_get_settings(self.source)
        if s then
            obs.obs_data_set_string(s, "file", new_file)
            obs.obs_source_update(self.source, s)
            obs.obs_data_release(s)
        end

        -- Trigger swap pulse
        self.swap_pulse = 0.75
        self.vel_swap.val = 1
        self.was_pointer = is_pointer
    end

    self.swap_pulse = SmoothDamp(self.swap_pulse, 1.0, self.vel_swap, 0.12, 100000, dt)

    -- Click animation
    local is_clicking = platform_is_clicking()
    local target_scale = is_clicking and (self.cursor_scale * self.cursor_click_scale) or self.cursor_scale
    self.current_scale = SmoothDamp(self.current_scale, target_scale, self.vel_scale, 0.1, 100000, dt)

    -- Calculate position relative to zoom
    local zoom_factor = 1.0
    local crop_x, crop_y = 0, 0

    if camera_crop and SM:is_zoomed() then
        zoom_factor = source_manager_get_size() / camera_crop.w
        crop_x = camera_crop.x
        crop_y = camera_crop.y
    end

    local final_x = (self.pos.x - crop_x) * zoom_factor + (self.cursor_offset_x * zoom_factor)
    local final_y = (self.pos.y - crop_y) * zoom_factor + (self.cursor_offset_y * zoom_factor)

    -- Apply to scene item
    local pos = obs.vec2()
    pos.x = final_x
    pos.y = final_y
    obs.obs_sceneitem_set_pos(self.sceneitem, pos)

    local scale = obs.vec2()
    local s = self.current_scale * zoom_factor * self.swap_pulse
    scale.x = s
    scale.y = s
    obs.obs_sceneitem_set_scale(self.sceneitem, scale)

    -- Rotation
    local dynamic_rot = self:compute_rotation(dt)
    obs.obs_sceneitem_set_rot(self.sceneitem, dynamic_rot)
end

-- Compute rotation based on mode
function CursorRenderer:compute_rotation(dt)
    local vx = self.vel_x.val
    local vy = self.vel_y.val
    local speed = math.sqrt(vx * vx + vy * vy)

    if self.cursor_rotation_mode == "Directional" then
        if speed > 20 then
            local angle = math.atan2(vy, vx) * (180 / math.pi)
            local target = angle + self.cursor_angle_offset
            local diff = (target - self.current_rot + 180) % 360 - 180
            self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.05, 100000, dt)
        end
        return self.current_rot

    elseif self.cursor_rotation_mode == "Lean" then
        local lean = clamp(-40, 40, vx * 0.05 * self.cursor_tilt_strength) + self.cursor_angle_offset
        local diff = (lean - self.current_rot + 180) % 360 - 180
        self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.08, 100000, dt)
        return self.current_rot
    end

    -- "None" mode
    local diff = (self.cursor_angle_offset - self.current_rot + 180) % 360 - 180
    self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.15, 100000, dt)
    return self.current_rot
end

-- Update configuration
function CursorRenderer:update_config(settings)
    self.cursor_scale = obs.obs_data_get_double(settings, "cursor_scale")
    self.cursor_click_scale = obs.obs_data_get_double(settings, "cursor_click_scale")
    self.cursor_smooth_time = obs.obs_data_get_double(settings, "cursor_smooth_time")
    self.cursor_offset_x = obs.obs_data_get_int(settings, "cursor_offset_x")
    self.cursor_offset_y = obs.obs_data_get_int(settings, "cursor_offset_y")
    self.cursor_rotation_mode = obs.obs_data_get_string(settings, "cursor_rotation_mode") or "None"
    self.cursor_angle_offset = obs.obs_data_get_double(settings, "cursor_angle_offset")
    self.cursor_tilt_strength = obs.obs_data_get_double(settings, "cursor_tilt_strength")
end

-- Cleanup
function CursorRenderer:cleanup()
    if self.sceneitem then
        obs.obs_sceneitem_remove(self.sceneitem)
        self.sceneitem = nil
    end

    if self.source then
        local source_name = obs.obs_source_get_name(self.source)
        obs.obs_source_release(self.source)

        -- Remove from OBS source list
        local s = obs.obs_get_source_by_name(source_name)
        if s then
            obs.obs_source_remove(s)
            obs.obs_source_release(s)
        end
        self.source = nil
    end

    self.enabled = false
    self.initialized = false
end

-- Check if active
function CursorRenderer:is_active()
    return self.enabled and self.initialized
end

-- Global convenience functions
function cursor_renderer_init()
    return CursorRenderer:init()
end

function cursor_renderer_update(dt, raw_mouse, camera_crop)
    return CursorRenderer:update(dt, raw_mouse, camera_crop)
end

function cursor_renderer_update_config(settings)
    return CursorRenderer:update_config(settings)
end

function cursor_renderer_cleanup()
    return CursorRenderer:cleanup()
end

function cursor_renderer_is_active()
    return CursorRenderer:is_active()
end

--================================================
-- MODULE: Bookmark Manager (M17)
--================================================
-- Manages saved zoom positions (bookmarks)

local BookmarkManager = {
    -- Saved bookmarks: { name = { zoom_level, x, y, w, h, source } }
    bookmarks = {},

    -- Maximum bookmarks
    max_bookmarks = 20,

    -- Hotkey IDs
    hotkeys = {},
}

-- Save current zoom position as a bookmark
function BookmarkManager:save(name)
    if not name or name == "" then
        return false
    end

    -- Check limit
    local count = 0
    for _, _ in pairs(self.bookmarks) do count = count + 1 end

    if count >= self.max_bookmarks and not self.bookmarks[name] then
        log("Bookmark: Max bookmarks reached (" .. self.max_bookmarks .. ")")
        return false
    end

    -- Get current crop
    local crop = crop_filter_get_crop()
    if not crop then
        return false
    end

    -- Save bookmark
    self.bookmarks[name] = {
        zoom_level = SM.zoom_level,
        x = crop.x,
        y = crop.y,
        w = crop.w,
        h = crop.h,
        source = cfg.source_name,
    }

    log("Bookmark: Saved '" .. name .. "' (zoom=" .. string.format("%.2f", SM.zoom_level) .. ")")
    return true
end

-- Recall a bookmark
function BookmarkManager:recall(name)
    local bm = self.bookmarks[name]
    if not bm then
        log("Bookmark: Not found: " .. name)
        return false
    end

    if not SM:can_jump() then
        return false
    end

    if not source_manager_is_valid() then
        return false
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        return false
    end

    -- Get current crop as start
    local start_crop = crop_filter_get_crop() or { x = 0, y = 0, w = source_w, h = source_h }

    -- Set target
    local target_crop = {
        x = bm.x,
        y = bm.y,
        w = bm.w,
        h = bm.h,
    }

    -- Transition to bookmark
    SM:transition(ZoomState.JUMPING, {
        start_crop = start_crop,
        target_crop = target_crop,
        target_level = bm.zoom_level
    })

    start_timer()
    log("Bookmark: Recall '" .. name .. "'")
    return true
end

-- Delete a bookmark
function BookmarkManager:delete(name)
    if self.bookmarks[name] then
        self.bookmarks[name] = nil
        log("Bookmark: Deleted '" .. name .. "'")
        return true
    end
    return false
end

-- Rename a bookmark
function BookmarkManager:rename(old_name, new_name)
    if not self.bookmarks[old_name] then
        return false
    end

    if self.bookmarks[new_name] then
        return false
    end

    self.bookmarks[new_name] = self.bookmarks[old_name]
    self.bookmarks[old_name] = nil
    log("Bookmark: Renamed '" .. old_name .. "' to '" .. new_name .. "'")
    return true
end

-- Get all bookmark names
function BookmarkManager:get_names()
    local names = {}
    for k, _ in pairs(self.bookmarks) do
        table.insert(names, k)
    end
    table.sort(names)
    return names
end

-- Get bookmark info
function BookmarkManager:get(name)
    return self.bookmarks[name]
end

-- Persist bookmarks to settings
function BookmarkManager:persist(settings)
    local array = obs.obs_data_array_create()

    for name, bm in pairs(self.bookmarks) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "name", name)
        obs.obs_data_set_double(item, "zoom_level", bm.zoom_level)
        obs.obs_data_set_double(item, "x", bm.x)
        obs.obs_data_set_double(item, "y", bm.y)
        obs.obs_data_set_double(item, "w", bm.w)
        obs.obs_data_set_double(item, "h", bm.h)
        obs.obs_data_set_string(item, "source", bm.source or "")
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "zoom_bookmarks", array)
    obs.obs_data_array_release(array)
end

-- Load bookmarks from settings
function BookmarkManager:load(settings)
    self.bookmarks = {}

    local array = obs.obs_data_get_array(settings, "zoom_bookmarks")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local name = obs.obs_data_get_string(item, "name")

        if name and name ~= "" then
            self.bookmarks[name] = {
                zoom_level = obs.obs_data_get_double(item, "zoom_level"),
                x = obs.obs_data_get_double(item, "x"),
                y = obs.obs_data_get_double(item, "y"),
                w = obs.obs_data_get_double(item, "w"),
                h = obs.obs_data_get_double(item, "h"),
                source = obs.obs_data_get_string(item, "source"),
            }
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)

    local count = 0
    for _, _ in pairs(self.bookmarks) do count = count + 1 end
    log("Bookmark: Loaded " .. count .. " bookmarks")
end

-- Register bookmark hotkeys
function BookmarkManager:register_hotkeys(settings)
    for i = 1, 5 do
        self.hotkeys[i] = obs.obs_hotkey_register_frontend(
            "obs_zoom_pro.bookmark_" .. i,
            "Zoom to Bookmark " .. i,
            function(pressed)
                if not pressed then return end
                local names = self:get_names()
                if names[i] then
                    self:recall(names[i])
                end
            end
        )

        -- Load saved bindings
        local key = "obs_zoom_pro.hotkey.bookmark_" .. i
        local save_array = obs.obs_data_get_array(settings, key)
        if save_array then
            obs.obs_hotkey_load(self.hotkeys[i], save_array)
            obs.obs_data_array_release(save_array)
        end
    end
end

-- Save bookmark hotkeys
function BookmarkManager:save_hotkeys(settings)
    for i = 1, 5 do
        if self.hotkeys[i] then
            local save_array = obs.obs_hotkey_save(self.hotkeys[i])
            obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.bookmark_" .. i, save_array)
            obs.obs_data_array_release(save_array)
        end
    end
end

-- Global convenience functions
function bookmark_save(name)
    return BookmarkManager:save(name)
end

function bookmark_recall(name)
    return BookmarkManager:recall(name)
end

function bookmark_delete(name)
    return BookmarkManager:delete(name)
end

function bookmark_get_names()
    return BookmarkManager:get_names()
end

function bookmark_get(name)
    return BookmarkManager:get(name)
end

--================================================
-- MODULE: UDP API Server (M18)
--================================================
-- Provides external control via UDP for Stream Deck integration

local APIServer = {
    enabled = false,
    port = 12345,
    socket = nil,
}

-- Command handlers
local API_COMMANDS = {
    ZOOM_IN = function(args)
        local level = tonumber(args[1]) or cfg.zoom_value
        on_scroll_zoom_to(level)
        return "OK"
    end,

    ZOOM_OUT = function(args)
        if SM:is_zoomed() then
            on_toggle_zoom(true)
        end
        return "OK"
    end,

    ZOOM_SET = function(args)
        local level = tonumber(args[1])
        if not level then return "ERROR: Missing level" end
        on_scroll_zoom_to(level)
        return "OK"
    end,

    ZOOM_TOGGLE = function(args)
        on_toggle_zoom(true)
        return "OK"
    end,

    FOLLOW_ON = function(args)
        if SM:is_zoomed() then SM.following = true end
        return "OK"
    end,

    FOLLOW_OFF = function(args)
        SM.following = false
        return "OK"
    end,

    FOLLOW_TOGGLE = function(args)
        if SM:is_zoomed() then SM.following = not SM.following end
        return "OK"
    end,

    PRESET = function(args)
        local name = args[1]
        if not name then return "ERROR: Missing preset name" end
        local ok = preset_apply(name)
        return ok and "OK" or "ERROR: Unknown preset"
    end,

    BOOKMARK = function(args)
        local name = args[1]
        if not name then return "ERROR: Missing bookmark name" end
        local ok = bookmark_recall(name)
        return ok and "OK" or "ERROR: Bookmark not found"
    end,

    STATUS = function(args)
        local crop = crop_filter_get_crop()
        return string.format(
            '{"version":"%s","zoom_level":%.2f,"state":"%s","following":%s,"position":{"x":%.0f,"y":%.0f},"preset":"%s"}',
            VERSION,
            SM.zoom_level,
            SM.state,
            tostring(SM.following),
            crop and crop.x or 0,
            crop and crop.y or 0,
            cfg.zoom_preset or ""
        )
    end,

    HELP = function(args)
        return "Commands: ZOOM_IN [level], ZOOM_OUT, ZOOM_SET level, ZOOM_TOGGLE, FOLLOW_ON, FOLLOW_OFF, FOLLOW_TOGGLE, PRESET name, BOOKMARK name, STATUS"
    end,
}

-- Start the API server
function APIServer:start(port)
    self:stop()

    self.port = port or self.port

    -- Try to use luasocket if available
    local socket_ok, socket = pcall(require, "socket")
    if not socket_ok then
        log("API: Socket library not available")
        return false
    end

    -- Try UDP
    local udp, err = socket.udp()
    if not udp then
        log("API: Failed to create UDP socket: " .. tostring(err))
        return false
    end

    -- Set socket options
    udp:setoption("reuseaddr", true)
    udp:settimeout(0)  -- Non-blocking

    -- Bind to port
    local bind_ok, err = udp:setsockname("*", self.port)
    if not bind_ok then
        log("API: Failed to bind to port " .. self.port .. ": " .. tostring(err))
        udp:close()
        return false
    end

    self.socket = udp
    self.enabled = true

    -- Start polling timer
    obs.timer_add(function() self:poll() end, 50)  -- 20Hz polling

    log("API: Listening on port " .. self.port)
    return true
end

-- Stop the API server
function APIServer:stop()
    if self.socket then
        self.socket:close()
        self.socket = nil
    end
    self.enabled = false
    log("API: Stopped")
end

-- Poll for incoming commands
function APIServer:poll()
    if not self.enabled or not self.socket then
        return
    end

    repeat
        local data, err = self.socket:receivefrom()
        if data then
            local response = self:handle_command(data)
            if response then
                -- Note: UDP response requires sender address
                log("API: " .. data:gsub("%s+", " ") .. " Ã¢â€ â€™ " .. response)
            end
        elseif err ~= "timeout" then
            log("API: Error: " .. tostring(err))
        end
    until not data
end

-- Handle a command
function APIServer:handle_command(raw)
    -- Parse command
    local parts = {}
    for word in raw:gmatch("%S+") do
        table.insert(parts, word)
    end

    if #parts == 0 then
        return "ERROR: Empty command"
    end

    local cmd = parts[1]:upper()
    local args = {}
    for i = 2, #parts do
        table.insert(args, parts[i])
    end

    -- Look up handler
    local handler = API_COMMANDS[cmd]
    if handler then
        local ok, result = pcall(handler, args)
        if ok then
            return result
        else
            return "ERROR: " .. tostring(result)
        end
    end

    return "ERROR: Unknown command: " .. cmd
end

-- Check if enabled
function APIServer:is_enabled()
    return self.enabled
end

-- Global convenience functions
function api_start(port)
    return APIServer:start(port)
end

function api_stop()
    return APIServer:stop()
end

function api_is_enabled()
    return APIServer:is_enabled()
end

--================================================
-- OBS SCRIPT REGISTRATION
--================================================

--[[ Called when the script is loaded
--[[ @param data table Script data
function script_load(data)
    log("Script loaded - OBS Zoom Pro v" .. VERSION)

    -- Load custom presets
    PresetManager:load(data)

    -- Load scene memory
    SceneMemory:load(data)

    -- Load bookmarks
    BookmarkManager:load(data)

    -- Register hotkeys
    register_hotkeys(data)

    -- Register bookmark hotkeys
    BookmarkManager:register_hotkeys(data)

    -- Register frontend event handler
    obs.obs_frontend_add_event_callback(on_frontend_event)

    -- Start API server if enabled
    local api_enabled = obs.obs_data_get_bool(data, "api_enabled")
    if api_enabled then
        local api_port = obs.obs_data_get_int(data, "api_port")
        APIServer:start(api_port)
    end
end

--[[ Called when the script is unloaded
function script_unload()
    log("Script unloaded - OBS Zoom Pro")

    -- Stop timer and cleanup
    stop_timer()
    unregister_hotkeys()
    source_manager_release()

    -- Stop API server
    APIServer:stop()

    -- Remove frontend event handler
    obs.obs_frontend_remove_event_callback(on_frontend_event)
end

--[[ Called when settings are updated
--[[ @param data table Settings data
function script_update(data)
    log("Settings updated")

    -- Update legacy settings
    debug_logs = obs.obs_data_get_bool(data, "debug_logging") or false
    settings.debug_logging = debug_logs
    settings.easing_type = obs.obs_data_get_string(data, "easing_type") or defaults.easing_type
    settings.smooth_time = obs.obs_data_get_double(data, "smooth_time") or defaults.smooth_time
    settings.max_speed = obs.obs_data_get_double(data, "max_speed") or defaults.max_speed

    -- Update M09 configuration
    update_config(data)

    -- Update API server settings
    local api_enabled = obs.obs_data_get_bool(data, "api_enabled")
    local api_port = obs.obs_data_get_int(data, "api_port")

    if api_enabled and not APIServer:is_enabled() then
        APIServer:start(api_port)
    elseif not api_enabled and APIServer:is_enabled() then
        APIServer:stop()
    elseif APIServer:is_enabled() and APIServer.port ~= api_port then
        APIServer:start(api_port)
    end
end

--[[ Called to save settings
--[[ @param data table Settings data to save
function script_save(data)
    log("Settings saved")

    -- Save custom presets
    PresetManager:persist(data)

    -- Save scene memory
    SceneMemory:persist(data)

    -- Save bookmarks
    BookmarkManager:persist(data)

    -- Save hotkey bindings
    save_hotkeys(data)

    -- Save bookmark hotkeys
    BookmarkManager:save_hotkeys(data)
end

--[[ Called to create the properties UI
--[[ @return obs.obs_properties_t Properties object
function script_properties()
    local props = obs.obs_properties_create()

    --==========================
    -- QUICK SETUP (always expanded)
    --==========================
    local grp_quick = obs.obs_properties_create()

    -- Source dropdown
    local src_list = obs.obs_properties_add_list(grp_quick, "source", "Zoom Source",
        obs.OBS_COMBO_TYPE_LIST, obs.OBS_COMBO_FORMAT_STRING)
    obs.obs_property_list_add_string(src_list, "-- Select Source --", "")

    -- Populate with available capture sources
    local sources = source_manager_get_available_sources()
    for _, src in ipairs(sources) do
        obs.obs_property_list_add_string(src_list, src.name, src.name)
    end

    -- Zoom Factor
    obs.obs_properties_add_float_slider(grp_quick, "zoom_value", "Zoom Factor", 1.0, 10.0, 0.1)

    -- Duration
    obs.obs_properties_add_float_slider(grp_quick, "zoom_duration", "Duration (s)", 0.05, 3.0, 0.05)

    obs.obs_properties_add_group(props, "quick_setup", "Ã¢Å¡Â¡ Quick Setup", obs.OBS_GROUP_NORMAL, grp_quick)

    --==========================
    -- ANIMATION (collapsed)
    --==========================
    local grp_anim = obs.obs_properties_create()

    -- Overshoot/Bounce
    obs.obs_properties_add_float_slider(grp_anim, "zoom_overshoot", "Bounce", 0.0, 1.0, 0.01)

    -- Easing Curve
    local p_easing = obs.obs_properties_add_list(grp_anim, "zoom_easing", "Easing Curve",
        obs.OBS_COMBO_TYPE_LIST, obs.OBS_COMBO_FORMAT_STRING)
    for _, name in ipairs(Easing.NAMES) do
        obs.obs_property_list_add_string(p_easing, name, name)
    end

    obs.obs_properties_add_group(props, "animation", "Ã°Å¸Å½Â¬ Animation", obs.OBS_GROUP_NORMAL, grp_anim)

    --==========================
    -- MOUSE FOLLOW (collapsed)
    --==========================
    local grp_follow = obs.obs_properties_create()

    obs.obs_properties_add_bool(grp_follow, "auto_follow", "Auto-Follow Mouse")
    obs.obs_properties_add_float_slider(grp_follow, "follow_smooth_time", "Smoothness", 0.01, 1.0, 0.01)
    obs.obs_properties_add_int_slider(grp_follow, "follow_dead_zone", "Dead Zone (px)", 0, 500, 1)

    obs.obs_properties_add_group(props, "follow", "Ã°Å¸Å½Â¯ Mouse Follow", obs.OBS_GROUP_NORMAL, grp_follow)

    --==========================
    -- ADVANCED (collapsed)
    --==========================
    local grp_adv = obs.obs_properties_create()
    obs.obs_properties_add_float_slider(grp_adv, "scroll_step", "Scroll Zoom Step", 0.1, 1.0, 0.05)
    obs.obs_properties_add_bool(grp_adv, "debug_logs", "Debug Logging")
    obs.obs_properties_add_group(props, "advanced", "Ã¢Å¡â„¢Ã¯Â¸Â Advanced", obs.OBS_GROUP_NORMAL, grp_adv)

    --==========================
    -- API SERVER (collapsed)
    --==========================
    local grp_api = obs.obs_properties_create()
    obs.obs_properties_add_bool(grp_api, "api_enabled", "Enable UDP API Server")
    obs.obs_properties_add_int(grp_api, "api_port", "API Port", 1024, 65535, 1)
    obs.obs_properties_add_group(props, "api_server", "Ã°Å¸Å’Â UDP API Server", obs.OBS_GROUP_NORMAL, grp_api)

    --==========================
    -- HELP (collapsed)
    --==========================
    local grp_help = obs.obs_properties_create()
    obs.obs_properties_add_text(grp_help, "help_text",
        "QUICK START:\n" ..
        "1. Select your capture source above\n" ..
        "2. Set hotkeys in OBS Settings Ã¢â€ â€™ Hotkeys\n" ..
        "   Ã¢â‚¬Â¢ 'Toggle Zoom to Mouse' Ã¢â‚¬â€ Main zoom\n" ..
        "   Ã¢â‚¬Â¢ 'Toggle Mouse Follow' Ã¢â‚¬â€ Enable/disable follow\n" ..
        "3. Press the hotkey to zoom!\n\n" ..
        "TIPS:\n" ..
        "Ã¢â‚¬Â¢ Zoom centers on mouse position\n" ..
        "Ã¢â‚¬Â¢ Enable Auto-Follow for smooth tracking\n" ..
        "Ã¢â‚¬Â¢ Adjust Dead Zone to reduce jitter",
        obs.OBS_TEXT_INFO)
    obs.obs_properties_add_group(props, "help", "Ã¢Ââ€œ Help", obs.OBS_GROUP_NORMAL, grp_help)

    return props
end

--[[ Called to set default values
--[[ @param data table Settings data
function script_defaults(data)
    obs.obs_data_set_default_string(data, "source", "")
    obs.obs_data_set_default_double(data, "zoom_value", 2.0)
    obs.obs_data_set_default_double(data, "zoom_duration", 0.6)
    obs.obs_data_set_default_double(data, "zoom_overshoot", 0.0)
    obs.obs_data_set_default_string(data, "zoom_easing", "Cubic.Out")
    obs.obs_data_set_default_bool(data, "auto_follow", true)
    obs.obs_data_set_default_double(data, "follow_smooth_time", 0.15)
    obs.obs_data_set_default_int(data, "follow_dead_zone", 5)
    obs.obs_data_set_default_double(data, "scroll_step", 0.25)
    obs.obs_data_set_default_bool(data, "debug_logs", false)
    obs.obs_data_set_default_bool(data, "api_enabled", false)
    obs.obs_data_set_default_int(data, "api_port", 12345)
end

--================================================
-- SCRIPT METADATA
--================================================
script_info = {
    name = "OBS Zoom Pro",
    version = VERSION,
    description = "Intelligent camera zoom functionality with smooth transitions and easing curves.",
    author = "OBS Zoom Pro Team"
}
)
        handle:close()
        if uname == 'Darwin' then
            is_macos = true
            is_linux = false
        end
    end

    return {
        WINDOWS = is_windows,
        LINUX = is_linux,
        MACOS = is_macos
    }
end

local platform = detect_platform()
local IS_WINDOWS = platform.WINDOWS
local IS_LINUX = platform.LINUX
local IS_MACOS = platform.MACOS

-- Log platform detection
log("Platform detected: " .. (jit and jit.os or "Unknown") .. (IS_WINDOWS and " (Full support)" or " (Basic support)"))

-- Virtual key codes (Lua constants instead of C #define)
local VK_LBUTTON = 0x01
local VK_RBUTTON = 0x02
local VK_MBUTTON = 0x04
local VK_CONTROL = 0x11
local VK_SHIFT = 0x10
local VK_MENU = 0x12  -- Alt

-- FFI declarations for Windows (only if FFI is available)


-- Cursor shape constants (Windows)
local CURSOR_ARROW = 1
local CURSOR_IBEAM = 2
local CURSOR_HAND = 3
local CURSOR_WAIT = 4

-- Module state
local Platform = {
    cursor_shape_available = IS_WINDOWS,
    last_mouse = { x = 0, y = 0 },
    last_click = false,
}

-- Get mouse position (cross-platform)
function Platform.get_mouse_pos()
    if IS_WINDOWS then
        local success, pt = pcall(function()
            local pt = ffi.new("POINT")
            if ffi.C.GetCursorPos(pt) ~= 0 then
                return { x = tonumber(pt.x), y = tonumber(pt.y) }
            end
            return nil
        end)
        if success and pt then
            return pt
        end
    elseif IS_LINUX then
        -- Linux: Use xdotool if available, fallback to X11
        local success, result = pcall(function()
            local handle = io.popen("xdotool getmouselocation 2>/dev/null || echo 'x:0 y:0'")
            if handle then
                local output = handle:read("*a")
                handle:close()
                local x, y = output:match("x:(%d+)%s+y:(%d+)")
                if x and y then
                    return { x = tonumber(x), y = tonumber(y) }
                end
            end
            return nil
        end)
        if success and result then
            return result
        end
    elseif IS_MACOS then
        -- macOS: Use osascript
        local success, result = pcall(function()
            local handle = io.popen(--[[osascript -e 'tell application "System Events" to get position of the mouse' 2>/dev/null || echo "0, 0"]])
            if handle then
                local output = handle:read("*a")
                handle:close()
                local x, y = output:match("(%d+),%s*(%d+)")
                if x and y then
                    return { x = tonumber(x), y = tonumber(y) }
                end
            end
            return nil
        end)
        if success and result then
            return result
        end
    end

    -- Fallback
    return { x = 0, y = 0 }
end

-- Check if left mouse button is clicked (Windows only, others return false)
function Platform.is_clicking()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x01) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if a modifier key is held (Windows only)
function Platform.is_key_held(vk_code)
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(vk_code) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if cursor is a pointer/hand (Windows only)
function Platform.is_cursor_pointer()
    if IS_WINDOWS then
        local success, result = pcall(function()
            local ci = ffi.new("CURSORINFO")
            ci.cbSize = ffi.sizeof("CURSORINFO")
            if ffi.C.GetCursorInfo(ci) ~= 0 then
                -- Check if hCursor is a hand pointer
                -- This is a simplified check; real implementation would compare cursor handles
                return ci.flags ~= 0  -- Simplified; actual implementation needs cursor handle comparison
            end
            return false
        end)
        return success and result or false
    end
    return false
end

-- Get cursor shape (Windows only, returns "arrow" for others)
function Platform.get_cursor_shape()
    if IS_WINDOWS then
        local success, result = pcall(function()
            local ci = ffi.new("CURSORINFO")
            ci.cbSize = ffi.sizeof("CURSORINFO")
            if ffi.C.GetCursorInfo(ci) ~= 0 and ci.hCursor ~= nil then
                local addr = tonumber(ffi.cast("uintptr_t", ci.hCursor))
                -- Common cursor IDs (these are typical values, may vary)
                -- IDC_ARROW = 32512, IDC_IBEAM = 32513, IDC_HAND = 32649
                -- We use address ranges as heuristic
                return "arrow"  -- Simplified; actual implementation would map handles
            end
            return "arrow"
        end)
        return success and result or "arrow"
    end
    return "arrow"
end

-- Check if Control key is held
function Platform.is_ctrl_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x11) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if Shift key is held
function Platform.is_shift_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x10) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if Alt key is held
function Platform.is_alt_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x12) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Convenience wrapper functions
function platform_get_mouse_pos()
    return Platform.get_mouse_pos()
end

function platform_is_clicking()
    return Platform.is_clicking()
end

function platform_is_cursor_pointer()
    return Platform.is_cursor_pointer()
end

function platform_cursor_shape_available()
    return Platform.cursor_shape_available
end

function platform_is_ctrl_held()
    return Platform.is_ctrl_held()
end

function platform_is_shift_held()
    return Platform.is_shift_held()
end

function platform_is_alt_held()
    return Platform.is_alt_held()
end

--================================================
-- MODULE: State Machine (M05)
--================================================
-- Manages zoom states and transitions
-- States: IDLE, ZOOMING_IN, ZOOMED_IN, ZOOMING_OUT, SCROLLING, JUMPING

local ZoomState = {
    IDLE         = "idle",
    ZOOMING_IN   = "zooming_in",
    ZOOMED_IN    = "zoomed_in",
    ZOOMING_OUT  = "zooming_out",
    SCROLLING    = "scrolling",    -- Scroll wheel mid-transition
    JUMPING      = "jumping",      -- Bookmark transition
}

local StateMachine = {
    state = ZoomState.IDLE,
    zoom_time = 0,          -- Animation progress (0 Ã¢â€ â€™ 1)
    zoom_level = 1.0,       -- Current zoom factor
    target_level = 1.0,     -- Target zoom factor
    start_crop = nil,       -- Crop at animation start {x, y, w, h}
    target_crop = nil,      -- Crop at animation end {x, y, w, h}
    following = false,      -- Mouse follow active

    -- Transition guards
    can_zoom_in = function(self)
        return self.state == ZoomState.IDLE
    end,

    can_zoom_out = function(self)
        return self.state == ZoomState.ZOOMED_IN
            or self.state == ZoomState.SCROLLING
    end,

    can_scroll = function(self)
        return self.state == ZoomState.ZOOMED_IN
            or self.state == ZoomState.IDLE
            or self.state == ZoomState.SCROLLING
    end,

    can_jump = function(self)
        return self.state ~= ZoomState.ZOOMING_IN
           and self.state ~= ZoomState.ZOOMING_OUT
           and self.state ~= ZoomState.JUMPING
    end,

    is_animating = function(self)
        return self.state == ZoomState.ZOOMING_IN
            or self.state == ZoomState.ZOOMING_OUT
            or self.state == ZoomState.SCROLLING
            or self.state == ZoomState.JUMPING
    end,

    is_zoomed = function(self)
        return self.state ~= ZoomState.IDLE
    end,
}

-- Transition to a new state
function StateMachine:transition(new_state, params)
    local old = self.state
    self.state = new_state
    self.zoom_time = 0

    if params then
        if params.start_crop then self.start_crop = params.start_crop end
        if params.target_crop then self.target_crop = params.target_crop end
        if params.target_level then self.target_level = params.target_level end
    end

    log("State: " .. old .. " Ã¢â€ â€™ " .. new_state)
end

-- Complete the current animation
function StateMachine:complete()
    if self.state == ZoomState.ZOOMING_IN
       or self.state == ZoomState.SCROLLING
       or self.state == ZoomState.JUMPING then
        self.zoom_level = self.target_level
        self.state = ZoomState.ZOOMED_IN
        self.zoom_time = 0
        log("State: " .. self.state .. " Ã¢â€ â€™ ZOOMED_IN (complete)")
    elseif self.state == ZoomState.ZOOMING_OUT then
        self.zoom_level = 1.0
        self.target_level = 1.0
        self.start_crop = nil
        self.target_crop = nil
        self.following = false
        self.state = ZoomState.IDLE
        self.zoom_time = 0
        log("State: ZOOMING_OUT Ã¢â€ â€™ IDLE (complete)")
    end
end

-- Reset to initial state
function StateMachine:reset()
    self.state = ZoomState.IDLE
    self.zoom_time = 0
    self.zoom_level = 1.0
    self.target_level = 1.0
    self.start_crop = nil
    self.target_crop = nil
    self.following = false
    log("StateMachine: Reset to IDLE")
end

-- Get current animation progress (0-1)
function StateMachine:get_progress()
    return clamp(0, 1, self.zoom_time)
end

-- Check if in a specific state
function StateMachine:is_state(state)
    return self.state == state
end

-- Get state name for display
function StateMachine:get_state_name()
    return self.state
end

-- Create a new state machine instance (for testing/isolation)
function StateMachine:new()
    local sm = {}
    setmetatable(sm, { __index = self })
    sm.state = ZoomState.IDLE
    sm.zoom_time = 0
    sm.zoom_level = 1.0
    sm.target_level = 1.0
    sm.start_crop = nil
    sm.target_crop = nil
    sm.following = false
    return sm
end

-- Global state machine instance
local SM = StateMachine:new()

--================================================
-- MODULE: Crop Filter Manager (M07)
--================================================
-- Manages the crop/pad filter used to simulate zoom
-- Creates, updates, and destroys the filter automatically

local FILTER_PREFIX = "[ZoomPro] "
local CROP_FILTER_NAME = FILTER_PREFIX .. "Crop"

local CropFilterManager = {
    filter = nil,           -- The crop filter source
    source = nil,           -- The parent source
    original_crop = nil,    -- Original crop values for restoration
    current_crop = { x = 0, y = 0, w = 0, h = 0 },
    initialized = false,
}

-- Create the crop filter on a source
function CropFilterManager:create(source)
    if not source then
        log("CropFilter: No source provided")
        return false
    end

    self:cleanup()  -- Clean up any existing filter
    self.source = source

    -- Check if our filter already exists
    local existing = obs.obs_source_get_filter_by_name(source, CROP_FILTER_NAME)
    if existing then
        log("CropFilter: Found existing filter")
        self.filter = existing
        self.initialized = true
        return true
    end

    -- Create new crop/pad filter
    local settings = obs.obs_data_create()
    obs.obs_data_set_int(settings, "left", 0)
    obs.obs_data_set_int(settings, "top", 0)
    obs.obs_data_set_int(settings, "right", 0)
    obs.obs_data_set_int(settings, "bottom", 0)
    obs.obs_data_set_bool(settings, "relative", false)  -- Absolute positioning

    self.filter = obs.obs_source_create_private(
        "crop_filter",      -- Filter type
        CROP_FILTER_NAME,   -- Filter name
        settings            -- Settings
    )

    obs.obs_data_release(settings)

    if not self.filter then
        log("CropFilter: Failed to create filter")
        return false
    end

    -- Add filter to source
    obs.obs_source_filter_add(source, self.filter)

    -- Store original crop (none)
    self.original_crop = { x = 0, y = 0, w = 0, h = 0 }

    self.initialized = true
    log("CropFilter: Created successfully")
    return true
end

-- Update the crop filter with new values
function CropFilterManager:update(x, y, w, h)
    if not self.filter or not self.initialized then
        return false
    end

    -- Store current crop
    self.current_crop = { x = x, y = y, w = w, h = h }

    -- Get filter settings
    local settings = obs.obs_source_get_settings(self.filter)
    if not settings then
        return false
    end

    -- Calculate crop values
    -- For crop_filter: left, top are absolute position
    -- right, bottom are width/height from right/bottom edge
    -- We need to convert our x, y, w, h to this format

    -- Get source dimensions
    local source_w = obs.obs_source_get_width(self.source)
    local source_h = obs.obs_source_get_height(self.source)

    if source_w == 0 or source_h == 0 then
        obs.obs_data_release(settings)
        return false
    end

    -- Set crop values
    -- left = x offset from left
    -- top = y offset from top
    -- right = source_w - (x + w) = remaining width on right
    -- bottom = source_h - (y + h) = remaining height on bottom
    local left = math.floor(x)
    local top = math.floor(y)
    local right = math.floor(source_w - (x + w))
    local bottom = math.floor(source_h - (y + h))

    -- Clamp to valid values
    left = math.max(0, left)
    top = math.max(0, top)
    right = math.max(0, right)
    bottom = math.max(0, bottom)

    obs.obs_data_set_int(settings, "left", left)
    obs.obs_data_set_int(settings, "top", top)
    obs.obs_data_set_int(settings, "right", right)
    obs.obs_data_set_int(settings, "bottom", bottom)

    -- Update the filter
    obs.obs_source_update(self.filter, settings)
    obs.obs_data_release(settings)

    return true
end

-- Get current crop values
function CropFilterManager:get_crop()
    return self.current_crop
end

-- Reset crop to original (no crop)
function CropFilterManager:reset()
    if not self.filter or not self.initialized then
        return false
    end

    local settings = obs.obs_source_get_settings(self.filter)
    if settings then
        obs.obs_data_set_int(settings, "left", 0)
        obs.obs_data_set_int(settings, "top", 0)
        obs.obs_data_set_int(settings, "right", 0)
        obs.obs_data_set_int(settings, "bottom", 0)
        obs.obs_source_update(self.filter, settings)
        obs.obs_data_release(settings)
    end

    self.current_crop = { x = 0, y = 0, w = 0, h = 0 }
    return true
end

-- Remove the filter and restore original state
function CropFilterManager:cleanup()
    if self.filter and self.source then
        -- Reset to no crop first
        self:reset()

        -- Remove filter from source
        obs.obs_source_filter_remove(self.source, self.filter)
        obs.obs_source_release(self.filter)
        self.filter = nil
        log("CropFilter: Removed from source")
    end

    self.source = nil
    self.original_crop = nil
    self.current_crop = { x = 0, y = 0, w = 0, h = 0 }
    self.initialized = false
end

-- Check if filter is ready
function CropFilterManager:is_ready()
    return self.initialized and self.filter ~= nil
end

-- Get source dimensions
function CropFilterManager:get_source_size()
    if not self.source then
        return 0, 0
    end
    return obs.obs_source_get_width(self.source), obs.obs_source_get_height(self.source)
end

-- Convenience wrapper functions
function crop_filter_create(source)
    return CropFilterManager:create(source)
end

function crop_filter_update(x, y, w, h)
    return CropFilterManager:update(x, y, w, h)
end

function crop_filter_reset()
    return CropFilterManager:reset()
end

function crop_filter_cleanup()
    return CropFilterManager:cleanup()
end

function crop_filter_is_ready()
    return CropFilterManager:is_ready()
end

function crop_filter_get_crop()
    return CropFilterManager:get_crop()
end

function crop_filter_get_source_size()
    return CropFilterManager:get_source_size()
end

--================================================
-- MODULE: Source Manager (M08)
--================================================
-- Handles finding sources in scenes, capturing transforms,
-- and managing source state for zoom operations

local SourceManager = {
    source = nil,           -- Current zoom source
    sceneitem = nil,        -- Scene item reference
    scene = nil,            -- Current scene
    original_transform = nil, -- Saved original transform
    source_name = "",       -- Source name for settings
    initialized = false,
}

-- Transform data structure
local TransformData = {
    pos = { x = 0, y = 0 },
    scale = { x = 1.0, y = 1.0 },
    rot = 0,
    bounds_type = 0,
    bounds = { x = 0, y = 0 },
    crop = { left = 0, top = 0, right = 0, bottom = 0 },
}

-- Find a source in a scene (BFS through groups)
function SourceManager:find_sceneitem(scene, source_name)
    if not scene or not source_name then
        return nil
    end

    local scene_source = obs.obs_scene_from_source(scene)
    if not scene_source then
        return nil
    end

    -- BFS queue
    local queue = {}
    table.insert(queue, scene_source)

    while #queue > 0 do
        local current_scene = table.remove(queue, 1)

        -- Iterate through items
        local items = obs.obs_scene_enum_items(current_scene)
        if items then
            for _, item in ipairs(items) do
                local item_source = obs.obs_sceneitem_get_source(item)
                if item_source then
                    local name = obs.obs_source_get_name(item_source)

                    -- Check if this is our target
                    if name == source_name then
                        obs.sceneitem_list_release(items)
                        return item
                    end

                    -- Check if this is a group (nested scene)
                    if obs.obs_source_get_type(item_source) == obs.OBS_SOURCE_TYPE_INPUT then
                        local id = obs.obs_source_get_id(item_source)
                        if id == "group" then
                            local group_scene = obs.obs_group_from_source(item_source)
                            if group_scene then
                                table.insert(queue, group_scene)
                            end
                        end
                    end
                end
            end
            obs.sceneitem_list_release(items)
        end
    end

    return nil
end

-- Capture the current transform of a scene item
function SourceManager:capture_transform(sceneitem)
    if not sceneitem then
        return nil
    end

    local transform = {}

    -- Position
    local pos = obs.vec2()
    obs.obs_sceneitem_get_pos(sceneitem, pos)
    transform.pos = { x = pos.x, y = pos.y }

    -- Scale
    local scale = obs.vec2()
    obs.obs_sceneitem_get_scale(sceneitem, scale)
    transform.scale = { x = scale.x, y = scale.y }

    -- Rotation
    transform.rot = obs.obs_sceneitem_get_rot(sceneitem)

    -- Bounds
    transform.bounds_type = obs.obs_sceneitem_get_bounds_type(sceneitem)
    local bounds = obs.vec2()
    obs.obs_sceneitem_get_bounds(sceneitem, bounds)
    transform.bounds = { x = bounds.x, y = bounds.y }

    -- Crop
    local crop = obs.obs_sceneitem_crop()
    obs.obs_sceneitem_get_crop(sceneitem, crop)
    transform.crop = {
        left = crop.left,
        top = crop.top,
        right = crop.right,
        bottom = crop.bottom
    }

    return transform
end

-- Restore a saved transform to a scene item
function SourceManager:restore_transform(sceneitem, transform)
    if not sceneitem or not transform then
        return false
    end

    -- Position
    local pos = obs.vec2()
    pos.x = transform.pos.x
    pos.y = transform.pos.y
    obs.obs_sceneitem_set_pos(sceneitem, pos)

    -- Scale
    local scale = obs.vec2()
    scale.x = transform.scale.x
    scale.y = transform.scale.y
    obs.obs_sceneitem_set_scale(sceneitem, scale)

    -- Rotation
    obs.obs_sceneitem_set_rot(sceneitem, transform.rot)

    -- Bounds
    obs.obs_sceneitem_set_bounds_type(sceneitem, transform.bounds_type)
    local bounds = obs.vec2()
    bounds.x = transform.bounds.x
    bounds.y = transform.bounds.y
    obs.obs_sceneitem_set_bounds(sceneitem, bounds)

    -- Crop
    local crop = obs.obs_sceneitem_crop()
    crop.left = transform.crop.left
    crop.top = transform.crop.top
    crop.right = transform.crop.right
    crop.bottom = transform.crop.bottom
    obs.obs_sceneitem_set_crop(sceneitem, crop)

    return true
end

-- Initialize with a source name
function SourceManager:init(source_name)
    self:release()  -- Clean up any existing state

    if not source_name or source_name == "" then
        log("SourceManager: No source name provided")
        return false
    end

    self.source_name = source_name

    -- Get current scene
    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then
        log("SourceManager: No current scene")
        return false
    end

    self.scene = scene_source

    -- Find the scene item
    self.sceneitem = self:find_sceneitem(scene_source, source_name)
    if not self.sceneitem then
        log("SourceManager: Source not found in scene: " .. source_name)
        obs.obs_source_release(scene_source)
        return false
    end

    -- Get the source
    self.source = obs.obs_sceneitem_get_source(self.sceneitem)
    if not self.source then
        log("SourceManager: Failed to get source from sceneitem")
        obs.obs_source_release(scene_source)
        return false
    end

    -- Capture original transform
    self.original_transform = self:capture_transform(self.sceneitem)

    -- Create crop filter
    if not crop_filter_create(self.source) then
        log("SourceManager: Failed to create crop filter")
        obs.obs_source_release(scene_source)
        return false
    end

    self.initialized = true
    log("SourceManager: Initialized with source: " .. source_name)

    obs.obs_source_release(scene_source)
    return true
end

-- Release all resources
function SourceManager:release()
    -- Clean up crop filter
    crop_filter_cleanup()

    -- Restore original transform if we have it
    if self.sceneitem and self.original_transform then
        self:restore_transform(self.sceneitem, self.original_transform)
        log("SourceManager: Restored original transform")
    end

    self.source = nil
    self.sceneitem = nil
    self.scene = nil
    self.original_transform = nil
    self.initialized = false

    log("SourceManager: Released")
end

-- Get source dimensions
function SourceManager:get_source_size()
    if not self.source then
        return 0, 0
    end
    return obs.obs_source_get_width(self.source), obs.obs_source_get_height(self.source)
end

-- Check if source is valid
function SourceManager:is_valid()
    return self.initialized and self.source ~= nil and self.sceneitem ~= nil
end

-- Get source info
function SourceManager:get_info()
    if not self:is_valid() then
        return nil
    end

    return {
        name = self.source_name,
        width = obs.obs_source_get_width(self.source),
        height = obs.obs_source_get_height(self.source),
    }
end

-- Get list of available capture sources
function SourceManager.get_available_sources()
    local sources = {}

    -- Get all sources
    local source_list = obs.obs_enum_sources()
    if source_list then
        for _, source in ipairs(source_list) do
            local source_id = obs.obs_source_get_id(source)
            local name = obs.obs_source_get_name(source)

            -- Filter for capture sources
            local is_capture = false
            if source_id == "monitor_capture" or      -- Display capture
               source_id == "window_capture" or       -- Window capture
               source_id == "game_capture" or         -- Game capture
               source_id == "xshm_input" or           -- Linux X11 capture
               source_id == "av_capture_input" then   -- macOS capture
                is_capture = true
            end

            if is_capture then
                table.insert(sources, {
                    name = name,
                    id = source_id,
                })
            end
        end
        obs.source_list_release(source_list)
    end

    return sources
end

-- Convenience wrapper functions
function source_manager_init(source_name)
    return SourceManager:init(source_name)
end

function source_manager_release()
    return SourceManager:release()
end

function source_manager_is_valid()
    return SourceManager:is_valid()
end

function source_manager_get_source()
    return SourceManager.source
end

function source_manager_get_sceneitem()
    return SourceManager.sceneitem
end

function source_manager_get_size()
    return SourceManager:get_source_size()
end

function source_manager_get_available_sources()
    return SourceManager.get_available_sources()
end

--================================================
-- MODULE: Camera Physics (M06)
--================================================
-- Handles camera position calculations, dead zones,
-- and SmoothDamp-based camera movement

local CameraPhysics = {
    -- Smoothed camera position
    pos = { x = 0, y = 0 },

    -- Velocities for SmoothDamp
    vel_x = { val = 0 },
    vel_y = { val = 0 },

    -- Dead zone state
    tracked_pos = { x = 0, y = 0 },
    dead_zone_active = false,

    -- Last camera position (for velocity calculation)
    last_pos = { x = 0, y = 0 },

    -- Monitor offset (for multi-monitor setups)
    monitor_offset = { x = 0, y = 0 },
}

-- Initialize camera tracking with starting position
function CameraPhysics:init(mouse_pos)
    if mouse_pos then
        self.pos.x = mouse_pos.x
        self.pos.y = mouse_pos.y
        self.tracked_pos.x = mouse_pos.x
        self.tracked_pos.y = mouse_pos.y
    end
    self.vel_x.val = 0
    self.vel_y.val = 0
    self.last_pos.x = self.pos.x
    self.last_pos.y = self.pos.y
end

-- Apply dead zone to mouse input
-- Returns the position the camera should track
function CameraPhysics:apply_dead_zone(mouse_pos, dead_zone_radius)
    if not mouse_pos then
        return self.tracked_pos
    end

    if dead_zone_radius <= 0 then
        self.tracked_pos.x = mouse_pos.x
        self.tracked_pos.y = mouse_pos.y
        return self.tracked_pos
    end

    -- Calculate distance from tracked position to mouse
    local dx = mouse_pos.x - self.tracked_pos.x
    local dy = mouse_pos.y - self.tracked_pos.y
    local dist = math.sqrt(dx * dx + dy * dy)

    if dist <= dead_zone_radius then
        -- Mouse is within dead zone, don't move tracked position
        self.dead_zone_active = true
        return self.tracked_pos
    end

    -- Mouse is outside dead zone
    -- Move tracked position so it stays exactly dead_zone_radius from mouse
    self.dead_zone_active = false
    local excess = dist - dead_zone_radius
    local nx = dx / dist  -- Normalized direction
    local ny = dy / dist

    self.tracked_pos.x = self.tracked_pos.x + nx * excess
    self.tracked_pos.y = self.tracked_pos.y + ny * excess

    return self.tracked_pos
end

-- Smooth the input position using SmoothDamp
function CameraPhysics:smooth_input(target_pos, smooth_time, dt)
    if not target_pos then
        return self.pos
    end

    local max_speed = 100000  -- Very high max speed for smooth camera

    self.pos.x = SmoothDamp(self.pos.x, target_pos.x, self.vel_x, smooth_time, max_speed, dt)
    self.pos.y = SmoothDamp(self.pos.y, target_pos.y, self.vel_y, smooth_time, max_speed, dt)

    return self.pos
end

-- Calculate the crop rectangle for a given zoom level and center position
function CameraPhysics:compute_crop(center_x, center_y, zoom_level, source_w, source_h)
    if zoom_level <= 1.0 then
        -- No zoom, return full source
        return {
            x = 0,
            y = 0,
            w = source_w,
            h = source_h,
        }
    end

    -- Calculate crop dimensions
    local crop_w = source_w / zoom_level
    local crop_h = source_h / zoom_level

    -- Center the crop on the target position
    local crop_x = center_x - crop_w / 2
    local crop_y = center_y - crop_h / 2

    -- Clamp to source bounds
    crop_x = clamp(0, source_w - crop_w, crop_x)
    crop_y = clamp(0, source_h - crop_h, crop_y)

    return {
        x = crop_x,
        y = crop_y,
        w = crop_w,
        h = crop_h,
    }
end

-- Calculate target crop for zoom animation
-- mouse_pos: current mouse position
-- zoom_level: target zoom level
-- source_w, source_h: source dimensions
-- monitor_offset: offset for multi-monitor (optional)
function CameraPhysics:get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
    if not mouse_pos then
        return nil
    end

    -- Apply monitor offset if provided
    local target_x = mouse_pos.x
    local target_y = mouse_pos.y

    if monitor_offset then
        target_x = target_x - monitor_offset.x
        target_y = target_y - monitor_offset.y
    end

    -- Clamp to source bounds
    target_x = clamp(0, source_w, target_x)
    target_y = clamp(0, source_h, target_y)

    return self:compute_crop(target_x, target_y, zoom_level, source_w, source_h)
end

-- Interpolate between two crop rectangles
function CameraPhysics:lerp_crop(start_crop, end_crop, t, easing_fn)
    if not start_crop or not end_crop then
        return nil
    end

    t = clamp(0, 1, t)

    -- Apply easing
    local eased_t = easing_fn and easing_fn(t) or t

    return {
        x = lerp(start_crop.x, end_crop.x, eased_t),
        y = lerp(start_crop.y, end_crop.y, eased_t),
        w = lerp(start_crop.w, end_crop.w, eased_t),
        h = lerp(start_crop.h, end_crop.h, eased_t),
    }
end

-- Get camera velocity (for motion blur)
function CameraPhysics:get_velocity()
    return {
        x = self.pos.x - self.last_pos.x,
        y = self.pos.y - self.last_pos.y,
    }
end

-- Update last position (call at end of frame)
function CameraPhysics:update_last_pos()
    self.last_pos.x = self.pos.x
    self.last_pos.y = self.pos.y
end

-- Set monitor offset
function CameraPhysics:set_monitor_offset(offset)
    self.monitor_offset = offset or { x = 0, y = 0 }
end

-- Reset camera state
function CameraPhysics:reset()
    self.pos = { x = 0, y = 0 }
    self.vel_x = { val = 0 }
    self.vel_y = { val = 0 }
    self.tracked_pos = { x = 0, y = 0 }
    self.dead_zone_active = false
    self.last_pos = { x = 0, y = 0 }
end

-- Convenience wrapper functions
function camera_physics_init(mouse_pos)
    return CameraPhysics:init(mouse_pos)
end

function camera_physics_apply_dead_zone(mouse_pos, dead_zone_radius)
    return CameraPhysics:apply_dead_zone(mouse_pos, dead_zone_radius)
end

function camera_physics_smooth_input(target_pos, smooth_time, dt)
    return CameraPhysics:smooth_input(target_pos, smooth_time, dt)
end

function camera_physics_compute_crop(center_x, center_y, zoom_level, source_w, source_h)
    return CameraPhysics:compute_crop(center_x, center_y, zoom_level, source_w, source_h)
end

function camera_physics_get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
    return CameraPhysics:get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
end

function camera_physics_lerp_crop(start_crop, end_crop, t, easing_fn)
    return CameraPhysics:lerp_crop(start_crop, end_crop, t, easing_fn)
end

function camera_physics_get_velocity()
    return CameraPhysics:get_velocity()
end

function camera_physics_update_last_pos()
    return CameraPhysics:update_last_pos()
end

function camera_physics_reset()
    return CameraPhysics:reset()
end

--================================================
-- MODULE: Timer & Main Loop (M09)
--================================================
-- Core integration module that handles frame-by-frame updates,
-- input processing, state machine updates, and output

-- Configuration (will be populated from settings)
local cfg = {
    source_name = "",
    zoom_value = 2.0,
    max_zoom = 10.0,
    zoom_duration = 0.6,
    zoom_overshoot = 0.0,
    zoom_easing = "Cubic.Out",

    auto_follow = true,
    follow_smooth_time = 0.15,
    follow_dead_zone = 5,

    debug_logs = false,
}

-- Timing
local last_tick_time = 0
local timer_running = false

-- Frame diff tracking (skip updates if nothing changed)
local last_output = { x = -1, y = -1, w = -1, h = -1 }

-- Original crop for zoom out
local original_crop = { x = 0, y = 0, w = 0, h = 0 }

-- Hotkey IDs
local hotkey_toggle_zoom = nil
local hotkey_toggle_follow = nil

-- Get reliable delta time
local function get_dt()
    local now = os.clock()
    local dt = now - last_tick_time
    last_tick_time = now
    return clamp(0.001, 0.1, dt)  -- Guard against freezes and div/zero
end

-- Start the timer
local function start_timer()
    if not timer_running then
        timer_running = true
        last_tick_time = os.clock()
        -- Use frame-synced interval
        local interval = 16  -- Default to ~60fps
        obs.timer_add(on_timer, interval)
        log("Timer: Started")
    end
end

-- Stop the timer
local function stop_timer()
    if timer_running then
        timer_running = false
        obs.timer_remove(on_timer)
        log("Timer: Stopped")
    end
end

-- Initialize mouse tracking
local function init_mouse_tracking(mouse_pos)
    camera_physics_init(mouse_pos)
    original_crop = {
        x = 0,
        y = 0,
        w = 0,
        h = 0,
    }
end

-- Main timer callback
function on_timer()
    local dt = get_dt()

    -- Guard: No valid source
    if not source_manager_is_valid() then
        return
    end

    --==========================
    -- 1. INPUT
    --==========================
    local raw_mouse = platform_get_mouse_pos()

    --==========================
    -- 2. STATE MACHINE UPDATE
    --==========================
    if SM:is_animating() then
        SM.zoom_time = SM.zoom_time + (dt / cfg.zoom_duration)

        -- Check for completion
        if SM.zoom_time >= 1.0 then
            SM:complete()

            -- Auto-enable follow after zoom in
            if SM.state == ZoomState.ZOOMED_IN and cfg.auto_follow then
                SM.following = true
            end

            -- Stop timer if idle
            if SM.state == ZoomState.IDLE then
                stop_timer()
            end
        end
    end

    --==========================
    -- 3. CAMERA POSITION
    --==========================
    local crop = nil
    local source_w, source_h = source_manager_get_size()

    if source_w == 0 or source_h == 0 then
        return
    end

    if SM:is_animating() then
        -- Animate between start and target crop
        local easing_fn = Easing.get(cfg.zoom_easing, cfg.zoom_overshoot)
        crop = camera_physics_lerp_crop(SM.start_crop, SM.target_crop, SM.zoom_time, easing_fn)
    elseif SM:is_zoomed() and SM.following then
        -- Follow mouse with dead zone and smoothing
        local tracked = camera_physics_apply_dead_zone(raw_mouse, cfg.follow_dead_zone)
        local smoothed = camera_physics_smooth_input(tracked, cfg.follow_smooth_time, dt)
        crop = camera_physics_compute_crop(smoothed.x, smoothed.y, SM.zoom_level, source_w, source_h)
        camera_physics_update_last_pos()
    elseif SM:is_zoomed() then
        -- Static zoom (not following)
        crop = camera_physics_get_target_crop(
            { x = SM.target_crop.x + SM.target_crop.w / 2, y = SM.target_crop.y + SM.target_crop.h / 2 },
            SM.zoom_level, source_w, source_h, nil
        )
    end

    --==========================
    -- 4. OUTPUT (Diff-based)
    --==========================
    if crop then
        local cx = math.floor(crop.x)
        local cy = math.floor(crop.y)
        local cw = math.floor(crop.w)
        local ch = math.floor(crop.h)

        if cx ~= last_output.x or cy ~= last_output.y or
           cw ~= last_output.w or ch ~= last_output.h then
            crop_filter_update(cx, cy, cw, ch)
            last_output.x = cx
            last_output.y = cy
            last_output.w = cw
            last_output.h = ch
        end
    end
end

--==========================
-- HOTKEY HANDLERS
--==========================

function on_toggle_zoom(pressed)
    if not pressed then return end

    if not source_manager_is_valid() then
        log("Toggle Zoom: No valid source")
        return
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        log("Toggle Zoom: Invalid source dimensions")
        return
    end

    if SM.state == ZoomState.IDLE then
        -- ZOOM IN
        local mouse = platform_get_mouse_pos()
        init_mouse_tracking(mouse)

        -- Store original crop
        original_crop = { x = 0, y = 0, w = source_w, h = source_h }

        -- Calculate target crop
        local target_crop = camera_physics_get_target_crop(mouse, cfg.zoom_value, source_w, source_h, nil)

        SM:transition(ZoomState.ZOOMING_IN, {
            start_crop = original_crop,
            target_crop = target_crop,
            target_level = cfg.zoom_value
        })

        start_timer()

    elseif SM.state == ZoomState.ZOOMED_IN then
        -- ZOOM OUT
        SM.following = false

        local current = crop_filter_get_crop()
        SM:transition(ZoomState.ZOOMING_OUT, {
            start_crop = current,
            target_crop = original_crop,
            target_level = 1.0
        })

        start_timer()
    end
    -- Ignore if already animating (guard against rapid presses)
end

function on_toggle_follow(pressed)
    if not pressed then return end
    if not SM:is_zoomed() then return end

    SM.following = not SM.following
    log("Follow: " .. tostring(SM.following))

    if SM.following and not timer_running then
        start_timer()
    end
end

--==========================
-- HOTKEY REGISTRATION
--==========================

local function register_hotkeys(settings)
    -- Toggle Zoom hotkey
    hotkey_toggle_zoom = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.toggle_zoom",
        "Toggle Zoom to Mouse",
        on_toggle_zoom
    )

    -- Toggle Follow hotkey
    hotkey_toggle_follow = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.toggle_follow",
        "Toggle Mouse Follow",
        on_toggle_follow
    )

    -- Load saved hotkey bindings
    local toggle_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.toggle_zoom")
    if toggle_array then
        obs.obs_hotkey_load(hotkey_toggle_zoom, toggle_array)
        obs.obs_data_array_release(toggle_array)
    end

    local follow_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.toggle_follow")
    if follow_array then
        obs.obs_hotkey_load(hotkey_toggle_follow, follow_array)
        obs.obs_data_array_release(follow_array)
    end

    -- Register scroll zoom hotkeys
    register_scroll_hotkeys(settings)

    log("Hotkeys: Registered")
end

local function save_hotkeys(settings)
    if hotkey_toggle_zoom then
        local array = obs.obs_hotkey_save(hotkey_toggle_zoom)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.toggle_zoom", array)
        obs.obs_data_array_release(array)
    end

    if hotkey_toggle_follow then
        local array = obs.obs_hotkey_save(hotkey_toggle_follow)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.toggle_follow", array)
        obs.obs_data_array_release(array)
    end

    -- Save scroll zoom hotkeys
    save_scroll_hotkeys(settings)
end

local function unregister_hotkeys()
    if hotkey_toggle_zoom then
        obs.obs_hotkey_unregister(hotkey_toggle_zoom)
        hotkey_toggle_zoom = nil
    end
    if hotkey_toggle_follow then
        obs.obs_hotkey_unregister(hotkey_toggle_follow)
        hotkey_toggle_follow = nil
    end
    -- Unregister scroll zoom hotkeys
    unregister_scroll_hotkeys()
    log("Hotkeys: Unregistered")
end

--==========================
-- SCENE EVENT HANDLERS
--==========================

function on_frontend_event(event)
    if event == obs.OBS_FRONTEND_EVENT_SCENE_CHANGED then
        -- Scene changed, re-acquire source
        log("Event: Scene changed")

        -- Handle scene memory
        scene_memory_on_scene_change()

        if cfg.source_name and cfg.source_name ~= "" then
            source_manager_release()
            source_manager_init(cfg.source_name)
        end
    elseif event == obs.OBS_FRONTEND_EVENT_EXIT then
        -- OBS is closing
        log("Event: OBS exiting")
        stop_timer()
        source_manager_release()
    end
end

--==========================
-- CONFIGURATION UPDATE
--==========================

local function update_config(settings)
    cfg.source_name = obs.obs_data_get_string(settings, "source") or ""
    cfg.zoom_value = obs.obs_data_get_double(settings, "zoom_value")
    cfg.zoom_duration = obs.obs_data_get_double(settings, "zoom_duration")
    cfg.zoom_overshoot = obs.obs_data_get_double(settings, "zoom_overshoot")
    cfg.zoom_easing = obs.obs_data_get_string(settings, "zoom_easing") or "Cubic.Out"

    cfg.auto_follow = obs.obs_data_get_bool(settings, "auto_follow")
    cfg.follow_smooth_time = obs.obs_data_get_double(settings, "follow_smooth_time")
    cfg.follow_dead_zone = obs.obs_data_get_int(settings, "follow_dead_zone")

    cfg.debug_logs = obs.obs_data_get_bool(settings, "debug_logs")
    debug_logs = cfg.debug_logs

    -- Update scroll zoom config
    update_scroll_config(settings)

    -- Check if source changed
    local current_source = source_manager_is_valid() and cfg.source_name
    if cfg.source_name ~= "" and cfg.source_name ~= current_source then
        -- Reset state and reinitialize
        SM:reset()
        stop_timer()
        source_manager_release()
        source_manager_init(cfg.source_name)
    end
end

--================================================
-- MODULE: Scroll Zoom (M10)
--================================================
-- Enables gradual zoom control via scroll wheel with modifier key
-- Provides dynamic zoom level adjustment during zoomed state

local ScrollZoom = {
    -- Hotkey IDs for scroll zoom
    hotkey_scroll_up = nil,
    hotkey_scroll_down = nil,

    -- Configuration (populated from settings)
    scroll_step = 0.25,
    scroll_modifier = "ctrl",  -- "ctrl", "alt", "shift"
}

-- Check if modifier key is held
local function is_modifier_held()
    if ScrollZoom.scroll_modifier == "ctrl" then
        return platform_is_ctrl_held()
    elseif ScrollZoom.scroll_modifier == "alt" then
        return platform_is_alt_held()
    elseif ScrollZoom.scroll_modifier == "shift" then
        return platform_is_shift_held()
    end
    return false
end

-- Handle scroll zoom in
function on_scroll_zoom_up(pressed)
    if not pressed then return end
    on_scroll_zoom(1)
end

-- Handle scroll zoom out
function on_scroll_zoom_down(pressed)
    if not pressed then return end
    on_scroll_zoom(-1)
end

-- Main scroll zoom handler
function on_scroll_zoom(direction)
    -- Check if we can scroll
    if not SM:can_scroll() then return end

    -- Check modifier (optional - can be configured)
    -- For now, we rely on OBS hotkey bindings which can include modifiers

    if not source_manager_is_valid() then
        log("Scroll Zoom: No valid source")
        return
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        return
    end

    -- Calculate new zoom level
    local step = ScrollZoom.scroll_step * direction  -- e.g., 0.25
    local new_level

    if SM.state == ZoomState.IDLE then
        -- Starting from unzoomed
        new_level = 1.0 + step
    else
        -- Already zoomed, adjust level
        new_level = SM.target_level + step
    end

    -- Clamp to valid range
    new_level = clamp(1.0, cfg.max_zoom, new_level)

    -- If we hit 1.0, fully zoom out
    if new_level <= 1.0 then
        if SM:is_zoomed() then
            -- Trigger full zoom out
            local current = crop_filter_get_crop()
            SM.following = false
            SM:transition(ZoomState.ZOOMING_OUT, {
                start_crop = current,
                target_crop = original_crop,
                target_level = 1.0
            })
            start_timer()
        end
        return
    end

    -- Get current mouse position
    local mouse = platform_get_mouse_pos()

    -- Calculate new target crop for new zoom level
    local target_crop = camera_physics_get_target_crop(mouse, new_level, source_w, source_h, nil)

    -- Get current crop as start
    local start_crop
    if SM:is_animating() then
        -- Use current interpolated crop
        start_crop = crop_filter_get_crop()
    elseif SM:is_zoomed() then
        -- Use current crop
        start_crop = crop_filter_get_crop()
    else
        -- Starting from unzoomed
        start_crop = { x = 0, y = 0, w = source_w, h = source_h }
        original_crop = start_crop
        camera_physics_init(mouse)
    end

    -- Transition to new zoom level
    if SM.state == ZoomState.IDLE then
        -- First scroll from unzoomed
        SM:transition(ZoomState.SCROLLING, {
            start_crop = start_crop,
            target_crop = target_crop,
            target_level = new_level
        })
    else
        -- Already zoomed, adjust level (interrupt current animation)
        SM:transition(ZoomState.SCROLLING, {
            start_crop = start_crop,
            target_crop = target_crop,
            target_level = new_level
        })
    end

    start_timer()
    log("Scroll Zoom: Level " .. string.format("%.2f", new_level))
end

-- Zoom to a specific level (for API calls)
function on_scroll_zoom_to(level)
    if not source_manager_is_valid() then return end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then return end

    level = clamp(1.0, cfg.max_zoom, level)

    if level <= 1.0 then
        -- Zoom out
        if SM:is_zoomed() then
            local current = crop_filter_get_crop()
            SM.following = false
            SM:transition(ZoomState.ZOOMING_OUT, {
                start_crop = current,
                target_crop = original_crop,
                target_level = 1.0
            })
            start_timer()
        end
        return
    end

    local mouse = platform_get_mouse_pos()
    local target_crop = camera_physics_get_target_crop(mouse, level, source_w, source_h, nil)

    local start_crop
    if SM:is_zoomed() then
        start_crop = crop_filter_get_crop()
    else
        start_crop = { x = 0, y = 0, w = source_w, h = source_h }
        original_crop = start_crop
        camera_physics_init(mouse)
    end

    SM:transition(ZoomState.SCROLLING, {
        start_crop = start_crop,
        target_crop = target_crop,
        target_level = level
    })

    start_timer()
end

-- Register scroll zoom hotkeys
local function register_scroll_hotkeys(settings)
    -- Scroll Up hotkey
    ScrollZoom.hotkey_scroll_up = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.scroll_up",
        "Zoom In (Scroll)",
        on_scroll_zoom_up
    )

    -- Scroll Down hotkey
    ScrollZoom.hotkey_scroll_down = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.scroll_down",
        "Zoom Out (Scroll)",
        on_scroll_zoom_down
    )

    -- Load saved bindings
    local up_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.scroll_up")
    if up_array then
        obs.obs_hotkey_load(ScrollZoom.hotkey_scroll_up, up_array)
        obs.obs_data_array_release(up_array)
    end

    local down_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.scroll_down")
    if down_array then
        obs.obs_hotkey_load(ScrollZoom.hotkey_scroll_down, down_array)
        obs.obs_data_array_release(down_array)
    end

    log("Scroll Zoom: Hotkeys registered")
end

-- Save scroll hotkey bindings
local function save_scroll_hotkeys(settings)
    if ScrollZoom.hotkey_scroll_up then
        local array = obs.obs_hotkey_save(ScrollZoom.hotkey_scroll_up)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.scroll_up", array)
        obs.obs_data_array_release(array)
    end

    if ScrollZoom.hotkey_scroll_down then
        local array = obs.obs_hotkey_save(ScrollZoom.hotkey_scroll_down)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.scroll_down", array)
        obs.obs_data_array_release(array)
    end
end

-- Unregister scroll hotkeys
local function unregister_scroll_hotkeys()
    if ScrollZoom.hotkey_scroll_up then
        obs.obs_hotkey_unregister(ScrollZoom.hotkey_scroll_up)
        ScrollZoom.hotkey_scroll_up = nil
    end
    if ScrollZoom.hotkey_scroll_down then
        obs.obs_hotkey_unregister(ScrollZoom.hotkey_scroll_down)
        ScrollZoom.hotkey_scroll_down = nil
    end
end

-- Update scroll zoom config
local function update_scroll_config(settings)
    ScrollZoom.scroll_step = obs.obs_data_get_double(settings, "scroll_step")
    ScrollZoom.scroll_modifier = obs.obs_data_get_string(settings, "scroll_modifier") or "ctrl"
end

--================================================
-- PLACEHOLDER: Future Modules
--================================================

-- M01: Configuration & Settings (TODO)
-- M05: Scene Manager (TODO)
-- M06: Source Manager (TODO)
-- M07: Crop/Zoom Controller (TODO)
-- M08: Motion Tracker (TODO)
-- M09: Face Detection (TODO)
-- M11: Audio Reactor (TODO)
-- M12: Transition Manager (TODO)
-- M13: Animation Controller (TODO)
-- M14: Preset Manager (TODO)
-- M15: Hotkey Manager (TODO)
-- M16: UI Components (TODO)
-- M17: Timer/Scheduler (TODO)
-- M18: State Machine (TODO)
-- M19: Performance Monitor (TODO)

--================================================
-- SCRIPT SETTINGS
--================================================
local settings = {}

-- Default settings
local defaults = {
    debug_logging = false,
    easing_type = "QuadInOut",
    smooth_time = 0.3,
    max_speed = 100.0
}

--================================================
-- MODULE: Preset Manager (M13)
--================================================
-- Manages built-in and custom animation presets

local PresetManager = {
    -- Built-in presets (read-only)
    built_in = {
        {
            name = "Smooth",
            duration = 0.8,
            overshoot = 0.0,
            smoothness = 0.25,
            easing = "Cubic.Out",
        },
        {
            name = "Bounce",
            duration = 0.6,
            overshoot = 0.35,
            smoothness = 0.15,
            easing = "Back.Out",
        },
        {
            name = "Snappy",
            duration = 0.3,
            overshoot = 0.0,
            smoothness = 0.05,
            easing = "Expo.Out",
        },
        {
            name = "Cinematic",
            duration = 1.2,
            overshoot = 0.05,
            smoothness = 0.4,
            easing = "Sine.Out",
        },
    },

    -- Custom user presets
    custom = {},

    -- Currently selected preset name
    current_preset = "Smooth",
}

-- Get all preset names (built-in + custom)
function PresetManager:get_all_names()
    local names = {}

    -- Add built-in presets
    for _, preset in ipairs(self.built_in) do
        table.insert(names, preset.name)
    end

    -- Add custom presets
    for name, _ in pairs(self.custom) do
        table.insert(names, name)
    end

    table.sort(names)
    return names
end

-- Get preset by name
function PresetManager:get_preset(name)
    -- Check built-in first
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            return preset
        end
    end

    -- Check custom
    if self.custom[name] then
        return self.custom[name]
    end

    -- Default to Smooth
    return self.built_in[1]
end

-- Apply preset to configuration
function PresetManager:apply_preset(name)
    local preset = self:get_preset(name)
    if not preset then
        log("Preset: Unknown preset: " .. name)
        return false
    end

    cfg.zoom_duration = preset.duration
    cfg.zoom_overshoot = preset.overshoot
    cfg.follow_smooth_time = preset.smoothness

    if preset.easing then
        cfg.zoom_easing = preset.easing
    end

    self.current_preset = name
    log("Preset: Applied '" .. name .. "'")
    return true
end

-- Save a custom preset
function PresetManager:save_preset(name, duration, overshoot, smoothness, easing)
    if not name or name == "" then
        return false
    end

    -- Check if it's a built-in preset (can't override)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            log("Preset: Cannot override built-in preset: " .. name)
            return false
        end
    end

    -- Save custom preset
    self.custom[name] = {
        name = name,
        duration = duration or cfg.zoom_duration,
        overshoot = overshoot or cfg.zoom_overshoot,
        smoothness = smoothness or cfg.follow_smooth_time,
        easing = easing or cfg.zoom_easing,
    }

    log("Preset: Saved custom preset '" .. name .. "'")
    return true
end

-- Delete a custom preset
function PresetManager:delete_preset(name)
    -- Check if it's a built-in preset (can't delete)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            log("Preset: Cannot delete built-in preset: " .. name)
            return false
        end
    end

    -- Delete custom preset
    if self.custom[name] then
        self.custom[name] = nil
        log("Preset: Deleted custom preset '" .. name .. "'")
        return true
    end

    return false
end

-- Check if a preset is built-in
function PresetManager:is_built_in(name)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            return true
        end
    end
    return false
end

-- Persist custom presets to settings
function PresetManager:persist(settings)
    local array = obs.obs_data_array_create()

    for name, preset in pairs(self.custom) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "name", name)
        obs.obs_data_set_double(item, "duration", preset.duration)
        obs.obs_data_set_double(item, "overshoot", preset.overshoot)
        obs.obs_data_set_double(item, "smoothness", preset.smoothness)
        obs.obs_data_set_string(item, "easing", preset.easing)
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "custom_presets", array)
    obs.obs_data_array_release(array)
end

-- Load custom presets from settings
function PresetManager:load(settings)
    self.custom = {}

    local array = obs.obs_data_get_array(settings, "custom_presets")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local name = obs.obs_data_get_string(item, "name")

        if name and name ~= "" then
            self.custom[name] = {
                name = name,
                duration = obs.obs_data_get_double(item, "duration"),
                overshoot = obs.obs_data_get_double(item, "overshoot"),
                smoothness = obs.obs_data_get_double(item, "smoothness"),
                easing = obs.obs_data_get_string(item, "easing"),
            }
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)
    log("Preset: Loaded " .. self:get_custom_count() .. " custom presets")
end

-- Get count of custom presets
function PresetManager:get_custom_count()
    local count = 0
    for _, _ in pairs(self.custom) do
        count = count + 1
    end
    return count
end

-- Get current preset name
function PresetManager:get_current_name()
    return self.current_preset
end

-- Set current preset name
function PresetManager:set_current_name(name)
    self.current_preset = name
end

-- Check if current preset is custom
function PresetManager:is_current_custom()
    return not self:is_built_in(self.current_preset)
end

-- Global convenience functions
function preset_get_all_names()
    return PresetManager:get_all_names()
end

function preset_apply(name)
    return PresetManager:apply_preset(name)
end

function preset_save(name, duration, overshoot, smoothness, easing)
    return PresetManager:save_preset(name, duration, overshoot, smoothness, easing)
end

function preset_delete(name)
    return PresetManager:delete_preset(name)
end

function preset_is_built_in(name)
    return PresetManager:is_built_in(name)
end

function preset_get_current()
    return PresetManager:get_current_name()
end

--================================================
-- MODULE: Auto Source Detection (M11)
--================================================
-- Automatically detects and selects the best zoom source on first run

local AutoSourceDetector = {
    -- Source type priorities (higher = more likely to be the main display)
    type_priorities = {
        ["monitor_capture"] = 100,     -- Display capture (highest priority)
        ["game_capture"] = 80,          -- Game capture
        ["window_capture"] = 60,        -- Window capture
        ["xshm_input"] = 40,           -- Linux X11 capture
        ["av_capture_input"] = 20,     -- macOS capture
    },

    -- Whether auto-detection has been run
    auto_detected = false,
}

-- Get all capture sources sorted by priority
function AutoSourceDetector:get_capture_sources()
    local sources = {}
    local source_list = obs.obs_enum_sources()

    if not source_list then
        return sources
    end

    for _, source in ipairs(source_list) do
        local source_id = obs.obs_source_get_id(source)
        local name = obs.obs_source_get_name(source)

        -- Check if it's a capture source
        local priority = self.type_priorities[source_id]
        if priority then
            table.insert(sources, {
                name = name,
                id = source_id,
                priority = priority,
            })
        end
    end

    obs.source_list_release(source_list)

    -- Sort by priority (highest first)
    table.sort(sources, function(a, b)
        return a.priority > b.priority
    end)

    return sources
end

-- Auto-detect the best source
function AutoSourceDetector:auto_detect()
    local sources = self:get_capture_sources()

    if #sources == 0 then
        log("AutoSource: No capture sources found")
        return nil
    end

    if #sources == 1 then
        -- Only one source, use it
        log("AutoSource: Found single source: " .. sources[1].name)
        return sources[1].name
    end

    -- Multiple sources - prioritize by type
    -- Prefer monitor_capture > game_capture > window_capture
    local best = sources[1]

    log("AutoSource: Found " .. #sources .. " sources, selecting: " .. best.name)
    return best.name
end

-- Get monitor geometry from a source (if available)
function AutoSourceDetector:get_monitor_geometry(source_name)
    local source = obs.obs_get_source_by_name(source_name)
    if not source then
        return nil
    end

    local settings = obs.obs_source_get_settings(source)
    if not settings then
        obs.obs_source_release(source)
        return nil
    end

    -- Try to get monitor info from settings
    local monitor = obs.obs_data_get_int(settings, "monitor")
    local x = obs.obs_data_get_int(settings, "x")
    local y = obs.obs_data_get_int(settings, "y")
    local width = obs.obs_data_get_int(settings, "width")
    local height = obs.obs_data_get_int(settings, "height")

    obs.obs_data_release(settings)
    obs.obs_source_release(source)

    -- Return geometry if available
    if monitor >= 0 or width > 0 then
        return {
            monitor = monitor,
            x = x,
            y = y,
            width = width or 1920,
            height = height or 1080,
        }
    end

    return nil
end

-- Check if we should auto-detect on first run
function AutoSourceDetector:should_auto_detect(settings)
    -- Check if source has ever been set
    local last_source = obs.obs_data_get_string(settings, "source")
    if last_source and last_source ~= "" then
        return false
    end

    -- Check if auto-detect has been done
    return not self.auto_detected
end

-- Run auto-detection and return the source name
function AutoSourceDetector:run(settings)
    local source_name = self:auto_detect()

    if source_name then
        -- Save the detected source
        obs.obs_data_set_string(settings, "source", source_name)
        self.auto_detected = true
    end

    return source_name
end

-- Global convenience functions
function auto_source_detect()
    return AutoSourceDetector:auto_detect()
end

function auto_source_should_detect(settings)
    return AutoSourceDetector:should_auto_detect(settings)
end

function auto_source_run(settings)
    return AutoSourceDetector:run(settings)
end

--================================================
-- MODULE: Scene Memory (M12)
--================================================
-- Remembers which zoom source to use for each OBS scene

local SceneMemory = {
    -- Scene to source mapping
    scene_source_map = {},

    -- Maximum number of mappings to store
    max_mappings = 50,
}

-- Get the current scene name
function SceneMemory:get_current_scene_name()
    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then
        return nil
    end

    local name = obs.obs_source_get_name(scene_source)
    obs.obs_source_release(scene_source)
    return name
end

-- Get the source to use for the current scene
function SceneMemory:get_source_for_current_scene()
    local scene_name = self:get_current_scene_name()
    if not scene_name then
        return nil
    end

    -- 1. Check explicit mapping for this scene
    if self.scene_source_map[scene_name] then
        return self.scene_source_map[scene_name]
    end

    -- 2. Fall back to global source from config
    return cfg.source_name
end

-- Set the source for a specific scene
function SceneMemory:set(scene_name, source_name)
    if not scene_name or scene_name == "" then
        return false
    end

    -- Check if we're at capacity
    local count = 0
    for _, _ in pairs(self.scene_source_map) do
        count = count + 1
    end

    if count >= self.max_mappings and not self.scene_source_map[scene_name] then
        log("SceneMemory: At capacity (" .. self.max_mappings .. "), cannot add: " .. scene_name)
        return false
    end

    self.scene_source_map[scene_name] = source_name
    log("SceneMemory: " .. scene_name .. " Ã¢â€ â€™ " .. source_name)
    return true
end

-- Remove a scene mapping
function SceneMemory:remove(scene_name)
    if self.scene_source_map[scene_name] then
        self.scene_source_map[scene_name] = nil
        log("SceneMemory: Removed mapping for " .. scene_name)
        return true
    end
    return false
end

-- Get all scene mappings
function SceneMemory:get_all()
    local mappings = {}
    for scene, source in pairs(self.scene_source_map) do
        table.insert(mappings, { scene = scene, source = source })
    end
    table.sort(mappings, function(a, b)
        return a.scene < b.scene
    end)
    return mappings
end

-- Check if a scene has a mapping
function SceneMemory:has_mapping(scene_name)
    return self.scene_source_map[scene_name] ~= nil
end

-- Persist mappings to settings
function SceneMemory:persist(settings)
    local array = obs.obs_data_array_create()

    for scene, source in pairs(self.scene_source_map) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "scene", scene)
        obs.obs_data_set_string(item, "source", source)
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "scene_source_map", array)
    obs.obs_data_array_release(array)
end

-- Load mappings from settings
function SceneMemory:load(settings)
    self.scene_source_map = {}

    local array = obs.obs_data_get_array(settings, "scene_source_map")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local scene = obs.obs_data_get_string(item, "scene")
        local source = obs.obs_data_get_string(item, "source")

        if scene and scene ~= "" and source and source ~= "" then
            self.scene_source_map[scene] = source
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)

    local count = 0
    for _, _ in pairs(self.scene_source_map) do count = count + 1 end
    log("SceneMemory: Loaded " .. count .. " scene mappings")
end

-- Handle scene change
function SceneMemory:on_scene_change()
    local scene_name = self:get_current_scene_name()
    if not scene_name then
        return
    end

    -- Get the source for this scene
    local source_name = self:get_source_for_current_scene()

    if source_name and source_name ~= "" then
        -- Check if source changed
        local current = source_manager_is_valid() and cfg.source_name

        if source_name ~= current then
            log("SceneMemory: Scene changed to " .. scene_name)

            -- Release current source
            source_manager_release()

            -- Initialize with new source
            cfg.source_name = source_name
            source_manager_init(source_name)
        end
    end
end

-- Global convenience functions
function scene_memory_get_source()
    return SceneMemory:get_source_for_current_scene()
end

function scene_memory_set(scene_name, source_name)
    return SceneMemory:set(scene_name, source_name)
end

function scene_memory_remove(scene_name)
    return SceneMemory:remove(scene_name)
end

function scene_memory_get_all()
    return SceneMemory:get_all()
end

function scene_memory_on_scene_change()
    return SceneMemory:on_scene_change()
end

--================================================
-- MODULE: Blur Manager (M14)
--================================================
-- Provides built-in blur effects without external plugins
-- Supports multiple strategies: shader, composite_blur plugin, or none

local BlurManager = {
    -- Current strategy: "shader", "composite_blur", "none"
    strategy = "none",

    -- Filter references
    zoom_blur_filter = nil,
    motion_blur_filter = nil,

    -- Settings references
    zoom_blur_settings = nil,
    motion_blur_settings = nil,

    -- State
    initialized = false,

    -- Configuration
    zoom_blur_enabled = false,
    zoom_blur_intensity = 5,
    zoom_blur_clear_radius = 150,
    motion_blur_enabled = false,
    motion_blur_intensity = 1.0,
}

-- Try to use custom shader (if effect files exist)
function BlurManager:try_shader_strategy(source)
    -- This would require .effect files in assets/shaders/
    -- For now, we'll use a simpler approach
    log("Blur: Shader strategy not implemented (requires effect files)")
    return false
end

-- Try to auto-create Composite Blur filters
function BlurManager:try_composite_blur_strategy(source)
    if not source then return false end

    -- Check if composite_blur filter type exists
    local test_filter = obs.obs_source_create_private("composite_blur", "__test_blur__", nil)
    if test_filter then
        obs.obs_source_release(test_filter)
    else
        log("Blur: Composite Blur plugin not available")
        return false
    end

    -- Create Zoom Blur filter
    local zs = obs.obs_data_create()
    obs.obs_data_set_double(zs, "radius", 0)
    obs.obs_data_set_int(zs, "blur_type", 2) -- Zoom type
    self.zoom_blur_filter = obs.obs_source_create_private(
        "composite_blur",
        FILTER_PREFIX .. "Zoom Blur",
        zs
    )

    if self.zoom_blur_filter then
        obs.obs_source_filter_add(source, self.zoom_blur_filter)
        self.zoom_blur_settings = zs
    else
        obs.obs_data_release(zs)
        return false
    end

    -- Create Motion Blur filter
    local ms = obs.obs_data_create()
    obs.obs_data_set_double(ms, "radius", 0)
    obs.obs_data_set_int(ms, "blur_type", 3) -- Motion/directional type
    self.motion_blur_filter = obs.obs_source_create_private(
        "composite_blur",
        FILTER_PREFIX .. "Motion Blur",
        ms
    )

    if self.motion_blur_filter then
        obs.obs_source_filter_add(source, self.motion_blur_filter)
        self.motion_blur_settings = ms
    else
        obs.obs_data_release(ms)
    end

    self.initialized = true
    return true
end

-- Initialize blur manager
function BlurManager:init(source)
    if not source then
        return false
    end

    self:cleanup()

    -- Try composite_blur strategy
    if self:try_composite_blur_strategy(source) then
        self.strategy = "composite_blur"
        log("Blur: Using Composite Blur plugin (auto-configured)")
        return true
    end

    -- No blur available
    self.strategy = "none"
    log("Blur: No blur backend available. Blur effects disabled.")
    return false
end

-- Update blur based on zoom state
function BlurManager:update(state_machine, crop, camera_velocity)
    if not self.initialized then return end
    if self.strategy == "none" then return end

    -- Zoom Blur: Active during zoom transitions
    if self.zoom_blur_enabled and self.zoom_blur_filter then
        local radius = 0

        if state_machine:is_animating() and
           (state_machine.state == ZoomState.ZOOMING_IN or
            state_machine.state == ZoomState.ZOOMING_OUT) then
            -- Bell curve: 0 at start Ã¢â€ â€™ peak at 50% Ã¢â€ â€™ 0 at end
            local t = clamp(0, 1, state_machine.zoom_time)
            local curve = math.sin(t * math.pi)
            radius = curve * curve * self.zoom_blur_intensity
        end

        self:set_zoom_blur(radius, crop)
    end

    -- Motion Blur: Active during camera panning (not during zoom transition)
    if self.motion_blur_enabled and self.motion_blur_filter then
        if not state_machine:is_animating() and state_machine:is_zoomed() and camera_velocity then
            local speed = math.sqrt(
                camera_velocity.x * camera_velocity.x +
                camera_velocity.y * camera_velocity.y
            )

            if speed > 1.0 then
                local radius = math.min(10, speed * self.motion_blur_intensity * 0.5)
                local angle = math.deg(math.atan2(camera_velocity.y, camera_velocity.x))
                self:set_motion_blur(radius, angle)
            else
                self:set_motion_blur(0, 0)
            end
        else
            self:set_motion_blur(0, 0)
        end
    end
end

-- Set zoom blur parameters
function BlurManager:set_zoom_blur(radius, crop)
    if self.strategy == "composite_blur" and self.zoom_blur_settings then
        obs.obs_data_set_double(self.zoom_blur_settings, "radius", radius)

        if crop then
            local cx = crop.x + (crop.w / 2)
            local cy = crop.y + (crop.h / 2)
            obs.obs_data_set_double(self.zoom_blur_settings, "center_x", cx)
            obs.obs_data_set_double(self.zoom_blur_settings, "center_y", cy)
        end

        obs.obs_data_set_double(self.zoom_blur_settings, "inactive_radius", self.zoom_blur_clear_radius)
        obs.obs_source_update(self.zoom_blur_filter, self.zoom_blur_settings)
    end
end

-- Set motion blur parameters
function BlurManager:set_motion_blur(radius, angle)
    if self.strategy == "composite_blur" and self.motion_blur_settings then
        obs.obs_data_set_double(self.motion_blur_settings, "radius", radius)
        obs.obs_data_set_double(self.motion_blur_settings, "angle", angle)
        obs.obs_source_update(self.motion_blur_filter, self.motion_blur_settings)
    end
end

-- Update configuration
function BlurManager:update_config(settings)
    self.zoom_blur_enabled = obs.obs_data_get_bool(settings, "zoom_blur_enabled")
    self.zoom_blur_intensity = obs.obs_data_get_double(settings, "zoom_blur_intensity")
    self.zoom_blur_clear_radius = obs.obs_data_get_double(settings, "zoom_blur_clear_radius")
    self.motion_blur_enabled = obs.obs_data_get_bool(settings, "motion_blur_enabled")
    self.motion_blur_intensity = obs.obs_data_get_double(settings, "motion_blur_intensity")
end

-- Cleanup filters
function BlurManager:cleanup()
    local source = source_manager_get_source()

    if self.zoom_blur_filter and source then
        obs.obs_source_filter_remove(source, self.zoom_blur_filter)
        obs.obs_source_release(self.zoom_blur_filter)
        self.zoom_blur_filter = nil
    end

    if self.motion_blur_filter and source then
        obs.obs_source_filter_remove(source, self.motion_blur_filter)
        obs.obs_source_release(self.motion_blur_filter)
        self.motion_blur_filter = nil
    end

    if self.zoom_blur_settings then
        obs.obs_data_release(self.zoom_blur_settings)
        self.zoom_blur_settings = nil
    end

    if self.motion_blur_settings then
        obs.obs_data_release(self.motion_blur_settings)
        self.motion_blur_settings = nil
    end

    self.initialized = false
    self.strategy = "none"
end

-- Check if blur is available
function BlurManager:is_available()
    return self.strategy ~= "none"
end

-- Global convenience functions
function blur_manager_init(source)
    return BlurManager:init(source)
end

function blur_manager_update(state_machine, crop, camera_velocity)
    return BlurManager:update(state_machine, crop, camera_velocity)
end

function blur_manager_update_config(settings)
    return BlurManager:update_config(settings)
end

function blur_manager_cleanup()
    return BlurManager:cleanup()
end

function blur_manager_is_available()
    return BlurManager:is_available()
end

--================================================
-- MODULE: Cursor Asset Manager (M16)
--================================================
-- Handles extracting and managing cursor image assets

local CursorAssets = {
    extracted = false,
    dir = nil,
}

-- Get the platform-specific asset directory
function CursorAssets:get_platform_dir()
    if IS_WINDOWS then
        local appdata = os.getenv("APPDATA")
        return appdata and (appdata .. "\\obs-studio\\obs-zoom-pro\\cursors") or nil
    elseif IS_LINUX then
        local home = os.getenv("HOME")
        return home and (home .. "/.config/obs-studio/obs-zoom-pro/cursors") or nil
    elseif IS_MACOS then
        local home = os.getenv("HOME")
        return home and (home .. "/Library/Application Support/obs-studio/obs-zoom-pro/cursors") or nil
    end
    -- Fallback for non-FFI environments
    return "cursors"
end

-- Ensure assets are extracted
function CursorAssets:ensure_extracted()
    if self.extracted then
        return self.dir
    end

    local dir = self:get_platform_dir()
    if not dir then
        log("CursorAssets: Could not determine asset directory")
        return nil
    end

    -- Create directory
    local cmd
    if IS_WINDOWS then
        cmd = 'mkdir "' .. dir .. '" 2>nul'
    else
        cmd = 'mkdir -p "' .. dir .. '"'
    end
    os.execute(cmd)

    -- Check if assets exist
    local sep = IS_WINDOWS and "\\" or "/"
    local arrow_path = dir .. sep .. "arrow.png"

    local f = io.open(arrow_path, "rb")
    if f then
        f:close()
        self.dir = dir
        self.extracted = true
        log("CursorAssets: Using existing assets from " .. dir)
        return dir
    end

    -- Try to copy from script directory
    local script_dir = get_script_directory()
    local assets_src = script_dir .. "assets" .. sep .. "cursors" .. sep

    local files = { "arrow.png", "pointer.png", "ibeam.png" }
    for _, filename in ipairs(files) do
        local src_path = assets_src .. filename
        local dst_path = dir .. sep .. filename

        local src = io.open(src_path, "rb")
        if src then
            local data = src:read("*a")
            src:close()

            local dst = io.open(dst_path, "wb")
            if dst then
                dst:write(data)
                dst:close()
                log("CursorAssets: Copied " .. filename)
            end
        end
    end

    self.dir = dir
    self.extracted = true
    return dir
end

-- Get the asset directory
function CursorAssets:get_dir()
    return self.dir
end

-- Check if assets are available
function CursorAssets:is_available()
    if not self.extracted then
        self:ensure_extracted()
    end
    return self.dir ~= nil
end

-- Get cursor image path
function CursorAssets:get_cursor_path(cursor_type)
    if not self:is_available() then
        return nil
    end

    local sep = IS_WINDOWS and "\\" or "/"
    local filename = (cursor_type or "arrow") .. ".png"
    return self.dir .. sep .. filename
end

-- Global convenience functions
function cursor_assets_ensure_extracted()
    return CursorAssets:ensure_extracted()
end

function cursor_assets_get_dir()
    return CursorAssets:get_dir()
end

function cursor_assets_is_available()
    return CursorAssets:is_available()
end

function cursor_assets_get_cursor_path(cursor_type)
    return CursorAssets:get_cursor_path(cursor_type)
end

--================================================
-- MODULE: Cursor Renderer (M15)
--================================================
-- Provides automatic cursor overlay rendering

local CursorRenderer = {
    enabled = false,
    source = nil,
    sceneitem = nil,

    -- Smoothed state
    pos = { x = 0, y = 0 },
    current_scale = 1.0,
    current_rot = 0,
    swap_pulse = 1.0,

    -- Velocities (SmoothDamp)
    vel_x = { val = 0 },
    vel_y = { val = 0 },
    vel_scale = { val = 0 },
    vel_rot = { val = 0 },
    vel_swap = { val = 0 },

    -- State
    was_pointer = false,
    initialized = false,

    -- Configuration
    cursor_scale = 1.0,
    cursor_click_scale = 0.78,
    cursor_smooth_time = 0.1,
    cursor_offset_x = -6,
    cursor_offset_y = -2,
    cursor_rotation_mode = "None",
    cursor_angle_offset = 0,
    cursor_tilt_strength = 0,
}

-- Initialize cursor renderer
function CursorRenderer:init()
    if not cfg.cursor_enabled then
        self.enabled = false
        return false
    end

    -- Ensure cursor assets are available
    local asset_dir = cursor_assets_ensure_extracted()
    if not asset_dir then
        log("CursorRenderer: Failed to extract cursor assets")
        self.enabled = false
        return false
    end

    -- Get or create the cursor image source
    local source_name = FILTER_PREFIX .. "Cursor"
    self.source = obs.obs_get_source_by_name(source_name)

    if not self.source then
        -- Create new image source
        local settings = obs.obs_data_create()
        local cursor_path = cursor_assets_get_cursor_path("arrow")
        if cursor_path then
            obs.obs_data_set_string(settings, "file", cursor_path)
        end
        self.source = obs.obs_source_create("image_source", source_name, settings, nil)
        obs.obs_data_release(settings)

        if not self.source then
            log("CursorRenderer: Failed to create image source")
            self.enabled = false
            return false
        end
    end

    -- Add to current scene
    self:add_to_scene()

    -- Initialize position
    local mouse = platform_get_mouse_pos()
    self.pos.x = mouse.x
    self.pos.y = mouse.y

    self.enabled = true
    self.initialized = true
    log("CursorRenderer: Initialized")
    return true
end

-- Add cursor source to scene
function CursorRenderer:add_to_scene()
    if not self.source then return false end

    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then return false end

    local scene = obs.obs_scene_from_source(scene_source)
    if not scene then
        obs.obs_source_release(scene_source)
        return false
    end

    -- Check if already in scene
    local source_name = obs.obs_source_get_name(self.source)
    self.sceneitem = obs.obs_scene_find_source(scene, source_name)

    if not self.sceneitem then
        -- Add to scene
        self.sceneitem = obs.obs_scene_add(scene, self.source)
        if self.sceneitem then
            -- Move to top (render last = on top)
            obs.obs_sceneitem_set_order(self.sceneitem, obs.OBS_ORDER_MOVE_TOP)
        end
    end

    obs.obs_source_release(scene_source)
    return true
end

-- Update cursor position and state
function CursorRenderer:update(dt, raw_mouse, camera_crop)
    if not self.enabled or not self.sceneitem then return end

    -- Smooth cursor position
    self.pos.x = SmoothDamp(self.pos.x, raw_mouse.x, self.vel_x, self.cursor_smooth_time, 100000, dt)
    self.pos.y = SmoothDamp(self.pos.y, raw_mouse.y, self.vel_y, self.cursor_smooth_time, 100000, dt)

    -- Snap when very close
    if math.abs(self.pos.x - raw_mouse.x) < 0.5 then
        self.pos.x = raw_mouse.x
        self.vel_x.val = 0
    end
    if math.abs(self.pos.y - raw_mouse.y) < 0.5 then
        self.pos.y = raw_mouse.y
        self.vel_y.val = 0
    end

    -- Cursor shape detection (Windows only)
    local is_pointer = false
    if platform_cursor_shape_available() then
        is_pointer = platform_is_cursor_pointer()
    end

    -- Swap cursor image if needed
    if is_pointer ~= self.was_pointer then
        local asset_dir = cursor_assets_get_dir()
        local sep = IS_WINDOWS and "\\" or "/"
        local new_file = is_pointer and (asset_dir .. sep .. "pointer.png") or (asset_dir .. sep .. "arrow.png")

        local s = obs.obs_source_get_settings(self.source)
        if s then
            obs.obs_data_set_string(s, "file", new_file)
            obs.obs_source_update(self.source, s)
            obs.obs_data_release(s)
        end

        -- Trigger swap pulse
        self.swap_pulse = 0.75
        self.vel_swap.val = 1
        self.was_pointer = is_pointer
    end

    self.swap_pulse = SmoothDamp(self.swap_pulse, 1.0, self.vel_swap, 0.12, 100000, dt)

    -- Click animation
    local is_clicking = platform_is_clicking()
    local target_scale = is_clicking and (self.cursor_scale * self.cursor_click_scale) or self.cursor_scale
    self.current_scale = SmoothDamp(self.current_scale, target_scale, self.vel_scale, 0.1, 100000, dt)

    -- Calculate position relative to zoom
    local zoom_factor = 1.0
    local crop_x, crop_y = 0, 0

    if camera_crop and SM:is_zoomed() then
        zoom_factor = source_manager_get_size() / camera_crop.w
        crop_x = camera_crop.x
        crop_y = camera_crop.y
    end

    local final_x = (self.pos.x - crop_x) * zoom_factor + (self.cursor_offset_x * zoom_factor)
    local final_y = (self.pos.y - crop_y) * zoom_factor + (self.cursor_offset_y * zoom_factor)

    -- Apply to scene item
    local pos = obs.vec2()
    pos.x = final_x
    pos.y = final_y
    obs.obs_sceneitem_set_pos(self.sceneitem, pos)

    local scale = obs.vec2()
    local s = self.current_scale * zoom_factor * self.swap_pulse
    scale.x = s
    scale.y = s
    obs.obs_sceneitem_set_scale(self.sceneitem, scale)

    -- Rotation
    local dynamic_rot = self:compute_rotation(dt)
    obs.obs_sceneitem_set_rot(self.sceneitem, dynamic_rot)
end

-- Compute rotation based on mode
function CursorRenderer:compute_rotation(dt)
    local vx = self.vel_x.val
    local vy = self.vel_y.val
    local speed = math.sqrt(vx * vx + vy * vy)

    if self.cursor_rotation_mode == "Directional" then
        if speed > 20 then
            local angle = math.atan2(vy, vx) * (180 / math.pi)
            local target = angle + self.cursor_angle_offset
            local diff = (target - self.current_rot + 180) % 360 - 180
            self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.05, 100000, dt)
        end
        return self.current_rot

    elseif self.cursor_rotation_mode == "Lean" then
        local lean = clamp(-40, 40, vx * 0.05 * self.cursor_tilt_strength) + self.cursor_angle_offset
        local diff = (lean - self.current_rot + 180) % 360 - 180
        self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.08, 100000, dt)
        return self.current_rot
    end

    -- "None" mode
    local diff = (self.cursor_angle_offset - self.current_rot + 180) % 360 - 180
    self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.15, 100000, dt)
    return self.current_rot
end

-- Update configuration
function CursorRenderer:update_config(settings)
    self.cursor_scale = obs.obs_data_get_double(settings, "cursor_scale")
    self.cursor_click_scale = obs.obs_data_get_double(settings, "cursor_click_scale")
    self.cursor_smooth_time = obs.obs_data_get_double(settings, "cursor_smooth_time")
    self.cursor_offset_x = obs.obs_data_get_int(settings, "cursor_offset_x")
    self.cursor_offset_y = obs.obs_data_get_int(settings, "cursor_offset_y")
    self.cursor_rotation_mode = obs.obs_data_get_string(settings, "cursor_rotation_mode") or "None"
    self.cursor_angle_offset = obs.obs_data_get_double(settings, "cursor_angle_offset")
    self.cursor_tilt_strength = obs.obs_data_get_double(settings, "cursor_tilt_strength")
end

-- Cleanup
function CursorRenderer:cleanup()
    if self.sceneitem then
        obs.obs_sceneitem_remove(self.sceneitem)
        self.sceneitem = nil
    end

    if self.source then
        local source_name = obs.obs_source_get_name(self.source)
        obs.obs_source_release(self.source)

        -- Remove from OBS source list
        local s = obs.obs_get_source_by_name(source_name)
        if s then
            obs.obs_source_remove(s)
            obs.obs_source_release(s)
        end
        self.source = nil
    end

    self.enabled = false
    self.initialized = false
end

-- Check if active
function CursorRenderer:is_active()
    return self.enabled and self.initialized
end

-- Global convenience functions
function cursor_renderer_init()
    return CursorRenderer:init()
end

function cursor_renderer_update(dt, raw_mouse, camera_crop)
    return CursorRenderer:update(dt, raw_mouse, camera_crop)
end

function cursor_renderer_update_config(settings)
    return CursorRenderer:update_config(settings)
end

function cursor_renderer_cleanup()
    return CursorRenderer:cleanup()
end

function cursor_renderer_is_active()
    return CursorRenderer:is_active()
end

--================================================
-- MODULE: Bookmark Manager (M17)
--================================================
-- Manages saved zoom positions (bookmarks)

local BookmarkManager = {
    -- Saved bookmarks: { name = { zoom_level, x, y, w, h, source } }
    bookmarks = {},

    -- Maximum bookmarks
    max_bookmarks = 20,

    -- Hotkey IDs
    hotkeys = {},
}

-- Save current zoom position as a bookmark
function BookmarkManager:save(name)
    if not name or name == "" then
        return false
    end

    -- Check limit
    local count = 0
    for _, _ in pairs(self.bookmarks) do count = count + 1 end

    if count >= self.max_bookmarks and not self.bookmarks[name] then
        log("Bookmark: Max bookmarks reached (" .. self.max_bookmarks .. ")")
        return false
    end

    -- Get current crop
    local crop = crop_filter_get_crop()
    if not crop then
        return false
    end

    -- Save bookmark
    self.bookmarks[name] = {
        zoom_level = SM.zoom_level,
        x = crop.x,
        y = crop.y,
        w = crop.w,
        h = crop.h,
        source = cfg.source_name,
    }

    log("Bookmark: Saved '" .. name .. "' (zoom=" .. string.format("%.2f", SM.zoom_level) .. ")")
    return true
end

-- Recall a bookmark
function BookmarkManager:recall(name)
    local bm = self.bookmarks[name]
    if not bm then
        log("Bookmark: Not found: " .. name)
        return false
    end

    if not SM:can_jump() then
        return false
    end

    if not source_manager_is_valid() then
        return false
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        return false
    end

    -- Get current crop as start
    local start_crop = crop_filter_get_crop() or { x = 0, y = 0, w = source_w, h = source_h }

    -- Set target
    local target_crop = {
        x = bm.x,
        y = bm.y,
        w = bm.w,
        h = bm.h,
    }

    -- Transition to bookmark
    SM:transition(ZoomState.JUMPING, {
        start_crop = start_crop,
        target_crop = target_crop,
        target_level = bm.zoom_level
    })

    start_timer()
    log("Bookmark: Recall '" .. name .. "'")
    return true
end

-- Delete a bookmark
function BookmarkManager:delete(name)
    if self.bookmarks[name] then
        self.bookmarks[name] = nil
        log("Bookmark: Deleted '" .. name .. "'")
        return true
    end
    return false
end

-- Rename a bookmark
function BookmarkManager:rename(old_name, new_name)
    if not self.bookmarks[old_name] then
        return false
    end

    if self.bookmarks[new_name] then
        return false
    end

    self.bookmarks[new_name] = self.bookmarks[old_name]
    self.bookmarks[old_name] = nil
    log("Bookmark: Renamed '" .. old_name .. "' to '" .. new_name .. "'")
    return true
end

-- Get all bookmark names
function BookmarkManager:get_names()
    local names = {}
    for k, _ in pairs(self.bookmarks) do
        table.insert(names, k)
    end
    table.sort(names)
    return names
end

-- Get bookmark info
function BookmarkManager:get(name)
    return self.bookmarks[name]
end

-- Persist bookmarks to settings
function BookmarkManager:persist(settings)
    local array = obs.obs_data_array_create()

    for name, bm in pairs(self.bookmarks) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "name", name)
        obs.obs_data_set_double(item, "zoom_level", bm.zoom_level)
        obs.obs_data_set_double(item, "x", bm.x)
        obs.obs_data_set_double(item, "y", bm.y)
        obs.obs_data_set_double(item, "w", bm.w)
        obs.obs_data_set_double(item, "h", bm.h)
        obs.obs_data_set_string(item, "source", bm.source or "")
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "zoom_bookmarks", array)
    obs.obs_data_array_release(array)
end

-- Load bookmarks from settings
function BookmarkManager:load(settings)
    self.bookmarks = {}

    local array = obs.obs_data_get_array(settings, "zoom_bookmarks")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local name = obs.obs_data_get_string(item, "name")

        if name and name ~= "" then
            self.bookmarks[name] = {
                zoom_level = obs.obs_data_get_double(item, "zoom_level"),
                x = obs.obs_data_get_double(item, "x"),
                y = obs.obs_data_get_double(item, "y"),
                w = obs.obs_data_get_double(item, "w"),
                h = obs.obs_data_get_double(item, "h"),
                source = obs.obs_data_get_string(item, "source"),
            }
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)

    local count = 0
    for _, _ in pairs(self.bookmarks) do count = count + 1 end
    log("Bookmark: Loaded " .. count .. " bookmarks")
end

-- Register bookmark hotkeys
function BookmarkManager:register_hotkeys(settings)
    for i = 1, 5 do
        self.hotkeys[i] = obs.obs_hotkey_register_frontend(
            "obs_zoom_pro.bookmark_" .. i,
            "Zoom to Bookmark " .. i,
            function(pressed)
                if not pressed then return end
                local names = self:get_names()
                if names[i] then
                    self:recall(names[i])
                end
            end
        )

        -- Load saved bindings
        local key = "obs_zoom_pro.hotkey.bookmark_" .. i
        local save_array = obs.obs_data_get_array(settings, key)
        if save_array then
            obs.obs_hotkey_load(self.hotkeys[i], save_array)
            obs.obs_data_array_release(save_array)
        end
    end
end

-- Save bookmark hotkeys
function BookmarkManager:save_hotkeys(settings)
    for i = 1, 5 do
        if self.hotkeys[i] then
            local save_array = obs.obs_hotkey_save(self.hotkeys[i])
            obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.bookmark_" .. i, save_array)
            obs.obs_data_array_release(save_array)
        end
    end
end

-- Global convenience functions
function bookmark_save(name)
    return BookmarkManager:save(name)
end

function bookmark_recall(name)
    return BookmarkManager:recall(name)
end

function bookmark_delete(name)
    return BookmarkManager:delete(name)
end

function bookmark_get_names()
    return BookmarkManager:get_names()
end

function bookmark_get(name)
    return BookmarkManager:get(name)
end

--================================================
-- MODULE: UDP API Server (M18)
--================================================
-- Provides external control via UDP for Stream Deck integration

local APIServer = {
    enabled = false,
    port = 12345,
    socket = nil,
}

-- Command handlers
local API_COMMANDS = {
    ZOOM_IN = function(args)
        local level = tonumber(args[1]) or cfg.zoom_value
        on_scroll_zoom_to(level)
        return "OK"
    end,

    ZOOM_OUT = function(args)
        if SM:is_zoomed() then
            on_toggle_zoom(true)
        end
        return "OK"
    end,

    ZOOM_SET = function(args)
        local level = tonumber(args[1])
        if not level then return "ERROR: Missing level" end
        on_scroll_zoom_to(level)
        return "OK"
    end,

    ZOOM_TOGGLE = function(args)
        on_toggle_zoom(true)
        return "OK"
    end,

    FOLLOW_ON = function(args)
        if SM:is_zoomed() then SM.following = true end
        return "OK"
    end,

    FOLLOW_OFF = function(args)
        SM.following = false
        return "OK"
    end,

    FOLLOW_TOGGLE = function(args)
        if SM:is_zoomed() then SM.following = not SM.following end
        return "OK"
    end,

    PRESET = function(args)
        local name = args[1]
        if not name then return "ERROR: Missing preset name" end
        local ok = preset_apply(name)
        return ok and "OK" or "ERROR: Unknown preset"
    end,

    BOOKMARK = function(args)
        local name = args[1]
        if not name then return "ERROR: Missing bookmark name" end
        local ok = bookmark_recall(name)
        return ok and "OK" or "ERROR: Bookmark not found"
    end,

    STATUS = function(args)
        local crop = crop_filter_get_crop()
        return string.format(
            '{"version":"%s","zoom_level":%.2f,"state":"%s","following":%s,"position":{"x":%.0f,"y":%.0f},"preset":"%s"}',
            VERSION,
            SM.zoom_level,
            SM.state,
            tostring(SM.following),
            crop and crop.x or 0,
            crop and crop.y or 0,
            cfg.zoom_preset or ""
        )
    end,

    HELP = function(args)
        return "Commands: ZOOM_IN [level], ZOOM_OUT, ZOOM_SET level, ZOOM_TOGGLE, FOLLOW_ON, FOLLOW_OFF, FOLLOW_TOGGLE, PRESET name, BOOKMARK name, STATUS"
    end,
}

-- Start the API server
function APIServer:start(port)
    self:stop()

    self.port = port or self.port

    -- Try to use luasocket if available
    local socket_ok, socket = pcall(require, "socket")
    if not socket_ok then
        log("API: Socket library not available")
        return false
    end

    -- Try UDP
    local udp, err = socket.udp()
    if not udp then
        log("API: Failed to create UDP socket: " .. tostring(err))
        return false
    end

    -- Set socket options
    udp:setoption("reuseaddr", true)
    udp:settimeout(0)  -- Non-blocking

    -- Bind to port
    local bind_ok, err = udp:setsockname("*", self.port)
    if not bind_ok then
        log("API: Failed to bind to port " .. self.port .. ": " .. tostring(err))
        udp:close()
        return false
    end

    self.socket = udp
    self.enabled = true

    -- Start polling timer
    obs.timer_add(function() self:poll() end, 50)  -- 20Hz polling

    log("API: Listening on port " .. self.port)
    return true
end

-- Stop the API server
function APIServer:stop()
    if self.socket then
        self.socket:close()
        self.socket = nil
    end
    self.enabled = false
    log("API: Stopped")
end

-- Poll for incoming commands
function APIServer:poll()
    if not self.enabled or not self.socket then
        return
    end

    repeat
        local data, err = self.socket:receivefrom()
        if data then
            local response = self:handle_command(data)
            if response then
                -- Note: UDP response requires sender address
                log("API: " .. data:gsub("%s+", " ") .. " Ã¢â€ â€™ " .. response)
            end
        elseif err ~= "timeout" then
            log("API: Error: " .. tostring(err))
        end
    until not data
end

-- Handle a command
function APIServer:handle_command(raw)
    -- Parse command
    local parts = {}
    for word in raw:gmatch("%S+") do
        table.insert(parts, word)
    end

    if #parts == 0 then
        return "ERROR: Empty command"
    end

    local cmd = parts[1]:upper()
    local args = {}
    for i = 2, #parts do
        table.insert(args, parts[i])
    end

    -- Look up handler
    local handler = API_COMMANDS[cmd]
    if handler then
        local ok, result = pcall(handler, args)
        if ok then
            return result
        else
            return "ERROR: " .. tostring(result)
        end
    end

    return "ERROR: Unknown command: " .. cmd
end

-- Check if enabled
function APIServer:is_enabled()
    return self.enabled
end

-- Global convenience functions
function api_start(port)
    return APIServer:start(port)
end

function api_stop()
    return APIServer:stop()
end

function api_is_enabled()
    return APIServer:is_enabled()
end

--================================================
-- OBS SCRIPT REGISTRATION
--================================================

--[[ Called when the script is loaded
--[[ @param data table Script data
function script_load(data)
    log("Script loaded - OBS Zoom Pro v" .. VERSION)

    -- Load custom presets
    PresetManager:load(data)

    -- Load scene memory
    SceneMemory:load(data)

    -- Load bookmarks
    BookmarkManager:load(data)

    -- Register hotkeys
    register_hotkeys(data)

    -- Register bookmark hotkeys
    BookmarkManager:register_hotkeys(data)

    -- Register frontend event handler
    obs.obs_frontend_add_event_callback(on_frontend_event)

    -- Start API server if enabled
    local api_enabled = obs.obs_data_get_bool(data, "api_enabled")
    if api_enabled then
        local api_port = obs.obs_data_get_int(data, "api_port")
        APIServer:start(api_port)
    end
end

--[[ Called when the script is unloaded
function script_unload()
    log("Script unloaded - OBS Zoom Pro")

    -- Stop timer and cleanup
    stop_timer()
    unregister_hotkeys()
    source_manager_release()

    -- Stop API server
    APIServer:stop()

    -- Remove frontend event handler
    obs.obs_frontend_remove_event_callback(on_frontend_event)
end

--[[ Called when settings are updated
--[[ @param data table Settings data
function script_update(data)
    log("Settings updated")

    -- Update legacy settings
    debug_logs = obs.obs_data_get_bool(data, "debug_logging") or false
    settings.debug_logging = debug_logs
    settings.easing_type = obs.obs_data_get_string(data, "easing_type") or defaults.easing_type
    settings.smooth_time = obs.obs_data_get_double(data, "smooth_time") or defaults.smooth_time
    settings.max_speed = obs.obs_data_get_double(data, "max_speed") or defaults.max_speed

    -- Update M09 configuration
    update_config(data)

    -- Update API server settings
    local api_enabled = obs.obs_data_get_bool(data, "api_enabled")
    local api_port = obs.obs_data_get_int(data, "api_port")

    if api_enabled and not APIServer:is_enabled() then
        APIServer:start(api_port)
    elseif not api_enabled and APIServer:is_enabled() then
        APIServer:stop()
    elseif APIServer:is_enabled() and APIServer.port ~= api_port then
        APIServer:start(api_port)
    end
end

--[[ Called to save settings
--[[ @param data table Settings data to save
function script_save(data)
    log("Settings saved")

    -- Save custom presets
    PresetManager:persist(data)

    -- Save scene memory
    SceneMemory:persist(data)

    -- Save bookmarks
    BookmarkManager:persist(data)

    -- Save hotkey bindings
    save_hotkeys(data)

    -- Save bookmark hotkeys
    BookmarkManager:save_hotkeys(data)
end

--[[ Called to create the properties UI
--[[ @return obs.obs_properties_t Properties object
function script_properties()
    local props = obs.obs_properties_create()

    --==========================
    -- QUICK SETUP (always expanded)
    --==========================
    local grp_quick = obs.obs_properties_create()

    -- Source dropdown
    local src_list = obs.obs_properties_add_list(grp_quick, "source", "Zoom Source",
        obs.OBS_COMBO_TYPE_LIST, obs.OBS_COMBO_FORMAT_STRING)
    obs.obs_property_list_add_string(src_list, "-- Select Source --", "")

    -- Populate with available capture sources
    local sources = source_manager_get_available_sources()
    for _, src in ipairs(sources) do
        obs.obs_property_list_add_string(src_list, src.name, src.name)
    end

    -- Zoom Factor
    obs.obs_properties_add_float_slider(grp_quick, "zoom_value", "Zoom Factor", 1.0, 10.0, 0.1)

    -- Duration
    obs.obs_properties_add_float_slider(grp_quick, "zoom_duration", "Duration (s)", 0.05, 3.0, 0.05)

    obs.obs_properties_add_group(props, "quick_setup", "Ã¢Å¡Â¡ Quick Setup", obs.OBS_GROUP_NORMAL, grp_quick)

    --==========================
    -- ANIMATION (collapsed)
    --==========================
    local grp_anim = obs.obs_properties_create()

    -- Overshoot/Bounce
    obs.obs_properties_add_float_slider(grp_anim, "zoom_overshoot", "Bounce", 0.0, 1.0, 0.01)

    -- Easing Curve
    local p_easing = obs.obs_properties_add_list(grp_anim, "zoom_easing", "Easing Curve",
        obs.OBS_COMBO_TYPE_LIST, obs.OBS_COMBO_FORMAT_STRING)
    for _, name in ipairs(Easing.NAMES) do
        obs.obs_property_list_add_string(p_easing, name, name)
    end

    obs.obs_properties_add_group(props, "animation", "Ã°Å¸Å½Â¬ Animation", obs.OBS_GROUP_NORMAL, grp_anim)

    --==========================
    -- MOUSE FOLLOW (collapsed)
    --==========================
    local grp_follow = obs.obs_properties_create()

    obs.obs_properties_add_bool(grp_follow, "auto_follow", "Auto-Follow Mouse")
    obs.obs_properties_add_float_slider(grp_follow, "follow_smooth_time", "Smoothness", 0.01, 1.0, 0.01)
    obs.obs_properties_add_int_slider(grp_follow, "follow_dead_zone", "Dead Zone (px)", 0, 500, 1)

    obs.obs_properties_add_group(props, "follow", "Ã°Å¸Å½Â¯ Mouse Follow", obs.OBS_GROUP_NORMAL, grp_follow)

    --==========================
    -- ADVANCED (collapsed)
    --==========================
    local grp_adv = obs.obs_properties_create()
    obs.obs_properties_add_float_slider(grp_adv, "scroll_step", "Scroll Zoom Step", 0.1, 1.0, 0.05)
    obs.obs_properties_add_bool(grp_adv, "debug_logs", "Debug Logging")
    obs.obs_properties_add_group(props, "advanced", "Ã¢Å¡â„¢Ã¯Â¸Â Advanced", obs.OBS_GROUP_NORMAL, grp_adv)

    --==========================
    -- API SERVER (collapsed)
    --==========================
    local grp_api = obs.obs_properties_create()
    obs.obs_properties_add_bool(grp_api, "api_enabled", "Enable UDP API Server")
    obs.obs_properties_add_int(grp_api, "api_port", "API Port", 1024, 65535, 1)
    obs.obs_properties_add_group(props, "api_server", "Ã°Å¸Å’Â UDP API Server", obs.OBS_GROUP_NORMAL, grp_api)

    --==========================
    -- HELP (collapsed)
    --==========================
    local grp_help = obs.obs_properties_create()
    obs.obs_properties_add_text(grp_help, "help_text",
        "QUICK START:\n" ..
        "1. Select your capture source above\n" ..
        "2. Set hotkeys in OBS Settings Ã¢â€ â€™ Hotkeys\n" ..
        "   Ã¢â‚¬Â¢ 'Toggle Zoom to Mouse' Ã¢â‚¬â€ Main zoom\n" ..
        "   Ã¢â‚¬Â¢ 'Toggle Mouse Follow' Ã¢â‚¬â€ Enable/disable follow\n" ..
        "3. Press the hotkey to zoom!\n\n" ..
        "TIPS:\n" ..
        "Ã¢â‚¬Â¢ Zoom centers on mouse position\n" ..
        "Ã¢â‚¬Â¢ Enable Auto-Follow for smooth tracking\n" ..
        "Ã¢â‚¬Â¢ Adjust Dead Zone to reduce jitter",
        obs.OBS_TEXT_INFO)
    obs.obs_properties_add_group(props, "help", "Ã¢Ââ€œ Help", obs.OBS_GROUP_NORMAL, grp_help)

    return props
end

--[[ Called to set default values
--[[ @param data table Settings data
function script_defaults(data)
    obs.obs_data_set_default_string(data, "source", "")
    obs.obs_data_set_default_double(data, "zoom_value", 2.0)
    obs.obs_data_set_default_double(data, "zoom_duration", 0.6)
    obs.obs_data_set_default_double(data, "zoom_overshoot", 0.0)
    obs.obs_data_set_default_string(data, "zoom_easing", "Cubic.Out")
    obs.obs_data_set_default_bool(data, "auto_follow", true)
    obs.obs_data_set_default_double(data, "follow_smooth_time", 0.15)
    obs.obs_data_set_default_int(data, "follow_dead_zone", 5)
    obs.obs_data_set_default_double(data, "scroll_step", 0.25)
    obs.obs_data_set_default_bool(data, "debug_logs", false)
    obs.obs_data_set_default_bool(data, "api_enabled", false)
    obs.obs_data_set_default_int(data, "api_port", 12345)
end

--================================================
-- SCRIPT METADATA
--================================================
script_info = {
    name = "OBS Zoom Pro",
    version = VERSION,
    description = "Intelligent camera zoom functionality with smooth transitions and easing curves.",
    author = "OBS Zoom Pro Team"
})
        handle:close()
        if uname == 'Darwin' then
            is_macos = true
        elseif uname == 'Linux' then
            is_linux = true
        end
    end

    return {
        WINDOWS = is_windows,
        LINUX = is_linux,
        MACOS = is_macos
    }
end

local platform = detect_platform()
local IS_WINDOWS = platform.WINDOWS
local IS_LINUX = platform.LINUX
local IS_MACOS = platform.MACOS

-- Log platform detection
local os_name = IS_WINDOWS and 'Windows' or (IS_LINUX and 'Linux' or (IS_MACOS and 'macOS' or 'Unknown'))
log("Platform detected: " .. os_name .. (IS_WINDOWS and " (Full support)" or " (Basic support)"))

-- Virtual key codes
local VK_LBUTTON = 0x01
local VK_RBUTTON = 0x02
local VK_MBUTTON = 0x04
local VK_CONTROL = 0x11
local VK_SHIFT = 0x10
local VK_MENU = 0x12  -- Alt

-- Cursor shape constants
local CURSOR_ARROW = 1
local CURSOR_IBEAM = 2
local CURSOR_HAND = 3
local CURSOR_WAIT = 4

-- Module state
local Platform = {
    cursor_shape_available = false,  -- Disabled (FFI not available)
    last_mouse = { x = 0, y = 0 },
    last_click = false,
}

-- Get mouse position (cross-platform - basic implementation)
function Platform.get_mouse_pos()
    -- Basic implementation - OBS doesn't provide mouse position API
    -- Return stored position or center of screen as fallback
    return Platform.last_mouse
end

-- Get mouse click state
function Platform.get_mouse_click()
    return Platform.last_click
end

-- Get key state (stub - not available without FFI)
function Platform.get_key_state(vk_code)
    return false
end

-- Get cursor shape (stub - not available without FFI)
function Platform.get_cursor_shape()
    return CURSOR_ARROW
end
        -- Linux: Use xdotool if available, fallback to X11
        local success, result = pcall(function()
            local handle = io.popen("xdotool getmouselocation 2>/dev/null || echo 'x:0 y:0'")
            if handle then
                local output = handle:read("*a")
                handle:close()
                local x, y = output:match("x:(%d+)%s+y:(%d+)")
                if x and y then
                    return { x = tonumber(x), y = tonumber(y) }
                end
            end
            return nil
        end)
        if success and result then
            return result
        end
    elseif IS_MACOS then
        -- macOS: Use osascript
        local success, result = pcall(function()
            local handle = io.popen(--[[osascript -e 'tell application "System Events" to get position of the mouse' 2>/dev/null || echo "0, 0"]])
            if handle then
                local output = handle:read("*a")
                handle:close()
                local x, y = output:match("(%d+),%s*(%d+)")
                if x and y then
                    return { x = tonumber(x), y = tonumber(y) }
                end
            end
            return nil
        end)
        if success and result then
            return result
        end
    end

    -- Fallback
    return { x = 0, y = 0 }
end

-- Check if left mouse button is clicked (Windows only, others return false)
function Platform.is_clicking()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x01) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if a modifier key is held (Windows only)
function Platform.is_key_held(vk_code)
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(vk_code) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if cursor is a pointer/hand (Windows only)
function Platform.is_cursor_pointer()
    if IS_WINDOWS then
        local success, result = pcall(function()
            local ci = ffi.new("CURSORINFO")
            ci.cbSize = ffi.sizeof("CURSORINFO")
            if ffi.C.GetCursorInfo(ci) ~= 0 then
                -- Check if hCursor is a hand pointer
                -- This is a simplified check; real implementation would compare cursor handles
                return ci.flags ~= 0  -- Simplified; actual implementation needs cursor handle comparison
            end
            return false
        end)
        return success and result or false
    end
    return false
end

-- Get cursor shape (Windows only, returns "arrow" for others)
function Platform.get_cursor_shape()
    if IS_WINDOWS then
        local success, result = pcall(function()
            local ci = ffi.new("CURSORINFO")
            ci.cbSize = ffi.sizeof("CURSORINFO")
            if ffi.C.GetCursorInfo(ci) ~= 0 and ci.hCursor ~= nil then
                local addr = tonumber(ffi.cast("uintptr_t", ci.hCursor))
                -- Common cursor IDs (these are typical values, may vary)
                -- IDC_ARROW = 32512, IDC_IBEAM = 32513, IDC_HAND = 32649
                -- We use address ranges as heuristic
                return "arrow"  -- Simplified; actual implementation would map handles
            end
            return "arrow"
        end)
        return success and result or "arrow"
    end
    return "arrow"
end

-- Check if Control key is held
function Platform.is_ctrl_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x11) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if Shift key is held
function Platform.is_shift_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x10) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if Alt key is held
function Platform.is_alt_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x12) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Convenience wrapper functions
function platform_get_mouse_pos()
    return Platform.get_mouse_pos()
end

function platform_is_clicking()
    return Platform.is_clicking()
end

function platform_is_cursor_pointer()
    return Platform.is_cursor_pointer()
end

function platform_cursor_shape_available()
    return Platform.cursor_shape_available
end

function platform_is_ctrl_held()
    return Platform.is_ctrl_held()
end

function platform_is_shift_held()
    return Platform.is_shift_held()
end

function platform_is_alt_held()
    return Platform.is_alt_held()
end

--================================================
-- MODULE: State Machine (M05)
--================================================
-- Manages zoom states and transitions
-- States: IDLE, ZOOMING_IN, ZOOMED_IN, ZOOMING_OUT, SCROLLING, JUMPING

local ZoomState = {
    IDLE         = "idle",
    ZOOMING_IN   = "zooming_in",
    ZOOMED_IN    = "zoomed_in",
    ZOOMING_OUT  = "zooming_out",
    SCROLLING    = "scrolling",    -- Scroll wheel mid-transition
    JUMPING      = "jumping",      -- Bookmark transition
}

local StateMachine = {
    state = ZoomState.IDLE,
    zoom_time = 0,          -- Animation progress (0 Ã¢â€ â€™ 1)
    zoom_level = 1.0,       -- Current zoom factor
    target_level = 1.0,     -- Target zoom factor
    start_crop = nil,       -- Crop at animation start {x, y, w, h}
    target_crop = nil,      -- Crop at animation end {x, y, w, h}
    following = false,      -- Mouse follow active

    -- Transition guards
    can_zoom_in = function(self)
        return self.state == ZoomState.IDLE
    end,

    can_zoom_out = function(self)
        return self.state == ZoomState.ZOOMED_IN
            or self.state == ZoomState.SCROLLING
    end,

    can_scroll = function(self)
        return self.state == ZoomState.ZOOMED_IN
            or self.state == ZoomState.IDLE
            or self.state == ZoomState.SCROLLING
    end,

    can_jump = function(self)
        return self.state ~= ZoomState.ZOOMING_IN
           and self.state ~= ZoomState.ZOOMING_OUT
           and self.state ~= ZoomState.JUMPING
    end,

    is_animating = function(self)
        return self.state == ZoomState.ZOOMING_IN
            or self.state == ZoomState.ZOOMING_OUT
            or self.state == ZoomState.SCROLLING
            or self.state == ZoomState.JUMPING
    end,

    is_zoomed = function(self)
        return self.state ~= ZoomState.IDLE
    end,
}

-- Transition to a new state
function StateMachine:transition(new_state, params)
    local old = self.state
    self.state = new_state
    self.zoom_time = 0

    if params then
        if params.start_crop then self.start_crop = params.start_crop end
        if params.target_crop then self.target_crop = params.target_crop end
        if params.target_level then self.target_level = params.target_level end
    end

    log("State: " .. old .. " Ã¢â€ â€™ " .. new_state)
end

-- Complete the current animation
function StateMachine:complete()
    if self.state == ZoomState.ZOOMING_IN
       or self.state == ZoomState.SCROLLING
       or self.state == ZoomState.JUMPING then
        self.zoom_level = self.target_level
        self.state = ZoomState.ZOOMED_IN
        self.zoom_time = 0
        log("State: " .. self.state .. " Ã¢â€ â€™ ZOOMED_IN (complete)")
    elseif self.state == ZoomState.ZOOMING_OUT then
        self.zoom_level = 1.0
        self.target_level = 1.0
        self.start_crop = nil
        self.target_crop = nil
        self.following = false
        self.state = ZoomState.IDLE
        self.zoom_time = 0
        log("State: ZOOMING_OUT Ã¢â€ â€™ IDLE (complete)")
    end
end

-- Reset to initial state
function StateMachine:reset()
    self.state = ZoomState.IDLE
    self.zoom_time = 0
    self.zoom_level = 1.0
    self.target_level = 1.0
    self.start_crop = nil
    self.target_crop = nil
    self.following = false
    log("StateMachine: Reset to IDLE")
end

-- Get current animation progress (0-1)
function StateMachine:get_progress()
    return clamp(0, 1, self.zoom_time)
end

-- Check if in a specific state
function StateMachine:is_state(state)
    return self.state == state
end

-- Get state name for display
function StateMachine:get_state_name()
    return self.state
end

-- Create a new state machine instance (for testing/isolation)
function StateMachine:new()
    local sm = {}
    setmetatable(sm, { __index = self })
    sm.state = ZoomState.IDLE
    sm.zoom_time = 0
    sm.zoom_level = 1.0
    sm.target_level = 1.0
    sm.start_crop = nil
    sm.target_crop = nil
    sm.following = false
    return sm
end

-- Global state machine instance
local SM = StateMachine:new()

--================================================
-- MODULE: Crop Filter Manager (M07)
--================================================
-- Manages the crop/pad filter used to simulate zoom
-- Creates, updates, and destroys the filter automatically

local FILTER_PREFIX = "[ZoomPro] "
local CROP_FILTER_NAME = FILTER_PREFIX .. "Crop"

local CropFilterManager = {
    filter = nil,           -- The crop filter source
    source = nil,           -- The parent source
    original_crop = nil,    -- Original crop values for restoration
    current_crop = { x = 0, y = 0, w = 0, h = 0 },
    initialized = false,
}

-- Create the crop filter on a source
function CropFilterManager:create(source)
    if not source then
        log("CropFilter: No source provided")
        return false
    end

    self:cleanup()  -- Clean up any existing filter
    self.source = source

    -- Check if our filter already exists
    local existing = obs.obs_source_get_filter_by_name(source, CROP_FILTER_NAME)
    if existing then
        log("CropFilter: Found existing filter")
        self.filter = existing
        self.initialized = true
        return true
    end

    -- Create new crop/pad filter
    local settings = obs.obs_data_create()
    obs.obs_data_set_int(settings, "left", 0)
    obs.obs_data_set_int(settings, "top", 0)
    obs.obs_data_set_int(settings, "right", 0)
    obs.obs_data_set_int(settings, "bottom", 0)
    obs.obs_data_set_bool(settings, "relative", false)  -- Absolute positioning

    self.filter = obs.obs_source_create_private(
        "crop_filter",      -- Filter type
        CROP_FILTER_NAME,   -- Filter name
        settings            -- Settings
    )

    obs.obs_data_release(settings)

    if not self.filter then
        log("CropFilter: Failed to create filter")
        return false
    end

    -- Add filter to source
    obs.obs_source_filter_add(source, self.filter)

    -- Store original crop (none)
    self.original_crop = { x = 0, y = 0, w = 0, h = 0 }

    self.initialized = true
    log("CropFilter: Created successfully")
    return true
end

-- Update the crop filter with new values
function CropFilterManager:update(x, y, w, h)
    if not self.filter or not self.initialized then
        return false
    end

    -- Store current crop
    self.current_crop = { x = x, y = y, w = w, h = h }

    -- Get filter settings
    local settings = obs.obs_source_get_settings(self.filter)
    if not settings then
        return false
    end

    -- Calculate crop values
    -- For crop_filter: left, top are absolute position
    -- right, bottom are width/height from right/bottom edge
    -- We need to convert our x, y, w, h to this format

    -- Get source dimensions
    local source_w = obs.obs_source_get_width(self.source)
    local source_h = obs.obs_source_get_height(self.source)

    if source_w == 0 or source_h == 0 then
        obs.obs_data_release(settings)
        return false
    end

    -- Set crop values
    -- left = x offset from left
    -- top = y offset from top
    -- right = source_w - (x + w) = remaining width on right
    -- bottom = source_h - (y + h) = remaining height on bottom
    local left = math.floor(x)
    local top = math.floor(y)
    local right = math.floor(source_w - (x + w))
    local bottom = math.floor(source_h - (y + h))

    -- Clamp to valid values
    left = math.max(0, left)
    top = math.max(0, top)
    right = math.max(0, right)
    bottom = math.max(0, bottom)

    obs.obs_data_set_int(settings, "left", left)
    obs.obs_data_set_int(settings, "top", top)
    obs.obs_data_set_int(settings, "right", right)
    obs.obs_data_set_int(settings, "bottom", bottom)

    -- Update the filter
    obs.obs_source_update(self.filter, settings)
    obs.obs_data_release(settings)

    return true
end

-- Get current crop values
function CropFilterManager:get_crop()
    return self.current_crop
end

-- Reset crop to original (no crop)
function CropFilterManager:reset()
    if not self.filter or not self.initialized then
        return false
    end

    local settings = obs.obs_source_get_settings(self.filter)
    if settings then
        obs.obs_data_set_int(settings, "left", 0)
        obs.obs_data_set_int(settings, "top", 0)
        obs.obs_data_set_int(settings, "right", 0)
        obs.obs_data_set_int(settings, "bottom", 0)
        obs.obs_source_update(self.filter, settings)
        obs.obs_data_release(settings)
    end

    self.current_crop = { x = 0, y = 0, w = 0, h = 0 }
    return true
end

-- Remove the filter and restore original state
function CropFilterManager:cleanup()
    if self.filter and self.source then
        -- Reset to no crop first
        self:reset()

        -- Remove filter from source
        obs.obs_source_filter_remove(self.source, self.filter)
        obs.obs_source_release(self.filter)
        self.filter = nil
        log("CropFilter: Removed from source")
    end

    self.source = nil
    self.original_crop = nil
    self.current_crop = { x = 0, y = 0, w = 0, h = 0 }
    self.initialized = false
end

-- Check if filter is ready
function CropFilterManager:is_ready()
    return self.initialized and self.filter ~= nil
end

-- Get source dimensions
function CropFilterManager:get_source_size()
    if not self.source then
        return 0, 0
    end
    return obs.obs_source_get_width(self.source), obs.obs_source_get_height(self.source)
end

-- Convenience wrapper functions
function crop_filter_create(source)
    return CropFilterManager:create(source)
end

function crop_filter_update(x, y, w, h)
    return CropFilterManager:update(x, y, w, h)
end

function crop_filter_reset()
    return CropFilterManager:reset()
end

function crop_filter_cleanup()
    return CropFilterManager:cleanup()
end

function crop_filter_is_ready()
    return CropFilterManager:is_ready()
end

function crop_filter_get_crop()
    return CropFilterManager:get_crop()
end

function crop_filter_get_source_size()
    return CropFilterManager:get_source_size()
end

--================================================
-- MODULE: Source Manager (M08)
--================================================
-- Handles finding sources in scenes, capturing transforms,
-- and managing source state for zoom operations

local SourceManager = {
    source = nil,           -- Current zoom source
    sceneitem = nil,        -- Scene item reference
    scene = nil,            -- Current scene
    original_transform = nil, -- Saved original transform
    source_name = "",       -- Source name for settings
    initialized = false,
}

-- Transform data structure
local TransformData = {
    pos = { x = 0, y = 0 },
    scale = { x = 1.0, y = 1.0 },
    rot = 0,
    bounds_type = 0,
    bounds = { x = 0, y = 0 },
    crop = { left = 0, top = 0, right = 0, bottom = 0 },
}

-- Find a source in a scene (BFS through groups)
function SourceManager:find_sceneitem(scene, source_name)
    if not scene or not source_name then
        return nil
    end

    local scene_source = obs.obs_scene_from_source(scene)
    if not scene_source then
        return nil
    end

    -- BFS queue
    local queue = {}
    table.insert(queue, scene_source)

    while #queue > 0 do
        local current_scene = table.remove(queue, 1)

        -- Iterate through items
        local items = obs.obs_scene_enum_items(current_scene)
        if items then
            for _, item in ipairs(items) do
                local item_source = obs.obs_sceneitem_get_source(item)
                if item_source then
                    local name = obs.obs_source_get_name(item_source)

                    -- Check if this is our target
                    if name == source_name then
                        obs.sceneitem_list_release(items)
                        return item
                    end

                    -- Check if this is a group (nested scene)
                    if obs.obs_source_get_type(item_source) == obs.OBS_SOURCE_TYPE_INPUT then
                        local id = obs.obs_source_get_id(item_source)
                        if id == "group" then
                            local group_scene = obs.obs_group_from_source(item_source)
                            if group_scene then
                                table.insert(queue, group_scene)
                            end
                        end
                    end
                end
            end
            obs.sceneitem_list_release(items)
        end
    end

    return nil
end

-- Capture the current transform of a scene item
function SourceManager:capture_transform(sceneitem)
    if not sceneitem then
        return nil
    end

    local transform = {}

    -- Position
    local pos = obs.vec2()
    obs.obs_sceneitem_get_pos(sceneitem, pos)
    transform.pos = { x = pos.x, y = pos.y }

    -- Scale
    local scale = obs.vec2()
    obs.obs_sceneitem_get_scale(sceneitem, scale)
    transform.scale = { x = scale.x, y = scale.y }

    -- Rotation
    transform.rot = obs.obs_sceneitem_get_rot(sceneitem)

    -- Bounds
    transform.bounds_type = obs.obs_sceneitem_get_bounds_type(sceneitem)
    local bounds = obs.vec2()
    obs.obs_sceneitem_get_bounds(sceneitem, bounds)
    transform.bounds = { x = bounds.x, y = bounds.y }

    -- Crop
    local crop = obs.obs_sceneitem_crop()
    obs.obs_sceneitem_get_crop(sceneitem, crop)
    transform.crop = {
        left = crop.left,
        top = crop.top,
        right = crop.right,
        bottom = crop.bottom
    }

    return transform
end

-- Restore a saved transform to a scene item
function SourceManager:restore_transform(sceneitem, transform)
    if not sceneitem or not transform then
        return false
    end

    -- Position
    local pos = obs.vec2()
    pos.x = transform.pos.x
    pos.y = transform.pos.y
    obs.obs_sceneitem_set_pos(sceneitem, pos)

    -- Scale
    local scale = obs.vec2()
    scale.x = transform.scale.x
    scale.y = transform.scale.y
    obs.obs_sceneitem_set_scale(sceneitem, scale)

    -- Rotation
    obs.obs_sceneitem_set_rot(sceneitem, transform.rot)

    -- Bounds
    obs.obs_sceneitem_set_bounds_type(sceneitem, transform.bounds_type)
    local bounds = obs.vec2()
    bounds.x = transform.bounds.x
    bounds.y = transform.bounds.y
    obs.obs_sceneitem_set_bounds(sceneitem, bounds)

    -- Crop
    local crop = obs.obs_sceneitem_crop()
    crop.left = transform.crop.left
    crop.top = transform.crop.top
    crop.right = transform.crop.right
    crop.bottom = transform.crop.bottom
    obs.obs_sceneitem_set_crop(sceneitem, crop)

    return true
end

-- Initialize with a source name
function SourceManager:init(source_name)
    self:release()  -- Clean up any existing state

    if not source_name or source_name == "" then
        log("SourceManager: No source name provided")
        return false
    end

    self.source_name = source_name

    -- Get current scene
    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then
        log("SourceManager: No current scene")
        return false
    end

    self.scene = scene_source

    -- Find the scene item
    self.sceneitem = self:find_sceneitem(scene_source, source_name)
    if not self.sceneitem then
        log("SourceManager: Source not found in scene: " .. source_name)
        obs.obs_source_release(scene_source)
        return false
    end

    -- Get the source
    self.source = obs.obs_sceneitem_get_source(self.sceneitem)
    if not self.source then
        log("SourceManager: Failed to get source from sceneitem")
        obs.obs_source_release(scene_source)
        return false
    end

    -- Capture original transform
    self.original_transform = self:capture_transform(self.sceneitem)

    -- Create crop filter
    if not crop_filter_create(self.source) then
        log("SourceManager: Failed to create crop filter")
        obs.obs_source_release(scene_source)
        return false
    end

    self.initialized = true
    log("SourceManager: Initialized with source: " .. source_name)

    obs.obs_source_release(scene_source)
    return true
end

-- Release all resources
function SourceManager:release()
    -- Clean up crop filter
    crop_filter_cleanup()

    -- Restore original transform if we have it
    if self.sceneitem and self.original_transform then
        self:restore_transform(self.sceneitem, self.original_transform)
        log("SourceManager: Restored original transform")
    end

    self.source = nil
    self.sceneitem = nil
    self.scene = nil
    self.original_transform = nil
    self.initialized = false

    log("SourceManager: Released")
end

-- Get source dimensions
function SourceManager:get_source_size()
    if not self.source then
        return 0, 0
    end
    return obs.obs_source_get_width(self.source), obs.obs_source_get_height(self.source)
end

-- Check if source is valid
function SourceManager:is_valid()
    return self.initialized and self.source ~= nil and self.sceneitem ~= nil
end

-- Get source info
function SourceManager:get_info()
    if not self:is_valid() then
        return nil
    end

    return {
        name = self.source_name,
        width = obs.obs_source_get_width(self.source),
        height = obs.obs_source_get_height(self.source),
    }
end

-- Get list of available capture sources
function SourceManager.get_available_sources()
    local sources = {}

    -- Get all sources
    local source_list = obs.obs_enum_sources()
    if source_list then
        for _, source in ipairs(source_list) do
            local source_id = obs.obs_source_get_id(source)
            local name = obs.obs_source_get_name(source)

            -- Filter for capture sources
            local is_capture = false
            if source_id == "monitor_capture" or      -- Display capture
               source_id == "window_capture" or       -- Window capture
               source_id == "game_capture" or         -- Game capture
               source_id == "xshm_input" or           -- Linux X11 capture
               source_id == "av_capture_input" then   -- macOS capture
                is_capture = true
            end

            if is_capture then
                table.insert(sources, {
                    name = name,
                    id = source_id,
                })
            end
        end
        obs.source_list_release(source_list)
    end

    return sources
end

-- Convenience wrapper functions
function source_manager_init(source_name)
    return SourceManager:init(source_name)
end

function source_manager_release()
    return SourceManager:release()
end

function source_manager_is_valid()
    return SourceManager:is_valid()
end

function source_manager_get_source()
    return SourceManager.source
end

function source_manager_get_sceneitem()
    return SourceManager.sceneitem
end

function source_manager_get_size()
    return SourceManager:get_source_size()
end

function source_manager_get_available_sources()
    return SourceManager.get_available_sources()
end

--================================================
-- MODULE: Camera Physics (M06)
--================================================
-- Handles camera position calculations, dead zones,
-- and SmoothDamp-based camera movement

local CameraPhysics = {
    -- Smoothed camera position
    pos = { x = 0, y = 0 },

    -- Velocities for SmoothDamp
    vel_x = { val = 0 },
    vel_y = { val = 0 },

    -- Dead zone state
    tracked_pos = { x = 0, y = 0 },
    dead_zone_active = false,

    -- Last camera position (for velocity calculation)
    last_pos = { x = 0, y = 0 },

    -- Monitor offset (for multi-monitor setups)
    monitor_offset = { x = 0, y = 0 },
}

-- Initialize camera tracking with starting position
function CameraPhysics:init(mouse_pos)
    if mouse_pos then
        self.pos.x = mouse_pos.x
        self.pos.y = mouse_pos.y
        self.tracked_pos.x = mouse_pos.x
        self.tracked_pos.y = mouse_pos.y
    end
    self.vel_x.val = 0
    self.vel_y.val = 0
    self.last_pos.x = self.pos.x
    self.last_pos.y = self.pos.y
end

-- Apply dead zone to mouse input
-- Returns the position the camera should track
function CameraPhysics:apply_dead_zone(mouse_pos, dead_zone_radius)
    if not mouse_pos then
        return self.tracked_pos
    end

    if dead_zone_radius <= 0 then
        self.tracked_pos.x = mouse_pos.x
        self.tracked_pos.y = mouse_pos.y
        return self.tracked_pos
    end

    -- Calculate distance from tracked position to mouse
    local dx = mouse_pos.x - self.tracked_pos.x
    local dy = mouse_pos.y - self.tracked_pos.y
    local dist = math.sqrt(dx * dx + dy * dy)

    if dist <= dead_zone_radius then
        -- Mouse is within dead zone, don't move tracked position
        self.dead_zone_active = true
        return self.tracked_pos
    end

    -- Mouse is outside dead zone
    -- Move tracked position so it stays exactly dead_zone_radius from mouse
    self.dead_zone_active = false
    local excess = dist - dead_zone_radius
    local nx = dx / dist  -- Normalized direction
    local ny = dy / dist

    self.tracked_pos.x = self.tracked_pos.x + nx * excess
    self.tracked_pos.y = self.tracked_pos.y + ny * excess

    return self.tracked_pos
end

-- Smooth the input position using SmoothDamp
function CameraPhysics:smooth_input(target_pos, smooth_time, dt)
    if not target_pos then
        return self.pos
    end

    local max_speed = 100000  -- Very high max speed for smooth camera

    self.pos.x = SmoothDamp(self.pos.x, target_pos.x, self.vel_x, smooth_time, max_speed, dt)
    self.pos.y = SmoothDamp(self.pos.y, target_pos.y, self.vel_y, smooth_time, max_speed, dt)

    return self.pos
end

-- Calculate the crop rectangle for a given zoom level and center position
function CameraPhysics:compute_crop(center_x, center_y, zoom_level, source_w, source_h)
    if zoom_level <= 1.0 then
        -- No zoom, return full source
        return {
            x = 0,
            y = 0,
            w = source_w,
            h = source_h,
        }
    end

    -- Calculate crop dimensions
    local crop_w = source_w / zoom_level
    local crop_h = source_h / zoom_level

    -- Center the crop on the target position
    local crop_x = center_x - crop_w / 2
    local crop_y = center_y - crop_h / 2

    -- Clamp to source bounds
    crop_x = clamp(0, source_w - crop_w, crop_x)
    crop_y = clamp(0, source_h - crop_h, crop_y)

    return {
        x = crop_x,
        y = crop_y,
        w = crop_w,
        h = crop_h,
    }
end

-- Calculate target crop for zoom animation
-- mouse_pos: current mouse position
-- zoom_level: target zoom level
-- source_w, source_h: source dimensions
-- monitor_offset: offset for multi-monitor (optional)
function CameraPhysics:get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
    if not mouse_pos then
        return nil
    end

    -- Apply monitor offset if provided
    local target_x = mouse_pos.x
    local target_y = mouse_pos.y

    if monitor_offset then
        target_x = target_x - monitor_offset.x
        target_y = target_y - monitor_offset.y
    end

    -- Clamp to source bounds
    target_x = clamp(0, source_w, target_x)
    target_y = clamp(0, source_h, target_y)

    return self:compute_crop(target_x, target_y, zoom_level, source_w, source_h)
end

-- Interpolate between two crop rectangles
function CameraPhysics:lerp_crop(start_crop, end_crop, t, easing_fn)
    if not start_crop or not end_crop then
        return nil
    end

    t = clamp(0, 1, t)

    -- Apply easing
    local eased_t = easing_fn and easing_fn(t) or t

    return {
        x = lerp(start_crop.x, end_crop.x, eased_t),
        y = lerp(start_crop.y, end_crop.y, eased_t),
        w = lerp(start_crop.w, end_crop.w, eased_t),
        h = lerp(start_crop.h, end_crop.h, eased_t),
    }
end

-- Get camera velocity (for motion blur)
function CameraPhysics:get_velocity()
    return {
        x = self.pos.x - self.last_pos.x,
        y = self.pos.y - self.last_pos.y,
    }
end

-- Update last position (call at end of frame)
function CameraPhysics:update_last_pos()
    self.last_pos.x = self.pos.x
    self.last_pos.y = self.pos.y
end

-- Set monitor offset
function CameraPhysics:set_monitor_offset(offset)
    self.monitor_offset = offset or { x = 0, y = 0 }
end

-- Reset camera state
function CameraPhysics:reset()
    self.pos = { x = 0, y = 0 }
    self.vel_x = { val = 0 }
    self.vel_y = { val = 0 }
    self.tracked_pos = { x = 0, y = 0 }
    self.dead_zone_active = false
    self.last_pos = { x = 0, y = 0 }
end

-- Convenience wrapper functions
function camera_physics_init(mouse_pos)
    return CameraPhysics:init(mouse_pos)
end

function camera_physics_apply_dead_zone(mouse_pos, dead_zone_radius)
    return CameraPhysics:apply_dead_zone(mouse_pos, dead_zone_radius)
end

function camera_physics_smooth_input(target_pos, smooth_time, dt)
    return CameraPhysics:smooth_input(target_pos, smooth_time, dt)
end

function camera_physics_compute_crop(center_x, center_y, zoom_level, source_w, source_h)
    return CameraPhysics:compute_crop(center_x, center_y, zoom_level, source_w, source_h)
end

function camera_physics_get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
    return CameraPhysics:get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
end

function camera_physics_lerp_crop(start_crop, end_crop, t, easing_fn)
    return CameraPhysics:lerp_crop(start_crop, end_crop, t, easing_fn)
end

function camera_physics_get_velocity()
    return CameraPhysics:get_velocity()
end

function camera_physics_update_last_pos()
    return CameraPhysics:update_last_pos()
end

function camera_physics_reset()
    return CameraPhysics:reset()
end

--================================================
-- MODULE: Timer & Main Loop (M09)
--================================================
-- Core integration module that handles frame-by-frame updates,
-- input processing, state machine updates, and output

-- Configuration (will be populated from settings)
local cfg = {
    source_name = "",
    zoom_value = 2.0,
    max_zoom = 10.0,
    zoom_duration = 0.6,
    zoom_overshoot = 0.0,
    zoom_easing = "Cubic.Out",

    auto_follow = true,
    follow_smooth_time = 0.15,
    follow_dead_zone = 5,

    debug_logs = false,
}

-- Timing
local last_tick_time = 0
local timer_running = false

-- Frame diff tracking (skip updates if nothing changed)
local last_output = { x = -1, y = -1, w = -1, h = -1 }

-- Original crop for zoom out
local original_crop = { x = 0, y = 0, w = 0, h = 0 }

-- Hotkey IDs
local hotkey_toggle_zoom = nil
local hotkey_toggle_follow = nil

-- Get reliable delta time
local function get_dt()
    local now = os.clock()
    local dt = now - last_tick_time
    last_tick_time = now
    return clamp(0.001, 0.1, dt)  -- Guard against freezes and div/zero
end

-- Start the timer
local function start_timer()
    if not timer_running then
        timer_running = true
        last_tick_time = os.clock()
        -- Use frame-synced interval
        local interval = 16  -- Default to ~60fps
        obs.timer_add(on_timer, interval)
        log("Timer: Started")
    end
end

-- Stop the timer
local function stop_timer()
    if timer_running then
        timer_running = false
        obs.timer_remove(on_timer)
        log("Timer: Stopped")
    end
end

-- Initialize mouse tracking
local function init_mouse_tracking(mouse_pos)
    camera_physics_init(mouse_pos)
    original_crop = {
        x = 0,
        y = 0,
        w = 0,
        h = 0,
    }
end

-- Main timer callback
function on_timer()
    local dt = get_dt()

    -- Guard: No valid source
    if not source_manager_is_valid() then
        return
    end

    --==========================
    -- 1. INPUT
    --==========================
    local raw_mouse = platform_get_mouse_pos()

    --==========================
    -- 2. STATE MACHINE UPDATE
    --==========================
    if SM:is_animating() then
        SM.zoom_time = SM.zoom_time + (dt / cfg.zoom_duration)

        -- Check for completion
        if SM.zoom_time >= 1.0 then
            SM:complete()

            -- Auto-enable follow after zoom in
            if SM.state == ZoomState.ZOOMED_IN and cfg.auto_follow then
                SM.following = true
            end

            -- Stop timer if idle
            if SM.state == ZoomState.IDLE then
                stop_timer()
            end
        end
    end

    --==========================
    -- 3. CAMERA POSITION
    --==========================
    local crop = nil
    local source_w, source_h = source_manager_get_size()

    if source_w == 0 or source_h == 0 then
        return
    end

    if SM:is_animating() then
        -- Animate between start and target crop
        local easing_fn = Easing.get(cfg.zoom_easing, cfg.zoom_overshoot)
        crop = camera_physics_lerp_crop(SM.start_crop, SM.target_crop, SM.zoom_time, easing_fn)
    elseif SM:is_zoomed() and SM.following then
        -- Follow mouse with dead zone and smoothing
        local tracked = camera_physics_apply_dead_zone(raw_mouse, cfg.follow_dead_zone)
        local smoothed = camera_physics_smooth_input(tracked, cfg.follow_smooth_time, dt)
        crop = camera_physics_compute_crop(smoothed.x, smoothed.y, SM.zoom_level, source_w, source_h)
        camera_physics_update_last_pos()
    elseif SM:is_zoomed() then
        -- Static zoom (not following)
        crop = camera_physics_get_target_crop(
            { x = SM.target_crop.x + SM.target_crop.w / 2, y = SM.target_crop.y + SM.target_crop.h / 2 },
            SM.zoom_level, source_w, source_h, nil
        )
    end

    --==========================
    -- 4. OUTPUT (Diff-based)
    --==========================
    if crop then
        local cx = math.floor(crop.x)
        local cy = math.floor(crop.y)
        local cw = math.floor(crop.w)
        local ch = math.floor(crop.h)

        if cx ~= last_output.x or cy ~= last_output.y or
           cw ~= last_output.w or ch ~= last_output.h then
            crop_filter_update(cx, cy, cw, ch)
            last_output.x = cx
            last_output.y = cy
            last_output.w = cw
            last_output.h = ch
        end
    end
end

--==========================
-- HOTKEY HANDLERS
--==========================

function on_toggle_zoom(pressed)
    if not pressed then return end

    if not source_manager_is_valid() then
        log("Toggle Zoom: No valid source")
        return
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        log("Toggle Zoom: Invalid source dimensions")
        return
    end

    if SM.state == ZoomState.IDLE then
        -- ZOOM IN
        local mouse = platform_get_mouse_pos()
        init_mouse_tracking(mouse)

        -- Store original crop
        original_crop = { x = 0, y = 0, w = source_w, h = source_h }

        -- Calculate target crop
        local target_crop = camera_physics_get_target_crop(mouse, cfg.zoom_value, source_w, source_h, nil)

        SM:transition(ZoomState.ZOOMING_IN, {
            start_crop = original_crop,
            target_crop = target_crop,
            target_level = cfg.zoom_value
        })

        start_timer()

    elseif SM.state == ZoomState.ZOOMED_IN then
        -- ZOOM OUT
        SM.following = false

        local current = crop_filter_get_crop()
        SM:transition(ZoomState.ZOOMING_OUT, {
            start_crop = current,
            target_crop = original_crop,
            target_level = 1.0
        })

        start_timer()
    end
    -- Ignore if already animating (guard against rapid presses)
end

function on_toggle_follow(pressed)
    if not pressed then return end
    if not SM:is_zoomed() then return end

    SM.following = not SM.following
    log("Follow: " .. tostring(SM.following))

    if SM.following and not timer_running then
        start_timer()
    end
end

--==========================
-- HOTKEY REGISTRATION
--==========================

local function register_hotkeys(settings)
    -- Toggle Zoom hotkey
    hotkey_toggle_zoom = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.toggle_zoom",
        "Toggle Zoom to Mouse",
        on_toggle_zoom
    )

    -- Toggle Follow hotkey
    hotkey_toggle_follow = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.toggle_follow",
        "Toggle Mouse Follow",
        on_toggle_follow
    )

    -- Load saved hotkey bindings
    local toggle_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.toggle_zoom")
    if toggle_array then
        obs.obs_hotkey_load(hotkey_toggle_zoom, toggle_array)
        obs.obs_data_array_release(toggle_array)
    end

    local follow_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.toggle_follow")
    if follow_array then
        obs.obs_hotkey_load(hotkey_toggle_follow, follow_array)
        obs.obs_data_array_release(follow_array)
    end

    -- Register scroll zoom hotkeys
    register_scroll_hotkeys(settings)

    log("Hotkeys: Registered")
end

local function save_hotkeys(settings)
    if hotkey_toggle_zoom then
        local array = obs.obs_hotkey_save(hotkey_toggle_zoom)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.toggle_zoom", array)
        obs.obs_data_array_release(array)
    end

    if hotkey_toggle_follow then
        local array = obs.obs_hotkey_save(hotkey_toggle_follow)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.toggle_follow", array)
        obs.obs_data_array_release(array)
    end

    -- Save scroll zoom hotkeys
    save_scroll_hotkeys(settings)
end

local function unregister_hotkeys()
    if hotkey_toggle_zoom then
        obs.obs_hotkey_unregister(hotkey_toggle_zoom)
        hotkey_toggle_zoom = nil
    end
    if hotkey_toggle_follow then
        obs.obs_hotkey_unregister(hotkey_toggle_follow)
        hotkey_toggle_follow = nil
    end
    -- Unregister scroll zoom hotkeys
    unregister_scroll_hotkeys()
    log("Hotkeys: Unregistered")
end

--==========================
-- SCENE EVENT HANDLERS
--==========================

function on_frontend_event(event)
    if event == obs.OBS_FRONTEND_EVENT_SCENE_CHANGED then
        -- Scene changed, re-acquire source
        log("Event: Scene changed")

        -- Handle scene memory
        scene_memory_on_scene_change()

        if cfg.source_name and cfg.source_name ~= "" then
            source_manager_release()
            source_manager_init(cfg.source_name)
        end
    elseif event == obs.OBS_FRONTEND_EVENT_EXIT then
        -- OBS is closing
        log("Event: OBS exiting")
        stop_timer()
        source_manager_release()
    end
end

--==========================
-- CONFIGURATION UPDATE
--==========================

local function update_config(settings)
    cfg.source_name = obs.obs_data_get_string(settings, "source") or ""
    cfg.zoom_value = obs.obs_data_get_double(settings, "zoom_value")
    cfg.zoom_duration = obs.obs_data_get_double(settings, "zoom_duration")
    cfg.zoom_overshoot = obs.obs_data_get_double(settings, "zoom_overshoot")
    cfg.zoom_easing = obs.obs_data_get_string(settings, "zoom_easing") or "Cubic.Out"

    cfg.auto_follow = obs.obs_data_get_bool(settings, "auto_follow")
    cfg.follow_smooth_time = obs.obs_data_get_double(settings, "follow_smooth_time")
    cfg.follow_dead_zone = obs.obs_data_get_int(settings, "follow_dead_zone")

    cfg.debug_logs = obs.obs_data_get_bool(settings, "debug_logs")
    debug_logs = cfg.debug_logs

    -- Update scroll zoom config
    update_scroll_config(settings)

    -- Check if source changed
    local current_source = source_manager_is_valid() and cfg.source_name
    if cfg.source_name ~= "" and cfg.source_name ~= current_source then
        -- Reset state and reinitialize
        SM:reset()
        stop_timer()
        source_manager_release()
        source_manager_init(cfg.source_name)
    end
end

--================================================
-- MODULE: Scroll Zoom (M10)
--================================================
-- Enables gradual zoom control via scroll wheel with modifier key
-- Provides dynamic zoom level adjustment during zoomed state

local ScrollZoom = {
    -- Hotkey IDs for scroll zoom
    hotkey_scroll_up = nil,
    hotkey_scroll_down = nil,

    -- Configuration (populated from settings)
    scroll_step = 0.25,
    scroll_modifier = "ctrl",  -- "ctrl", "alt", "shift"
}

-- Check if modifier key is held
local function is_modifier_held()
    if ScrollZoom.scroll_modifier == "ctrl" then
        return platform_is_ctrl_held()
    elseif ScrollZoom.scroll_modifier == "alt" then
        return platform_is_alt_held()
    elseif ScrollZoom.scroll_modifier == "shift" then
        return platform_is_shift_held()
    end
    return false
end

-- Handle scroll zoom in
function on_scroll_zoom_up(pressed)
    if not pressed then return end
    on_scroll_zoom(1)
end

-- Handle scroll zoom out
function on_scroll_zoom_down(pressed)
    if not pressed then return end
    on_scroll_zoom(-1)
end

-- Main scroll zoom handler
function on_scroll_zoom(direction)
    -- Check if we can scroll
    if not SM:can_scroll() then return end

    -- Check modifier (optional - can be configured)
    -- For now, we rely on OBS hotkey bindings which can include modifiers

    if not source_manager_is_valid() then
        log("Scroll Zoom: No valid source")
        return
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        return
    end

    -- Calculate new zoom level
    local step = ScrollZoom.scroll_step * direction  -- e.g., 0.25
    local new_level

    if SM.state == ZoomState.IDLE then
        -- Starting from unzoomed
        new_level = 1.0 + step
    else
        -- Already zoomed, adjust level
        new_level = SM.target_level + step
    end

    -- Clamp to valid range
    new_level = clamp(1.0, cfg.max_zoom, new_level)

    -- If we hit 1.0, fully zoom out
    if new_level <= 1.0 then
        if SM:is_zoomed() then
            -- Trigger full zoom out
            local current = crop_filter_get_crop()
            SM.following = false
            SM:transition(ZoomState.ZOOMING_OUT, {
                start_crop = current,
                target_crop = original_crop,
                target_level = 1.0
            })
            start_timer()
        end
        return
    end

    -- Get current mouse position
    local mouse = platform_get_mouse_pos()

    -- Calculate new target crop for new zoom level
    local target_crop = camera_physics_get_target_crop(mouse, new_level, source_w, source_h, nil)

    -- Get current crop as start
    local start_crop
    if SM:is_animating() then
        -- Use current interpolated crop
        start_crop = crop_filter_get_crop()
    elseif SM:is_zoomed() then
        -- Use current crop
        start_crop = crop_filter_get_crop()
    else
        -- Starting from unzoomed
        start_crop = { x = 0, y = 0, w = source_w, h = source_h }
        original_crop = start_crop
        camera_physics_init(mouse)
    end

    -- Transition to new zoom level
    if SM.state == ZoomState.IDLE then
        -- First scroll from unzoomed
        SM:transition(ZoomState.SCROLLING, {
            start_crop = start_crop,
            target_crop = target_crop,
            target_level = new_level
        })
    else
        -- Already zoomed, adjust level (interrupt current animation)
        SM:transition(ZoomState.SCROLLING, {
            start_crop = start_crop,
            target_crop = target_crop,
            target_level = new_level
        })
    end

    start_timer()
    log("Scroll Zoom: Level " .. string.format("%.2f", new_level))
end

-- Zoom to a specific level (for API calls)
function on_scroll_zoom_to(level)
    if not source_manager_is_valid() then return end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then return end

    level = clamp(1.0, cfg.max_zoom, level)

    if level <= 1.0 then
        -- Zoom out
        if SM:is_zoomed() then
            local current = crop_filter_get_crop()
            SM.following = false
            SM:transition(ZoomState.ZOOMING_OUT, {
                start_crop = current,
                target_crop = original_crop,
                target_level = 1.0
            })
            start_timer()
        end
        return
    end

    local mouse = platform_get_mouse_pos()
    local target_crop = camera_physics_get_target_crop(mouse, level, source_w, source_h, nil)

    local start_crop
    if SM:is_zoomed() then
        start_crop = crop_filter_get_crop()
    else
        start_crop = { x = 0, y = 0, w = source_w, h = source_h }
        original_crop = start_crop
        camera_physics_init(mouse)
    end

    SM:transition(ZoomState.SCROLLING, {
        start_crop = start_crop,
        target_crop = target_crop,
        target_level = level
    })

    start_timer()
end

-- Register scroll zoom hotkeys
local function register_scroll_hotkeys(settings)
    -- Scroll Up hotkey
    ScrollZoom.hotkey_scroll_up = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.scroll_up",
        "Zoom In (Scroll)",
        on_scroll_zoom_up
    )

    -- Scroll Down hotkey
    ScrollZoom.hotkey_scroll_down = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.scroll_down",
        "Zoom Out (Scroll)",
        on_scroll_zoom_down
    )

    -- Load saved bindings
    local up_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.scroll_up")
    if up_array then
        obs.obs_hotkey_load(ScrollZoom.hotkey_scroll_up, up_array)
        obs.obs_data_array_release(up_array)
    end

    local down_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.scroll_down")
    if down_array then
        obs.obs_hotkey_load(ScrollZoom.hotkey_scroll_down, down_array)
        obs.obs_data_array_release(down_array)
    end

    log("Scroll Zoom: Hotkeys registered")
end

-- Save scroll hotkey bindings
local function save_scroll_hotkeys(settings)
    if ScrollZoom.hotkey_scroll_up then
        local array = obs.obs_hotkey_save(ScrollZoom.hotkey_scroll_up)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.scroll_up", array)
        obs.obs_data_array_release(array)
    end

    if ScrollZoom.hotkey_scroll_down then
        local array = obs.obs_hotkey_save(ScrollZoom.hotkey_scroll_down)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.scroll_down", array)
        obs.obs_data_array_release(array)
    end
end

-- Unregister scroll hotkeys
local function unregister_scroll_hotkeys()
    if ScrollZoom.hotkey_scroll_up then
        obs.obs_hotkey_unregister(ScrollZoom.hotkey_scroll_up)
        ScrollZoom.hotkey_scroll_up = nil
    end
    if ScrollZoom.hotkey_scroll_down then
        obs.obs_hotkey_unregister(ScrollZoom.hotkey_scroll_down)
        ScrollZoom.hotkey_scroll_down = nil
    end
end

-- Update scroll zoom config
local function update_scroll_config(settings)
    ScrollZoom.scroll_step = obs.obs_data_get_double(settings, "scroll_step")
    ScrollZoom.scroll_modifier = obs.obs_data_get_string(settings, "scroll_modifier") or "ctrl"
end

--================================================
-- PLACEHOLDER: Future Modules
--================================================

-- M01: Configuration & Settings (TODO)
-- M05: Scene Manager (TODO)
-- M06: Source Manager (TODO)
-- M07: Crop/Zoom Controller (TODO)
-- M08: Motion Tracker (TODO)
-- M09: Face Detection (TODO)
-- M11: Audio Reactor (TODO)
-- M12: Transition Manager (TODO)
-- M13: Animation Controller (TODO)
-- M14: Preset Manager (TODO)
-- M15: Hotkey Manager (TODO)
-- M16: UI Components (TODO)
-- M17: Timer/Scheduler (TODO)
-- M18: State Machine (TODO)
-- M19: Performance Monitor (TODO)

--================================================
-- SCRIPT SETTINGS
--================================================
local settings = {}

-- Default settings
local defaults = {
    debug_logging = false,
    easing_type = "QuadInOut",
    smooth_time = 0.3,
    max_speed = 100.0
}

--================================================
-- MODULE: Preset Manager (M13)
--================================================
-- Manages built-in and custom animation presets

local PresetManager = {
    -- Built-in presets (read-only)
    built_in = {
        {
            name = "Smooth",
            duration = 0.8,
            overshoot = 0.0,
            smoothness = 0.25,
            easing = "Cubic.Out",
        },
        {
            name = "Bounce",
            duration = 0.6,
            overshoot = 0.35,
            smoothness = 0.15,
            easing = "Back.Out",
        },
        {
            name = "Snappy",
            duration = 0.3,
            overshoot = 0.0,
            smoothness = 0.05,
            easing = "Expo.Out",
        },
        {
            name = "Cinematic",
            duration = 1.2,
            overshoot = 0.05,
            smoothness = 0.4,
            easing = "Sine.Out",
        },
    },

    -- Custom user presets
    custom = {},

    -- Currently selected preset name
    current_preset = "Smooth",
}

-- Get all preset names (built-in + custom)
function PresetManager:get_all_names()
    local names = {}

    -- Add built-in presets
    for _, preset in ipairs(self.built_in) do
        table.insert(names, preset.name)
    end

    -- Add custom presets
    for name, _ in pairs(self.custom) do
        table.insert(names, name)
    end

    table.sort(names)
    return names
end

-- Get preset by name
function PresetManager:get_preset(name)
    -- Check built-in first
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            return preset
        end
    end

    -- Check custom
    if self.custom[name] then
        return self.custom[name]
    end

    -- Default to Smooth
    return self.built_in[1]
end

-- Apply preset to configuration
function PresetManager:apply_preset(name)
    local preset = self:get_preset(name)
    if not preset then
        log("Preset: Unknown preset: " .. name)
        return false
    end

    cfg.zoom_duration = preset.duration
    cfg.zoom_overshoot = preset.overshoot
    cfg.follow_smooth_time = preset.smoothness

    if preset.easing then
        cfg.zoom_easing = preset.easing
    end

    self.current_preset = name
    log("Preset: Applied '" .. name .. "'")
    return true
end

-- Save a custom preset
function PresetManager:save_preset(name, duration, overshoot, smoothness, easing)
    if not name or name == "" then
        return false
    end

    -- Check if it's a built-in preset (can't override)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            log("Preset: Cannot override built-in preset: " .. name)
            return false
        end
    end

    -- Save custom preset
    self.custom[name] = {
        name = name,
        duration = duration or cfg.zoom_duration,
        overshoot = overshoot or cfg.zoom_overshoot,
        smoothness = smoothness or cfg.follow_smooth_time,
        easing = easing or cfg.zoom_easing,
    }

    log("Preset: Saved custom preset '" .. name .. "'")
    return true
end

-- Delete a custom preset
function PresetManager:delete_preset(name)
    -- Check if it's a built-in preset (can't delete)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            log("Preset: Cannot delete built-in preset: " .. name)
            return false
        end
    end

    -- Delete custom preset
    if self.custom[name] then
        self.custom[name] = nil
        log("Preset: Deleted custom preset '" .. name .. "'")
        return true
    end

    return false
end

-- Check if a preset is built-in
function PresetManager:is_built_in(name)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            return true
        end
    end
    return false
end

-- Persist custom presets to settings
function PresetManager:persist(settings)
    local array = obs.obs_data_array_create()

    for name, preset in pairs(self.custom) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "name", name)
        obs.obs_data_set_double(item, "duration", preset.duration)
        obs.obs_data_set_double(item, "overshoot", preset.overshoot)
        obs.obs_data_set_double(item, "smoothness", preset.smoothness)
        obs.obs_data_set_string(item, "easing", preset.easing)
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "custom_presets", array)
    obs.obs_data_array_release(array)
end

-- Load custom presets from settings
function PresetManager:load(settings)
    self.custom = {}

    local array = obs.obs_data_get_array(settings, "custom_presets")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local name = obs.obs_data_get_string(item, "name")

        if name and name ~= "" then
            self.custom[name] = {
                name = name,
                duration = obs.obs_data_get_double(item, "duration"),
                overshoot = obs.obs_data_get_double(item, "overshoot"),
                smoothness = obs.obs_data_get_double(item, "smoothness"),
                easing = obs.obs_data_get_string(item, "easing"),
            }
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)
    log("Preset: Loaded " .. self:get_custom_count() .. " custom presets")
end

-- Get count of custom presets
function PresetManager:get_custom_count()
    local count = 0
    for _, _ in pairs(self.custom) do
        count = count + 1
    end
    return count
end

-- Get current preset name
function PresetManager:get_current_name()
    return self.current_preset
end

-- Set current preset name
function PresetManager:set_current_name(name)
    self.current_preset = name
end

-- Check if current preset is custom
function PresetManager:is_current_custom()
    return not self:is_built_in(self.current_preset)
end

-- Global convenience functions
function preset_get_all_names()
    return PresetManager:get_all_names()
end

function preset_apply(name)
    return PresetManager:apply_preset(name)
end

function preset_save(name, duration, overshoot, smoothness, easing)
    return PresetManager:save_preset(name, duration, overshoot, smoothness, easing)
end

function preset_delete(name)
    return PresetManager:delete_preset(name)
end

function preset_is_built_in(name)
    return PresetManager:is_built_in(name)
end

function preset_get_current()
    return PresetManager:get_current_name()
end

--================================================
-- MODULE: Auto Source Detection (M11)
--================================================
-- Automatically detects and selects the best zoom source on first run

local AutoSourceDetector = {
    -- Source type priorities (higher = more likely to be the main display)
    type_priorities = {
        ["monitor_capture"] = 100,     -- Display capture (highest priority)
        ["game_capture"] = 80,          -- Game capture
        ["window_capture"] = 60,        -- Window capture
        ["xshm_input"] = 40,           -- Linux X11 capture
        ["av_capture_input"] = 20,     -- macOS capture
    },

    -- Whether auto-detection has been run
    auto_detected = false,
}

-- Get all capture sources sorted by priority
function AutoSourceDetector:get_capture_sources()
    local sources = {}
    local source_list = obs.obs_enum_sources()

    if not source_list then
        return sources
    end

    for _, source in ipairs(source_list) do
        local source_id = obs.obs_source_get_id(source)
        local name = obs.obs_source_get_name(source)

        -- Check if it's a capture source
        local priority = self.type_priorities[source_id]
        if priority then
            table.insert(sources, {
                name = name,
                id = source_id,
                priority = priority,
            })
        end
    end

    obs.source_list_release(source_list)

    -- Sort by priority (highest first)
    table.sort(sources, function(a, b)
        return a.priority > b.priority
    end)

    return sources
end

-- Auto-detect the best source
function AutoSourceDetector:auto_detect()
    local sources = self:get_capture_sources()

    if #sources == 0 then
        log("AutoSource: No capture sources found")
        return nil
    end

    if #sources == 1 then
        -- Only one source, use it
        log("AutoSource: Found single source: " .. sources[1].name)
        return sources[1].name
    end

    -- Multiple sources - prioritize by type
    -- Prefer monitor_capture > game_capture > window_capture
    local best = sources[1]

    log("AutoSource: Found " .. #sources .. " sources, selecting: " .. best.name)
    return best.name
end

-- Get monitor geometry from a source (if available)
function AutoSourceDetector:get_monitor_geometry(source_name)
    local source = obs.obs_get_source_by_name(source_name)
    if not source then
        return nil
    end

    local settings = obs.obs_source_get_settings(source)
    if not settings then
        obs.obs_source_release(source)
        return nil
    end

    -- Try to get monitor info from settings
    local monitor = obs.obs_data_get_int(settings, "monitor")
    local x = obs.obs_data_get_int(settings, "x")
    local y = obs.obs_data_get_int(settings, "y")
    local width = obs.obs_data_get_int(settings, "width")
    local height = obs.obs_data_get_int(settings, "height")

    obs.obs_data_release(settings)
    obs.obs_source_release(source)

    -- Return geometry if available
    if monitor >= 0 or width > 0 then
        return {
            monitor = monitor,
            x = x,
            y = y,
            width = width or 1920,
            height = height or 1080,
        }
    end

    return nil
end

-- Check if we should auto-detect on first run
function AutoSourceDetector:should_auto_detect(settings)
    -- Check if source has ever been set
    local last_source = obs.obs_data_get_string(settings, "source")
    if last_source and last_source ~= "" then
        return false
    end

    -- Check if auto-detect has been done
    return not self.auto_detected
end

-- Run auto-detection and return the source name
function AutoSourceDetector:run(settings)
    local source_name = self:auto_detect()

    if source_name then
        -- Save the detected source
        obs.obs_data_set_string(settings, "source", source_name)
        self.auto_detected = true
    end

    return source_name
end

-- Global convenience functions
function auto_source_detect()
    return AutoSourceDetector:auto_detect()
end

function auto_source_should_detect(settings)
    return AutoSourceDetector:should_auto_detect(settings)
end

function auto_source_run(settings)
    return AutoSourceDetector:run(settings)
end

--================================================
-- MODULE: Scene Memory (M12)
--================================================
-- Remembers which zoom source to use for each OBS scene

local SceneMemory = {
    -- Scene to source mapping
    scene_source_map = {},

    -- Maximum number of mappings to store
    max_mappings = 50,
}

-- Get the current scene name
function SceneMemory:get_current_scene_name()
    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then
        return nil
    end

    local name = obs.obs_source_get_name(scene_source)
    obs.obs_source_release(scene_source)
    return name
end

-- Get the source to use for the current scene
function SceneMemory:get_source_for_current_scene()
    local scene_name = self:get_current_scene_name()
    if not scene_name then
        return nil
    end

    -- 1. Check explicit mapping for this scene
    if self.scene_source_map[scene_name] then
        return self.scene_source_map[scene_name]
    end

    -- 2. Fall back to global source from config
    return cfg.source_name
end

-- Set the source for a specific scene
function SceneMemory:set(scene_name, source_name)
    if not scene_name or scene_name == "" then
        return false
    end

    -- Check if we're at capacity
    local count = 0
    for _, _ in pairs(self.scene_source_map) do
        count = count + 1
    end

    if count >= self.max_mappings and not self.scene_source_map[scene_name] then
        log("SceneMemory: At capacity (" .. self.max_mappings .. "), cannot add: " .. scene_name)
        return false
    end

    self.scene_source_map[scene_name] = source_name
    log("SceneMemory: " .. scene_name .. " Ã¢â€ â€™ " .. source_name)
    return true
end

-- Remove a scene mapping
function SceneMemory:remove(scene_name)
    if self.scene_source_map[scene_name] then
        self.scene_source_map[scene_name] = nil
        log("SceneMemory: Removed mapping for " .. scene_name)
        return true
    end
    return false
end

-- Get all scene mappings
function SceneMemory:get_all()
    local mappings = {}
    for scene, source in pairs(self.scene_source_map) do
        table.insert(mappings, { scene = scene, source = source })
    end
    table.sort(mappings, function(a, b)
        return a.scene < b.scene
    end)
    return mappings
end

-- Check if a scene has a mapping
function SceneMemory:has_mapping(scene_name)
    return self.scene_source_map[scene_name] ~= nil
end

-- Persist mappings to settings
function SceneMemory:persist(settings)
    local array = obs.obs_data_array_create()

    for scene, source in pairs(self.scene_source_map) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "scene", scene)
        obs.obs_data_set_string(item, "source", source)
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "scene_source_map", array)
    obs.obs_data_array_release(array)
end

-- Load mappings from settings
function SceneMemory:load(settings)
    self.scene_source_map = {}

    local array = obs.obs_data_get_array(settings, "scene_source_map")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local scene = obs.obs_data_get_string(item, "scene")
        local source = obs.obs_data_get_string(item, "source")

        if scene and scene ~= "" and source and source ~= "" then
            self.scene_source_map[scene] = source
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)

    local count = 0
    for _, _ in pairs(self.scene_source_map) do count = count + 1 end
    log("SceneMemory: Loaded " .. count .. " scene mappings")
end

-- Handle scene change
function SceneMemory:on_scene_change()
    local scene_name = self:get_current_scene_name()
    if not scene_name then
        return
    end

    -- Get the source for this scene
    local source_name = self:get_source_for_current_scene()

    if source_name and source_name ~= "" then
        -- Check if source changed
        local current = source_manager_is_valid() and cfg.source_name

        if source_name ~= current then
            log("SceneMemory: Scene changed to " .. scene_name)

            -- Release current source
            source_manager_release()

            -- Initialize with new source
            cfg.source_name = source_name
            source_manager_init(source_name)
        end
    end
end

-- Global convenience functions
function scene_memory_get_source()
    return SceneMemory:get_source_for_current_scene()
end

function scene_memory_set(scene_name, source_name)
    return SceneMemory:set(scene_name, source_name)
end

function scene_memory_remove(scene_name)
    return SceneMemory:remove(scene_name)
end

function scene_memory_get_all()
    return SceneMemory:get_all()
end

function scene_memory_on_scene_change()
    return SceneMemory:on_scene_change()
end

--================================================
-- MODULE: Blur Manager (M14)
--================================================
-- Provides built-in blur effects without external plugins
-- Supports multiple strategies: shader, composite_blur plugin, or none

local BlurManager = {
    -- Current strategy: "shader", "composite_blur", "none"
    strategy = "none",

    -- Filter references
    zoom_blur_filter = nil,
    motion_blur_filter = nil,

    -- Settings references
    zoom_blur_settings = nil,
    motion_blur_settings = nil,

    -- State
    initialized = false,

    -- Configuration
    zoom_blur_enabled = false,
    zoom_blur_intensity = 5,
    zoom_blur_clear_radius = 150,
    motion_blur_enabled = false,
    motion_blur_intensity = 1.0,
}

-- Try to use custom shader (if effect files exist)
function BlurManager:try_shader_strategy(source)
    -- This would require .effect files in assets/shaders/
    -- For now, we'll use a simpler approach
    log("Blur: Shader strategy not implemented (requires effect files)")
    return false
end

-- Try to auto-create Composite Blur filters
function BlurManager:try_composite_blur_strategy(source)
    if not source then return false end

    -- Check if composite_blur filter type exists
    local test_filter = obs.obs_source_create_private("composite_blur", "__test_blur__", nil)
    if test_filter then
        obs.obs_source_release(test_filter)
    else
        log("Blur: Composite Blur plugin not available")
        return false
    end

    -- Create Zoom Blur filter
    local zs = obs.obs_data_create()
    obs.obs_data_set_double(zs, "radius", 0)
    obs.obs_data_set_int(zs, "blur_type", 2) -- Zoom type
    self.zoom_blur_filter = obs.obs_source_create_private(
        "composite_blur",
        FILTER_PREFIX .. "Zoom Blur",
        zs
    )

    if self.zoom_blur_filter then
        obs.obs_source_filter_add(source, self.zoom_blur_filter)
        self.zoom_blur_settings = zs
    else
        obs.obs_data_release(zs)
        return false
    end

    -- Create Motion Blur filter
    local ms = obs.obs_data_create()
    obs.obs_data_set_double(ms, "radius", 0)
    obs.obs_data_set_int(ms, "blur_type", 3) -- Motion/directional type
    self.motion_blur_filter = obs.obs_source_create_private(
        "composite_blur",
        FILTER_PREFIX .. "Motion Blur",
        ms
    )

    if self.motion_blur_filter then
        obs.obs_source_filter_add(source, self.motion_blur_filter)
        self.motion_blur_settings = ms
    else
        obs.obs_data_release(ms)
    end

    self.initialized = true
    return true
end

-- Initialize blur manager
function BlurManager:init(source)
    if not source then
        return false
    end

    self:cleanup()

    -- Try composite_blur strategy
    if self:try_composite_blur_strategy(source) then
        self.strategy = "composite_blur"
        log("Blur: Using Composite Blur plugin (auto-configured)")
        return true
    end

    -- No blur available
    self.strategy = "none"
    log("Blur: No blur backend available. Blur effects disabled.")
    return false
end

-- Update blur based on zoom state
function BlurManager:update(state_machine, crop, camera_velocity)
    if not self.initialized then return end
    if self.strategy == "none" then return end

    -- Zoom Blur: Active during zoom transitions
    if self.zoom_blur_enabled and self.zoom_blur_filter then
        local radius = 0

        if state_machine:is_animating() and
           (state_machine.state == ZoomState.ZOOMING_IN or
            state_machine.state == ZoomState.ZOOMING_OUT) then
            -- Bell curve: 0 at start Ã¢â€ â€™ peak at 50% Ã¢â€ â€™ 0 at end
            local t = clamp(0, 1, state_machine.zoom_time)
            local curve = math.sin(t * math.pi)
            radius = curve * curve * self.zoom_blur_intensity
        end

        self:set_zoom_blur(radius, crop)
    end

    -- Motion Blur: Active during camera panning (not during zoom transition)
    if self.motion_blur_enabled and self.motion_blur_filter then
        if not state_machine:is_animating() and state_machine:is_zoomed() and camera_velocity then
            local speed = math.sqrt(
                camera_velocity.x * camera_velocity.x +
                camera_velocity.y * camera_velocity.y
            )

            if speed > 1.0 then
                local radius = math.min(10, speed * self.motion_blur_intensity * 0.5)
                local angle = math.deg(math.atan2(camera_velocity.y, camera_velocity.x))
                self:set_motion_blur(radius, angle)
            else
                self:set_motion_blur(0, 0)
            end
        else
            self:set_motion_blur(0, 0)
        end
    end
end

-- Set zoom blur parameters
function BlurManager:set_zoom_blur(radius, crop)
    if self.strategy == "composite_blur" and self.zoom_blur_settings then
        obs.obs_data_set_double(self.zoom_blur_settings, "radius", radius)

        if crop then
            local cx = crop.x + (crop.w / 2)
            local cy = crop.y + (crop.h / 2)
            obs.obs_data_set_double(self.zoom_blur_settings, "center_x", cx)
            obs.obs_data_set_double(self.zoom_blur_settings, "center_y", cy)
        end

        obs.obs_data_set_double(self.zoom_blur_settings, "inactive_radius", self.zoom_blur_clear_radius)
        obs.obs_source_update(self.zoom_blur_filter, self.zoom_blur_settings)
    end
end

-- Set motion blur parameters
function BlurManager:set_motion_blur(radius, angle)
    if self.strategy == "composite_blur" and self.motion_blur_settings then
        obs.obs_data_set_double(self.motion_blur_settings, "radius", radius)
        obs.obs_data_set_double(self.motion_blur_settings, "angle", angle)
        obs.obs_source_update(self.motion_blur_filter, self.motion_blur_settings)
    end
end

-- Update configuration
function BlurManager:update_config(settings)
    self.zoom_blur_enabled = obs.obs_data_get_bool(settings, "zoom_blur_enabled")
    self.zoom_blur_intensity = obs.obs_data_get_double(settings, "zoom_blur_intensity")
    self.zoom_blur_clear_radius = obs.obs_data_get_double(settings, "zoom_blur_clear_radius")
    self.motion_blur_enabled = obs.obs_data_get_bool(settings, "motion_blur_enabled")
    self.motion_blur_intensity = obs.obs_data_get_double(settings, "motion_blur_intensity")
end

-- Cleanup filters
function BlurManager:cleanup()
    local source = source_manager_get_source()

    if self.zoom_blur_filter and source then
        obs.obs_source_filter_remove(source, self.zoom_blur_filter)
        obs.obs_source_release(self.zoom_blur_filter)
        self.zoom_blur_filter = nil
    end

    if self.motion_blur_filter and source then
        obs.obs_source_filter_remove(source, self.motion_blur_filter)
        obs.obs_source_release(self.motion_blur_filter)
        self.motion_blur_filter = nil
    end

    if self.zoom_blur_settings then
        obs.obs_data_release(self.zoom_blur_settings)
        self.zoom_blur_settings = nil
    end

    if self.motion_blur_settings then
        obs.obs_data_release(self.motion_blur_settings)
        self.motion_blur_settings = nil
    end

    self.initialized = false
    self.strategy = "none"
end

-- Check if blur is available
function BlurManager:is_available()
    return self.strategy ~= "none"
end

-- Global convenience functions
function blur_manager_init(source)
    return BlurManager:init(source)
end

function blur_manager_update(state_machine, crop, camera_velocity)
    return BlurManager:update(state_machine, crop, camera_velocity)
end

function blur_manager_update_config(settings)
    return BlurManager:update_config(settings)
end

function blur_manager_cleanup()
    return BlurManager:cleanup()
end

function blur_manager_is_available()
    return BlurManager:is_available()
end

--================================================
-- MODULE: Cursor Asset Manager (M16)
--================================================
-- Handles extracting and managing cursor image assets

local CursorAssets = {
    extracted = false,
    dir = nil,
}

-- Get the platform-specific asset directory
function CursorAssets:get_platform_dir()
    if IS_WINDOWS then
        local appdata = os.getenv("APPDATA")
        return appdata and (appdata .. "\\obs-studio\\obs-zoom-pro\\cursors") or nil
    elseif IS_LINUX then
        local home = os.getenv("HOME")
        return home and (home .. "/.config/obs-studio/obs-zoom-pro/cursors") or nil
    elseif IS_MACOS then
        local home = os.getenv("HOME")
        return home and (home .. "/Library/Application Support/obs-studio/obs-zoom-pro/cursors") or nil
    end
    -- Fallback for non-FFI environments
    return "cursors"
end

-- Ensure assets are extracted
function CursorAssets:ensure_extracted()
    if self.extracted then
        return self.dir
    end

    local dir = self:get_platform_dir()
    if not dir then
        log("CursorAssets: Could not determine asset directory")
        return nil
    end

    -- Create directory
    local cmd
    if IS_WINDOWS then
        cmd = 'mkdir "' .. dir .. '" 2>nul'
    else
        cmd = 'mkdir -p "' .. dir .. '"'
    end
    os.execute(cmd)

    -- Check if assets exist
    local sep = IS_WINDOWS and "\\" or "/"
    local arrow_path = dir .. sep .. "arrow.png"

    local f = io.open(arrow_path, "rb")
    if f then
        f:close()
        self.dir = dir
        self.extracted = true
        log("CursorAssets: Using existing assets from " .. dir)
        return dir
    end

    -- Try to copy from script directory
    local script_dir = get_script_directory()
    local assets_src = script_dir .. "assets" .. sep .. "cursors" .. sep

    local files = { "arrow.png", "pointer.png", "ibeam.png" }
    for _, filename in ipairs(files) do
        local src_path = assets_src .. filename
        local dst_path = dir .. sep .. filename

        local src = io.open(src_path, "rb")
        if src then
            local data = src:read("*a")
            src:close()

            local dst = io.open(dst_path, "wb")
            if dst then
                dst:write(data)
                dst:close()
                log("CursorAssets: Copied " .. filename)
            end
        end
    end

    self.dir = dir
    self.extracted = true
    return dir
end

-- Get the asset directory
function CursorAssets:get_dir()
    return self.dir
end

-- Check if assets are available
function CursorAssets:is_available()
    if not self.extracted then
        self:ensure_extracted()
    end
    return self.dir ~= nil
end

-- Get cursor image path
function CursorAssets:get_cursor_path(cursor_type)
    if not self:is_available() then
        return nil
    end

    local sep = IS_WINDOWS and "\\" or "/"
    local filename = (cursor_type or "arrow") .. ".png"
    return self.dir .. sep .. filename
end

-- Global convenience functions
function cursor_assets_ensure_extracted()
    return CursorAssets:ensure_extracted()
end

function cursor_assets_get_dir()
    return CursorAssets:get_dir()
end

function cursor_assets_is_available()
    return CursorAssets:is_available()
end

function cursor_assets_get_cursor_path(cursor_type)
    return CursorAssets:get_cursor_path(cursor_type)
end

--================================================
-- MODULE: Cursor Renderer (M15)
--================================================
-- Provides automatic cursor overlay rendering

local CursorRenderer = {
    enabled = false,
    source = nil,
    sceneitem = nil,

    -- Smoothed state
    pos = { x = 0, y = 0 },
    current_scale = 1.0,
    current_rot = 0,
    swap_pulse = 1.0,

    -- Velocities (SmoothDamp)
    vel_x = { val = 0 },
    vel_y = { val = 0 },
    vel_scale = { val = 0 },
    vel_rot = { val = 0 },
    vel_swap = { val = 0 },

    -- State
    was_pointer = false,
    initialized = false,

    -- Configuration
    cursor_scale = 1.0,
    cursor_click_scale = 0.78,
    cursor_smooth_time = 0.1,
    cursor_offset_x = -6,
    cursor_offset_y = -2,
    cursor_rotation_mode = "None",
    cursor_angle_offset = 0,
    cursor_tilt_strength = 0,
}

-- Initialize cursor renderer
function CursorRenderer:init()
    if not cfg.cursor_enabled then
        self.enabled = false
        return false
    end

    -- Ensure cursor assets are available
    local asset_dir = cursor_assets_ensure_extracted()
    if not asset_dir then
        log("CursorRenderer: Failed to extract cursor assets")
        self.enabled = false
        return false
    end

    -- Get or create the cursor image source
    local source_name = FILTER_PREFIX .. "Cursor"
    self.source = obs.obs_get_source_by_name(source_name)

    if not self.source then
        -- Create new image source
        local settings = obs.obs_data_create()
        local cursor_path = cursor_assets_get_cursor_path("arrow")
        if cursor_path then
            obs.obs_data_set_string(settings, "file", cursor_path)
        end
        self.source = obs.obs_source_create("image_source", source_name, settings, nil)
        obs.obs_data_release(settings)

        if not self.source then
            log("CursorRenderer: Failed to create image source")
            self.enabled = false
            return false
        end
    end

    -- Add to current scene
    self:add_to_scene()

    -- Initialize position
    local mouse = platform_get_mouse_pos()
    self.pos.x = mouse.x
    self.pos.y = mouse.y

    self.enabled = true
    self.initialized = true
    log("CursorRenderer: Initialized")
    return true
end

-- Add cursor source to scene
function CursorRenderer:add_to_scene()
    if not self.source then return false end

    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then return false end

    local scene = obs.obs_scene_from_source(scene_source)
    if not scene then
        obs.obs_source_release(scene_source)
        return false
    end

    -- Check if already in scene
    local source_name = obs.obs_source_get_name(self.source)
    self.sceneitem = obs.obs_scene_find_source(scene, source_name)

    if not self.sceneitem then
        -- Add to scene
        self.sceneitem = obs.obs_scene_add(scene, self.source)
        if self.sceneitem then
            -- Move to top (render last = on top)
            obs.obs_sceneitem_set_order(self.sceneitem, obs.OBS_ORDER_MOVE_TOP)
        end
    end

    obs.obs_source_release(scene_source)
    return true
end

-- Update cursor position and state
function CursorRenderer:update(dt, raw_mouse, camera_crop)
    if not self.enabled or not self.sceneitem then return end

    -- Smooth cursor position
    self.pos.x = SmoothDamp(self.pos.x, raw_mouse.x, self.vel_x, self.cursor_smooth_time, 100000, dt)
    self.pos.y = SmoothDamp(self.pos.y, raw_mouse.y, self.vel_y, self.cursor_smooth_time, 100000, dt)

    -- Snap when very close
    if math.abs(self.pos.x - raw_mouse.x) < 0.5 then
        self.pos.x = raw_mouse.x
        self.vel_x.val = 0
    end
    if math.abs(self.pos.y - raw_mouse.y) < 0.5 then
        self.pos.y = raw_mouse.y
        self.vel_y.val = 0
    end

    -- Cursor shape detection (Windows only)
    local is_pointer = false
    if platform_cursor_shape_available() then
        is_pointer = platform_is_cursor_pointer()
    end

    -- Swap cursor image if needed
    if is_pointer ~= self.was_pointer then
        local asset_dir = cursor_assets_get_dir()
        local sep = IS_WINDOWS and "\\" or "/"
        local new_file = is_pointer and (asset_dir .. sep .. "pointer.png") or (asset_dir .. sep .. "arrow.png")

        local s = obs.obs_source_get_settings(self.source)
        if s then
            obs.obs_data_set_string(s, "file", new_file)
            obs.obs_source_update(self.source, s)
            obs.obs_data_release(s)
        end

        -- Trigger swap pulse
        self.swap_pulse = 0.75
        self.vel_swap.val = 1
        self.was_pointer = is_pointer
    end

    self.swap_pulse = SmoothDamp(self.swap_pulse, 1.0, self.vel_swap, 0.12, 100000, dt)

    -- Click animation
    local is_clicking = platform_is_clicking()
    local target_scale = is_clicking and (self.cursor_scale * self.cursor_click_scale) or self.cursor_scale
    self.current_scale = SmoothDamp(self.current_scale, target_scale, self.vel_scale, 0.1, 100000, dt)

    -- Calculate position relative to zoom
    local zoom_factor = 1.0
    local crop_x, crop_y = 0, 0

    if camera_crop and SM:is_zoomed() then
        zoom_factor = source_manager_get_size() / camera_crop.w
        crop_x = camera_crop.x
        crop_y = camera_crop.y
    end

    local final_x = (self.pos.x - crop_x) * zoom_factor + (self.cursor_offset_x * zoom_factor)
    local final_y = (self.pos.y - crop_y) * zoom_factor + (self.cursor_offset_y * zoom_factor)

    -- Apply to scene item
    local pos = obs.vec2()
    pos.x = final_x
    pos.y = final_y
    obs.obs_sceneitem_set_pos(self.sceneitem, pos)

    local scale = obs.vec2()
    local s = self.current_scale * zoom_factor * self.swap_pulse
    scale.x = s
    scale.y = s
    obs.obs_sceneitem_set_scale(self.sceneitem, scale)

    -- Rotation
    local dynamic_rot = self:compute_rotation(dt)
    obs.obs_sceneitem_set_rot(self.sceneitem, dynamic_rot)
end

-- Compute rotation based on mode
function CursorRenderer:compute_rotation(dt)
    local vx = self.vel_x.val
    local vy = self.vel_y.val
    local speed = math.sqrt(vx * vx + vy * vy)

    if self.cursor_rotation_mode == "Directional" then
        if speed > 20 then
            local angle = math.atan2(vy, vx) * (180 / math.pi)
            local target = angle + self.cursor_angle_offset
            local diff = (target - self.current_rot + 180) % 360 - 180
            self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.05, 100000, dt)
        end
        return self.current_rot

    elseif self.cursor_rotation_mode == "Lean" then
        local lean = clamp(-40, 40, vx * 0.05 * self.cursor_tilt_strength) + self.cursor_angle_offset
        local diff = (lean - self.current_rot + 180) % 360 - 180
        self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.08, 100000, dt)
        return self.current_rot
    end

    -- "None" mode
    local diff = (self.cursor_angle_offset - self.current_rot + 180) % 360 - 180
    self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.15, 100000, dt)
    return self.current_rot
end

-- Update configuration
function CursorRenderer:update_config(settings)
    self.cursor_scale = obs.obs_data_get_double(settings, "cursor_scale")
    self.cursor_click_scale = obs.obs_data_get_double(settings, "cursor_click_scale")
    self.cursor_smooth_time = obs.obs_data_get_double(settings, "cursor_smooth_time")
    self.cursor_offset_x = obs.obs_data_get_int(settings, "cursor_offset_x")
    self.cursor_offset_y = obs.obs_data_get_int(settings, "cursor_offset_y")
    self.cursor_rotation_mode = obs.obs_data_get_string(settings, "cursor_rotation_mode") or "None"
    self.cursor_angle_offset = obs.obs_data_get_double(settings, "cursor_angle_offset")
    self.cursor_tilt_strength = obs.obs_data_get_double(settings, "cursor_tilt_strength")
end

-- Cleanup
function CursorRenderer:cleanup()
    if self.sceneitem then
        obs.obs_sceneitem_remove(self.sceneitem)
        self.sceneitem = nil
    end

    if self.source then
        local source_name = obs.obs_source_get_name(self.source)
        obs.obs_source_release(self.source)

        -- Remove from OBS source list
        local s = obs.obs_get_source_by_name(source_name)
        if s then
            obs.obs_source_remove(s)
            obs.obs_source_release(s)
        end
        self.source = nil
    end

    self.enabled = false
    self.initialized = false
end

-- Check if active
function CursorRenderer:is_active()
    return self.enabled and self.initialized
end

-- Global convenience functions
function cursor_renderer_init()
    return CursorRenderer:init()
end

function cursor_renderer_update(dt, raw_mouse, camera_crop)
    return CursorRenderer:update(dt, raw_mouse, camera_crop)
end

function cursor_renderer_update_config(settings)
    return CursorRenderer:update_config(settings)
end

function cursor_renderer_cleanup()
    return CursorRenderer:cleanup()
end

function cursor_renderer_is_active()
    return CursorRenderer:is_active()
end

--================================================
-- MODULE: Bookmark Manager (M17)
--================================================
-- Manages saved zoom positions (bookmarks)

local BookmarkManager = {
    -- Saved bookmarks: { name = { zoom_level, x, y, w, h, source } }
    bookmarks = {},

    -- Maximum bookmarks
    max_bookmarks = 20,

    -- Hotkey IDs
    hotkeys = {},
}

-- Save current zoom position as a bookmark
function BookmarkManager:save(name)
    if not name or name == "" then
        return false
    end

    -- Check limit
    local count = 0
    for _, _ in pairs(self.bookmarks) do count = count + 1 end

    if count >= self.max_bookmarks and not self.bookmarks[name] then
        log("Bookmark: Max bookmarks reached (" .. self.max_bookmarks .. ")")
        return false
    end

    -- Get current crop
    local crop = crop_filter_get_crop()
    if not crop then
        return false
    end

    -- Save bookmark
    self.bookmarks[name] = {
        zoom_level = SM.zoom_level,
        x = crop.x,
        y = crop.y,
        w = crop.w,
        h = crop.h,
        source = cfg.source_name,
    }

    log("Bookmark: Saved '" .. name .. "' (zoom=" .. string.format("%.2f", SM.zoom_level) .. ")")
    return true
end

-- Recall a bookmark
function BookmarkManager:recall(name)
    local bm = self.bookmarks[name]
    if not bm then
        log("Bookmark: Not found: " .. name)
        return false
    end

    if not SM:can_jump() then
        return false
    end

    if not source_manager_is_valid() then
        return false
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        return false
    end

    -- Get current crop as start
    local start_crop = crop_filter_get_crop() or { x = 0, y = 0, w = source_w, h = source_h }

    -- Set target
    local target_crop = {
        x = bm.x,
        y = bm.y,
        w = bm.w,
        h = bm.h,
    }

    -- Transition to bookmark
    SM:transition(ZoomState.JUMPING, {
        start_crop = start_crop,
        target_crop = target_crop,
        target_level = bm.zoom_level
    })

    start_timer()
    log("Bookmark: Recall '" .. name .. "'")
    return true
end

-- Delete a bookmark
function BookmarkManager:delete(name)
    if self.bookmarks[name] then
        self.bookmarks[name] = nil
        log("Bookmark: Deleted '" .. name .. "'")
        return true
    end
    return false
end

-- Rename a bookmark
function BookmarkManager:rename(old_name, new_name)
    if not self.bookmarks[old_name] then
        return false
    end

    if self.bookmarks[new_name] then
        return false
    end

    self.bookmarks[new_name] = self.bookmarks[old_name]
    self.bookmarks[old_name] = nil
    log("Bookmark: Renamed '" .. old_name .. "' to '" .. new_name .. "'")
    return true
end

-- Get all bookmark names
function BookmarkManager:get_names()
    local names = {}
    for k, _ in pairs(self.bookmarks) do
        table.insert(names, k)
    end
    table.sort(names)
    return names
end

-- Get bookmark info
function BookmarkManager:get(name)
    return self.bookmarks[name]
end

-- Persist bookmarks to settings
function BookmarkManager:persist(settings)
    local array = obs.obs_data_array_create()

    for name, bm in pairs(self.bookmarks) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "name", name)
        obs.obs_data_set_double(item, "zoom_level", bm.zoom_level)
        obs.obs_data_set_double(item, "x", bm.x)
        obs.obs_data_set_double(item, "y", bm.y)
        obs.obs_data_set_double(item, "w", bm.w)
        obs.obs_data_set_double(item, "h", bm.h)
        obs.obs_data_set_string(item, "source", bm.source or "")
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "zoom_bookmarks", array)
    obs.obs_data_array_release(array)
end

-- Load bookmarks from settings
function BookmarkManager:load(settings)
    self.bookmarks = {}

    local array = obs.obs_data_get_array(settings, "zoom_bookmarks")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local name = obs.obs_data_get_string(item, "name")

        if name and name ~= "" then
            self.bookmarks[name] = {
                zoom_level = obs.obs_data_get_double(item, "zoom_level"),
                x = obs.obs_data_get_double(item, "x"),
                y = obs.obs_data_get_double(item, "y"),
                w = obs.obs_data_get_double(item, "w"),
                h = obs.obs_data_get_double(item, "h"),
                source = obs.obs_data_get_string(item, "source"),
            }
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)

    local count = 0
    for _, _ in pairs(self.bookmarks) do count = count + 1 end
    log("Bookmark: Loaded " .. count .. " bookmarks")
end

-- Register bookmark hotkeys
function BookmarkManager:register_hotkeys(settings)
    for i = 1, 5 do
        self.hotkeys[i] = obs.obs_hotkey_register_frontend(
            "obs_zoom_pro.bookmark_" .. i,
            "Zoom to Bookmark " .. i,
            function(pressed)
                if not pressed then return end
                local names = self:get_names()
                if names[i] then
                    self:recall(names[i])
                end
            end
        )

        -- Load saved bindings
        local key = "obs_zoom_pro.hotkey.bookmark_" .. i
        local save_array = obs.obs_data_get_array(settings, key)
        if save_array then
            obs.obs_hotkey_load(self.hotkeys[i], save_array)
            obs.obs_data_array_release(save_array)
        end
    end
end

-- Save bookmark hotkeys
function BookmarkManager:save_hotkeys(settings)
    for i = 1, 5 do
        if self.hotkeys[i] then
            local save_array = obs.obs_hotkey_save(self.hotkeys[i])
            obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.bookmark_" .. i, save_array)
            obs.obs_data_array_release(save_array)
        end
    end
end

-- Global convenience functions
function bookmark_save(name)
    return BookmarkManager:save(name)
end

function bookmark_recall(name)
    return BookmarkManager:recall(name)
end

function bookmark_delete(name)
    return BookmarkManager:delete(name)
end

function bookmark_get_names()
    return BookmarkManager:get_names()
end

function bookmark_get(name)
    return BookmarkManager:get(name)
end

--================================================
-- MODULE: UDP API Server (M18)
--================================================
-- Provides external control via UDP for Stream Deck integration

local APIServer = {
    enabled = false,
    port = 12345,
    socket = nil,
}

-- Command handlers
local API_COMMANDS = {
    ZOOM_IN = function(args)
        local level = tonumber(args[1]) or cfg.zoom_value
        on_scroll_zoom_to(level)
        return "OK"
    end,

    ZOOM_OUT = function(args)
        if SM:is_zoomed() then
            on_toggle_zoom(true)
        end
        return "OK"
    end,

    ZOOM_SET = function(args)
        local level = tonumber(args[1])
        if not level then return "ERROR: Missing level" end
        on_scroll_zoom_to(level)
        return "OK"
    end,

    ZOOM_TOGGLE = function(args)
        on_toggle_zoom(true)
        return "OK"
    end,

    FOLLOW_ON = function(args)
        if SM:is_zoomed() then SM.following = true end
        return "OK"
    end,

    FOLLOW_OFF = function(args)
        SM.following = false
        return "OK"
    end,

    FOLLOW_TOGGLE = function(args)
        if SM:is_zoomed() then SM.following = not SM.following end
        return "OK"
    end,

    PRESET = function(args)
        local name = args[1]
        if not name then return "ERROR: Missing preset name" end
        local ok = preset_apply(name)
        return ok and "OK" or "ERROR: Unknown preset"
    end,

    BOOKMARK = function(args)
        local name = args[1]
        if not name then return "ERROR: Missing bookmark name" end
        local ok = bookmark_recall(name)
        return ok and "OK" or "ERROR: Bookmark not found"
    end,

    STATUS = function(args)
        local crop = crop_filter_get_crop()
        return string.format(
            '{"version":"%s","zoom_level":%.2f,"state":"%s","following":%s,"position":{"x":%.0f,"y":%.0f},"preset":"%s"}',
            VERSION,
            SM.zoom_level,
            SM.state,
            tostring(SM.following),
            crop and crop.x or 0,
            crop and crop.y or 0,
            cfg.zoom_preset or ""
        )
    end,

    HELP = function(args)
        return "Commands: ZOOM_IN [level], ZOOM_OUT, ZOOM_SET level, ZOOM_TOGGLE, FOLLOW_ON, FOLLOW_OFF, FOLLOW_TOGGLE, PRESET name, BOOKMARK name, STATUS"
    end,
}

-- Start the API server
function APIServer:start(port)
    self:stop()

    self.port = port or self.port

    -- Try to use luasocket if available
    local socket_ok, socket = pcall(require, "socket")
    if not socket_ok then
        log("API: Socket library not available")
        return false
    end

    -- Try UDP
    local udp, err = socket.udp()
    if not udp then
        log("API: Failed to create UDP socket: " .. tostring(err))
        return false
    end

    -- Set socket options
    udp:setoption("reuseaddr", true)
    udp:settimeout(0)  -- Non-blocking

    -- Bind to port
    local bind_ok, err = udp:setsockname("*", self.port)
    if not bind_ok then
        log("API: Failed to bind to port " .. self.port .. ": " .. tostring(err))
        udp:close()
        return false
    end

    self.socket = udp
    self.enabled = true

    -- Start polling timer
    obs.timer_add(function() self:poll() end, 50)  -- 20Hz polling

    log("API: Listening on port " .. self.port)
    return true
end

-- Stop the API server
function APIServer:stop()
    if self.socket then
        self.socket:close()
        self.socket = nil
    end
    self.enabled = false
    log("API: Stopped")
end

-- Poll for incoming commands
function APIServer:poll()
    if not self.enabled or not self.socket then
        return
    end

    repeat
        local data, err = self.socket:receivefrom()
        if data then
            local response = self:handle_command(data)
            if response then
                -- Note: UDP response requires sender address
                log("API: " .. data:gsub("%s+", " ") .. " Ã¢â€ â€™ " .. response)
            end
        elseif err ~= "timeout" then
            log("API: Error: " .. tostring(err))
        end
    until not data
end

-- Handle a command
function APIServer:handle_command(raw)
    -- Parse command
    local parts = {}
    for word in raw:gmatch("%S+") do
        table.insert(parts, word)
    end

    if #parts == 0 then
        return "ERROR: Empty command"
    end

    local cmd = parts[1]:upper()
    local args = {}
    for i = 2, #parts do
        table.insert(args, parts[i])
    end

    -- Look up handler
    local handler = API_COMMANDS[cmd]
    if handler then
        local ok, result = pcall(handler, args)
        if ok then
            return result
        else
            return "ERROR: " .. tostring(result)
        end
    end

    return "ERROR: Unknown command: " .. cmd
end

-- Check if enabled
function APIServer:is_enabled()
    return self.enabled
end

-- Global convenience functions
function api_start(port)
    return APIServer:start(port)
end

function api_stop()
    return APIServer:stop()
end

function api_is_enabled()
    return APIServer:is_enabled()
end

--================================================
-- OBS SCRIPT REGISTRATION
--================================================

--[[ Called when the script is loaded
--[[ @param data table Script data
function script_load(data)
    log("Script loaded - OBS Zoom Pro v" .. VERSION)

    -- Load custom presets
    PresetManager:load(data)

    -- Load scene memory
    SceneMemory:load(data)

    -- Load bookmarks
    BookmarkManager:load(data)

    -- Register hotkeys
    register_hotkeys(data)

    -- Register bookmark hotkeys
    BookmarkManager:register_hotkeys(data)

    -- Register frontend event handler
    obs.obs_frontend_add_event_callback(on_frontend_event)

    -- Start API server if enabled
    local api_enabled = obs.obs_data_get_bool(data, "api_enabled")
    if api_enabled then
        local api_port = obs.obs_data_get_int(data, "api_port")
        APIServer:start(api_port)
    end
end

--[[ Called when the script is unloaded
function script_unload()
    log("Script unloaded - OBS Zoom Pro")

    -- Stop timer and cleanup
    stop_timer()
    unregister_hotkeys()
    source_manager_release()

    -- Stop API server
    APIServer:stop()

    -- Remove frontend event handler
    obs.obs_frontend_remove_event_callback(on_frontend_event)
end

--[[ Called when settings are updated
--[[ @param data table Settings data
function script_update(data)
    log("Settings updated")

    -- Update legacy settings
    debug_logs = obs.obs_data_get_bool(data, "debug_logging") or false
    settings.debug_logging = debug_logs
    settings.easing_type = obs.obs_data_get_string(data, "easing_type") or defaults.easing_type
    settings.smooth_time = obs.obs_data_get_double(data, "smooth_time") or defaults.smooth_time
    settings.max_speed = obs.obs_data_get_double(data, "max_speed") or defaults.max_speed

    -- Update M09 configuration
    update_config(data)

    -- Update API server settings
    local api_enabled = obs.obs_data_get_bool(data, "api_enabled")
    local api_port = obs.obs_data_get_int(data, "api_port")

    if api_enabled and not APIServer:is_enabled() then
        APIServer:start(api_port)
    elseif not api_enabled and APIServer:is_enabled() then
        APIServer:stop()
    elseif APIServer:is_enabled() and APIServer.port ~= api_port then
        APIServer:start(api_port)
    end
end

--[[ Called to save settings
--[[ @param data table Settings data to save
function script_save(data)
    log("Settings saved")

    -- Save custom presets
    PresetManager:persist(data)

    -- Save scene memory
    SceneMemory:persist(data)

    -- Save bookmarks
    BookmarkManager:persist(data)

    -- Save hotkey bindings
    save_hotkeys(data)

    -- Save bookmark hotkeys
    BookmarkManager:save_hotkeys(data)
end

--[[ Called to create the properties UI
--[[ @return obs.obs_properties_t Properties object
function script_properties()
    local props = obs.obs_properties_create()

    --==========================
    -- QUICK SETUP (always expanded)
    --==========================
    local grp_quick = obs.obs_properties_create()

    -- Source dropdown
    local src_list = obs.obs_properties_add_list(grp_quick, "source", "Zoom Source",
        obs.OBS_COMBO_TYPE_LIST, obs.OBS_COMBO_FORMAT_STRING)
    obs.obs_property_list_add_string(src_list, "-- Select Source --", "")

    -- Populate with available capture sources
    local sources = source_manager_get_available_sources()
    for _, src in ipairs(sources) do
        obs.obs_property_list_add_string(src_list, src.name, src.name)
    end

    -- Zoom Factor
    obs.obs_properties_add_float_slider(grp_quick, "zoom_value", "Zoom Factor", 1.0, 10.0, 0.1)

    -- Duration
    obs.obs_properties_add_float_slider(grp_quick, "zoom_duration", "Duration (s)", 0.05, 3.0, 0.05)

    obs.obs_properties_add_group(props, "quick_setup", "Ã¢Å¡Â¡ Quick Setup", obs.OBS_GROUP_NORMAL, grp_quick)

    --==========================
    -- ANIMATION (collapsed)
    --==========================
    local grp_anim = obs.obs_properties_create()

    -- Overshoot/Bounce
    obs.obs_properties_add_float_slider(grp_anim, "zoom_overshoot", "Bounce", 0.0, 1.0, 0.01)

    -- Easing Curve
    local p_easing = obs.obs_properties_add_list(grp_anim, "zoom_easing", "Easing Curve",
        obs.OBS_COMBO_TYPE_LIST, obs.OBS_COMBO_FORMAT_STRING)
    for _, name in ipairs(Easing.NAMES) do
        obs.obs_property_list_add_string(p_easing, name, name)
    end

    obs.obs_properties_add_group(props, "animation", "Ã°Å¸Å½Â¬ Animation", obs.OBS_GROUP_NORMAL, grp_anim)

    --==========================
    -- MOUSE FOLLOW (collapsed)
    --==========================
    local grp_follow = obs.obs_properties_create()

    obs.obs_properties_add_bool(grp_follow, "auto_follow", "Auto-Follow Mouse")
    obs.obs_properties_add_float_slider(grp_follow, "follow_smooth_time", "Smoothness", 0.01, 1.0, 0.01)
    obs.obs_properties_add_int_slider(grp_follow, "follow_dead_zone", "Dead Zone (px)", 0, 500, 1)

    obs.obs_properties_add_group(props, "follow", "Ã°Å¸Å½Â¯ Mouse Follow", obs.OBS_GROUP_NORMAL, grp_follow)

    --==========================
    -- ADVANCED (collapsed)
    --==========================
    local grp_adv = obs.obs_properties_create()
    obs.obs_properties_add_float_slider(grp_adv, "scroll_step", "Scroll Zoom Step", 0.1, 1.0, 0.05)
    obs.obs_properties_add_bool(grp_adv, "debug_logs", "Debug Logging")
    obs.obs_properties_add_group(props, "advanced", "Ã¢Å¡â„¢Ã¯Â¸Â Advanced", obs.OBS_GROUP_NORMAL, grp_adv)

    --==========================
    -- API SERVER (collapsed)
    --==========================
    local grp_api = obs.obs_properties_create()
    obs.obs_properties_add_bool(grp_api, "api_enabled", "Enable UDP API Server")
    obs.obs_properties_add_int(grp_api, "api_port", "API Port", 1024, 65535, 1)
    obs.obs_properties_add_group(props, "api_server", "Ã°Å¸Å’Â UDP API Server", obs.OBS_GROUP_NORMAL, grp_api)

    --==========================
    -- HELP (collapsed)
    --==========================
    local grp_help = obs.obs_properties_create()
    obs.obs_properties_add_text(grp_help, "help_text",
        "QUICK START:\n" ..
        "1. Select your capture source above\n" ..
        "2. Set hotkeys in OBS Settings Ã¢â€ â€™ Hotkeys\n" ..
        "   Ã¢â‚¬Â¢ 'Toggle Zoom to Mouse' Ã¢â‚¬â€ Main zoom\n" ..
        "   Ã¢â‚¬Â¢ 'Toggle Mouse Follow' Ã¢â‚¬â€ Enable/disable follow\n" ..
        "3. Press the hotkey to zoom!\n\n" ..
        "TIPS:\n" ..
        "Ã¢â‚¬Â¢ Zoom centers on mouse position\n" ..
        "Ã¢â‚¬Â¢ Enable Auto-Follow for smooth tracking\n" ..
        "Ã¢â‚¬Â¢ Adjust Dead Zone to reduce jitter",
        obs.OBS_TEXT_INFO)
    obs.obs_properties_add_group(props, "help", "Ã¢Ââ€œ Help", obs.OBS_GROUP_NORMAL, grp_help)

    return props
end

--[[ Called to set default values
--[[ @param data table Settings data
function script_defaults(data)
    obs.obs_data_set_default_string(data, "source", "")
    obs.obs_data_set_default_double(data, "zoom_value", 2.0)
    obs.obs_data_set_default_double(data, "zoom_duration", 0.6)
    obs.obs_data_set_default_double(data, "zoom_overshoot", 0.0)
    obs.obs_data_set_default_string(data, "zoom_easing", "Cubic.Out")
    obs.obs_data_set_default_bool(data, "auto_follow", true)
    obs.obs_data_set_default_double(data, "follow_smooth_time", 0.15)
    obs.obs_data_set_default_int(data, "follow_dead_zone", 5)
    obs.obs_data_set_default_double(data, "scroll_step", 0.25)
    obs.obs_data_set_default_bool(data, "debug_logs", false)
    obs.obs_data_set_default_bool(data, "api_enabled", false)
    obs.obs_data_set_default_int(data, "api_port", 12345)
end

--================================================
-- SCRIPT METADATA
--================================================
script_info = {
    name = "OBS Zoom Pro",
    version = VERSION,
    description = "Intelligent camera zoom functionality with smooth transitions and easing curves.",
    author = "OBS Zoom Pro Team"
}
)
        handle:close()
        if uname == 'Darwin' then
            is_macos = true
            is_linux = false
        end
    end

    return {
        WINDOWS = is_windows,
        LINUX = is_linux,
        MACOS = is_macos
    }
end

local platform = detect_platform()
local IS_WINDOWS = platform.WINDOWS
local IS_LINUX = platform.LINUX
local IS_MACOS = platform.MACOS

-- Log platform detection
log("Platform detected: " .. (jit and jit.os or "Unknown") .. (IS_WINDOWS and " (Full support)" or " (Basic support)"))

-- Virtual key codes (Lua constants instead of C #define)
local VK_LBUTTON = 0x01
local VK_RBUTTON = 0x02
local VK_MBUTTON = 0x04
local VK_CONTROL = 0x11
local VK_SHIFT = 0x10
local VK_MENU = 0x12  -- Alt

-- FFI declarations for Windows (only if FFI is available)


-- Cursor shape constants (Windows)
local CURSOR_ARROW = 1
local CURSOR_IBEAM = 2
local CURSOR_HAND = 3
local CURSOR_WAIT = 4

-- Module state
local Platform = {
    cursor_shape_available = IS_WINDOWS,
    last_mouse = { x = 0, y = 0 },
    last_click = false,
}

-- Get mouse position (cross-platform)
function Platform.get_mouse_pos()
    if IS_WINDOWS then
        local success, pt = pcall(function()
            local pt = ffi.new("POINT")
            if ffi.C.GetCursorPos(pt) ~= 0 then
                return { x = tonumber(pt.x), y = tonumber(pt.y) }
            end
            return nil
        end)
        if success and pt then
            return pt
        end
    elseif IS_LINUX then
        -- Linux: Use xdotool if available, fallback to X11
        local success, result = pcall(function()
            local handle = io.popen("xdotool getmouselocation 2>/dev/null || echo 'x:0 y:0'")
            if handle then
                local output = handle:read("*a")
                handle:close()
                local x, y = output:match("x:(%d+)%s+y:(%d+)")
                if x and y then
                    return { x = tonumber(x), y = tonumber(y) }
                end
            end
            return nil
        end)
        if success and result then
            return result
        end
    elseif IS_MACOS then
        -- macOS: Use osascript
        local success, result = pcall(function()
            local handle = io.popen(--[[osascript -e 'tell application "System Events" to get position of the mouse' 2>/dev/null || echo "0, 0"]])
            if handle then
                local output = handle:read("*a")
                handle:close()
                local x, y = output:match("(%d+),%s*(%d+)")
                if x and y then
                    return { x = tonumber(x), y = tonumber(y) }
                end
            end
            return nil
        end)
        if success and result then
            return result
        end
    end

    -- Fallback
    return { x = 0, y = 0 }
end

-- Check if left mouse button is clicked (Windows only, others return false)
function Platform.is_clicking()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x01) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if a modifier key is held (Windows only)
function Platform.is_key_held(vk_code)
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(vk_code) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if cursor is a pointer/hand (Windows only)
function Platform.is_cursor_pointer()
    if IS_WINDOWS then
        local success, result = pcall(function()
            local ci = ffi.new("CURSORINFO")
            ci.cbSize = ffi.sizeof("CURSORINFO")
            if ffi.C.GetCursorInfo(ci) ~= 0 then
                -- Check if hCursor is a hand pointer
                -- This is a simplified check; real implementation would compare cursor handles
                return ci.flags ~= 0  -- Simplified; actual implementation needs cursor handle comparison
            end
            return false
        end)
        return success and result or false
    end
    return false
end

-- Get cursor shape (Windows only, returns "arrow" for others)
function Platform.get_cursor_shape()
    if IS_WINDOWS then
        local success, result = pcall(function()
            local ci = ffi.new("CURSORINFO")
            ci.cbSize = ffi.sizeof("CURSORINFO")
            if ffi.C.GetCursorInfo(ci) ~= 0 and ci.hCursor ~= nil then
                local addr = tonumber(ffi.cast("uintptr_t", ci.hCursor))
                -- Common cursor IDs (these are typical values, may vary)
                -- IDC_ARROW = 32512, IDC_IBEAM = 32513, IDC_HAND = 32649
                -- We use address ranges as heuristic
                return "arrow"  -- Simplified; actual implementation would map handles
            end
            return "arrow"
        end)
        return success and result or "arrow"
    end
    return "arrow"
end

-- Check if Control key is held
function Platform.is_ctrl_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x11) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if Shift key is held
function Platform.is_shift_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x10) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if Alt key is held
function Platform.is_alt_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x12) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Convenience wrapper functions
function platform_get_mouse_pos()
    return Platform.get_mouse_pos()
end

function platform_is_clicking()
    return Platform.is_clicking()
end

function platform_is_cursor_pointer()
    return Platform.is_cursor_pointer()
end

function platform_cursor_shape_available()
    return Platform.cursor_shape_available
end

function platform_is_ctrl_held()
    return Platform.is_ctrl_held()
end

function platform_is_shift_held()
    return Platform.is_shift_held()
end

function platform_is_alt_held()
    return Platform.is_alt_held()
end

--================================================
-- MODULE: State Machine (M05)
--================================================
-- Manages zoom states and transitions
-- States: IDLE, ZOOMING_IN, ZOOMED_IN, ZOOMING_OUT, SCROLLING, JUMPING

local ZoomState = {
    IDLE         = "idle",
    ZOOMING_IN   = "zooming_in",
    ZOOMED_IN    = "zoomed_in",
    ZOOMING_OUT  = "zooming_out",
    SCROLLING    = "scrolling",    -- Scroll wheel mid-transition
    JUMPING      = "jumping",      -- Bookmark transition
}

local StateMachine = {
    state = ZoomState.IDLE,
    zoom_time = 0,          -- Animation progress (0 Ã¢â€ â€™ 1)
    zoom_level = 1.0,       -- Current zoom factor
    target_level = 1.0,     -- Target zoom factor
    start_crop = nil,       -- Crop at animation start {x, y, w, h}
    target_crop = nil,      -- Crop at animation end {x, y, w, h}
    following = false,      -- Mouse follow active

    -- Transition guards
    can_zoom_in = function(self)
        return self.state == ZoomState.IDLE
    end,

    can_zoom_out = function(self)
        return self.state == ZoomState.ZOOMED_IN
            or self.state == ZoomState.SCROLLING
    end,

    can_scroll = function(self)
        return self.state == ZoomState.ZOOMED_IN
            or self.state == ZoomState.IDLE
            or self.state == ZoomState.SCROLLING
    end,

    can_jump = function(self)
        return self.state ~= ZoomState.ZOOMING_IN
           and self.state ~= ZoomState.ZOOMING_OUT
           and self.state ~= ZoomState.JUMPING
    end,

    is_animating = function(self)
        return self.state == ZoomState.ZOOMING_IN
            or self.state == ZoomState.ZOOMING_OUT
            or self.state == ZoomState.SCROLLING
            or self.state == ZoomState.JUMPING
    end,

    is_zoomed = function(self)
        return self.state ~= ZoomState.IDLE
    end,
}

-- Transition to a new state
function StateMachine:transition(new_state, params)
    local old = self.state
    self.state = new_state
    self.zoom_time = 0

    if params then
        if params.start_crop then self.start_crop = params.start_crop end
        if params.target_crop then self.target_crop = params.target_crop end
        if params.target_level then self.target_level = params.target_level end
    end

    log("State: " .. old .. " Ã¢â€ â€™ " .. new_state)
end

-- Complete the current animation
function StateMachine:complete()
    if self.state == ZoomState.ZOOMING_IN
       or self.state == ZoomState.SCROLLING
       or self.state == ZoomState.JUMPING then
        self.zoom_level = self.target_level
        self.state = ZoomState.ZOOMED_IN
        self.zoom_time = 0
        log("State: " .. self.state .. " Ã¢â€ â€™ ZOOMED_IN (complete)")
    elseif self.state == ZoomState.ZOOMING_OUT then
        self.zoom_level = 1.0
        self.target_level = 1.0
        self.start_crop = nil
        self.target_crop = nil
        self.following = false
        self.state = ZoomState.IDLE
        self.zoom_time = 0
        log("State: ZOOMING_OUT Ã¢â€ â€™ IDLE (complete)")
    end
end

-- Reset to initial state
function StateMachine:reset()
    self.state = ZoomState.IDLE
    self.zoom_time = 0
    self.zoom_level = 1.0
    self.target_level = 1.0
    self.start_crop = nil
    self.target_crop = nil
    self.following = false
    log("StateMachine: Reset to IDLE")
end

-- Get current animation progress (0-1)
function StateMachine:get_progress()
    return clamp(0, 1, self.zoom_time)
end

-- Check if in a specific state
function StateMachine:is_state(state)
    return self.state == state
end

-- Get state name for display
function StateMachine:get_state_name()
    return self.state
end

-- Create a new state machine instance (for testing/isolation)
function StateMachine:new()
    local sm = {}
    setmetatable(sm, { __index = self })
    sm.state = ZoomState.IDLE
    sm.zoom_time = 0
    sm.zoom_level = 1.0
    sm.target_level = 1.0
    sm.start_crop = nil
    sm.target_crop = nil
    sm.following = false
    return sm
end

-- Global state machine instance
local SM = StateMachine:new()

--================================================
-- MODULE: Crop Filter Manager (M07)
--================================================
-- Manages the crop/pad filter used to simulate zoom
-- Creates, updates, and destroys the filter automatically

local FILTER_PREFIX = "[ZoomPro] "
local CROP_FILTER_NAME = FILTER_PREFIX .. "Crop"

local CropFilterManager = {
    filter = nil,           -- The crop filter source
    source = nil,           -- The parent source
    original_crop = nil,    -- Original crop values for restoration
    current_crop = { x = 0, y = 0, w = 0, h = 0 },
    initialized = false,
}

-- Create the crop filter on a source
function CropFilterManager:create(source)
    if not source then
        log("CropFilter: No source provided")
        return false
    end

    self:cleanup()  -- Clean up any existing filter
    self.source = source

    -- Check if our filter already exists
    local existing = obs.obs_source_get_filter_by_name(source, CROP_FILTER_NAME)
    if existing then
        log("CropFilter: Found existing filter")
        self.filter = existing
        self.initialized = true
        return true
    end

    -- Create new crop/pad filter
    local settings = obs.obs_data_create()
    obs.obs_data_set_int(settings, "left", 0)
    obs.obs_data_set_int(settings, "top", 0)
    obs.obs_data_set_int(settings, "right", 0)
    obs.obs_data_set_int(settings, "bottom", 0)
    obs.obs_data_set_bool(settings, "relative", false)  -- Absolute positioning

    self.filter = obs.obs_source_create_private(
        "crop_filter",      -- Filter type
        CROP_FILTER_NAME,   -- Filter name
        settings            -- Settings
    )

    obs.obs_data_release(settings)

    if not self.filter then
        log("CropFilter: Failed to create filter")
        return false
    end

    -- Add filter to source
    obs.obs_source_filter_add(source, self.filter)

    -- Store original crop (none)
    self.original_crop = { x = 0, y = 0, w = 0, h = 0 }

    self.initialized = true
    log("CropFilter: Created successfully")
    return true
end

-- Update the crop filter with new values
function CropFilterManager:update(x, y, w, h)
    if not self.filter or not self.initialized then
        return false
    end

    -- Store current crop
    self.current_crop = { x = x, y = y, w = w, h = h }

    -- Get filter settings
    local settings = obs.obs_source_get_settings(self.filter)
    if not settings then
        return false
    end

    -- Calculate crop values
    -- For crop_filter: left, top are absolute position
    -- right, bottom are width/height from right/bottom edge
    -- We need to convert our x, y, w, h to this format

    -- Get source dimensions
    local source_w = obs.obs_source_get_width(self.source)
    local source_h = obs.obs_source_get_height(self.source)

    if source_w == 0 or source_h == 0 then
        obs.obs_data_release(settings)
        return false
    end

    -- Set crop values
    -- left = x offset from left
    -- top = y offset from top
    -- right = source_w - (x + w) = remaining width on right
    -- bottom = source_h - (y + h) = remaining height on bottom
    local left = math.floor(x)
    local top = math.floor(y)
    local right = math.floor(source_w - (x + w))
    local bottom = math.floor(source_h - (y + h))

    -- Clamp to valid values
    left = math.max(0, left)
    top = math.max(0, top)
    right = math.max(0, right)
    bottom = math.max(0, bottom)

    obs.obs_data_set_int(settings, "left", left)
    obs.obs_data_set_int(settings, "top", top)
    obs.obs_data_set_int(settings, "right", right)
    obs.obs_data_set_int(settings, "bottom", bottom)

    -- Update the filter
    obs.obs_source_update(self.filter, settings)
    obs.obs_data_release(settings)

    return true
end

-- Get current crop values
function CropFilterManager:get_crop()
    return self.current_crop
end

-- Reset crop to original (no crop)
function CropFilterManager:reset()
    if not self.filter or not self.initialized then
        return false
    end

    local settings = obs.obs_source_get_settings(self.filter)
    if settings then
        obs.obs_data_set_int(settings, "left", 0)
        obs.obs_data_set_int(settings, "top", 0)
        obs.obs_data_set_int(settings, "right", 0)
        obs.obs_data_set_int(settings, "bottom", 0)
        obs.obs_source_update(self.filter, settings)
        obs.obs_data_release(settings)
    end

    self.current_crop = { x = 0, y = 0, w = 0, h = 0 }
    return true
end

-- Remove the filter and restore original state
function CropFilterManager:cleanup()
    if self.filter and self.source then
        -- Reset to no crop first
        self:reset()

        -- Remove filter from source
        obs.obs_source_filter_remove(self.source, self.filter)
        obs.obs_source_release(self.filter)
        self.filter = nil
        log("CropFilter: Removed from source")
    end

    self.source = nil
    self.original_crop = nil
    self.current_crop = { x = 0, y = 0, w = 0, h = 0 }
    self.initialized = false
end

-- Check if filter is ready
function CropFilterManager:is_ready()
    return self.initialized and self.filter ~= nil
end

-- Get source dimensions
function CropFilterManager:get_source_size()
    if not self.source then
        return 0, 0
    end
    return obs.obs_source_get_width(self.source), obs.obs_source_get_height(self.source)
end

-- Convenience wrapper functions
function crop_filter_create(source)
    return CropFilterManager:create(source)
end

function crop_filter_update(x, y, w, h)
    return CropFilterManager:update(x, y, w, h)
end

function crop_filter_reset()
    return CropFilterManager:reset()
end

function crop_filter_cleanup()
    return CropFilterManager:cleanup()
end

function crop_filter_is_ready()
    return CropFilterManager:is_ready()
end

function crop_filter_get_crop()
    return CropFilterManager:get_crop()
end

function crop_filter_get_source_size()
    return CropFilterManager:get_source_size()
end

--================================================
-- MODULE: Source Manager (M08)
--================================================
-- Handles finding sources in scenes, capturing transforms,
-- and managing source state for zoom operations

local SourceManager = {
    source = nil,           -- Current zoom source
    sceneitem = nil,        -- Scene item reference
    scene = nil,            -- Current scene
    original_transform = nil, -- Saved original transform
    source_name = "",       -- Source name for settings
    initialized = false,
}

-- Transform data structure
local TransformData = {
    pos = { x = 0, y = 0 },
    scale = { x = 1.0, y = 1.0 },
    rot = 0,
    bounds_type = 0,
    bounds = { x = 0, y = 0 },
    crop = { left = 0, top = 0, right = 0, bottom = 0 },
}

-- Find a source in a scene (BFS through groups)
function SourceManager:find_sceneitem(scene, source_name)
    if not scene or not source_name then
        return nil
    end

    local scene_source = obs.obs_scene_from_source(scene)
    if not scene_source then
        return nil
    end

    -- BFS queue
    local queue = {}
    table.insert(queue, scene_source)

    while #queue > 0 do
        local current_scene = table.remove(queue, 1)

        -- Iterate through items
        local items = obs.obs_scene_enum_items(current_scene)
        if items then
            for _, item in ipairs(items) do
                local item_source = obs.obs_sceneitem_get_source(item)
                if item_source then
                    local name = obs.obs_source_get_name(item_source)

                    -- Check if this is our target
                    if name == source_name then
                        obs.sceneitem_list_release(items)
                        return item
                    end

                    -- Check if this is a group (nested scene)
                    if obs.obs_source_get_type(item_source) == obs.OBS_SOURCE_TYPE_INPUT then
                        local id = obs.obs_source_get_id(item_source)
                        if id == "group" then
                            local group_scene = obs.obs_group_from_source(item_source)
                            if group_scene then
                                table.insert(queue, group_scene)
                            end
                        end
                    end
                end
            end
            obs.sceneitem_list_release(items)
        end
    end

    return nil
end

-- Capture the current transform of a scene item
function SourceManager:capture_transform(sceneitem)
    if not sceneitem then
        return nil
    end

    local transform = {}

    -- Position
    local pos = obs.vec2()
    obs.obs_sceneitem_get_pos(sceneitem, pos)
    transform.pos = { x = pos.x, y = pos.y }

    -- Scale
    local scale = obs.vec2()
    obs.obs_sceneitem_get_scale(sceneitem, scale)
    transform.scale = { x = scale.x, y = scale.y }

    -- Rotation
    transform.rot = obs.obs_sceneitem_get_rot(sceneitem)

    -- Bounds
    transform.bounds_type = obs.obs_sceneitem_get_bounds_type(sceneitem)
    local bounds = obs.vec2()
    obs.obs_sceneitem_get_bounds(sceneitem, bounds)
    transform.bounds = { x = bounds.x, y = bounds.y }

    -- Crop
    local crop = obs.obs_sceneitem_crop()
    obs.obs_sceneitem_get_crop(sceneitem, crop)
    transform.crop = {
        left = crop.left,
        top = crop.top,
        right = crop.right,
        bottom = crop.bottom
    }

    return transform
end

-- Restore a saved transform to a scene item
function SourceManager:restore_transform(sceneitem, transform)
    if not sceneitem or not transform then
        return false
    end

    -- Position
    local pos = obs.vec2()
    pos.x = transform.pos.x
    pos.y = transform.pos.y
    obs.obs_sceneitem_set_pos(sceneitem, pos)

    -- Scale
    local scale = obs.vec2()
    scale.x = transform.scale.x
    scale.y = transform.scale.y
    obs.obs_sceneitem_set_scale(sceneitem, scale)

    -- Rotation
    obs.obs_sceneitem_set_rot(sceneitem, transform.rot)

    -- Bounds
    obs.obs_sceneitem_set_bounds_type(sceneitem, transform.bounds_type)
    local bounds = obs.vec2()
    bounds.x = transform.bounds.x
    bounds.y = transform.bounds.y
    obs.obs_sceneitem_set_bounds(sceneitem, bounds)

    -- Crop
    local crop = obs.obs_sceneitem_crop()
    crop.left = transform.crop.left
    crop.top = transform.crop.top
    crop.right = transform.crop.right
    crop.bottom = transform.crop.bottom
    obs.obs_sceneitem_set_crop(sceneitem, crop)

    return true
end

-- Initialize with a source name
function SourceManager:init(source_name)
    self:release()  -- Clean up any existing state

    if not source_name or source_name == "" then
        log("SourceManager: No source name provided")
        return false
    end

    self.source_name = source_name

    -- Get current scene
    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then
        log("SourceManager: No current scene")
        return false
    end

    self.scene = scene_source

    -- Find the scene item
    self.sceneitem = self:find_sceneitem(scene_source, source_name)
    if not self.sceneitem then
        log("SourceManager: Source not found in scene: " .. source_name)
        obs.obs_source_release(scene_source)
        return false
    end

    -- Get the source
    self.source = obs.obs_sceneitem_get_source(self.sceneitem)
    if not self.source then
        log("SourceManager: Failed to get source from sceneitem")
        obs.obs_source_release(scene_source)
        return false
    end

    -- Capture original transform
    self.original_transform = self:capture_transform(self.sceneitem)

    -- Create crop filter
    if not crop_filter_create(self.source) then
        log("SourceManager: Failed to create crop filter")
        obs.obs_source_release(scene_source)
        return false
    end

    self.initialized = true
    log("SourceManager: Initialized with source: " .. source_name)

    obs.obs_source_release(scene_source)
    return true
end

-- Release all resources
function SourceManager:release()
    -- Clean up crop filter
    crop_filter_cleanup()

    -- Restore original transform if we have it
    if self.sceneitem and self.original_transform then
        self:restore_transform(self.sceneitem, self.original_transform)
        log("SourceManager: Restored original transform")
    end

    self.source = nil
    self.sceneitem = nil
    self.scene = nil
    self.original_transform = nil
    self.initialized = false

    log("SourceManager: Released")
end

-- Get source dimensions
function SourceManager:get_source_size()
    if not self.source then
        return 0, 0
    end
    return obs.obs_source_get_width(self.source), obs.obs_source_get_height(self.source)
end

-- Check if source is valid
function SourceManager:is_valid()
    return self.initialized and self.source ~= nil and self.sceneitem ~= nil
end

-- Get source info
function SourceManager:get_info()
    if not self:is_valid() then
        return nil
    end

    return {
        name = self.source_name,
        width = obs.obs_source_get_width(self.source),
        height = obs.obs_source_get_height(self.source),
    }
end

-- Get list of available capture sources
function SourceManager.get_available_sources()
    local sources = {}

    -- Get all sources
    local source_list = obs.obs_enum_sources()
    if source_list then
        for _, source in ipairs(source_list) do
            local source_id = obs.obs_source_get_id(source)
            local name = obs.obs_source_get_name(source)

            -- Filter for capture sources
            local is_capture = false
            if source_id == "monitor_capture" or      -- Display capture
               source_id == "window_capture" or       -- Window capture
               source_id == "game_capture" or         -- Game capture
               source_id == "xshm_input" or           -- Linux X11 capture
               source_id == "av_capture_input" then   -- macOS capture
                is_capture = true
            end

            if is_capture then
                table.insert(sources, {
                    name = name,
                    id = source_id,
                })
            end
        end
        obs.source_list_release(source_list)
    end

    return sources
end

-- Convenience wrapper functions
function source_manager_init(source_name)
    return SourceManager:init(source_name)
end

function source_manager_release()
    return SourceManager:release()
end

function source_manager_is_valid()
    return SourceManager:is_valid()
end

function source_manager_get_source()
    return SourceManager.source
end

function source_manager_get_sceneitem()
    return SourceManager.sceneitem
end

function source_manager_get_size()
    return SourceManager:get_source_size()
end

function source_manager_get_available_sources()
    return SourceManager.get_available_sources()
end

--================================================
-- MODULE: Camera Physics (M06)
--================================================
-- Handles camera position calculations, dead zones,
-- and SmoothDamp-based camera movement

local CameraPhysics = {
    -- Smoothed camera position
    pos = { x = 0, y = 0 },

    -- Velocities for SmoothDamp
    vel_x = { val = 0 },
    vel_y = { val = 0 },

    -- Dead zone state
    tracked_pos = { x = 0, y = 0 },
    dead_zone_active = false,

    -- Last camera position (for velocity calculation)
    last_pos = { x = 0, y = 0 },

    -- Monitor offset (for multi-monitor setups)
    monitor_offset = { x = 0, y = 0 },
}

-- Initialize camera tracking with starting position
function CameraPhysics:init(mouse_pos)
    if mouse_pos then
        self.pos.x = mouse_pos.x
        self.pos.y = mouse_pos.y
        self.tracked_pos.x = mouse_pos.x
        self.tracked_pos.y = mouse_pos.y
    end
    self.vel_x.val = 0
    self.vel_y.val = 0
    self.last_pos.x = self.pos.x
    self.last_pos.y = self.pos.y
end

-- Apply dead zone to mouse input
-- Returns the position the camera should track
function CameraPhysics:apply_dead_zone(mouse_pos, dead_zone_radius)
    if not mouse_pos then
        return self.tracked_pos
    end

    if dead_zone_radius <= 0 then
        self.tracked_pos.x = mouse_pos.x
        self.tracked_pos.y = mouse_pos.y
        return self.tracked_pos
    end

    -- Calculate distance from tracked position to mouse
    local dx = mouse_pos.x - self.tracked_pos.x
    local dy = mouse_pos.y - self.tracked_pos.y
    local dist = math.sqrt(dx * dx + dy * dy)

    if dist <= dead_zone_radius then
        -- Mouse is within dead zone, don't move tracked position
        self.dead_zone_active = true
        return self.tracked_pos
    end

    -- Mouse is outside dead zone
    -- Move tracked position so it stays exactly dead_zone_radius from mouse
    self.dead_zone_active = false
    local excess = dist - dead_zone_radius
    local nx = dx / dist  -- Normalized direction
    local ny = dy / dist

    self.tracked_pos.x = self.tracked_pos.x + nx * excess
    self.tracked_pos.y = self.tracked_pos.y + ny * excess

    return self.tracked_pos
end

-- Smooth the input position using SmoothDamp
function CameraPhysics:smooth_input(target_pos, smooth_time, dt)
    if not target_pos then
        return self.pos
    end

    local max_speed = 100000  -- Very high max speed for smooth camera

    self.pos.x = SmoothDamp(self.pos.x, target_pos.x, self.vel_x, smooth_time, max_speed, dt)
    self.pos.y = SmoothDamp(self.pos.y, target_pos.y, self.vel_y, smooth_time, max_speed, dt)

    return self.pos
end

-- Calculate the crop rectangle for a given zoom level and center position
function CameraPhysics:compute_crop(center_x, center_y, zoom_level, source_w, source_h)
    if zoom_level <= 1.0 then
        -- No zoom, return full source
        return {
            x = 0,
            y = 0,
            w = source_w,
            h = source_h,
        }
    end

    -- Calculate crop dimensions
    local crop_w = source_w / zoom_level
    local crop_h = source_h / zoom_level

    -- Center the crop on the target position
    local crop_x = center_x - crop_w / 2
    local crop_y = center_y - crop_h / 2

    -- Clamp to source bounds
    crop_x = clamp(0, source_w - crop_w, crop_x)
    crop_y = clamp(0, source_h - crop_h, crop_y)

    return {
        x = crop_x,
        y = crop_y,
        w = crop_w,
        h = crop_h,
    }
end

-- Calculate target crop for zoom animation
-- mouse_pos: current mouse position
-- zoom_level: target zoom level
-- source_w, source_h: source dimensions
-- monitor_offset: offset for multi-monitor (optional)
function CameraPhysics:get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
    if not mouse_pos then
        return nil
    end

    -- Apply monitor offset if provided
    local target_x = mouse_pos.x
    local target_y = mouse_pos.y

    if monitor_offset then
        target_x = target_x - monitor_offset.x
        target_y = target_y - monitor_offset.y
    end

    -- Clamp to source bounds
    target_x = clamp(0, source_w, target_x)
    target_y = clamp(0, source_h, target_y)

    return self:compute_crop(target_x, target_y, zoom_level, source_w, source_h)
end

-- Interpolate between two crop rectangles
function CameraPhysics:lerp_crop(start_crop, end_crop, t, easing_fn)
    if not start_crop or not end_crop then
        return nil
    end

    t = clamp(0, 1, t)

    -- Apply easing
    local eased_t = easing_fn and easing_fn(t) or t

    return {
        x = lerp(start_crop.x, end_crop.x, eased_t),
        y = lerp(start_crop.y, end_crop.y, eased_t),
        w = lerp(start_crop.w, end_crop.w, eased_t),
        h = lerp(start_crop.h, end_crop.h, eased_t),
    }
end

-- Get camera velocity (for motion blur)
function CameraPhysics:get_velocity()
    return {
        x = self.pos.x - self.last_pos.x,
        y = self.pos.y - self.last_pos.y,
    }
end

-- Update last position (call at end of frame)
function CameraPhysics:update_last_pos()
    self.last_pos.x = self.pos.x
    self.last_pos.y = self.pos.y
end

-- Set monitor offset
function CameraPhysics:set_monitor_offset(offset)
    self.monitor_offset = offset or { x = 0, y = 0 }
end

-- Reset camera state
function CameraPhysics:reset()
    self.pos = { x = 0, y = 0 }
    self.vel_x = { val = 0 }
    self.vel_y = { val = 0 }
    self.tracked_pos = { x = 0, y = 0 }
    self.dead_zone_active = false
    self.last_pos = { x = 0, y = 0 }
end

-- Convenience wrapper functions
function camera_physics_init(mouse_pos)
    return CameraPhysics:init(mouse_pos)
end

function camera_physics_apply_dead_zone(mouse_pos, dead_zone_radius)
    return CameraPhysics:apply_dead_zone(mouse_pos, dead_zone_radius)
end

function camera_physics_smooth_input(target_pos, smooth_time, dt)
    return CameraPhysics:smooth_input(target_pos, smooth_time, dt)
end

function camera_physics_compute_crop(center_x, center_y, zoom_level, source_w, source_h)
    return CameraPhysics:compute_crop(center_x, center_y, zoom_level, source_w, source_h)
end

function camera_physics_get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
    return CameraPhysics:get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
end

function camera_physics_lerp_crop(start_crop, end_crop, t, easing_fn)
    return CameraPhysics:lerp_crop(start_crop, end_crop, t, easing_fn)
end

function camera_physics_get_velocity()
    return CameraPhysics:get_velocity()
end

function camera_physics_update_last_pos()
    return CameraPhysics:update_last_pos()
end

function camera_physics_reset()
    return CameraPhysics:reset()
end

--================================================
-- MODULE: Timer & Main Loop (M09)
--================================================
-- Core integration module that handles frame-by-frame updates,
-- input processing, state machine updates, and output

-- Configuration (will be populated from settings)
local cfg = {
    source_name = "",
    zoom_value = 2.0,
    max_zoom = 10.0,
    zoom_duration = 0.6,
    zoom_overshoot = 0.0,
    zoom_easing = "Cubic.Out",

    auto_follow = true,
    follow_smooth_time = 0.15,
    follow_dead_zone = 5,

    debug_logs = false,
}

-- Timing
local last_tick_time = 0
local timer_running = false

-- Frame diff tracking (skip updates if nothing changed)
local last_output = { x = -1, y = -1, w = -1, h = -1 }

-- Original crop for zoom out
local original_crop = { x = 0, y = 0, w = 0, h = 0 }

-- Hotkey IDs
local hotkey_toggle_zoom = nil
local hotkey_toggle_follow = nil

-- Get reliable delta time
local function get_dt()
    local now = os.clock()
    local dt = now - last_tick_time
    last_tick_time = now
    return clamp(0.001, 0.1, dt)  -- Guard against freezes and div/zero
end

-- Start the timer
local function start_timer()
    if not timer_running then
        timer_running = true
        last_tick_time = os.clock()
        -- Use frame-synced interval
        local interval = 16  -- Default to ~60fps
        obs.timer_add(on_timer, interval)
        log("Timer: Started")
    end
end

-- Stop the timer
local function stop_timer()
    if timer_running then
        timer_running = false
        obs.timer_remove(on_timer)
        log("Timer: Stopped")
    end
end

-- Initialize mouse tracking
local function init_mouse_tracking(mouse_pos)
    camera_physics_init(mouse_pos)
    original_crop = {
        x = 0,
        y = 0,
        w = 0,
        h = 0,
    }
end

-- Main timer callback
function on_timer()
    local dt = get_dt()

    -- Guard: No valid source
    if not source_manager_is_valid() then
        return
    end

    --==========================
    -- 1. INPUT
    --==========================
    local raw_mouse = platform_get_mouse_pos()

    --==========================
    -- 2. STATE MACHINE UPDATE
    --==========================
    if SM:is_animating() then
        SM.zoom_time = SM.zoom_time + (dt / cfg.zoom_duration)

        -- Check for completion
        if SM.zoom_time >= 1.0 then
            SM:complete()

            -- Auto-enable follow after zoom in
            if SM.state == ZoomState.ZOOMED_IN and cfg.auto_follow then
                SM.following = true
            end

            -- Stop timer if idle
            if SM.state == ZoomState.IDLE then
                stop_timer()
            end
        end
    end

    --==========================
    -- 3. CAMERA POSITION
    --==========================
    local crop = nil
    local source_w, source_h = source_manager_get_size()

    if source_w == 0 or source_h == 0 then
        return
    end

    if SM:is_animating() then
        -- Animate between start and target crop
        local easing_fn = Easing.get(cfg.zoom_easing, cfg.zoom_overshoot)
        crop = camera_physics_lerp_crop(SM.start_crop, SM.target_crop, SM.zoom_time, easing_fn)
    elseif SM:is_zoomed() and SM.following then
        -- Follow mouse with dead zone and smoothing
        local tracked = camera_physics_apply_dead_zone(raw_mouse, cfg.follow_dead_zone)
        local smoothed = camera_physics_smooth_input(tracked, cfg.follow_smooth_time, dt)
        crop = camera_physics_compute_crop(smoothed.x, smoothed.y, SM.zoom_level, source_w, source_h)
        camera_physics_update_last_pos()
    elseif SM:is_zoomed() then
        -- Static zoom (not following)
        crop = camera_physics_get_target_crop(
            { x = SM.target_crop.x + SM.target_crop.w / 2, y = SM.target_crop.y + SM.target_crop.h / 2 },
            SM.zoom_level, source_w, source_h, nil
        )
    end

    --==========================
    -- 4. OUTPUT (Diff-based)
    --==========================
    if crop then
        local cx = math.floor(crop.x)
        local cy = math.floor(crop.y)
        local cw = math.floor(crop.w)
        local ch = math.floor(crop.h)

        if cx ~= last_output.x or cy ~= last_output.y or
           cw ~= last_output.w or ch ~= last_output.h then
            crop_filter_update(cx, cy, cw, ch)
            last_output.x = cx
            last_output.y = cy
            last_output.w = cw
            last_output.h = ch
        end
    end
end

--==========================
-- HOTKEY HANDLERS
--==========================

function on_toggle_zoom(pressed)
    if not pressed then return end

    if not source_manager_is_valid() then
        log("Toggle Zoom: No valid source")
        return
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        log("Toggle Zoom: Invalid source dimensions")
        return
    end

    if SM.state == ZoomState.IDLE then
        -- ZOOM IN
        local mouse = platform_get_mouse_pos()
        init_mouse_tracking(mouse)

        -- Store original crop
        original_crop = { x = 0, y = 0, w = source_w, h = source_h }

        -- Calculate target crop
        local target_crop = camera_physics_get_target_crop(mouse, cfg.zoom_value, source_w, source_h, nil)

        SM:transition(ZoomState.ZOOMING_IN, {
            start_crop = original_crop,
            target_crop = target_crop,
            target_level = cfg.zoom_value
        })

        start_timer()

    elseif SM.state == ZoomState.ZOOMED_IN then
        -- ZOOM OUT
        SM.following = false

        local current = crop_filter_get_crop()
        SM:transition(ZoomState.ZOOMING_OUT, {
            start_crop = current,
            target_crop = original_crop,
            target_level = 1.0
        })

        start_timer()
    end
    -- Ignore if already animating (guard against rapid presses)
end

function on_toggle_follow(pressed)
    if not pressed then return end
    if not SM:is_zoomed() then return end

    SM.following = not SM.following
    log("Follow: " .. tostring(SM.following))

    if SM.following and not timer_running then
        start_timer()
    end
end

--==========================
-- HOTKEY REGISTRATION
--==========================

local function register_hotkeys(settings)
    -- Toggle Zoom hotkey
    hotkey_toggle_zoom = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.toggle_zoom",
        "Toggle Zoom to Mouse",
        on_toggle_zoom
    )

    -- Toggle Follow hotkey
    hotkey_toggle_follow = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.toggle_follow",
        "Toggle Mouse Follow",
        on_toggle_follow
    )

    -- Load saved hotkey bindings
    local toggle_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.toggle_zoom")
    if toggle_array then
        obs.obs_hotkey_load(hotkey_toggle_zoom, toggle_array)
        obs.obs_data_array_release(toggle_array)
    end

    local follow_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.toggle_follow")
    if follow_array then
        obs.obs_hotkey_load(hotkey_toggle_follow, follow_array)
        obs.obs_data_array_release(follow_array)
    end

    -- Register scroll zoom hotkeys
    register_scroll_hotkeys(settings)

    log("Hotkeys: Registered")
end

local function save_hotkeys(settings)
    if hotkey_toggle_zoom then
        local array = obs.obs_hotkey_save(hotkey_toggle_zoom)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.toggle_zoom", array)
        obs.obs_data_array_release(array)
    end

    if hotkey_toggle_follow then
        local array = obs.obs_hotkey_save(hotkey_toggle_follow)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.toggle_follow", array)
        obs.obs_data_array_release(array)
    end

    -- Save scroll zoom hotkeys
    save_scroll_hotkeys(settings)
end

local function unregister_hotkeys()
    if hotkey_toggle_zoom then
        obs.obs_hotkey_unregister(hotkey_toggle_zoom)
        hotkey_toggle_zoom = nil
    end
    if hotkey_toggle_follow then
        obs.obs_hotkey_unregister(hotkey_toggle_follow)
        hotkey_toggle_follow = nil
    end
    -- Unregister scroll zoom hotkeys
    unregister_scroll_hotkeys()
    log("Hotkeys: Unregistered")
end

--==========================
-- SCENE EVENT HANDLERS
--==========================

function on_frontend_event(event)
    if event == obs.OBS_FRONTEND_EVENT_SCENE_CHANGED then
        -- Scene changed, re-acquire source
        log("Event: Scene changed")

        -- Handle scene memory
        scene_memory_on_scene_change()

        if cfg.source_name and cfg.source_name ~= "" then
            source_manager_release()
            source_manager_init(cfg.source_name)
        end
    elseif event == obs.OBS_FRONTEND_EVENT_EXIT then
        -- OBS is closing
        log("Event: OBS exiting")
        stop_timer()
        source_manager_release()
    end
end

--==========================
-- CONFIGURATION UPDATE
--==========================

local function update_config(settings)
    cfg.source_name = obs.obs_data_get_string(settings, "source") or ""
    cfg.zoom_value = obs.obs_data_get_double(settings, "zoom_value")
    cfg.zoom_duration = obs.obs_data_get_double(settings, "zoom_duration")
    cfg.zoom_overshoot = obs.obs_data_get_double(settings, "zoom_overshoot")
    cfg.zoom_easing = obs.obs_data_get_string(settings, "zoom_easing") or "Cubic.Out"

    cfg.auto_follow = obs.obs_data_get_bool(settings, "auto_follow")
    cfg.follow_smooth_time = obs.obs_data_get_double(settings, "follow_smooth_time")
    cfg.follow_dead_zone = obs.obs_data_get_int(settings, "follow_dead_zone")

    cfg.debug_logs = obs.obs_data_get_bool(settings, "debug_logs")
    debug_logs = cfg.debug_logs

    -- Update scroll zoom config
    update_scroll_config(settings)

    -- Check if source changed
    local current_source = source_manager_is_valid() and cfg.source_name
    if cfg.source_name ~= "" and cfg.source_name ~= current_source then
        -- Reset state and reinitialize
        SM:reset()
        stop_timer()
        source_manager_release()
        source_manager_init(cfg.source_name)
    end
end

--================================================
-- MODULE: Scroll Zoom (M10)
--================================================
-- Enables gradual zoom control via scroll wheel with modifier key
-- Provides dynamic zoom level adjustment during zoomed state

local ScrollZoom = {
    -- Hotkey IDs for scroll zoom
    hotkey_scroll_up = nil,
    hotkey_scroll_down = nil,

    -- Configuration (populated from settings)
    scroll_step = 0.25,
    scroll_modifier = "ctrl",  -- "ctrl", "alt", "shift"
}

-- Check if modifier key is held
local function is_modifier_held()
    if ScrollZoom.scroll_modifier == "ctrl" then
        return platform_is_ctrl_held()
    elseif ScrollZoom.scroll_modifier == "alt" then
        return platform_is_alt_held()
    elseif ScrollZoom.scroll_modifier == "shift" then
        return platform_is_shift_held()
    end
    return false
end

-- Handle scroll zoom in
function on_scroll_zoom_up(pressed)
    if not pressed then return end
    on_scroll_zoom(1)
end

-- Handle scroll zoom out
function on_scroll_zoom_down(pressed)
    if not pressed then return end
    on_scroll_zoom(-1)
end

-- Main scroll zoom handler
function on_scroll_zoom(direction)
    -- Check if we can scroll
    if not SM:can_scroll() then return end

    -- Check modifier (optional - can be configured)
    -- For now, we rely on OBS hotkey bindings which can include modifiers

    if not source_manager_is_valid() then
        log("Scroll Zoom: No valid source")
        return
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        return
    end

    -- Calculate new zoom level
    local step = ScrollZoom.scroll_step * direction  -- e.g., 0.25
    local new_level

    if SM.state == ZoomState.IDLE then
        -- Starting from unzoomed
        new_level = 1.0 + step
    else
        -- Already zoomed, adjust level
        new_level = SM.target_level + step
    end

    -- Clamp to valid range
    new_level = clamp(1.0, cfg.max_zoom, new_level)

    -- If we hit 1.0, fully zoom out
    if new_level <= 1.0 then
        if SM:is_zoomed() then
            -- Trigger full zoom out
            local current = crop_filter_get_crop()
            SM.following = false
            SM:transition(ZoomState.ZOOMING_OUT, {
                start_crop = current,
                target_crop = original_crop,
                target_level = 1.0
            })
            start_timer()
        end
        return
    end

    -- Get current mouse position
    local mouse = platform_get_mouse_pos()

    -- Calculate new target crop for new zoom level
    local target_crop = camera_physics_get_target_crop(mouse, new_level, source_w, source_h, nil)

    -- Get current crop as start
    local start_crop
    if SM:is_animating() then
        -- Use current interpolated crop
        start_crop = crop_filter_get_crop()
    elseif SM:is_zoomed() then
        -- Use current crop
        start_crop = crop_filter_get_crop()
    else
        -- Starting from unzoomed
        start_crop = { x = 0, y = 0, w = source_w, h = source_h }
        original_crop = start_crop
        camera_physics_init(mouse)
    end

    -- Transition to new zoom level
    if SM.state == ZoomState.IDLE then
        -- First scroll from unzoomed
        SM:transition(ZoomState.SCROLLING, {
            start_crop = start_crop,
            target_crop = target_crop,
            target_level = new_level
        })
    else
        -- Already zoomed, adjust level (interrupt current animation)
        SM:transition(ZoomState.SCROLLING, {
            start_crop = start_crop,
            target_crop = target_crop,
            target_level = new_level
        })
    end

    start_timer()
    log("Scroll Zoom: Level " .. string.format("%.2f", new_level))
end

-- Zoom to a specific level (for API calls)
function on_scroll_zoom_to(level)
    if not source_manager_is_valid() then return end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then return end

    level = clamp(1.0, cfg.max_zoom, level)

    if level <= 1.0 then
        -- Zoom out
        if SM:is_zoomed() then
            local current = crop_filter_get_crop()
            SM.following = false
            SM:transition(ZoomState.ZOOMING_OUT, {
                start_crop = current,
                target_crop = original_crop,
                target_level = 1.0
            })
            start_timer()
        end
        return
    end

    local mouse = platform_get_mouse_pos()
    local target_crop = camera_physics_get_target_crop(mouse, level, source_w, source_h, nil)

    local start_crop
    if SM:is_zoomed() then
        start_crop = crop_filter_get_crop()
    else
        start_crop = { x = 0, y = 0, w = source_w, h = source_h }
        original_crop = start_crop
        camera_physics_init(mouse)
    end

    SM:transition(ZoomState.SCROLLING, {
        start_crop = start_crop,
        target_crop = target_crop,
        target_level = level
    })

    start_timer()
end

-- Register scroll zoom hotkeys
local function register_scroll_hotkeys(settings)
    -- Scroll Up hotkey
    ScrollZoom.hotkey_scroll_up = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.scroll_up",
        "Zoom In (Scroll)",
        on_scroll_zoom_up
    )

    -- Scroll Down hotkey
    ScrollZoom.hotkey_scroll_down = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.scroll_down",
        "Zoom Out (Scroll)",
        on_scroll_zoom_down
    )

    -- Load saved bindings
    local up_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.scroll_up")
    if up_array then
        obs.obs_hotkey_load(ScrollZoom.hotkey_scroll_up, up_array)
        obs.obs_data_array_release(up_array)
    end

    local down_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.scroll_down")
    if down_array then
        obs.obs_hotkey_load(ScrollZoom.hotkey_scroll_down, down_array)
        obs.obs_data_array_release(down_array)
    end

    log("Scroll Zoom: Hotkeys registered")
end

-- Save scroll hotkey bindings
local function save_scroll_hotkeys(settings)
    if ScrollZoom.hotkey_scroll_up then
        local array = obs.obs_hotkey_save(ScrollZoom.hotkey_scroll_up)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.scroll_up", array)
        obs.obs_data_array_release(array)
    end

    if ScrollZoom.hotkey_scroll_down then
        local array = obs.obs_hotkey_save(ScrollZoom.hotkey_scroll_down)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.scroll_down", array)
        obs.obs_data_array_release(array)
    end
end

-- Unregister scroll hotkeys
local function unregister_scroll_hotkeys()
    if ScrollZoom.hotkey_scroll_up then
        obs.obs_hotkey_unregister(ScrollZoom.hotkey_scroll_up)
        ScrollZoom.hotkey_scroll_up = nil
    end
    if ScrollZoom.hotkey_scroll_down then
        obs.obs_hotkey_unregister(ScrollZoom.hotkey_scroll_down)
        ScrollZoom.hotkey_scroll_down = nil
    end
end

-- Update scroll zoom config
local function update_scroll_config(settings)
    ScrollZoom.scroll_step = obs.obs_data_get_double(settings, "scroll_step")
    ScrollZoom.scroll_modifier = obs.obs_data_get_string(settings, "scroll_modifier") or "ctrl"
end

--================================================
-- PLACEHOLDER: Future Modules
--================================================

-- M01: Configuration & Settings (TODO)
-- M05: Scene Manager (TODO)
-- M06: Source Manager (TODO)
-- M07: Crop/Zoom Controller (TODO)
-- M08: Motion Tracker (TODO)
-- M09: Face Detection (TODO)
-- M11: Audio Reactor (TODO)
-- M12: Transition Manager (TODO)
-- M13: Animation Controller (TODO)
-- M14: Preset Manager (TODO)
-- M15: Hotkey Manager (TODO)
-- M16: UI Components (TODO)
-- M17: Timer/Scheduler (TODO)
-- M18: State Machine (TODO)
-- M19: Performance Monitor (TODO)

--================================================
-- SCRIPT SETTINGS
--================================================
local settings = {}

-- Default settings
local defaults = {
    debug_logging = false,
    easing_type = "QuadInOut",
    smooth_time = 0.3,
    max_speed = 100.0
}

--================================================
-- MODULE: Preset Manager (M13)
--================================================
-- Manages built-in and custom animation presets

local PresetManager = {
    -- Built-in presets (read-only)
    built_in = {
        {
            name = "Smooth",
            duration = 0.8,
            overshoot = 0.0,
            smoothness = 0.25,
            easing = "Cubic.Out",
        },
        {
            name = "Bounce",
            duration = 0.6,
            overshoot = 0.35,
            smoothness = 0.15,
            easing = "Back.Out",
        },
        {
            name = "Snappy",
            duration = 0.3,
            overshoot = 0.0,
            smoothness = 0.05,
            easing = "Expo.Out",
        },
        {
            name = "Cinematic",
            duration = 1.2,
            overshoot = 0.05,
            smoothness = 0.4,
            easing = "Sine.Out",
        },
    },

    -- Custom user presets
    custom = {},

    -- Currently selected preset name
    current_preset = "Smooth",
}

-- Get all preset names (built-in + custom)
function PresetManager:get_all_names()
    local names = {}

    -- Add built-in presets
    for _, preset in ipairs(self.built_in) do
        table.insert(names, preset.name)
    end

    -- Add custom presets
    for name, _ in pairs(self.custom) do
        table.insert(names, name)
    end

    table.sort(names)
    return names
end

-- Get preset by name
function PresetManager:get_preset(name)
    -- Check built-in first
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            return preset
        end
    end

    -- Check custom
    if self.custom[name] then
        return self.custom[name]
    end

    -- Default to Smooth
    return self.built_in[1]
end

-- Apply preset to configuration
function PresetManager:apply_preset(name)
    local preset = self:get_preset(name)
    if not preset then
        log("Preset: Unknown preset: " .. name)
        return false
    end

    cfg.zoom_duration = preset.duration
    cfg.zoom_overshoot = preset.overshoot
    cfg.follow_smooth_time = preset.smoothness

    if preset.easing then
        cfg.zoom_easing = preset.easing
    end

    self.current_preset = name
    log("Preset: Applied '" .. name .. "'")
    return true
end

-- Save a custom preset
function PresetManager:save_preset(name, duration, overshoot, smoothness, easing)
    if not name or name == "" then
        return false
    end

    -- Check if it's a built-in preset (can't override)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            log("Preset: Cannot override built-in preset: " .. name)
            return false
        end
    end

    -- Save custom preset
    self.custom[name] = {
        name = name,
        duration = duration or cfg.zoom_duration,
        overshoot = overshoot or cfg.zoom_overshoot,
        smoothness = smoothness or cfg.follow_smooth_time,
        easing = easing or cfg.zoom_easing,
    }

    log("Preset: Saved custom preset '" .. name .. "'")
    return true
end

-- Delete a custom preset
function PresetManager:delete_preset(name)
    -- Check if it's a built-in preset (can't delete)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            log("Preset: Cannot delete built-in preset: " .. name)
            return false
        end
    end

    -- Delete custom preset
    if self.custom[name] then
        self.custom[name] = nil
        log("Preset: Deleted custom preset '" .. name .. "'")
        return true
    end

    return false
end

-- Check if a preset is built-in
function PresetManager:is_built_in(name)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            return true
        end
    end
    return false
end

-- Persist custom presets to settings
function PresetManager:persist(settings)
    local array = obs.obs_data_array_create()

    for name, preset in pairs(self.custom) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "name", name)
        obs.obs_data_set_double(item, "duration", preset.duration)
        obs.obs_data_set_double(item, "overshoot", preset.overshoot)
        obs.obs_data_set_double(item, "smoothness", preset.smoothness)
        obs.obs_data_set_string(item, "easing", preset.easing)
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "custom_presets", array)
    obs.obs_data_array_release(array)
end

-- Load custom presets from settings
function PresetManager:load(settings)
    self.custom = {}

    local array = obs.obs_data_get_array(settings, "custom_presets")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local name = obs.obs_data_get_string(item, "name")

        if name and name ~= "" then
            self.custom[name] = {
                name = name,
                duration = obs.obs_data_get_double(item, "duration"),
                overshoot = obs.obs_data_get_double(item, "overshoot"),
                smoothness = obs.obs_data_get_double(item, "smoothness"),
                easing = obs.obs_data_get_string(item, "easing"),
            }
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)
    log("Preset: Loaded " .. self:get_custom_count() .. " custom presets")
end

-- Get count of custom presets
function PresetManager:get_custom_count()
    local count = 0
    for _, _ in pairs(self.custom) do
        count = count + 1
    end
    return count
end

-- Get current preset name
function PresetManager:get_current_name()
    return self.current_preset
end

-- Set current preset name
function PresetManager:set_current_name(name)
    self.current_preset = name
end

-- Check if current preset is custom
function PresetManager:is_current_custom()
    return not self:is_built_in(self.current_preset)
end

-- Global convenience functions
function preset_get_all_names()
    return PresetManager:get_all_names()
end

function preset_apply(name)
    return PresetManager:apply_preset(name)
end

function preset_save(name, duration, overshoot, smoothness, easing)
    return PresetManager:save_preset(name, duration, overshoot, smoothness, easing)
end

function preset_delete(name)
    return PresetManager:delete_preset(name)
end

function preset_is_built_in(name)
    return PresetManager:is_built_in(name)
end

function preset_get_current()
    return PresetManager:get_current_name()
end

--================================================
-- MODULE: Auto Source Detection (M11)
--================================================
-- Automatically detects and selects the best zoom source on first run

local AutoSourceDetector = {
    -- Source type priorities (higher = more likely to be the main display)
    type_priorities = {
        ["monitor_capture"] = 100,     -- Display capture (highest priority)
        ["game_capture"] = 80,          -- Game capture
        ["window_capture"] = 60,        -- Window capture
        ["xshm_input"] = 40,           -- Linux X11 capture
        ["av_capture_input"] = 20,     -- macOS capture
    },

    -- Whether auto-detection has been run
    auto_detected = false,
}

-- Get all capture sources sorted by priority
function AutoSourceDetector:get_capture_sources()
    local sources = {}
    local source_list = obs.obs_enum_sources()

    if not source_list then
        return sources
    end

    for _, source in ipairs(source_list) do
        local source_id = obs.obs_source_get_id(source)
        local name = obs.obs_source_get_name(source)

        -- Check if it's a capture source
        local priority = self.type_priorities[source_id]
        if priority then
            table.insert(sources, {
                name = name,
                id = source_id,
                priority = priority,
            })
        end
    end

    obs.source_list_release(source_list)

    -- Sort by priority (highest first)
    table.sort(sources, function(a, b)
        return a.priority > b.priority
    end)

    return sources
end

-- Auto-detect the best source
function AutoSourceDetector:auto_detect()
    local sources = self:get_capture_sources()

    if #sources == 0 then
        log("AutoSource: No capture sources found")
        return nil
    end

    if #sources == 1 then
        -- Only one source, use it
        log("AutoSource: Found single source: " .. sources[1].name)
        return sources[1].name
    end

    -- Multiple sources - prioritize by type
    -- Prefer monitor_capture > game_capture > window_capture
    local best = sources[1]

    log("AutoSource: Found " .. #sources .. " sources, selecting: " .. best.name)
    return best.name
end

-- Get monitor geometry from a source (if available)
function AutoSourceDetector:get_monitor_geometry(source_name)
    local source = obs.obs_get_source_by_name(source_name)
    if not source then
        return nil
    end

    local settings = obs.obs_source_get_settings(source)
    if not settings then
        obs.obs_source_release(source)
        return nil
    end

    -- Try to get monitor info from settings
    local monitor = obs.obs_data_get_int(settings, "monitor")
    local x = obs.obs_data_get_int(settings, "x")
    local y = obs.obs_data_get_int(settings, "y")
    local width = obs.obs_data_get_int(settings, "width")
    local height = obs.obs_data_get_int(settings, "height")

    obs.obs_data_release(settings)
    obs.obs_source_release(source)

    -- Return geometry if available
    if monitor >= 0 or width > 0 then
        return {
            monitor = monitor,
            x = x,
            y = y,
            width = width or 1920,
            height = height or 1080,
        }
    end

    return nil
end

-- Check if we should auto-detect on first run
function AutoSourceDetector:should_auto_detect(settings)
    -- Check if source has ever been set
    local last_source = obs.obs_data_get_string(settings, "source")
    if last_source and last_source ~= "" then
        return false
    end

    -- Check if auto-detect has been done
    return not self.auto_detected
end

-- Run auto-detection and return the source name
function AutoSourceDetector:run(settings)
    local source_name = self:auto_detect()

    if source_name then
        -- Save the detected source
        obs.obs_data_set_string(settings, "source", source_name)
        self.auto_detected = true
    end

    return source_name
end

-- Global convenience functions
function auto_source_detect()
    return AutoSourceDetector:auto_detect()
end

function auto_source_should_detect(settings)
    return AutoSourceDetector:should_auto_detect(settings)
end

function auto_source_run(settings)
    return AutoSourceDetector:run(settings)
end

--================================================
-- MODULE: Scene Memory (M12)
--================================================
-- Remembers which zoom source to use for each OBS scene

local SceneMemory = {
    -- Scene to source mapping
    scene_source_map = {},

    -- Maximum number of mappings to store
    max_mappings = 50,
}

-- Get the current scene name
function SceneMemory:get_current_scene_name()
    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then
        return nil
    end

    local name = obs.obs_source_get_name(scene_source)
    obs.obs_source_release(scene_source)
    return name
end

-- Get the source to use for the current scene
function SceneMemory:get_source_for_current_scene()
    local scene_name = self:get_current_scene_name()
    if not scene_name then
        return nil
    end

    -- 1. Check explicit mapping for this scene
    if self.scene_source_map[scene_name] then
        return self.scene_source_map[scene_name]
    end

    -- 2. Fall back to global source from config
    return cfg.source_name
end

-- Set the source for a specific scene
function SceneMemory:set(scene_name, source_name)
    if not scene_name or scene_name == "" then
        return false
    end

    -- Check if we're at capacity
    local count = 0
    for _, _ in pairs(self.scene_source_map) do
        count = count + 1
    end

    if count >= self.max_mappings and not self.scene_source_map[scene_name] then
        log("SceneMemory: At capacity (" .. self.max_mappings .. "), cannot add: " .. scene_name)
        return false
    end

    self.scene_source_map[scene_name] = source_name
    log("SceneMemory: " .. scene_name .. " Ã¢â€ â€™ " .. source_name)
    return true
end

-- Remove a scene mapping
function SceneMemory:remove(scene_name)
    if self.scene_source_map[scene_name] then
        self.scene_source_map[scene_name] = nil
        log("SceneMemory: Removed mapping for " .. scene_name)
        return true
    end
    return false
end

-- Get all scene mappings
function SceneMemory:get_all()
    local mappings = {}
    for scene, source in pairs(self.scene_source_map) do
        table.insert(mappings, { scene = scene, source = source })
    end
    table.sort(mappings, function(a, b)
        return a.scene < b.scene
    end)
    return mappings
end

-- Check if a scene has a mapping
function SceneMemory:has_mapping(scene_name)
    return self.scene_source_map[scene_name] ~= nil
end

-- Persist mappings to settings
function SceneMemory:persist(settings)
    local array = obs.obs_data_array_create()

    for scene, source in pairs(self.scene_source_map) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "scene", scene)
        obs.obs_data_set_string(item, "source", source)
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "scene_source_map", array)
    obs.obs_data_array_release(array)
end

-- Load mappings from settings
function SceneMemory:load(settings)
    self.scene_source_map = {}

    local array = obs.obs_data_get_array(settings, "scene_source_map")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local scene = obs.obs_data_get_string(item, "scene")
        local source = obs.obs_data_get_string(item, "source")

        if scene and scene ~= "" and source and source ~= "" then
            self.scene_source_map[scene] = source
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)

    local count = 0
    for _, _ in pairs(self.scene_source_map) do count = count + 1 end
    log("SceneMemory: Loaded " .. count .. " scene mappings")
end

-- Handle scene change
function SceneMemory:on_scene_change()
    local scene_name = self:get_current_scene_name()
    if not scene_name then
        return
    end

    -- Get the source for this scene
    local source_name = self:get_source_for_current_scene()

    if source_name and source_name ~= "" then
        -- Check if source changed
        local current = source_manager_is_valid() and cfg.source_name

        if source_name ~= current then
            log("SceneMemory: Scene changed to " .. scene_name)

            -- Release current source
            source_manager_release()

            -- Initialize with new source
            cfg.source_name = source_name
            source_manager_init(source_name)
        end
    end
end

-- Global convenience functions
function scene_memory_get_source()
    return SceneMemory:get_source_for_current_scene()
end

function scene_memory_set(scene_name, source_name)
    return SceneMemory:set(scene_name, source_name)
end

function scene_memory_remove(scene_name)
    return SceneMemory:remove(scene_name)
end

function scene_memory_get_all()
    return SceneMemory:get_all()
end

function scene_memory_on_scene_change()
    return SceneMemory:on_scene_change()
end

--================================================
-- MODULE: Blur Manager (M14)
--================================================
-- Provides built-in blur effects without external plugins
-- Supports multiple strategies: shader, composite_blur plugin, or none

local BlurManager = {
    -- Current strategy: "shader", "composite_blur", "none"
    strategy = "none",

    -- Filter references
    zoom_blur_filter = nil,
    motion_blur_filter = nil,

    -- Settings references
    zoom_blur_settings = nil,
    motion_blur_settings = nil,

    -- State
    initialized = false,

    -- Configuration
    zoom_blur_enabled = false,
    zoom_blur_intensity = 5,
    zoom_blur_clear_radius = 150,
    motion_blur_enabled = false,
    motion_blur_intensity = 1.0,
}

-- Try to use custom shader (if effect files exist)
function BlurManager:try_shader_strategy(source)
    -- This would require .effect files in assets/shaders/
    -- For now, we'll use a simpler approach
    log("Blur: Shader strategy not implemented (requires effect files)")
    return false
end

-- Try to auto-create Composite Blur filters
function BlurManager:try_composite_blur_strategy(source)
    if not source then return false end

    -- Check if composite_blur filter type exists
    local test_filter = obs.obs_source_create_private("composite_blur", "__test_blur__", nil)
    if test_filter then
        obs.obs_source_release(test_filter)
    else
        log("Blur: Composite Blur plugin not available")
        return false
    end

    -- Create Zoom Blur filter
    local zs = obs.obs_data_create()
    obs.obs_data_set_double(zs, "radius", 0)
    obs.obs_data_set_int(zs, "blur_type", 2) -- Zoom type
    self.zoom_blur_filter = obs.obs_source_create_private(
        "composite_blur",
        FILTER_PREFIX .. "Zoom Blur",
        zs
    )

    if self.zoom_blur_filter then
        obs.obs_source_filter_add(source, self.zoom_blur_filter)
        self.zoom_blur_settings = zs
    else
        obs.obs_data_release(zs)
        return false
    end

    -- Create Motion Blur filter
    local ms = obs.obs_data_create()
    obs.obs_data_set_double(ms, "radius", 0)
    obs.obs_data_set_int(ms, "blur_type", 3) -- Motion/directional type
    self.motion_blur_filter = obs.obs_source_create_private(
        "composite_blur",
        FILTER_PREFIX .. "Motion Blur",
        ms
    )

    if self.motion_blur_filter then
        obs.obs_source_filter_add(source, self.motion_blur_filter)
        self.motion_blur_settings = ms
    else
        obs.obs_data_release(ms)
    end

    self.initialized = true
    return true
end

-- Initialize blur manager
function BlurManager:init(source)
    if not source then
        return false
    end

    self:cleanup()

    -- Try composite_blur strategy
    if self:try_composite_blur_strategy(source) then
        self.strategy = "composite_blur"
        log("Blur: Using Composite Blur plugin (auto-configured)")
        return true
    end

    -- No blur available
    self.strategy = "none"
    log("Blur: No blur backend available. Blur effects disabled.")
    return false
end

-- Update blur based on zoom state
function BlurManager:update(state_machine, crop, camera_velocity)
    if not self.initialized then return end
    if self.strategy == "none" then return end

    -- Zoom Blur: Active during zoom transitions
    if self.zoom_blur_enabled and self.zoom_blur_filter then
        local radius = 0

        if state_machine:is_animating() and
           (state_machine.state == ZoomState.ZOOMING_IN or
            state_machine.state == ZoomState.ZOOMING_OUT) then
            -- Bell curve: 0 at start Ã¢â€ â€™ peak at 50% Ã¢â€ â€™ 0 at end
            local t = clamp(0, 1, state_machine.zoom_time)
            local curve = math.sin(t * math.pi)
            radius = curve * curve * self.zoom_blur_intensity
        end

        self:set_zoom_blur(radius, crop)
    end

    -- Motion Blur: Active during camera panning (not during zoom transition)
    if self.motion_blur_enabled and self.motion_blur_filter then
        if not state_machine:is_animating() and state_machine:is_zoomed() and camera_velocity then
            local speed = math.sqrt(
                camera_velocity.x * camera_velocity.x +
                camera_velocity.y * camera_velocity.y
            )

            if speed > 1.0 then
                local radius = math.min(10, speed * self.motion_blur_intensity * 0.5)
                local angle = math.deg(math.atan2(camera_velocity.y, camera_velocity.x))
                self:set_motion_blur(radius, angle)
            else
                self:set_motion_blur(0, 0)
            end
        else
            self:set_motion_blur(0, 0)
        end
    end
end

-- Set zoom blur parameters
function BlurManager:set_zoom_blur(radius, crop)
    if self.strategy == "composite_blur" and self.zoom_blur_settings then
        obs.obs_data_set_double(self.zoom_blur_settings, "radius", radius)

        if crop then
            local cx = crop.x + (crop.w / 2)
            local cy = crop.y + (crop.h / 2)
            obs.obs_data_set_double(self.zoom_blur_settings, "center_x", cx)
            obs.obs_data_set_double(self.zoom_blur_settings, "center_y", cy)
        end

        obs.obs_data_set_double(self.zoom_blur_settings, "inactive_radius", self.zoom_blur_clear_radius)
        obs.obs_source_update(self.zoom_blur_filter, self.zoom_blur_settings)
    end
end

-- Set motion blur parameters
function BlurManager:set_motion_blur(radius, angle)
    if self.strategy == "composite_blur" and self.motion_blur_settings then
        obs.obs_data_set_double(self.motion_blur_settings, "radius", radius)
        obs.obs_data_set_double(self.motion_blur_settings, "angle", angle)
        obs.obs_source_update(self.motion_blur_filter, self.motion_blur_settings)
    end
end

-- Update configuration
function BlurManager:update_config(settings)
    self.zoom_blur_enabled = obs.obs_data_get_bool(settings, "zoom_blur_enabled")
    self.zoom_blur_intensity = obs.obs_data_get_double(settings, "zoom_blur_intensity")
    self.zoom_blur_clear_radius = obs.obs_data_get_double(settings, "zoom_blur_clear_radius")
    self.motion_blur_enabled = obs.obs_data_get_bool(settings, "motion_blur_enabled")
    self.motion_blur_intensity = obs.obs_data_get_double(settings, "motion_blur_intensity")
end

-- Cleanup filters
function BlurManager:cleanup()
    local source = source_manager_get_source()

    if self.zoom_blur_filter and source then
        obs.obs_source_filter_remove(source, self.zoom_blur_filter)
        obs.obs_source_release(self.zoom_blur_filter)
        self.zoom_blur_filter = nil
    end

    if self.motion_blur_filter and source then
        obs.obs_source_filter_remove(source, self.motion_blur_filter)
        obs.obs_source_release(self.motion_blur_filter)
        self.motion_blur_filter = nil
    end

    if self.zoom_blur_settings then
        obs.obs_data_release(self.zoom_blur_settings)
        self.zoom_blur_settings = nil
    end

    if self.motion_blur_settings then
        obs.obs_data_release(self.motion_blur_settings)
        self.motion_blur_settings = nil
    end

    self.initialized = false
    self.strategy = "none"
end

-- Check if blur is available
function BlurManager:is_available()
    return self.strategy ~= "none"
end

-- Global convenience functions
function blur_manager_init(source)
    return BlurManager:init(source)
end

function blur_manager_update(state_machine, crop, camera_velocity)
    return BlurManager:update(state_machine, crop, camera_velocity)
end

function blur_manager_update_config(settings)
    return BlurManager:update_config(settings)
end

function blur_manager_cleanup()
    return BlurManager:cleanup()
end

function blur_manager_is_available()
    return BlurManager:is_available()
end

--================================================
-- MODULE: Cursor Asset Manager (M16)
--================================================
-- Handles extracting and managing cursor image assets

local CursorAssets = {
    extracted = false,
    dir = nil,
}

-- Get the platform-specific asset directory
function CursorAssets:get_platform_dir()
    if IS_WINDOWS then
        local appdata = os.getenv("APPDATA")
        return appdata and (appdata .. "\\obs-studio\\obs-zoom-pro\\cursors") or nil
    elseif IS_LINUX then
        local home = os.getenv("HOME")
        return home and (home .. "/.config/obs-studio/obs-zoom-pro/cursors") or nil
    elseif IS_MACOS then
        local home = os.getenv("HOME")
        return home and (home .. "/Library/Application Support/obs-studio/obs-zoom-pro/cursors") or nil
    end
    -- Fallback for non-FFI environments
    return "cursors"
end

-- Ensure assets are extracted
function CursorAssets:ensure_extracted()
    if self.extracted then
        return self.dir
    end

    local dir = self:get_platform_dir()
    if not dir then
        log("CursorAssets: Could not determine asset directory")
        return nil
    end

    -- Create directory
    local cmd
    if IS_WINDOWS then
        cmd = 'mkdir "' .. dir .. '" 2>nul'
    else
        cmd = 'mkdir -p "' .. dir .. '"'
    end
    os.execute(cmd)

    -- Check if assets exist
    local sep = IS_WINDOWS and "\\" or "/"
    local arrow_path = dir .. sep .. "arrow.png"

    local f = io.open(arrow_path, "rb")
    if f then
        f:close()
        self.dir = dir
        self.extracted = true
        log("CursorAssets: Using existing assets from " .. dir)
        return dir
    end

    -- Try to copy from script directory
    local script_dir = get_script_directory()
    local assets_src = script_dir .. "assets" .. sep .. "cursors" .. sep

    local files = { "arrow.png", "pointer.png", "ibeam.png" }
    for _, filename in ipairs(files) do
        local src_path = assets_src .. filename
        local dst_path = dir .. sep .. filename

        local src = io.open(src_path, "rb")
        if src then
            local data = src:read("*a")
            src:close()

            local dst = io.open(dst_path, "wb")
            if dst then
                dst:write(data)
                dst:close()
                log("CursorAssets: Copied " .. filename)
            end
        end
    end

    self.dir = dir
    self.extracted = true
    return dir
end

-- Get the asset directory
function CursorAssets:get_dir()
    return self.dir
end

-- Check if assets are available
function CursorAssets:is_available()
    if not self.extracted then
        self:ensure_extracted()
    end
    return self.dir ~= nil
end

-- Get cursor image path
function CursorAssets:get_cursor_path(cursor_type)
    if not self:is_available() then
        return nil
    end

    local sep = IS_WINDOWS and "\\" or "/"
    local filename = (cursor_type or "arrow") .. ".png"
    return self.dir .. sep .. filename
end

-- Global convenience functions
function cursor_assets_ensure_extracted()
    return CursorAssets:ensure_extracted()
end

function cursor_assets_get_dir()
    return CursorAssets:get_dir()
end

function cursor_assets_is_available()
    return CursorAssets:is_available()
end

function cursor_assets_get_cursor_path(cursor_type)
    return CursorAssets:get_cursor_path(cursor_type)
end

--================================================
-- MODULE: Cursor Renderer (M15)
--================================================
-- Provides automatic cursor overlay rendering

local CursorRenderer = {
    enabled = false,
    source = nil,
    sceneitem = nil,

    -- Smoothed state
    pos = { x = 0, y = 0 },
    current_scale = 1.0,
    current_rot = 0,
    swap_pulse = 1.0,

    -- Velocities (SmoothDamp)
    vel_x = { val = 0 },
    vel_y = { val = 0 },
    vel_scale = { val = 0 },
    vel_rot = { val = 0 },
    vel_swap = { val = 0 },

    -- State
    was_pointer = false,
    initialized = false,

    -- Configuration
    cursor_scale = 1.0,
    cursor_click_scale = 0.78,
    cursor_smooth_time = 0.1,
    cursor_offset_x = -6,
    cursor_offset_y = -2,
    cursor_rotation_mode = "None",
    cursor_angle_offset = 0,
    cursor_tilt_strength = 0,
}

-- Initialize cursor renderer
function CursorRenderer:init()
    if not cfg.cursor_enabled then
        self.enabled = false
        return false
    end

    -- Ensure cursor assets are available
    local asset_dir = cursor_assets_ensure_extracted()
    if not asset_dir then
        log("CursorRenderer: Failed to extract cursor assets")
        self.enabled = false
        return false
    end

    -- Get or create the cursor image source
    local source_name = FILTER_PREFIX .. "Cursor"
    self.source = obs.obs_get_source_by_name(source_name)

    if not self.source then
        -- Create new image source
        local settings = obs.obs_data_create()
        local cursor_path = cursor_assets_get_cursor_path("arrow")
        if cursor_path then
            obs.obs_data_set_string(settings, "file", cursor_path)
        end
        self.source = obs.obs_source_create("image_source", source_name, settings, nil)
        obs.obs_data_release(settings)

        if not self.source then
            log("CursorRenderer: Failed to create image source")
            self.enabled = false
            return false
        end
    end

    -- Add to current scene
    self:add_to_scene()

    -- Initialize position
    local mouse = platform_get_mouse_pos()
    self.pos.x = mouse.x
    self.pos.y = mouse.y

    self.enabled = true
    self.initialized = true
    log("CursorRenderer: Initialized")
    return true
end

-- Add cursor source to scene
function CursorRenderer:add_to_scene()
    if not self.source then return false end

    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then return false end

    local scene = obs.obs_scene_from_source(scene_source)
    if not scene then
        obs.obs_source_release(scene_source)
        return false
    end

    -- Check if already in scene
    local source_name = obs.obs_source_get_name(self.source)
    self.sceneitem = obs.obs_scene_find_source(scene, source_name)

    if not self.sceneitem then
        -- Add to scene
        self.sceneitem = obs.obs_scene_add(scene, self.source)
        if self.sceneitem then
            -- Move to top (render last = on top)
            obs.obs_sceneitem_set_order(self.sceneitem, obs.OBS_ORDER_MOVE_TOP)
        end
    end

    obs.obs_source_release(scene_source)
    return true
end

-- Update cursor position and state
function CursorRenderer:update(dt, raw_mouse, camera_crop)
    if not self.enabled or not self.sceneitem then return end

    -- Smooth cursor position
    self.pos.x = SmoothDamp(self.pos.x, raw_mouse.x, self.vel_x, self.cursor_smooth_time, 100000, dt)
    self.pos.y = SmoothDamp(self.pos.y, raw_mouse.y, self.vel_y, self.cursor_smooth_time, 100000, dt)

    -- Snap when very close
    if math.abs(self.pos.x - raw_mouse.x) < 0.5 then
        self.pos.x = raw_mouse.x
        self.vel_x.val = 0
    end
    if math.abs(self.pos.y - raw_mouse.y) < 0.5 then
        self.pos.y = raw_mouse.y
        self.vel_y.val = 0
    end

    -- Cursor shape detection (Windows only)
    local is_pointer = false
    if platform_cursor_shape_available() then
        is_pointer = platform_is_cursor_pointer()
    end

    -- Swap cursor image if needed
    if is_pointer ~= self.was_pointer then
        local asset_dir = cursor_assets_get_dir()
        local sep = IS_WINDOWS and "\\" or "/"
        local new_file = is_pointer and (asset_dir .. sep .. "pointer.png") or (asset_dir .. sep .. "arrow.png")

        local s = obs.obs_source_get_settings(self.source)
        if s then
            obs.obs_data_set_string(s, "file", new_file)
            obs.obs_source_update(self.source, s)
            obs.obs_data_release(s)
        end

        -- Trigger swap pulse
        self.swap_pulse = 0.75
        self.vel_swap.val = 1
        self.was_pointer = is_pointer
    end

    self.swap_pulse = SmoothDamp(self.swap_pulse, 1.0, self.vel_swap, 0.12, 100000, dt)

    -- Click animation
    local is_clicking = platform_is_clicking()
    local target_scale = is_clicking and (self.cursor_scale * self.cursor_click_scale) or self.cursor_scale
    self.current_scale = SmoothDamp(self.current_scale, target_scale, self.vel_scale, 0.1, 100000, dt)

    -- Calculate position relative to zoom
    local zoom_factor = 1.0
    local crop_x, crop_y = 0, 0

    if camera_crop and SM:is_zoomed() then
        zoom_factor = source_manager_get_size() / camera_crop.w
        crop_x = camera_crop.x
        crop_y = camera_crop.y
    end

    local final_x = (self.pos.x - crop_x) * zoom_factor + (self.cursor_offset_x * zoom_factor)
    local final_y = (self.pos.y - crop_y) * zoom_factor + (self.cursor_offset_y * zoom_factor)

    -- Apply to scene item
    local pos = obs.vec2()
    pos.x = final_x
    pos.y = final_y
    obs.obs_sceneitem_set_pos(self.sceneitem, pos)

    local scale = obs.vec2()
    local s = self.current_scale * zoom_factor * self.swap_pulse
    scale.x = s
    scale.y = s
    obs.obs_sceneitem_set_scale(self.sceneitem, scale)

    -- Rotation
    local dynamic_rot = self:compute_rotation(dt)
    obs.obs_sceneitem_set_rot(self.sceneitem, dynamic_rot)
end

-- Compute rotation based on mode
function CursorRenderer:compute_rotation(dt)
    local vx = self.vel_x.val
    local vy = self.vel_y.val
    local speed = math.sqrt(vx * vx + vy * vy)

    if self.cursor_rotation_mode == "Directional" then
        if speed > 20 then
            local angle = math.atan2(vy, vx) * (180 / math.pi)
            local target = angle + self.cursor_angle_offset
            local diff = (target - self.current_rot + 180) % 360 - 180
            self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.05, 100000, dt)
        end
        return self.current_rot

    elseif self.cursor_rotation_mode == "Lean" then
        local lean = clamp(-40, 40, vx * 0.05 * self.cursor_tilt_strength) + self.cursor_angle_offset
        local diff = (lean - self.current_rot + 180) % 360 - 180
        self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.08, 100000, dt)
        return self.current_rot
    end

    -- "None" mode
    local diff = (self.cursor_angle_offset - self.current_rot + 180) % 360 - 180
    self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.15, 100000, dt)
    return self.current_rot
end

-- Update configuration
function CursorRenderer:update_config(settings)
    self.cursor_scale = obs.obs_data_get_double(settings, "cursor_scale")
    self.cursor_click_scale = obs.obs_data_get_double(settings, "cursor_click_scale")
    self.cursor_smooth_time = obs.obs_data_get_double(settings, "cursor_smooth_time")
    self.cursor_offset_x = obs.obs_data_get_int(settings, "cursor_offset_x")
    self.cursor_offset_y = obs.obs_data_get_int(settings, "cursor_offset_y")
    self.cursor_rotation_mode = obs.obs_data_get_string(settings, "cursor_rotation_mode") or "None"
    self.cursor_angle_offset = obs.obs_data_get_double(settings, "cursor_angle_offset")
    self.cursor_tilt_strength = obs.obs_data_get_double(settings, "cursor_tilt_strength")
end

-- Cleanup
function CursorRenderer:cleanup()
    if self.sceneitem then
        obs.obs_sceneitem_remove(self.sceneitem)
        self.sceneitem = nil
    end

    if self.source then
        local source_name = obs.obs_source_get_name(self.source)
        obs.obs_source_release(self.source)

        -- Remove from OBS source list
        local s = obs.obs_get_source_by_name(source_name)
        if s then
            obs.obs_source_remove(s)
            obs.obs_source_release(s)
        end
        self.source = nil
    end

    self.enabled = false
    self.initialized = false
end

-- Check if active
function CursorRenderer:is_active()
    return self.enabled and self.initialized
end

-- Global convenience functions
function cursor_renderer_init()
    return CursorRenderer:init()
end

function cursor_renderer_update(dt, raw_mouse, camera_crop)
    return CursorRenderer:update(dt, raw_mouse, camera_crop)
end

function cursor_renderer_update_config(settings)
    return CursorRenderer:update_config(settings)
end

function cursor_renderer_cleanup()
    return CursorRenderer:cleanup()
end

function cursor_renderer_is_active()
    return CursorRenderer:is_active()
end

--================================================
-- MODULE: Bookmark Manager (M17)
--================================================
-- Manages saved zoom positions (bookmarks)

local BookmarkManager = {
    -- Saved bookmarks: { name = { zoom_level, x, y, w, h, source } }
    bookmarks = {},

    -- Maximum bookmarks
    max_bookmarks = 20,

    -- Hotkey IDs
    hotkeys = {},
}

-- Save current zoom position as a bookmark
function BookmarkManager:save(name)
    if not name or name == "" then
        return false
    end

    -- Check limit
    local count = 0
    for _, _ in pairs(self.bookmarks) do count = count + 1 end

    if count >= self.max_bookmarks and not self.bookmarks[name] then
        log("Bookmark: Max bookmarks reached (" .. self.max_bookmarks .. ")")
        return false
    end

    -- Get current crop
    local crop = crop_filter_get_crop()
    if not crop then
        return false
    end

    -- Save bookmark
    self.bookmarks[name] = {
        zoom_level = SM.zoom_level,
        x = crop.x,
        y = crop.y,
        w = crop.w,
        h = crop.h,
        source = cfg.source_name,
    }

    log("Bookmark: Saved '" .. name .. "' (zoom=" .. string.format("%.2f", SM.zoom_level) .. ")")
    return true
end

-- Recall a bookmark
function BookmarkManager:recall(name)
    local bm = self.bookmarks[name]
    if not bm then
        log("Bookmark: Not found: " .. name)
        return false
    end

    if not SM:can_jump() then
        return false
    end

    if not source_manager_is_valid() then
        return false
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        return false
    end

    -- Get current crop as start
    local start_crop = crop_filter_get_crop() or { x = 0, y = 0, w = source_w, h = source_h }

    -- Set target
    local target_crop = {
        x = bm.x,
        y = bm.y,
        w = bm.w,
        h = bm.h,
    }

    -- Transition to bookmark
    SM:transition(ZoomState.JUMPING, {
        start_crop = start_crop,
        target_crop = target_crop,
        target_level = bm.zoom_level
    })

    start_timer()
    log("Bookmark: Recall '" .. name .. "'")
    return true
end

-- Delete a bookmark
function BookmarkManager:delete(name)
    if self.bookmarks[name] then
        self.bookmarks[name] = nil
        log("Bookmark: Deleted '" .. name .. "'")
        return true
    end
    return false
end

-- Rename a bookmark
function BookmarkManager:rename(old_name, new_name)
    if not self.bookmarks[old_name] then
        return false
    end

    if self.bookmarks[new_name] then
        return false
    end

    self.bookmarks[new_name] = self.bookmarks[old_name]
    self.bookmarks[old_name] = nil
    log("Bookmark: Renamed '" .. old_name .. "' to '" .. new_name .. "'")
    return true
end

-- Get all bookmark names
function BookmarkManager:get_names()
    local names = {}
    for k, _ in pairs(self.bookmarks) do
        table.insert(names, k)
    end
    table.sort(names)
    return names
end

-- Get bookmark info
function BookmarkManager:get(name)
    return self.bookmarks[name]
end

-- Persist bookmarks to settings
function BookmarkManager:persist(settings)
    local array = obs.obs_data_array_create()

    for name, bm in pairs(self.bookmarks) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "name", name)
        obs.obs_data_set_double(item, "zoom_level", bm.zoom_level)
        obs.obs_data_set_double(item, "x", bm.x)
        obs.obs_data_set_double(item, "y", bm.y)
        obs.obs_data_set_double(item, "w", bm.w)
        obs.obs_data_set_double(item, "h", bm.h)
        obs.obs_data_set_string(item, "source", bm.source or "")
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "zoom_bookmarks", array)
    obs.obs_data_array_release(array)
end

-- Load bookmarks from settings
function BookmarkManager:load(settings)
    self.bookmarks = {}

    local array = obs.obs_data_get_array(settings, "zoom_bookmarks")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local name = obs.obs_data_get_string(item, "name")

        if name and name ~= "" then
            self.bookmarks[name] = {
                zoom_level = obs.obs_data_get_double(item, "zoom_level"),
                x = obs.obs_data_get_double(item, "x"),
                y = obs.obs_data_get_double(item, "y"),
                w = obs.obs_data_get_double(item, "w"),
                h = obs.obs_data_get_double(item, "h"),
                source = obs.obs_data_get_string(item, "source"),
            }
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)

    local count = 0
    for _, _ in pairs(self.bookmarks) do count = count + 1 end
    log("Bookmark: Loaded " .. count .. " bookmarks")
end

-- Register bookmark hotkeys
function BookmarkManager:register_hotkeys(settings)
    for i = 1, 5 do
        self.hotkeys[i] = obs.obs_hotkey_register_frontend(
            "obs_zoom_pro.bookmark_" .. i,
            "Zoom to Bookmark " .. i,
            function(pressed)
                if not pressed then return end
                local names = self:get_names()
                if names[i] then
                    self:recall(names[i])
                end
            end
        )

        -- Load saved bindings
        local key = "obs_zoom_pro.hotkey.bookmark_" .. i
        local save_array = obs.obs_data_get_array(settings, key)
        if save_array then
            obs.obs_hotkey_load(self.hotkeys[i], save_array)
            obs.obs_data_array_release(save_array)
        end
    end
end

-- Save bookmark hotkeys
function BookmarkManager:save_hotkeys(settings)
    for i = 1, 5 do
        if self.hotkeys[i] then
            local save_array = obs.obs_hotkey_save(self.hotkeys[i])
            obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.bookmark_" .. i, save_array)
            obs.obs_data_array_release(save_array)
        end
    end
end

-- Global convenience functions
function bookmark_save(name)
    return BookmarkManager:save(name)
end

function bookmark_recall(name)
    return BookmarkManager:recall(name)
end

function bookmark_delete(name)
    return BookmarkManager:delete(name)
end

function bookmark_get_names()
    return BookmarkManager:get_names()
end

function bookmark_get(name)
    return BookmarkManager:get(name)
end

--================================================
-- MODULE: UDP API Server (M18)
--================================================
-- Provides external control via UDP for Stream Deck integration

local APIServer = {
    enabled = false,
    port = 12345,
    socket = nil,
}

-- Command handlers
local API_COMMANDS = {
    ZOOM_IN = function(args)
        local level = tonumber(args[1]) or cfg.zoom_value
        on_scroll_zoom_to(level)
        return "OK"
    end,

    ZOOM_OUT = function(args)
        if SM:is_zoomed() then
            on_toggle_zoom(true)
        end
        return "OK"
    end,

    ZOOM_SET = function(args)
        local level = tonumber(args[1])
        if not level then return "ERROR: Missing level" end
        on_scroll_zoom_to(level)
        return "OK"
    end,

    ZOOM_TOGGLE = function(args)
        on_toggle_zoom(true)
        return "OK"
    end,

    FOLLOW_ON = function(args)
        if SM:is_zoomed() then SM.following = true end
        return "OK"
    end,

    FOLLOW_OFF = function(args)
        SM.following = false
        return "OK"
    end,

    FOLLOW_TOGGLE = function(args)
        if SM:is_zoomed() then SM.following = not SM.following end
        return "OK"
    end,

    PRESET = function(args)
        local name = args[1]
        if not name then return "ERROR: Missing preset name" end
        local ok = preset_apply(name)
        return ok and "OK" or "ERROR: Unknown preset"
    end,

    BOOKMARK = function(args)
        local name = args[1]
        if not name then return "ERROR: Missing bookmark name" end
        local ok = bookmark_recall(name)
        return ok and "OK" or "ERROR: Bookmark not found"
    end,

    STATUS = function(args)
        local crop = crop_filter_get_crop()
        return string.format(
            '{"version":"%s","zoom_level":%.2f,"state":"%s","following":%s,"position":{"x":%.0f,"y":%.0f},"preset":"%s"}',
            VERSION,
            SM.zoom_level,
            SM.state,
            tostring(SM.following),
            crop and crop.x or 0,
            crop and crop.y or 0,
            cfg.zoom_preset or ""
        )
    end,

    HELP = function(args)
        return "Commands: ZOOM_IN [level], ZOOM_OUT, ZOOM_SET level, ZOOM_TOGGLE, FOLLOW_ON, FOLLOW_OFF, FOLLOW_TOGGLE, PRESET name, BOOKMARK name, STATUS"
    end,
}

-- Start the API server
function APIServer:start(port)
    self:stop()

    self.port = port or self.port

    -- Try to use luasocket if available
    local socket_ok, socket = pcall(require, "socket")
    if not socket_ok then
        log("API: Socket library not available")
        return false
    end

    -- Try UDP
    local udp, err = socket.udp()
    if not udp then
        log("API: Failed to create UDP socket: " .. tostring(err))
        return false
    end

    -- Set socket options
    udp:setoption("reuseaddr", true)
    udp:settimeout(0)  -- Non-blocking

    -- Bind to port
    local bind_ok, err = udp:setsockname("*", self.port)
    if not bind_ok then
        log("API: Failed to bind to port " .. self.port .. ": " .. tostring(err))
        udp:close()
        return false
    end

    self.socket = udp
    self.enabled = true

    -- Start polling timer
    obs.timer_add(function() self:poll() end, 50)  -- 20Hz polling

    log("API: Listening on port " .. self.port)
    return true
end

-- Stop the API server
function APIServer:stop()
    if self.socket then
        self.socket:close()
        self.socket = nil
    end
    self.enabled = false
    log("API: Stopped")
end

-- Poll for incoming commands
function APIServer:poll()
    if not self.enabled or not self.socket then
        return
    end

    repeat
        local data, err = self.socket:receivefrom()
        if data then
            local response = self:handle_command(data)
            if response then
                -- Note: UDP response requires sender address
                log("API: " .. data:gsub("%s+", " ") .. " Ã¢â€ â€™ " .. response)
            end
        elseif err ~= "timeout" then
            log("API: Error: " .. tostring(err))
        end
    until not data
end

-- Handle a command
function APIServer:handle_command(raw)
    -- Parse command
    local parts = {}
    for word in raw:gmatch("%S+") do
        table.insert(parts, word)
    end

    if #parts == 0 then
        return "ERROR: Empty command"
    end

    local cmd = parts[1]:upper()
    local args = {}
    for i = 2, #parts do
        table.insert(args, parts[i])
    end

    -- Look up handler
    local handler = API_COMMANDS[cmd]
    if handler then
        local ok, result = pcall(handler, args)
        if ok then
            return result
        else
            return "ERROR: " .. tostring(result)
        end
    end

    return "ERROR: Unknown command: " .. cmd
end

-- Check if enabled
function APIServer:is_enabled()
    return self.enabled
end

-- Global convenience functions
function api_start(port)
    return APIServer:start(port)
end

function api_stop()
    return APIServer:stop()
end

function api_is_enabled()
    return APIServer:is_enabled()
end

--================================================
-- OBS SCRIPT REGISTRATION
--================================================

--[[ Called when the script is loaded
--[[ @param data table Script data
function script_load(data)
    log("Script loaded - OBS Zoom Pro v" .. VERSION)

    -- Load custom presets
    PresetManager:load(data)

    -- Load scene memory
    SceneMemory:load(data)

    -- Load bookmarks
    BookmarkManager:load(data)

    -- Register hotkeys
    register_hotkeys(data)

    -- Register bookmark hotkeys
    BookmarkManager:register_hotkeys(data)

    -- Register frontend event handler
    obs.obs_frontend_add_event_callback(on_frontend_event)

    -- Start API server if enabled
    local api_enabled = obs.obs_data_get_bool(data, "api_enabled")
    if api_enabled then
        local api_port = obs.obs_data_get_int(data, "api_port")
        APIServer:start(api_port)
    end
end

--[[ Called when the script is unloaded
function script_unload()
    log("Script unloaded - OBS Zoom Pro")

    -- Stop timer and cleanup
    stop_timer()
    unregister_hotkeys()
    source_manager_release()

    -- Stop API server
    APIServer:stop()

    -- Remove frontend event handler
    obs.obs_frontend_remove_event_callback(on_frontend_event)
end

--[[ Called when settings are updated
--[[ @param data table Settings data
function script_update(data)
    log("Settings updated")

    -- Update legacy settings
    debug_logs = obs.obs_data_get_bool(data, "debug_logging") or false
    settings.debug_logging = debug_logs
    settings.easing_type = obs.obs_data_get_string(data, "easing_type") or defaults.easing_type
    settings.smooth_time = obs.obs_data_get_double(data, "smooth_time") or defaults.smooth_time
    settings.max_speed = obs.obs_data_get_double(data, "max_speed") or defaults.max_speed

    -- Update M09 configuration
    update_config(data)

    -- Update API server settings
    local api_enabled = obs.obs_data_get_bool(data, "api_enabled")
    local api_port = obs.obs_data_get_int(data, "api_port")

    if api_enabled and not APIServer:is_enabled() then
        APIServer:start(api_port)
    elseif not api_enabled and APIServer:is_enabled() then
        APIServer:stop()
    elseif APIServer:is_enabled() and APIServer.port ~= api_port then
        APIServer:start(api_port)
    end
end

--[[ Called to save settings
--[[ @param data table Settings data to save
function script_save(data)
    log("Settings saved")

    -- Save custom presets
    PresetManager:persist(data)

    -- Save scene memory
    SceneMemory:persist(data)

    -- Save bookmarks
    BookmarkManager:persist(data)

    -- Save hotkey bindings
    save_hotkeys(data)

    -- Save bookmark hotkeys
    BookmarkManager:save_hotkeys(data)
end

--[[ Called to create the properties UI
--[[ @return obs.obs_properties_t Properties object
function script_properties()
    local props = obs.obs_properties_create()

    --==========================
    -- QUICK SETUP (always expanded)
    --==========================
    local grp_quick = obs.obs_properties_create()

    -- Source dropdown
    local src_list = obs.obs_properties_add_list(grp_quick, "source", "Zoom Source",
        obs.OBS_COMBO_TYPE_LIST, obs.OBS_COMBO_FORMAT_STRING)
    obs.obs_property_list_add_string(src_list, "-- Select Source --", "")

    -- Populate with available capture sources
    local sources = source_manager_get_available_sources()
    for _, src in ipairs(sources) do
        obs.obs_property_list_add_string(src_list, src.name, src.name)
    end

    -- Zoom Factor
    obs.obs_properties_add_float_slider(grp_quick, "zoom_value", "Zoom Factor", 1.0, 10.0, 0.1)

    -- Duration
    obs.obs_properties_add_float_slider(grp_quick, "zoom_duration", "Duration (s)", 0.05, 3.0, 0.05)

    obs.obs_properties_add_group(props, "quick_setup", "Ã¢Å¡Â¡ Quick Setup", obs.OBS_GROUP_NORMAL, grp_quick)

    --==========================
    -- ANIMATION (collapsed)
    --==========================
    local grp_anim = obs.obs_properties_create()

    -- Overshoot/Bounce
    obs.obs_properties_add_float_slider(grp_anim, "zoom_overshoot", "Bounce", 0.0, 1.0, 0.01)

    -- Easing Curve
    local p_easing = obs.obs_properties_add_list(grp_anim, "zoom_easing", "Easing Curve",
        obs.OBS_COMBO_TYPE_LIST, obs.OBS_COMBO_FORMAT_STRING)
    for _, name in ipairs(Easing.NAMES) do
        obs.obs_property_list_add_string(p_easing, name, name)
    end

    obs.obs_properties_add_group(props, "animation", "Ã°Å¸Å½Â¬ Animation", obs.OBS_GROUP_NORMAL, grp_anim)

    --==========================
    -- MOUSE FOLLOW (collapsed)
    --==========================
    local grp_follow = obs.obs_properties_create()

    obs.obs_properties_add_bool(grp_follow, "auto_follow", "Auto-Follow Mouse")
    obs.obs_properties_add_float_slider(grp_follow, "follow_smooth_time", "Smoothness", 0.01, 1.0, 0.01)
    obs.obs_properties_add_int_slider(grp_follow, "follow_dead_zone", "Dead Zone (px)", 0, 500, 1)

    obs.obs_properties_add_group(props, "follow", "Ã°Å¸Å½Â¯ Mouse Follow", obs.OBS_GROUP_NORMAL, grp_follow)

    --==========================
    -- ADVANCED (collapsed)
    --==========================
    local grp_adv = obs.obs_properties_create()
    obs.obs_properties_add_float_slider(grp_adv, "scroll_step", "Scroll Zoom Step", 0.1, 1.0, 0.05)
    obs.obs_properties_add_bool(grp_adv, "debug_logs", "Debug Logging")
    obs.obs_properties_add_group(props, "advanced", "Ã¢Å¡â„¢Ã¯Â¸Â Advanced", obs.OBS_GROUP_NORMAL, grp_adv)

    --==========================
    -- API SERVER (collapsed)
    --==========================
    local grp_api = obs.obs_properties_create()
    obs.obs_properties_add_bool(grp_api, "api_enabled", "Enable UDP API Server")
    obs.obs_properties_add_int(grp_api, "api_port", "API Port", 1024, 65535, 1)
    obs.obs_properties_add_group(props, "api_server", "Ã°Å¸Å’Â UDP API Server", obs.OBS_GROUP_NORMAL, grp_api)

    --==========================
    -- HELP (collapsed)
    --==========================
    local grp_help = obs.obs_properties_create()
    obs.obs_properties_add_text(grp_help, "help_text",
        "QUICK START:\n" ..
        "1. Select your capture source above\n" ..
        "2. Set hotkeys in OBS Settings Ã¢â€ â€™ Hotkeys\n" ..
        "   Ã¢â‚¬Â¢ 'Toggle Zoom to Mouse' Ã¢â‚¬â€ Main zoom\n" ..
        "   Ã¢â‚¬Â¢ 'Toggle Mouse Follow' Ã¢â‚¬â€ Enable/disable follow\n" ..
        "3. Press the hotkey to zoom!\n\n" ..
        "TIPS:\n" ..
        "Ã¢â‚¬Â¢ Zoom centers on mouse position\n" ..
        "Ã¢â‚¬Â¢ Enable Auto-Follow for smooth tracking\n" ..
        "Ã¢â‚¬Â¢ Adjust Dead Zone to reduce jitter",
        obs.OBS_TEXT_INFO)
    obs.obs_properties_add_group(props, "help", "Ã¢Ââ€œ Help", obs.OBS_GROUP_NORMAL, grp_help)

    return props
end

--[[ Called to set default values
--[[ @param data table Settings data
function script_defaults(data)
    obs.obs_data_set_default_string(data, "source", "")
    obs.obs_data_set_default_double(data, "zoom_value", 2.0)
    obs.obs_data_set_default_double(data, "zoom_duration", 0.6)
    obs.obs_data_set_default_double(data, "zoom_overshoot", 0.0)
    obs.obs_data_set_default_string(data, "zoom_easing", "Cubic.Out")
    obs.obs_data_set_default_bool(data, "auto_follow", true)
    obs.obs_data_set_default_double(data, "follow_smooth_time", 0.15)
    obs.obs_data_set_default_int(data, "follow_dead_zone", 5)
    obs.obs_data_set_default_double(data, "scroll_step", 0.25)
    obs.obs_data_set_default_bool(data, "debug_logs", false)
    obs.obs_data_set_default_bool(data, "api_enabled", false)
    obs.obs_data_set_default_int(data, "api_port", 12345)
end

--================================================
-- SCRIPT METADATA
--================================================
script_info = {
    name = "OBS Zoom Pro",
    version = VERSION,
    description = "Intelligent camera zoom functionality with smooth transitions and easing curves.",
    author = "OBS Zoom Pro Team"
}
)

local platform = detect_platform()
local IS_WINDOWS = platform.WINDOWS
local IS_LINUX = platform.LINUX
local IS_MACOS = platform.MACOS

-- Log platform detection
log("Platform detected: " .. (jit and jit.os or "Unknown") .. (IS_WINDOWS and " (Full support)" or " (Basic support)"))

-- Virtual key codes (Lua constants instead of C #define)
local VK_LBUTTON = 0x01
local VK_RBUTTON = 0x02
local VK_MBUTTON = 0x04
local VK_CONTROL = 0x11
local VK_SHIFT = 0x10
local VK_MENU = 0x12  -- Alt

-- FFI declarations for Windows (only if FFI is available)


-- Cursor shape constants (Windows)
local CURSOR_ARROW = 1
local CURSOR_IBEAM = 2
local CURSOR_HAND = 3
local CURSOR_WAIT = 4

-- Module state
local Platform = {
    cursor_shape_available = IS_WINDOWS,
    last_mouse = { x = 0, y = 0 },
    last_click = false,
}

-- Get mouse position (cross-platform)
function Platform.get_mouse_pos()
    if IS_WINDOWS then
        local success, pt = pcall(function()
            local pt = ffi.new("POINT")
            if ffi.C.GetCursorPos(pt) ~= 0 then
                return { x = tonumber(pt.x), y = tonumber(pt.y) }
            end
            return nil
        end)
        if success and pt then
            return pt
        end
    elseif IS_LINUX then
        -- Linux: Use xdotool if available, fallback to X11
        local success, result = pcall(function()
            local handle = io.popen("xdotool getmouselocation 2>/dev/null || echo 'x:0 y:0'")
            if handle then
                local output = handle:read("*a")
                handle:close()
                local x, y = output:match("x:(%d+)%s+y:(%d+)")
                if x and y then
                    return { x = tonumber(x), y = tonumber(y) }
                end
            end
            return nil
        end)
        if success and result then
            return result
        end
    elseif IS_MACOS then
        -- macOS: Use osascript
        local success, result = pcall(function()
            local handle = io.popen(--[[osascript -e 'tell application "System Events" to get position of the mouse' 2>/dev/null || echo "0, 0"]])
            if handle then
                local output = handle:read("*a")
                handle:close()
                local x, y = output:match("(%d+),%s*(%d+)")
                if x and y then
                    return { x = tonumber(x), y = tonumber(y) }
                end
            end
            return nil
        end)
        if success and result then
            return result
        end
    end

    -- Fallback
    return { x = 0, y = 0 }
end

-- Check if left mouse button is clicked (Windows only, others return false)
function Platform.is_clicking()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x01) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if a modifier key is held (Windows only)
function Platform.is_key_held(vk_code)
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(vk_code) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if cursor is a pointer/hand (Windows only)
function Platform.is_cursor_pointer()
    if IS_WINDOWS then
        local success, result = pcall(function()
            local ci = ffi.new("CURSORINFO")
            ci.cbSize = ffi.sizeof("CURSORINFO")
            if ffi.C.GetCursorInfo(ci) ~= 0 then
                -- Check if hCursor is a hand pointer
                -- This is a simplified check; real implementation would compare cursor handles
                return ci.flags ~= 0  -- Simplified; actual implementation needs cursor handle comparison
            end
            return false
        end)
        return success and result or false
    end
    return false
end

-- Get cursor shape (Windows only, returns "arrow" for others)
function Platform.get_cursor_shape()
    if IS_WINDOWS then
        local success, result = pcall(function()
            local ci = ffi.new("CURSORINFO")
            ci.cbSize = ffi.sizeof("CURSORINFO")
            if ffi.C.GetCursorInfo(ci) ~= 0 and ci.hCursor ~= nil then
                local addr = tonumber(ffi.cast("uintptr_t", ci.hCursor))
                -- Common cursor IDs (these are typical values, may vary)
                -- IDC_ARROW = 32512, IDC_IBEAM = 32513, IDC_HAND = 32649
                -- We use address ranges as heuristic
                return "arrow"  -- Simplified; actual implementation would map handles
            end
            return "arrow"
        end)
        return success and result or "arrow"
    end
    return "arrow"
end

-- Check if Control key is held
function Platform.is_ctrl_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x11) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if Shift key is held
function Platform.is_shift_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x10) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if Alt key is held
function Platform.is_alt_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x12) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Convenience wrapper functions
function platform_get_mouse_pos()
    return Platform.get_mouse_pos()
end

function platform_is_clicking()
    return Platform.is_clicking()
end

function platform_is_cursor_pointer()
    return Platform.is_cursor_pointer()
end

function platform_cursor_shape_available()
    return Platform.cursor_shape_available
end

function platform_is_ctrl_held()
    return Platform.is_ctrl_held()
end

function platform_is_shift_held()
    return Platform.is_shift_held()
end

function platform_is_alt_held()
    return Platform.is_alt_held()
end

--================================================
-- MODULE: State Machine (M05)
--================================================
-- Manages zoom states and transitions
-- States: IDLE, ZOOMING_IN, ZOOMED_IN, ZOOMING_OUT, SCROLLING, JUMPING

local ZoomState = {
    IDLE         = "idle",
    ZOOMING_IN   = "zooming_in",
    ZOOMED_IN    = "zoomed_in",
    ZOOMING_OUT  = "zooming_out",
    SCROLLING    = "scrolling",    -- Scroll wheel mid-transition
    JUMPING      = "jumping",      -- Bookmark transition
}

local StateMachine = {
    state = ZoomState.IDLE,
    zoom_time = 0,          -- Animation progress (0 Ã¢â€ â€™ 1)
    zoom_level = 1.0,       -- Current zoom factor
    target_level = 1.0,     -- Target zoom factor
    start_crop = nil,       -- Crop at animation start {x, y, w, h}
    target_crop = nil,      -- Crop at animation end {x, y, w, h}
    following = false,      -- Mouse follow active

    -- Transition guards
    can_zoom_in = function(self)
        return self.state == ZoomState.IDLE
    end,

    can_zoom_out = function(self)
        return self.state == ZoomState.ZOOMED_IN
            or self.state == ZoomState.SCROLLING
    end,

    can_scroll = function(self)
        return self.state == ZoomState.ZOOMED_IN
            or self.state == ZoomState.IDLE
            or self.state == ZoomState.SCROLLING
    end,

    can_jump = function(self)
        return self.state ~= ZoomState.ZOOMING_IN
           and self.state ~= ZoomState.ZOOMING_OUT
           and self.state ~= ZoomState.JUMPING
    end,

    is_animating = function(self)
        return self.state == ZoomState.ZOOMING_IN
            or self.state == ZoomState.ZOOMING_OUT
            or self.state == ZoomState.SCROLLING
            or self.state == ZoomState.JUMPING
    end,

    is_zoomed = function(self)
        return self.state ~= ZoomState.IDLE
    end,
}

-- Transition to a new state
function StateMachine:transition(new_state, params)
    local old = self.state
    self.state = new_state
    self.zoom_time = 0

    if params then
        if params.start_crop then self.start_crop = params.start_crop end
        if params.target_crop then self.target_crop = params.target_crop end
        if params.target_level then self.target_level = params.target_level end
    end

    log("State: " .. old .. " Ã¢â€ â€™ " .. new_state)
end

-- Complete the current animation
function StateMachine:complete()
    if self.state == ZoomState.ZOOMING_IN
       or self.state == ZoomState.SCROLLING
       or self.state == ZoomState.JUMPING then
        self.zoom_level = self.target_level
        self.state = ZoomState.ZOOMED_IN
        self.zoom_time = 0
        log("State: " .. self.state .. " Ã¢â€ â€™ ZOOMED_IN (complete)")
    elseif self.state == ZoomState.ZOOMING_OUT then
        self.zoom_level = 1.0
        self.target_level = 1.0
        self.start_crop = nil
        self.target_crop = nil
        self.following = false
        self.state = ZoomState.IDLE
        self.zoom_time = 0
        log("State: ZOOMING_OUT Ã¢â€ â€™ IDLE (complete)")
    end
end

-- Reset to initial state
function StateMachine:reset()
    self.state = ZoomState.IDLE
    self.zoom_time = 0
    self.zoom_level = 1.0
    self.target_level = 1.0
    self.start_crop = nil
    self.target_crop = nil
    self.following = false
    log("StateMachine: Reset to IDLE")
end

-- Get current animation progress (0-1)
function StateMachine:get_progress()
    return clamp(0, 1, self.zoom_time)
end

-- Check if in a specific state
function StateMachine:is_state(state)
    return self.state == state
end

-- Get state name for display
function StateMachine:get_state_name()
    return self.state
end

-- Create a new state machine instance (for testing/isolation)
function StateMachine:new()
    local sm = {}
    setmetatable(sm, { __index = self })
    sm.state = ZoomState.IDLE
    sm.zoom_time = 0
    sm.zoom_level = 1.0
    sm.target_level = 1.0
    sm.start_crop = nil
    sm.target_crop = nil
    sm.following = false
    return sm
end

-- Global state machine instance
local SM = StateMachine:new()

--================================================
-- MODULE: Crop Filter Manager (M07)
--================================================
-- Manages the crop/pad filter used to simulate zoom
-- Creates, updates, and destroys the filter automatically

local FILTER_PREFIX = "[ZoomPro] "
local CROP_FILTER_NAME = FILTER_PREFIX .. "Crop"

local CropFilterManager = {
    filter = nil,           -- The crop filter source
    source = nil,           -- The parent source
    original_crop = nil,    -- Original crop values for restoration
    current_crop = { x = 0, y = 0, w = 0, h = 0 },
    initialized = false,
}

-- Create the crop filter on a source
function CropFilterManager:create(source)
    if not source then
        log("CropFilter: No source provided")
        return false
    end

    self:cleanup()  -- Clean up any existing filter
    self.source = source

    -- Check if our filter already exists
    local existing = obs.obs_source_get_filter_by_name(source, CROP_FILTER_NAME)
    if existing then
        log("CropFilter: Found existing filter")
        self.filter = existing
        self.initialized = true
        return true
    end

    -- Create new crop/pad filter
    local settings = obs.obs_data_create()
    obs.obs_data_set_int(settings, "left", 0)
    obs.obs_data_set_int(settings, "top", 0)
    obs.obs_data_set_int(settings, "right", 0)
    obs.obs_data_set_int(settings, "bottom", 0)
    obs.obs_data_set_bool(settings, "relative", false)  -- Absolute positioning

    self.filter = obs.obs_source_create_private(
        "crop_filter",      -- Filter type
        CROP_FILTER_NAME,   -- Filter name
        settings            -- Settings
    )

    obs.obs_data_release(settings)

    if not self.filter then
        log("CropFilter: Failed to create filter")
        return false
    end

    -- Add filter to source
    obs.obs_source_filter_add(source, self.filter)

    -- Store original crop (none)
    self.original_crop = { x = 0, y = 0, w = 0, h = 0 }

    self.initialized = true
    log("CropFilter: Created successfully")
    return true
end

-- Update the crop filter with new values
function CropFilterManager:update(x, y, w, h)
    if not self.filter or not self.initialized then
        return false
    end

    -- Store current crop
    self.current_crop = { x = x, y = y, w = w, h = h }

    -- Get filter settings
    local settings = obs.obs_source_get_settings(self.filter)
    if not settings then
        return false
    end

    -- Calculate crop values
    -- For crop_filter: left, top are absolute position
    -- right, bottom are width/height from right/bottom edge
    -- We need to convert our x, y, w, h to this format

    -- Get source dimensions
    local source_w = obs.obs_source_get_width(self.source)
    local source_h = obs.obs_source_get_height(self.source)

    if source_w == 0 or source_h == 0 then
        obs.obs_data_release(settings)
        return false
    end

    -- Set crop values
    -- left = x offset from left
    -- top = y offset from top
    -- right = source_w - (x + w) = remaining width on right
    -- bottom = source_h - (y + h) = remaining height on bottom
    local left = math.floor(x)
    local top = math.floor(y)
    local right = math.floor(source_w - (x + w))
    local bottom = math.floor(source_h - (y + h))

    -- Clamp to valid values
    left = math.max(0, left)
    top = math.max(0, top)
    right = math.max(0, right)
    bottom = math.max(0, bottom)

    obs.obs_data_set_int(settings, "left", left)
    obs.obs_data_set_int(settings, "top", top)
    obs.obs_data_set_int(settings, "right", right)
    obs.obs_data_set_int(settings, "bottom", bottom)

    -- Update the filter
    obs.obs_source_update(self.filter, settings)
    obs.obs_data_release(settings)

    return true
end

-- Get current crop values
function CropFilterManager:get_crop()
    return self.current_crop
end

-- Reset crop to original (no crop)
function CropFilterManager:reset()
    if not self.filter or not self.initialized then
        return false
    end

    local settings = obs.obs_source_get_settings(self.filter)
    if settings then
        obs.obs_data_set_int(settings, "left", 0)
        obs.obs_data_set_int(settings, "top", 0)
        obs.obs_data_set_int(settings, "right", 0)
        obs.obs_data_set_int(settings, "bottom", 0)
        obs.obs_source_update(self.filter, settings)
        obs.obs_data_release(settings)
    end

    self.current_crop = { x = 0, y = 0, w = 0, h = 0 }
    return true
end

-- Remove the filter and restore original state
function CropFilterManager:cleanup()
    if self.filter and self.source then
        -- Reset to no crop first
        self:reset()

        -- Remove filter from source
        obs.obs_source_filter_remove(self.source, self.filter)
        obs.obs_source_release(self.filter)
        self.filter = nil
        log("CropFilter: Removed from source")
    end

    self.source = nil
    self.original_crop = nil
    self.current_crop = { x = 0, y = 0, w = 0, h = 0 }
    self.initialized = false
end

-- Check if filter is ready
function CropFilterManager:is_ready()
    return self.initialized and self.filter ~= nil
end

-- Get source dimensions
function CropFilterManager:get_source_size()
    if not self.source then
        return 0, 0
    end
    return obs.obs_source_get_width(self.source), obs.obs_source_get_height(self.source)
end

-- Convenience wrapper functions
function crop_filter_create(source)
    return CropFilterManager:create(source)
end

function crop_filter_update(x, y, w, h)
    return CropFilterManager:update(x, y, w, h)
end

function crop_filter_reset()
    return CropFilterManager:reset()
end

function crop_filter_cleanup()
    return CropFilterManager:cleanup()
end

function crop_filter_is_ready()
    return CropFilterManager:is_ready()
end

function crop_filter_get_crop()
    return CropFilterManager:get_crop()
end

function crop_filter_get_source_size()
    return CropFilterManager:get_source_size()
end

--================================================
-- MODULE: Source Manager (M08)
--================================================
-- Handles finding sources in scenes, capturing transforms,
-- and managing source state for zoom operations

local SourceManager = {
    source = nil,           -- Current zoom source
    sceneitem = nil,        -- Scene item reference
    scene = nil,            -- Current scene
    original_transform = nil, -- Saved original transform
    source_name = "",       -- Source name for settings
    initialized = false,
}

-- Transform data structure
local TransformData = {
    pos = { x = 0, y = 0 },
    scale = { x = 1.0, y = 1.0 },
    rot = 0,
    bounds_type = 0,
    bounds = { x = 0, y = 0 },
    crop = { left = 0, top = 0, right = 0, bottom = 0 },
}

-- Find a source in a scene (BFS through groups)
function SourceManager:find_sceneitem(scene, source_name)
    if not scene or not source_name then
        return nil
    end

    local scene_source = obs.obs_scene_from_source(scene)
    if not scene_source then
        return nil
    end

    -- BFS queue
    local queue = {}
    table.insert(queue, scene_source)

    while #queue > 0 do
        local current_scene = table.remove(queue, 1)

        -- Iterate through items
        local items = obs.obs_scene_enum_items(current_scene)
        if items then
            for _, item in ipairs(items) do
                local item_source = obs.obs_sceneitem_get_source(item)
                if item_source then
                    local name = obs.obs_source_get_name(item_source)

                    -- Check if this is our target
                    if name == source_name then
                        obs.sceneitem_list_release(items)
                        return item
                    end

                    -- Check if this is a group (nested scene)
                    if obs.obs_source_get_type(item_source) == obs.OBS_SOURCE_TYPE_INPUT then
                        local id = obs.obs_source_get_id(item_source)
                        if id == "group" then
                            local group_scene = obs.obs_group_from_source(item_source)
                            if group_scene then
                                table.insert(queue, group_scene)
                            end
                        end
                    end
                end
            end
            obs.sceneitem_list_release(items)
        end
    end

    return nil
end

-- Capture the current transform of a scene item
function SourceManager:capture_transform(sceneitem)
    if not sceneitem then
        return nil
    end

    local transform = {}

    -- Position
    local pos = obs.vec2()
    obs.obs_sceneitem_get_pos(sceneitem, pos)
    transform.pos = { x = pos.x, y = pos.y }

    -- Scale
    local scale = obs.vec2()
    obs.obs_sceneitem_get_scale(sceneitem, scale)
    transform.scale = { x = scale.x, y = scale.y }

    -- Rotation
    transform.rot = obs.obs_sceneitem_get_rot(sceneitem)

    -- Bounds
    transform.bounds_type = obs.obs_sceneitem_get_bounds_type(sceneitem)
    local bounds = obs.vec2()
    obs.obs_sceneitem_get_bounds(sceneitem, bounds)
    transform.bounds = { x = bounds.x, y = bounds.y }

    -- Crop
    local crop = obs.obs_sceneitem_crop()
    obs.obs_sceneitem_get_crop(sceneitem, crop)
    transform.crop = {
        left = crop.left,
        top = crop.top,
        right = crop.right,
        bottom = crop.bottom
    }

    return transform
end

-- Restore a saved transform to a scene item
function SourceManager:restore_transform(sceneitem, transform)
    if not sceneitem or not transform then
        return false
    end

    -- Position
    local pos = obs.vec2()
    pos.x = transform.pos.x
    pos.y = transform.pos.y
    obs.obs_sceneitem_set_pos(sceneitem, pos)

    -- Scale
    local scale = obs.vec2()
    scale.x = transform.scale.x
    scale.y = transform.scale.y
    obs.obs_sceneitem_set_scale(sceneitem, scale)

    -- Rotation
    obs.obs_sceneitem_set_rot(sceneitem, transform.rot)

    -- Bounds
    obs.obs_sceneitem_set_bounds_type(sceneitem, transform.bounds_type)
    local bounds = obs.vec2()
    bounds.x = transform.bounds.x
    bounds.y = transform.bounds.y
    obs.obs_sceneitem_set_bounds(sceneitem, bounds)

    -- Crop
    local crop = obs.obs_sceneitem_crop()
    crop.left = transform.crop.left
    crop.top = transform.crop.top
    crop.right = transform.crop.right
    crop.bottom = transform.crop.bottom
    obs.obs_sceneitem_set_crop(sceneitem, crop)

    return true
end

-- Initialize with a source name
function SourceManager:init(source_name)
    self:release()  -- Clean up any existing state

    if not source_name or source_name == "" then
        log("SourceManager: No source name provided")
        return false
    end

    self.source_name = source_name

    -- Get current scene
    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then
        log("SourceManager: No current scene")
        return false
    end

    self.scene = scene_source

    -- Find the scene item
    self.sceneitem = self:find_sceneitem(scene_source, source_name)
    if not self.sceneitem then
        log("SourceManager: Source not found in scene: " .. source_name)
        obs.obs_source_release(scene_source)
        return false
    end

    -- Get the source
    self.source = obs.obs_sceneitem_get_source(self.sceneitem)
    if not self.source then
        log("SourceManager: Failed to get source from sceneitem")
        obs.obs_source_release(scene_source)
        return false
    end

    -- Capture original transform
    self.original_transform = self:capture_transform(self.sceneitem)

    -- Create crop filter
    if not crop_filter_create(self.source) then
        log("SourceManager: Failed to create crop filter")
        obs.obs_source_release(scene_source)
        return false
    end

    self.initialized = true
    log("SourceManager: Initialized with source: " .. source_name)

    obs.obs_source_release(scene_source)
    return true
end

-- Release all resources
function SourceManager:release()
    -- Clean up crop filter
    crop_filter_cleanup()

    -- Restore original transform if we have it
    if self.sceneitem and self.original_transform then
        self:restore_transform(self.sceneitem, self.original_transform)
        log("SourceManager: Restored original transform")
    end

    self.source = nil
    self.sceneitem = nil
    self.scene = nil
    self.original_transform = nil
    self.initialized = false

    log("SourceManager: Released")
end

-- Get source dimensions
function SourceManager:get_source_size()
    if not self.source then
        return 0, 0
    end
    return obs.obs_source_get_width(self.source), obs.obs_source_get_height(self.source)
end

-- Check if source is valid
function SourceManager:is_valid()
    return self.initialized and self.source ~= nil and self.sceneitem ~= nil
end

-- Get source info
function SourceManager:get_info()
    if not self:is_valid() then
        return nil
    end

    return {
        name = self.source_name,
        width = obs.obs_source_get_width(self.source),
        height = obs.obs_source_get_height(self.source),
    }
end

-- Get list of available capture sources
function SourceManager.get_available_sources()
    local sources = {}

    -- Get all sources
    local source_list = obs.obs_enum_sources()
    if source_list then
        for _, source in ipairs(source_list) do
            local source_id = obs.obs_source_get_id(source)
            local name = obs.obs_source_get_name(source)

            -- Filter for capture sources
            local is_capture = false
            if source_id == "monitor_capture" or      -- Display capture
               source_id == "window_capture" or       -- Window capture
               source_id == "game_capture" or         -- Game capture
               source_id == "xshm_input" or           -- Linux X11 capture
               source_id == "av_capture_input" then   -- macOS capture
                is_capture = true
            end

            if is_capture then
                table.insert(sources, {
                    name = name,
                    id = source_id,
                })
            end
        end
        obs.source_list_release(source_list)
    end

    return sources
end

-- Convenience wrapper functions
function source_manager_init(source_name)
    return SourceManager:init(source_name)
end

function source_manager_release()
    return SourceManager:release()
end

function source_manager_is_valid()
    return SourceManager:is_valid()
end

function source_manager_get_source()
    return SourceManager.source
end

function source_manager_get_sceneitem()
    return SourceManager.sceneitem
end

function source_manager_get_size()
    return SourceManager:get_source_size()
end

function source_manager_get_available_sources()
    return SourceManager.get_available_sources()
end

--================================================
-- MODULE: Camera Physics (M06)
--================================================
-- Handles camera position calculations, dead zones,
-- and SmoothDamp-based camera movement

local CameraPhysics = {
    -- Smoothed camera position
    pos = { x = 0, y = 0 },

    -- Velocities for SmoothDamp
    vel_x = { val = 0 },
    vel_y = { val = 0 },

    -- Dead zone state
    tracked_pos = { x = 0, y = 0 },
    dead_zone_active = false,

    -- Last camera position (for velocity calculation)
    last_pos = { x = 0, y = 0 },

    -- Monitor offset (for multi-monitor setups)
    monitor_offset = { x = 0, y = 0 },
}

-- Initialize camera tracking with starting position
function CameraPhysics:init(mouse_pos)
    if mouse_pos then
        self.pos.x = mouse_pos.x
        self.pos.y = mouse_pos.y
        self.tracked_pos.x = mouse_pos.x
        self.tracked_pos.y = mouse_pos.y
    end
    self.vel_x.val = 0
    self.vel_y.val = 0
    self.last_pos.x = self.pos.x
    self.last_pos.y = self.pos.y
end

-- Apply dead zone to mouse input
-- Returns the position the camera should track
function CameraPhysics:apply_dead_zone(mouse_pos, dead_zone_radius)
    if not mouse_pos then
        return self.tracked_pos
    end

    if dead_zone_radius <= 0 then
        self.tracked_pos.x = mouse_pos.x
        self.tracked_pos.y = mouse_pos.y
        return self.tracked_pos
    end

    -- Calculate distance from tracked position to mouse
    local dx = mouse_pos.x - self.tracked_pos.x
    local dy = mouse_pos.y - self.tracked_pos.y
    local dist = math.sqrt(dx * dx + dy * dy)

    if dist <= dead_zone_radius then
        -- Mouse is within dead zone, don't move tracked position
        self.dead_zone_active = true
        return self.tracked_pos
    end

    -- Mouse is outside dead zone
    -- Move tracked position so it stays exactly dead_zone_radius from mouse
    self.dead_zone_active = false
    local excess = dist - dead_zone_radius
    local nx = dx / dist  -- Normalized direction
    local ny = dy / dist

    self.tracked_pos.x = self.tracked_pos.x + nx * excess
    self.tracked_pos.y = self.tracked_pos.y + ny * excess

    return self.tracked_pos
end

-- Smooth the input position using SmoothDamp
function CameraPhysics:smooth_input(target_pos, smooth_time, dt)
    if not target_pos then
        return self.pos
    end

    local max_speed = 100000  -- Very high max speed for smooth camera

    self.pos.x = SmoothDamp(self.pos.x, target_pos.x, self.vel_x, smooth_time, max_speed, dt)
    self.pos.y = SmoothDamp(self.pos.y, target_pos.y, self.vel_y, smooth_time, max_speed, dt)

    return self.pos
end

-- Calculate the crop rectangle for a given zoom level and center position
function CameraPhysics:compute_crop(center_x, center_y, zoom_level, source_w, source_h)
    if zoom_level <= 1.0 then
        -- No zoom, return full source
        return {
            x = 0,
            y = 0,
            w = source_w,
            h = source_h,
        }
    end

    -- Calculate crop dimensions
    local crop_w = source_w / zoom_level
    local crop_h = source_h / zoom_level

    -- Center the crop on the target position
    local crop_x = center_x - crop_w / 2
    local crop_y = center_y - crop_h / 2

    -- Clamp to source bounds
    crop_x = clamp(0, source_w - crop_w, crop_x)
    crop_y = clamp(0, source_h - crop_h, crop_y)

    return {
        x = crop_x,
        y = crop_y,
        w = crop_w,
        h = crop_h,
    }
end

-- Calculate target crop for zoom animation
-- mouse_pos: current mouse position
-- zoom_level: target zoom level
-- source_w, source_h: source dimensions
-- monitor_offset: offset for multi-monitor (optional)
function CameraPhysics:get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
    if not mouse_pos then
        return nil
    end

    -- Apply monitor offset if provided
    local target_x = mouse_pos.x
    local target_y = mouse_pos.y

    if monitor_offset then
        target_x = target_x - monitor_offset.x
        target_y = target_y - monitor_offset.y
    end

    -- Clamp to source bounds
    target_x = clamp(0, source_w, target_x)
    target_y = clamp(0, source_h, target_y)

    return self:compute_crop(target_x, target_y, zoom_level, source_w, source_h)
end

-- Interpolate between two crop rectangles
function CameraPhysics:lerp_crop(start_crop, end_crop, t, easing_fn)
    if not start_crop or not end_crop then
        return nil
    end

    t = clamp(0, 1, t)

    -- Apply easing
    local eased_t = easing_fn and easing_fn(t) or t

    return {
        x = lerp(start_crop.x, end_crop.x, eased_t),
        y = lerp(start_crop.y, end_crop.y, eased_t),
        w = lerp(start_crop.w, end_crop.w, eased_t),
        h = lerp(start_crop.h, end_crop.h, eased_t),
    }
end

-- Get camera velocity (for motion blur)
function CameraPhysics:get_velocity()
    return {
        x = self.pos.x - self.last_pos.x,
        y = self.pos.y - self.last_pos.y,
    }
end

-- Update last position (call at end of frame)
function CameraPhysics:update_last_pos()
    self.last_pos.x = self.pos.x
    self.last_pos.y = self.pos.y
end

-- Set monitor offset
function CameraPhysics:set_monitor_offset(offset)
    self.monitor_offset = offset or { x = 0, y = 0 }
end

-- Reset camera state
function CameraPhysics:reset()
    self.pos = { x = 0, y = 0 }
    self.vel_x = { val = 0 }
    self.vel_y = { val = 0 }
    self.tracked_pos = { x = 0, y = 0 }
    self.dead_zone_active = false
    self.last_pos = { x = 0, y = 0 }
end

-- Convenience wrapper functions
function camera_physics_init(mouse_pos)
    return CameraPhysics:init(mouse_pos)
end

function camera_physics_apply_dead_zone(mouse_pos, dead_zone_radius)
    return CameraPhysics:apply_dead_zone(mouse_pos, dead_zone_radius)
end

function camera_physics_smooth_input(target_pos, smooth_time, dt)
    return CameraPhysics:smooth_input(target_pos, smooth_time, dt)
end

function camera_physics_compute_crop(center_x, center_y, zoom_level, source_w, source_h)
    return CameraPhysics:compute_crop(center_x, center_y, zoom_level, source_w, source_h)
end

function camera_physics_get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
    return CameraPhysics:get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
end

function camera_physics_lerp_crop(start_crop, end_crop, t, easing_fn)
    return CameraPhysics:lerp_crop(start_crop, end_crop, t, easing_fn)
end

function camera_physics_get_velocity()
    return CameraPhysics:get_velocity()
end

function camera_physics_update_last_pos()
    return CameraPhysics:update_last_pos()
end

function camera_physics_reset()
    return CameraPhysics:reset()
end

--================================================
-- MODULE: Timer & Main Loop (M09)
--================================================
-- Core integration module that handles frame-by-frame updates,
-- input processing, state machine updates, and output

-- Configuration (will be populated from settings)
local cfg = {
    source_name = "",
    zoom_value = 2.0,
    max_zoom = 10.0,
    zoom_duration = 0.6,
    zoom_overshoot = 0.0,
    zoom_easing = "Cubic.Out",

    auto_follow = true,
    follow_smooth_time = 0.15,
    follow_dead_zone = 5,

    debug_logs = false,
}

-- Timing
local last_tick_time = 0
local timer_running = false

-- Frame diff tracking (skip updates if nothing changed)
local last_output = { x = -1, y = -1, w = -1, h = -1 }

-- Original crop for zoom out
local original_crop = { x = 0, y = 0, w = 0, h = 0 }

-- Hotkey IDs
local hotkey_toggle_zoom = nil
local hotkey_toggle_follow = nil

-- Get reliable delta time
local function get_dt()
    local now = os.clock()
    local dt = now - last_tick_time
    last_tick_time = now
    return clamp(0.001, 0.1, dt)  -- Guard against freezes and div/zero
end

-- Start the timer
local function start_timer()
    if not timer_running then
        timer_running = true
        last_tick_time = os.clock()
        -- Use frame-synced interval
        local interval = 16  -- Default to ~60fps
        obs.timer_add(on_timer, interval)
        log("Timer: Started")
    end
end

-- Stop the timer
local function stop_timer()
    if timer_running then
        timer_running = false
        obs.timer_remove(on_timer)
        log("Timer: Stopped")
    end
end

-- Initialize mouse tracking
local function init_mouse_tracking(mouse_pos)
    camera_physics_init(mouse_pos)
    original_crop = {
        x = 0,
        y = 0,
        w = 0,
        h = 0,
    }
end

-- Main timer callback
function on_timer()
    local dt = get_dt()

    -- Guard: No valid source
    if not source_manager_is_valid() then
        return
    end

    --==========================
    -- 1. INPUT
    --==========================
    local raw_mouse = platform_get_mouse_pos()

    --==========================
    -- 2. STATE MACHINE UPDATE
    --==========================
    if SM:is_animating() then
        SM.zoom_time = SM.zoom_time + (dt / cfg.zoom_duration)

        -- Check for completion
        if SM.zoom_time >= 1.0 then
            SM:complete()

            -- Auto-enable follow after zoom in
            if SM.state == ZoomState.ZOOMED_IN and cfg.auto_follow then
                SM.following = true
            end

            -- Stop timer if idle
            if SM.state == ZoomState.IDLE then
                stop_timer()
            end
        end
    end

    --==========================
    -- 3. CAMERA POSITION
    --==========================
    local crop = nil
    local source_w, source_h = source_manager_get_size()

    if source_w == 0 or source_h == 0 then
        return
    end

    if SM:is_animating() then
        -- Animate between start and target crop
        local easing_fn = Easing.get(cfg.zoom_easing, cfg.zoom_overshoot)
        crop = camera_physics_lerp_crop(SM.start_crop, SM.target_crop, SM.zoom_time, easing_fn)
    elseif SM:is_zoomed() and SM.following then
        -- Follow mouse with dead zone and smoothing
        local tracked = camera_physics_apply_dead_zone(raw_mouse, cfg.follow_dead_zone)
        local smoothed = camera_physics_smooth_input(tracked, cfg.follow_smooth_time, dt)
        crop = camera_physics_compute_crop(smoothed.x, smoothed.y, SM.zoom_level, source_w, source_h)
        camera_physics_update_last_pos()
    elseif SM:is_zoomed() then
        -- Static zoom (not following)
        crop = camera_physics_get_target_crop(
            { x = SM.target_crop.x + SM.target_crop.w / 2, y = SM.target_crop.y + SM.target_crop.h / 2 },
            SM.zoom_level, source_w, source_h, nil
        )
    end

    --==========================
    -- 4. OUTPUT (Diff-based)
    --==========================
    if crop then
        local cx = math.floor(crop.x)
        local cy = math.floor(crop.y)
        local cw = math.floor(crop.w)
        local ch = math.floor(crop.h)

        if cx ~= last_output.x or cy ~= last_output.y or
           cw ~= last_output.w or ch ~= last_output.h then
            crop_filter_update(cx, cy, cw, ch)
            last_output.x = cx
            last_output.y = cy
            last_output.w = cw
            last_output.h = ch
        end
    end
end

--==========================
-- HOTKEY HANDLERS
--==========================

function on_toggle_zoom(pressed)
    if not pressed then return end

    if not source_manager_is_valid() then
        log("Toggle Zoom: No valid source")
        return
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        log("Toggle Zoom: Invalid source dimensions")
        return
    end

    if SM.state == ZoomState.IDLE then
        -- ZOOM IN
        local mouse = platform_get_mouse_pos()
        init_mouse_tracking(mouse)

        -- Store original crop
        original_crop = { x = 0, y = 0, w = source_w, h = source_h }

        -- Calculate target crop
        local target_crop = camera_physics_get_target_crop(mouse, cfg.zoom_value, source_w, source_h, nil)

        SM:transition(ZoomState.ZOOMING_IN, {
            start_crop = original_crop,
            target_crop = target_crop,
            target_level = cfg.zoom_value
        })

        start_timer()

    elseif SM.state == ZoomState.ZOOMED_IN then
        -- ZOOM OUT
        SM.following = false

        local current = crop_filter_get_crop()
        SM:transition(ZoomState.ZOOMING_OUT, {
            start_crop = current,
            target_crop = original_crop,
            target_level = 1.0
        })

        start_timer()
    end
    -- Ignore if already animating (guard against rapid presses)
end

function on_toggle_follow(pressed)
    if not pressed then return end
    if not SM:is_zoomed() then return end

    SM.following = not SM.following
    log("Follow: " .. tostring(SM.following))

    if SM.following and not timer_running then
        start_timer()
    end
end

--==========================
-- HOTKEY REGISTRATION
--==========================

local function register_hotkeys(settings)
    -- Toggle Zoom hotkey
    hotkey_toggle_zoom = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.toggle_zoom",
        "Toggle Zoom to Mouse",
        on_toggle_zoom
    )

    -- Toggle Follow hotkey
    hotkey_toggle_follow = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.toggle_follow",
        "Toggle Mouse Follow",
        on_toggle_follow
    )

    -- Load saved hotkey bindings
    local toggle_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.toggle_zoom")
    if toggle_array then
        obs.obs_hotkey_load(hotkey_toggle_zoom, toggle_array)
        obs.obs_data_array_release(toggle_array)
    end

    local follow_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.toggle_follow")
    if follow_array then
        obs.obs_hotkey_load(hotkey_toggle_follow, follow_array)
        obs.obs_data_array_release(follow_array)
    end

    -- Register scroll zoom hotkeys
    register_scroll_hotkeys(settings)

    log("Hotkeys: Registered")
end

local function save_hotkeys(settings)
    if hotkey_toggle_zoom then
        local array = obs.obs_hotkey_save(hotkey_toggle_zoom)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.toggle_zoom", array)
        obs.obs_data_array_release(array)
    end

    if hotkey_toggle_follow then
        local array = obs.obs_hotkey_save(hotkey_toggle_follow)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.toggle_follow", array)
        obs.obs_data_array_release(array)
    end

    -- Save scroll zoom hotkeys
    save_scroll_hotkeys(settings)
end

local function unregister_hotkeys()
    if hotkey_toggle_zoom then
        obs.obs_hotkey_unregister(hotkey_toggle_zoom)
        hotkey_toggle_zoom = nil
    end
    if hotkey_toggle_follow then
        obs.obs_hotkey_unregister(hotkey_toggle_follow)
        hotkey_toggle_follow = nil
    end
    -- Unregister scroll zoom hotkeys
    unregister_scroll_hotkeys()
    log("Hotkeys: Unregistered")
end

--==========================
-- SCENE EVENT HANDLERS
--==========================

function on_frontend_event(event)
    if event == obs.OBS_FRONTEND_EVENT_SCENE_CHANGED then
        -- Scene changed, re-acquire source
        log("Event: Scene changed")

        -- Handle scene memory
        scene_memory_on_scene_change()

        if cfg.source_name and cfg.source_name ~= "" then
            source_manager_release()
            source_manager_init(cfg.source_name)
        end
    elseif event == obs.OBS_FRONTEND_EVENT_EXIT then
        -- OBS is closing
        log("Event: OBS exiting")
        stop_timer()
        source_manager_release()
    end
end

--==========================
-- CONFIGURATION UPDATE
--==========================

local function update_config(settings)
    cfg.source_name = obs.obs_data_get_string(settings, "source") or ""
    cfg.zoom_value = obs.obs_data_get_double(settings, "zoom_value")
    cfg.zoom_duration = obs.obs_data_get_double(settings, "zoom_duration")
    cfg.zoom_overshoot = obs.obs_data_get_double(settings, "zoom_overshoot")
    cfg.zoom_easing = obs.obs_data_get_string(settings, "zoom_easing") or "Cubic.Out"

    cfg.auto_follow = obs.obs_data_get_bool(settings, "auto_follow")
    cfg.follow_smooth_time = obs.obs_data_get_double(settings, "follow_smooth_time")
    cfg.follow_dead_zone = obs.obs_data_get_int(settings, "follow_dead_zone")

    cfg.debug_logs = obs.obs_data_get_bool(settings, "debug_logs")
    debug_logs = cfg.debug_logs

    -- Update scroll zoom config
    update_scroll_config(settings)

    -- Check if source changed
    local current_source = source_manager_is_valid() and cfg.source_name
    if cfg.source_name ~= "" and cfg.source_name ~= current_source then
        -- Reset state and reinitialize
        SM:reset()
        stop_timer()
        source_manager_release()
        source_manager_init(cfg.source_name)
    end
end

--================================================
-- MODULE: Scroll Zoom (M10)
--================================================
-- Enables gradual zoom control via scroll wheel with modifier key
-- Provides dynamic zoom level adjustment during zoomed state

local ScrollZoom = {
    -- Hotkey IDs for scroll zoom
    hotkey_scroll_up = nil,
    hotkey_scroll_down = nil,

    -- Configuration (populated from settings)
    scroll_step = 0.25,
    scroll_modifier = "ctrl",  -- "ctrl", "alt", "shift"
}

-- Check if modifier key is held
local function is_modifier_held()
    if ScrollZoom.scroll_modifier == "ctrl" then
        return platform_is_ctrl_held()
    elseif ScrollZoom.scroll_modifier == "alt" then
        return platform_is_alt_held()
    elseif ScrollZoom.scroll_modifier == "shift" then
        return platform_is_shift_held()
    end
    return false
end

-- Handle scroll zoom in
function on_scroll_zoom_up(pressed)
    if not pressed then return end
    on_scroll_zoom(1)
end

-- Handle scroll zoom out
function on_scroll_zoom_down(pressed)
    if not pressed then return end
    on_scroll_zoom(-1)
end

-- Main scroll zoom handler
function on_scroll_zoom(direction)
    -- Check if we can scroll
    if not SM:can_scroll() then return end

    -- Check modifier (optional - can be configured)
    -- For now, we rely on OBS hotkey bindings which can include modifiers

    if not source_manager_is_valid() then
        log("Scroll Zoom: No valid source")
        return
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        return
    end

    -- Calculate new zoom level
    local step = ScrollZoom.scroll_step * direction  -- e.g., 0.25
    local new_level

    if SM.state == ZoomState.IDLE then
        -- Starting from unzoomed
        new_level = 1.0 + step
    else
        -- Already zoomed, adjust level
        new_level = SM.target_level + step
    end

    -- Clamp to valid range
    new_level = clamp(1.0, cfg.max_zoom, new_level)

    -- If we hit 1.0, fully zoom out
    if new_level <= 1.0 then
        if SM:is_zoomed() then
            -- Trigger full zoom out
            local current = crop_filter_get_crop()
            SM.following = false
            SM:transition(ZoomState.ZOOMING_OUT, {
                start_crop = current,
                target_crop = original_crop,
                target_level = 1.0
            })
            start_timer()
        end
        return
    end

    -- Get current mouse position
    local mouse = platform_get_mouse_pos()

    -- Calculate new target crop for new zoom level
    local target_crop = camera_physics_get_target_crop(mouse, new_level, source_w, source_h, nil)

    -- Get current crop as start
    local start_crop
    if SM:is_animating() then
        -- Use current interpolated crop
        start_crop = crop_filter_get_crop()
    elseif SM:is_zoomed() then
        -- Use current crop
        start_crop = crop_filter_get_crop()
    else
        -- Starting from unzoomed
        start_crop = { x = 0, y = 0, w = source_w, h = source_h }
        original_crop = start_crop
        camera_physics_init(mouse)
    end

    -- Transition to new zoom level
    if SM.state == ZoomState.IDLE then
        -- First scroll from unzoomed
        SM:transition(ZoomState.SCROLLING, {
            start_crop = start_crop,
            target_crop = target_crop,
            target_level = new_level
        })
    else
        -- Already zoomed, adjust level (interrupt current animation)
        SM:transition(ZoomState.SCROLLING, {
            start_crop = start_crop,
            target_crop = target_crop,
            target_level = new_level
        })
    end

    start_timer()
    log("Scroll Zoom: Level " .. string.format("%.2f", new_level))
end

-- Zoom to a specific level (for API calls)
function on_scroll_zoom_to(level)
    if not source_manager_is_valid() then return end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then return end

    level = clamp(1.0, cfg.max_zoom, level)

    if level <= 1.0 then
        -- Zoom out
        if SM:is_zoomed() then
            local current = crop_filter_get_crop()
            SM.following = false
            SM:transition(ZoomState.ZOOMING_OUT, {
                start_crop = current,
                target_crop = original_crop,
                target_level = 1.0
            })
            start_timer()
        end
        return
    end

    local mouse = platform_get_mouse_pos()
    local target_crop = camera_physics_get_target_crop(mouse, level, source_w, source_h, nil)

    local start_crop
    if SM:is_zoomed() then
        start_crop = crop_filter_get_crop()
    else
        start_crop = { x = 0, y = 0, w = source_w, h = source_h }
        original_crop = start_crop
        camera_physics_init(mouse)
    end

    SM:transition(ZoomState.SCROLLING, {
        start_crop = start_crop,
        target_crop = target_crop,
        target_level = level
    })

    start_timer()
end

-- Register scroll zoom hotkeys
local function register_scroll_hotkeys(settings)
    -- Scroll Up hotkey
    ScrollZoom.hotkey_scroll_up = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.scroll_up",
        "Zoom In (Scroll)",
        on_scroll_zoom_up
    )

    -- Scroll Down hotkey
    ScrollZoom.hotkey_scroll_down = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.scroll_down",
        "Zoom Out (Scroll)",
        on_scroll_zoom_down
    )

    -- Load saved bindings
    local up_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.scroll_up")
    if up_array then
        obs.obs_hotkey_load(ScrollZoom.hotkey_scroll_up, up_array)
        obs.obs_data_array_release(up_array)
    end

    local down_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.scroll_down")
    if down_array then
        obs.obs_hotkey_load(ScrollZoom.hotkey_scroll_down, down_array)
        obs.obs_data_array_release(down_array)
    end

    log("Scroll Zoom: Hotkeys registered")
end

-- Save scroll hotkey bindings
local function save_scroll_hotkeys(settings)
    if ScrollZoom.hotkey_scroll_up then
        local array = obs.obs_hotkey_save(ScrollZoom.hotkey_scroll_up)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.scroll_up", array)
        obs.obs_data_array_release(array)
    end

    if ScrollZoom.hotkey_scroll_down then
        local array = obs.obs_hotkey_save(ScrollZoom.hotkey_scroll_down)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.scroll_down", array)
        obs.obs_data_array_release(array)
    end
end

-- Unregister scroll hotkeys
local function unregister_scroll_hotkeys()
    if ScrollZoom.hotkey_scroll_up then
        obs.obs_hotkey_unregister(ScrollZoom.hotkey_scroll_up)
        ScrollZoom.hotkey_scroll_up = nil
    end
    if ScrollZoom.hotkey_scroll_down then
        obs.obs_hotkey_unregister(ScrollZoom.hotkey_scroll_down)
        ScrollZoom.hotkey_scroll_down = nil
    end
end

-- Update scroll zoom config
local function update_scroll_config(settings)
    ScrollZoom.scroll_step = obs.obs_data_get_double(settings, "scroll_step")
    ScrollZoom.scroll_modifier = obs.obs_data_get_string(settings, "scroll_modifier") or "ctrl"
end

--================================================
-- PLACEHOLDER: Future Modules
--================================================

-- M01: Configuration & Settings (TODO)
-- M05: Scene Manager (TODO)
-- M06: Source Manager (TODO)
-- M07: Crop/Zoom Controller (TODO)
-- M08: Motion Tracker (TODO)
-- M09: Face Detection (TODO)
-- M11: Audio Reactor (TODO)
-- M12: Transition Manager (TODO)
-- M13: Animation Controller (TODO)
-- M14: Preset Manager (TODO)
-- M15: Hotkey Manager (TODO)
-- M16: UI Components (TODO)
-- M17: Timer/Scheduler (TODO)
-- M18: State Machine (TODO)
-- M19: Performance Monitor (TODO)

--================================================
-- SCRIPT SETTINGS
--================================================
local settings = {}

-- Default settings
local defaults = {
    debug_logging = false,
    easing_type = "QuadInOut",
    smooth_time = 0.3,
    max_speed = 100.0
}

--================================================
-- MODULE: Preset Manager (M13)
--================================================
-- Manages built-in and custom animation presets

local PresetManager = {
    -- Built-in presets (read-only)
    built_in = {
        {
            name = "Smooth",
            duration = 0.8,
            overshoot = 0.0,
            smoothness = 0.25,
            easing = "Cubic.Out",
        },
        {
            name = "Bounce",
            duration = 0.6,
            overshoot = 0.35,
            smoothness = 0.15,
            easing = "Back.Out",
        },
        {
            name = "Snappy",
            duration = 0.3,
            overshoot = 0.0,
            smoothness = 0.05,
            easing = "Expo.Out",
        },
        {
            name = "Cinematic",
            duration = 1.2,
            overshoot = 0.05,
            smoothness = 0.4,
            easing = "Sine.Out",
        },
    },

    -- Custom user presets
    custom = {},

    -- Currently selected preset name
    current_preset = "Smooth",
}

-- Get all preset names (built-in + custom)
function PresetManager:get_all_names()
    local names = {}

    -- Add built-in presets
    for _, preset in ipairs(self.built_in) do
        table.insert(names, preset.name)
    end

    -- Add custom presets
    for name, _ in pairs(self.custom) do
        table.insert(names, name)
    end

    table.sort(names)
    return names
end

-- Get preset by name
function PresetManager:get_preset(name)
    -- Check built-in first
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            return preset
        end
    end

    -- Check custom
    if self.custom[name] then
        return self.custom[name]
    end

    -- Default to Smooth
    return self.built_in[1]
end

-- Apply preset to configuration
function PresetManager:apply_preset(name)
    local preset = self:get_preset(name)
    if not preset then
        log("Preset: Unknown preset: " .. name)
        return false
    end

    cfg.zoom_duration = preset.duration
    cfg.zoom_overshoot = preset.overshoot
    cfg.follow_smooth_time = preset.smoothness

    if preset.easing then
        cfg.zoom_easing = preset.easing
    end

    self.current_preset = name
    log("Preset: Applied '" .. name .. "'")
    return true
end

-- Save a custom preset
function PresetManager:save_preset(name, duration, overshoot, smoothness, easing)
    if not name or name == "" then
        return false
    end

    -- Check if it's a built-in preset (can't override)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            log("Preset: Cannot override built-in preset: " .. name)
            return false
        end
    end

    -- Save custom preset
    self.custom[name] = {
        name = name,
        duration = duration or cfg.zoom_duration,
        overshoot = overshoot or cfg.zoom_overshoot,
        smoothness = smoothness or cfg.follow_smooth_time,
        easing = easing or cfg.zoom_easing,
    }

    log("Preset: Saved custom preset '" .. name .. "'")
    return true
end

-- Delete a custom preset
function PresetManager:delete_preset(name)
    -- Check if it's a built-in preset (can't delete)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            log("Preset: Cannot delete built-in preset: " .. name)
            return false
        end
    end

    -- Delete custom preset
    if self.custom[name] then
        self.custom[name] = nil
        log("Preset: Deleted custom preset '" .. name .. "'")
        return true
    end

    return false
end

-- Check if a preset is built-in
function PresetManager:is_built_in(name)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            return true
        end
    end
    return false
end

-- Persist custom presets to settings
function PresetManager:persist(settings)
    local array = obs.obs_data_array_create()

    for name, preset in pairs(self.custom) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "name", name)
        obs.obs_data_set_double(item, "duration", preset.duration)
        obs.obs_data_set_double(item, "overshoot", preset.overshoot)
        obs.obs_data_set_double(item, "smoothness", preset.smoothness)
        obs.obs_data_set_string(item, "easing", preset.easing)
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "custom_presets", array)
    obs.obs_data_array_release(array)
end

-- Load custom presets from settings
function PresetManager:load(settings)
    self.custom = {}

    local array = obs.obs_data_get_array(settings, "custom_presets")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local name = obs.obs_data_get_string(item, "name")

        if name and name ~= "" then
            self.custom[name] = {
                name = name,
                duration = obs.obs_data_get_double(item, "duration"),
                overshoot = obs.obs_data_get_double(item, "overshoot"),
                smoothness = obs.obs_data_get_double(item, "smoothness"),
                easing = obs.obs_data_get_string(item, "easing"),
            }
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)
    log("Preset: Loaded " .. self:get_custom_count() .. " custom presets")
end

-- Get count of custom presets
function PresetManager:get_custom_count()
    local count = 0
    for _, _ in pairs(self.custom) do
        count = count + 1
    end
    return count
end

-- Get current preset name
function PresetManager:get_current_name()
    return self.current_preset
end

-- Set current preset name
function PresetManager:set_current_name(name)
    self.current_preset = name
end

-- Check if current preset is custom
function PresetManager:is_current_custom()
    return not self:is_built_in(self.current_preset)
end

-- Global convenience functions
function preset_get_all_names()
    return PresetManager:get_all_names()
end

function preset_apply(name)
    return PresetManager:apply_preset(name)
end

function preset_save(name, duration, overshoot, smoothness, easing)
    return PresetManager:save_preset(name, duration, overshoot, smoothness, easing)
end

function preset_delete(name)
    return PresetManager:delete_preset(name)
end

function preset_is_built_in(name)
    return PresetManager:is_built_in(name)
end

function preset_get_current()
    return PresetManager:get_current_name()
end

--================================================
-- MODULE: Auto Source Detection (M11)
--================================================
-- Automatically detects and selects the best zoom source on first run

local AutoSourceDetector = {
    -- Source type priorities (higher = more likely to be the main display)
    type_priorities = {
        ["monitor_capture"] = 100,     -- Display capture (highest priority)
        ["game_capture"] = 80,          -- Game capture
        ["window_capture"] = 60,        -- Window capture
        ["xshm_input"] = 40,           -- Linux X11 capture
        ["av_capture_input"] = 20,     -- macOS capture
    },

    -- Whether auto-detection has been run
    auto_detected = false,
}

-- Get all capture sources sorted by priority
function AutoSourceDetector:get_capture_sources()
    local sources = {}
    local source_list = obs.obs_enum_sources()

    if not source_list then
        return sources
    end

    for _, source in ipairs(source_list) do
        local source_id = obs.obs_source_get_id(source)
        local name = obs.obs_source_get_name(source)

        -- Check if it's a capture source
        local priority = self.type_priorities[source_id]
        if priority then
            table.insert(sources, {
                name = name,
                id = source_id,
                priority = priority,
            })
        end
    end

    obs.source_list_release(source_list)

    -- Sort by priority (highest first)
    table.sort(sources, function(a, b)
        return a.priority > b.priority
    end)

    return sources
end

-- Auto-detect the best source
function AutoSourceDetector:auto_detect()
    local sources = self:get_capture_sources()

    if #sources == 0 then
        log("AutoSource: No capture sources found")
        return nil
    end

    if #sources == 1 then
        -- Only one source, use it
        log("AutoSource: Found single source: " .. sources[1].name)
        return sources[1].name
    end

    -- Multiple sources - prioritize by type
    -- Prefer monitor_capture > game_capture > window_capture
    local best = sources[1]

    log("AutoSource: Found " .. #sources .. " sources, selecting: " .. best.name)
    return best.name
end

-- Get monitor geometry from a source (if available)
function AutoSourceDetector:get_monitor_geometry(source_name)
    local source = obs.obs_get_source_by_name(source_name)
    if not source then
        return nil
    end

    local settings = obs.obs_source_get_settings(source)
    if not settings then
        obs.obs_source_release(source)
        return nil
    end

    -- Try to get monitor info from settings
    local monitor = obs.obs_data_get_int(settings, "monitor")
    local x = obs.obs_data_get_int(settings, "x")
    local y = obs.obs_data_get_int(settings, "y")
    local width = obs.obs_data_get_int(settings, "width")
    local height = obs.obs_data_get_int(settings, "height")

    obs.obs_data_release(settings)
    obs.obs_source_release(source)

    -- Return geometry if available
    if monitor >= 0 or width > 0 then
        return {
            monitor = monitor,
            x = x,
            y = y,
            width = width or 1920,
            height = height or 1080,
        }
    end

    return nil
end

-- Check if we should auto-detect on first run
function AutoSourceDetector:should_auto_detect(settings)
    -- Check if source has ever been set
    local last_source = obs.obs_data_get_string(settings, "source")
    if last_source and last_source ~= "" then
        return false
    end

    -- Check if auto-detect has been done
    return not self.auto_detected
end

-- Run auto-detection and return the source name
function AutoSourceDetector:run(settings)
    local source_name = self:auto_detect()

    if source_name then
        -- Save the detected source
        obs.obs_data_set_string(settings, "source", source_name)
        self.auto_detected = true
    end

    return source_name
end

-- Global convenience functions
function auto_source_detect()
    return AutoSourceDetector:auto_detect()
end

function auto_source_should_detect(settings)
    return AutoSourceDetector:should_auto_detect(settings)
end

function auto_source_run(settings)
    return AutoSourceDetector:run(settings)
end

--================================================
-- MODULE: Scene Memory (M12)
--================================================
-- Remembers which zoom source to use for each OBS scene

local SceneMemory = {
    -- Scene to source mapping
    scene_source_map = {},

    -- Maximum number of mappings to store
    max_mappings = 50,
}

-- Get the current scene name
function SceneMemory:get_current_scene_name()
    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then
        return nil
    end

    local name = obs.obs_source_get_name(scene_source)
    obs.obs_source_release(scene_source)
    return name
end

-- Get the source to use for the current scene
function SceneMemory:get_source_for_current_scene()
    local scene_name = self:get_current_scene_name()
    if not scene_name then
        return nil
    end

    -- 1. Check explicit mapping for this scene
    if self.scene_source_map[scene_name] then
        return self.scene_source_map[scene_name]
    end

    -- 2. Fall back to global source from config
    return cfg.source_name
end

-- Set the source for a specific scene
function SceneMemory:set(scene_name, source_name)
    if not scene_name or scene_name == "" then
        return false
    end

    -- Check if we're at capacity
    local count = 0
    for _, _ in pairs(self.scene_source_map) do
        count = count + 1
    end

    if count >= self.max_mappings and not self.scene_source_map[scene_name] then
        log("SceneMemory: At capacity (" .. self.max_mappings .. "), cannot add: " .. scene_name)
        return false
    end

    self.scene_source_map[scene_name] = source_name
    log("SceneMemory: " .. scene_name .. " Ã¢â€ â€™ " .. source_name)
    return true
end

-- Remove a scene mapping
function SceneMemory:remove(scene_name)
    if self.scene_source_map[scene_name] then
        self.scene_source_map[scene_name] = nil
        log("SceneMemory: Removed mapping for " .. scene_name)
        return true
    end
    return false
end

-- Get all scene mappings
function SceneMemory:get_all()
    local mappings = {}
    for scene, source in pairs(self.scene_source_map) do
        table.insert(mappings, { scene = scene, source = source })
    end
    table.sort(mappings, function(a, b)
        return a.scene < b.scene
    end)
    return mappings
end

-- Check if a scene has a mapping
function SceneMemory:has_mapping(scene_name)
    return self.scene_source_map[scene_name] ~= nil
end

-- Persist mappings to settings
function SceneMemory:persist(settings)
    local array = obs.obs_data_array_create()

    for scene, source in pairs(self.scene_source_map) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "scene", scene)
        obs.obs_data_set_string(item, "source", source)
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "scene_source_map", array)
    obs.obs_data_array_release(array)
end

-- Load mappings from settings
function SceneMemory:load(settings)
    self.scene_source_map = {}

    local array = obs.obs_data_get_array(settings, "scene_source_map")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local scene = obs.obs_data_get_string(item, "scene")
        local source = obs.obs_data_get_string(item, "source")

        if scene and scene ~= "" and source and source ~= "" then
            self.scene_source_map[scene] = source
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)

    local count = 0
    for _, _ in pairs(self.scene_source_map) do count = count + 1 end
    log("SceneMemory: Loaded " .. count .. " scene mappings")
end

-- Handle scene change
function SceneMemory:on_scene_change()
    local scene_name = self:get_current_scene_name()
    if not scene_name then
        return
    end

    -- Get the source for this scene
    local source_name = self:get_source_for_current_scene()

    if source_name and source_name ~= "" then
        -- Check if source changed
        local current = source_manager_is_valid() and cfg.source_name

        if source_name ~= current then
            log("SceneMemory: Scene changed to " .. scene_name)

            -- Release current source
            source_manager_release()

            -- Initialize with new source
            cfg.source_name = source_name
            source_manager_init(source_name)
        end
    end
end

-- Global convenience functions
function scene_memory_get_source()
    return SceneMemory:get_source_for_current_scene()
end

function scene_memory_set(scene_name, source_name)
    return SceneMemory:set(scene_name, source_name)
end

function scene_memory_remove(scene_name)
    return SceneMemory:remove(scene_name)
end

function scene_memory_get_all()
    return SceneMemory:get_all()
end

function scene_memory_on_scene_change()
    return SceneMemory:on_scene_change()
end

--================================================
-- MODULE: Blur Manager (M14)
--================================================
-- Provides built-in blur effects without external plugins
-- Supports multiple strategies: shader, composite_blur plugin, or none

local BlurManager = {
    -- Current strategy: "shader", "composite_blur", "none"
    strategy = "none",

    -- Filter references
    zoom_blur_filter = nil,
    motion_blur_filter = nil,

    -- Settings references
    zoom_blur_settings = nil,
    motion_blur_settings = nil,

    -- State
    initialized = false,

    -- Configuration
    zoom_blur_enabled = false,
    zoom_blur_intensity = 5,
    zoom_blur_clear_radius = 150,
    motion_blur_enabled = false,
    motion_blur_intensity = 1.0,
}

-- Try to use custom shader (if effect files exist)
function BlurManager:try_shader_strategy(source)
    -- This would require .effect files in assets/shaders/
    -- For now, we'll use a simpler approach
    log("Blur: Shader strategy not implemented (requires effect files)")
    return false
end

-- Try to auto-create Composite Blur filters
function BlurManager:try_composite_blur_strategy(source)
    if not source then return false end

    -- Check if composite_blur filter type exists
    local test_filter = obs.obs_source_create_private("composite_blur", "__test_blur__", nil)
    if test_filter then
        obs.obs_source_release(test_filter)
    else
        log("Blur: Composite Blur plugin not available")
        return false
    end

    -- Create Zoom Blur filter
    local zs = obs.obs_data_create()
    obs.obs_data_set_double(zs, "radius", 0)
    obs.obs_data_set_int(zs, "blur_type", 2) -- Zoom type
    self.zoom_blur_filter = obs.obs_source_create_private(
        "composite_blur",
        FILTER_PREFIX .. "Zoom Blur",
        zs
    )

    if self.zoom_blur_filter then
        obs.obs_source_filter_add(source, self.zoom_blur_filter)
        self.zoom_blur_settings = zs
    else
        obs.obs_data_release(zs)
        return false
    end

    -- Create Motion Blur filter
    local ms = obs.obs_data_create()
    obs.obs_data_set_double(ms, "radius", 0)
    obs.obs_data_set_int(ms, "blur_type", 3) -- Motion/directional type
    self.motion_blur_filter = obs.obs_source_create_private(
        "composite_blur",
        FILTER_PREFIX .. "Motion Blur",
        ms
    )

    if self.motion_blur_filter then
        obs.obs_source_filter_add(source, self.motion_blur_filter)
        self.motion_blur_settings = ms
    else
        obs.obs_data_release(ms)
    end

    self.initialized = true
    return true
end

-- Initialize blur manager
function BlurManager:init(source)
    if not source then
        return false
    end

    self:cleanup()

    -- Try composite_blur strategy
    if self:try_composite_blur_strategy(source) then
        self.strategy = "composite_blur"
        log("Blur: Using Composite Blur plugin (auto-configured)")
        return true
    end

    -- No blur available
    self.strategy = "none"
    log("Blur: No blur backend available. Blur effects disabled.")
    return false
end

-- Update blur based on zoom state
function BlurManager:update(state_machine, crop, camera_velocity)
    if not self.initialized then return end
    if self.strategy == "none" then return end

    -- Zoom Blur: Active during zoom transitions
    if self.zoom_blur_enabled and self.zoom_blur_filter then
        local radius = 0

        if state_machine:is_animating() and
           (state_machine.state == ZoomState.ZOOMING_IN or
            state_machine.state == ZoomState.ZOOMING_OUT) then
            -- Bell curve: 0 at start Ã¢â€ â€™ peak at 50% Ã¢â€ â€™ 0 at end
            local t = clamp(0, 1, state_machine.zoom_time)
            local curve = math.sin(t * math.pi)
            radius = curve * curve * self.zoom_blur_intensity
        end

        self:set_zoom_blur(radius, crop)
    end

    -- Motion Blur: Active during camera panning (not during zoom transition)
    if self.motion_blur_enabled and self.motion_blur_filter then
        if not state_machine:is_animating() and state_machine:is_zoomed() and camera_velocity then
            local speed = math.sqrt(
                camera_velocity.x * camera_velocity.x +
                camera_velocity.y * camera_velocity.y
            )

            if speed > 1.0 then
                local radius = math.min(10, speed * self.motion_blur_intensity * 0.5)
                local angle = math.deg(math.atan2(camera_velocity.y, camera_velocity.x))
                self:set_motion_blur(radius, angle)
            else
                self:set_motion_blur(0, 0)
            end
        else
            self:set_motion_blur(0, 0)
        end
    end
end

-- Set zoom blur parameters
function BlurManager:set_zoom_blur(radius, crop)
    if self.strategy == "composite_blur" and self.zoom_blur_settings then
        obs.obs_data_set_double(self.zoom_blur_settings, "radius", radius)

        if crop then
            local cx = crop.x + (crop.w / 2)
            local cy = crop.y + (crop.h / 2)
            obs.obs_data_set_double(self.zoom_blur_settings, "center_x", cx)
            obs.obs_data_set_double(self.zoom_blur_settings, "center_y", cy)
        end

        obs.obs_data_set_double(self.zoom_blur_settings, "inactive_radius", self.zoom_blur_clear_radius)
        obs.obs_source_update(self.zoom_blur_filter, self.zoom_blur_settings)
    end
end

-- Set motion blur parameters
function BlurManager:set_motion_blur(radius, angle)
    if self.strategy == "composite_blur" and self.motion_blur_settings then
        obs.obs_data_set_double(self.motion_blur_settings, "radius", radius)
        obs.obs_data_set_double(self.motion_blur_settings, "angle", angle)
        obs.obs_source_update(self.motion_blur_filter, self.motion_blur_settings)
    end
end

-- Update configuration
function BlurManager:update_config(settings)
    self.zoom_blur_enabled = obs.obs_data_get_bool(settings, "zoom_blur_enabled")
    self.zoom_blur_intensity = obs.obs_data_get_double(settings, "zoom_blur_intensity")
    self.zoom_blur_clear_radius = obs.obs_data_get_double(settings, "zoom_blur_clear_radius")
    self.motion_blur_enabled = obs.obs_data_get_bool(settings, "motion_blur_enabled")
    self.motion_blur_intensity = obs.obs_data_get_double(settings, "motion_blur_intensity")
end

-- Cleanup filters
function BlurManager:cleanup()
    local source = source_manager_get_source()

    if self.zoom_blur_filter and source then
        obs.obs_source_filter_remove(source, self.zoom_blur_filter)
        obs.obs_source_release(self.zoom_blur_filter)
        self.zoom_blur_filter = nil
    end

    if self.motion_blur_filter and source then
        obs.obs_source_filter_remove(source, self.motion_blur_filter)
        obs.obs_source_release(self.motion_blur_filter)
        self.motion_blur_filter = nil
    end

    if self.zoom_blur_settings then
        obs.obs_data_release(self.zoom_blur_settings)
        self.zoom_blur_settings = nil
    end

    if self.motion_blur_settings then
        obs.obs_data_release(self.motion_blur_settings)
        self.motion_blur_settings = nil
    end

    self.initialized = false
    self.strategy = "none"
end

-- Check if blur is available
function BlurManager:is_available()
    return self.strategy ~= "none"
end

-- Global convenience functions
function blur_manager_init(source)
    return BlurManager:init(source)
end

function blur_manager_update(state_machine, crop, camera_velocity)
    return BlurManager:update(state_machine, crop, camera_velocity)
end

function blur_manager_update_config(settings)
    return BlurManager:update_config(settings)
end

function blur_manager_cleanup()
    return BlurManager:cleanup()
end

function blur_manager_is_available()
    return BlurManager:is_available()
end

--================================================
-- MODULE: Cursor Asset Manager (M16)
--================================================
-- Handles extracting and managing cursor image assets

local CursorAssets = {
    extracted = false,
    dir = nil,
}

-- Get the platform-specific asset directory
function CursorAssets:get_platform_dir()
    if IS_WINDOWS then
        local appdata = os.getenv("APPDATA")
        return appdata and (appdata .. "\\obs-studio\\obs-zoom-pro\\cursors") or nil
    elseif IS_LINUX then
        local home = os.getenv("HOME")
        return home and (home .. "/.config/obs-studio/obs-zoom-pro/cursors") or nil
    elseif IS_MACOS then
        local home = os.getenv("HOME")
        return home and (home .. "/Library/Application Support/obs-studio/obs-zoom-pro/cursors") or nil
    end
    -- Fallback for non-FFI environments
    return "cursors"
end

-- Ensure assets are extracted
function CursorAssets:ensure_extracted()
    if self.extracted then
        return self.dir
    end

    local dir = self:get_platform_dir()
    if not dir then
        log("CursorAssets: Could not determine asset directory")
        return nil
    end

    -- Create directory
    local cmd
    if IS_WINDOWS then
        cmd = 'mkdir "' .. dir .. '" 2>nul'
    else
        cmd = 'mkdir -p "' .. dir .. '"'
    end
    os.execute(cmd)

    -- Check if assets exist
    local sep = IS_WINDOWS and "\\" or "/"
    local arrow_path = dir .. sep .. "arrow.png"

    local f = io.open(arrow_path, "rb")
    if f then
        f:close()
        self.dir = dir
        self.extracted = true
        log("CursorAssets: Using existing assets from " .. dir)
        return dir
    end

    -- Try to copy from script directory
    local script_dir = get_script_directory()
    local assets_src = script_dir .. "assets" .. sep .. "cursors" .. sep

    local files = { "arrow.png", "pointer.png", "ibeam.png" }
    for _, filename in ipairs(files) do
        local src_path = assets_src .. filename
        local dst_path = dir .. sep .. filename

        local src = io.open(src_path, "rb")
        if src then
            local data = src:read("*a")
            src:close()

            local dst = io.open(dst_path, "wb")
            if dst then
                dst:write(data)
                dst:close()
                log("CursorAssets: Copied " .. filename)
            end
        end
    end

    self.dir = dir
    self.extracted = true
    return dir
end

-- Get the asset directory
function CursorAssets:get_dir()
    return self.dir
end

-- Check if assets are available
function CursorAssets:is_available()
    if not self.extracted then
        self:ensure_extracted()
    end
    return self.dir ~= nil
end

-- Get cursor image path
function CursorAssets:get_cursor_path(cursor_type)
    if not self:is_available() then
        return nil
    end

    local sep = IS_WINDOWS and "\\" or "/"
    local filename = (cursor_type or "arrow") .. ".png"
    return self.dir .. sep .. filename
end

-- Global convenience functions
function cursor_assets_ensure_extracted()
    return CursorAssets:ensure_extracted()
end

function cursor_assets_get_dir()
    return CursorAssets:get_dir()
end

function cursor_assets_is_available()
    return CursorAssets:is_available()
end

function cursor_assets_get_cursor_path(cursor_type)
    return CursorAssets:get_cursor_path(cursor_type)
end

--================================================
-- MODULE: Cursor Renderer (M15)
--================================================
-- Provides automatic cursor overlay rendering

local CursorRenderer = {
    enabled = false,
    source = nil,
    sceneitem = nil,

    -- Smoothed state
    pos = { x = 0, y = 0 },
    current_scale = 1.0,
    current_rot = 0,
    swap_pulse = 1.0,

    -- Velocities (SmoothDamp)
    vel_x = { val = 0 },
    vel_y = { val = 0 },
    vel_scale = { val = 0 },
    vel_rot = { val = 0 },
    vel_swap = { val = 0 },

    -- State
    was_pointer = false,
    initialized = false,

    -- Configuration
    cursor_scale = 1.0,
    cursor_click_scale = 0.78,
    cursor_smooth_time = 0.1,
    cursor_offset_x = -6,
    cursor_offset_y = -2,
    cursor_rotation_mode = "None",
    cursor_angle_offset = 0,
    cursor_tilt_strength = 0,
}

-- Initialize cursor renderer
function CursorRenderer:init()
    if not cfg.cursor_enabled then
        self.enabled = false
        return false
    end

    -- Ensure cursor assets are available
    local asset_dir = cursor_assets_ensure_extracted()
    if not asset_dir then
        log("CursorRenderer: Failed to extract cursor assets")
        self.enabled = false
        return false
    end

    -- Get or create the cursor image source
    local source_name = FILTER_PREFIX .. "Cursor"
    self.source = obs.obs_get_source_by_name(source_name)

    if not self.source then
        -- Create new image source
        local settings = obs.obs_data_create()
        local cursor_path = cursor_assets_get_cursor_path("arrow")
        if cursor_path then
            obs.obs_data_set_string(settings, "file", cursor_path)
        end
        self.source = obs.obs_source_create("image_source", source_name, settings, nil)
        obs.obs_data_release(settings)

        if not self.source then
            log("CursorRenderer: Failed to create image source")
            self.enabled = false
            return false
        end
    end

    -- Add to current scene
    self:add_to_scene()

    -- Initialize position
    local mouse = platform_get_mouse_pos()
    self.pos.x = mouse.x
    self.pos.y = mouse.y

    self.enabled = true
    self.initialized = true
    log("CursorRenderer: Initialized")
    return true
end

-- Add cursor source to scene
function CursorRenderer:add_to_scene()
    if not self.source then return false end

    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then return false end

    local scene = obs.obs_scene_from_source(scene_source)
    if not scene then
        obs.obs_source_release(scene_source)
        return false
    end

    -- Check if already in scene
    local source_name = obs.obs_source_get_name(self.source)
    self.sceneitem = obs.obs_scene_find_source(scene, source_name)

    if not self.sceneitem then
        -- Add to scene
        self.sceneitem = obs.obs_scene_add(scene, self.source)
        if self.sceneitem then
            -- Move to top (render last = on top)
            obs.obs_sceneitem_set_order(self.sceneitem, obs.OBS_ORDER_MOVE_TOP)
        end
    end

    obs.obs_source_release(scene_source)
    return true
end

-- Update cursor position and state
function CursorRenderer:update(dt, raw_mouse, camera_crop)
    if not self.enabled or not self.sceneitem then return end

    -- Smooth cursor position
    self.pos.x = SmoothDamp(self.pos.x, raw_mouse.x, self.vel_x, self.cursor_smooth_time, 100000, dt)
    self.pos.y = SmoothDamp(self.pos.y, raw_mouse.y, self.vel_y, self.cursor_smooth_time, 100000, dt)

    -- Snap when very close
    if math.abs(self.pos.x - raw_mouse.x) < 0.5 then
        self.pos.x = raw_mouse.x
        self.vel_x.val = 0
    end
    if math.abs(self.pos.y - raw_mouse.y) < 0.5 then
        self.pos.y = raw_mouse.y
        self.vel_y.val = 0
    end

    -- Cursor shape detection (Windows only)
    local is_pointer = false
    if platform_cursor_shape_available() then
        is_pointer = platform_is_cursor_pointer()
    end

    -- Swap cursor image if needed
    if is_pointer ~= self.was_pointer then
        local asset_dir = cursor_assets_get_dir()
        local sep = IS_WINDOWS and "\\" or "/"
        local new_file = is_pointer and (asset_dir .. sep .. "pointer.png") or (asset_dir .. sep .. "arrow.png")

        local s = obs.obs_source_get_settings(self.source)
        if s then
            obs.obs_data_set_string(s, "file", new_file)
            obs.obs_source_update(self.source, s)
            obs.obs_data_release(s)
        end

        -- Trigger swap pulse
        self.swap_pulse = 0.75
        self.vel_swap.val = 1
        self.was_pointer = is_pointer
    end

    self.swap_pulse = SmoothDamp(self.swap_pulse, 1.0, self.vel_swap, 0.12, 100000, dt)

    -- Click animation
    local is_clicking = platform_is_clicking()
    local target_scale = is_clicking and (self.cursor_scale * self.cursor_click_scale) or self.cursor_scale
    self.current_scale = SmoothDamp(self.current_scale, target_scale, self.vel_scale, 0.1, 100000, dt)

    -- Calculate position relative to zoom
    local zoom_factor = 1.0
    local crop_x, crop_y = 0, 0

    if camera_crop and SM:is_zoomed() then
        zoom_factor = source_manager_get_size() / camera_crop.w
        crop_x = camera_crop.x
        crop_y = camera_crop.y
    end

    local final_x = (self.pos.x - crop_x) * zoom_factor + (self.cursor_offset_x * zoom_factor)
    local final_y = (self.pos.y - crop_y) * zoom_factor + (self.cursor_offset_y * zoom_factor)

    -- Apply to scene item
    local pos = obs.vec2()
    pos.x = final_x
    pos.y = final_y
    obs.obs_sceneitem_set_pos(self.sceneitem, pos)

    local scale = obs.vec2()
    local s = self.current_scale * zoom_factor * self.swap_pulse
    scale.x = s
    scale.y = s
    obs.obs_sceneitem_set_scale(self.sceneitem, scale)

    -- Rotation
    local dynamic_rot = self:compute_rotation(dt)
    obs.obs_sceneitem_set_rot(self.sceneitem, dynamic_rot)
end

-- Compute rotation based on mode
function CursorRenderer:compute_rotation(dt)
    local vx = self.vel_x.val
    local vy = self.vel_y.val
    local speed = math.sqrt(vx * vx + vy * vy)

    if self.cursor_rotation_mode == "Directional" then
        if speed > 20 then
            local angle = math.atan2(vy, vx) * (180 / math.pi)
            local target = angle + self.cursor_angle_offset
            local diff = (target - self.current_rot + 180) % 360 - 180
            self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.05, 100000, dt)
        end
        return self.current_rot

    elseif self.cursor_rotation_mode == "Lean" then
        local lean = clamp(-40, 40, vx * 0.05 * self.cursor_tilt_strength) + self.cursor_angle_offset
        local diff = (lean - self.current_rot + 180) % 360 - 180
        self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.08, 100000, dt)
        return self.current_rot
    end

    -- "None" mode
    local diff = (self.cursor_angle_offset - self.current_rot + 180) % 360 - 180
    self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.15, 100000, dt)
    return self.current_rot
end

-- Update configuration
function CursorRenderer:update_config(settings)
    self.cursor_scale = obs.obs_data_get_double(settings, "cursor_scale")
    self.cursor_click_scale = obs.obs_data_get_double(settings, "cursor_click_scale")
    self.cursor_smooth_time = obs.obs_data_get_double(settings, "cursor_smooth_time")
    self.cursor_offset_x = obs.obs_data_get_int(settings, "cursor_offset_x")
    self.cursor_offset_y = obs.obs_data_get_int(settings, "cursor_offset_y")
    self.cursor_rotation_mode = obs.obs_data_get_string(settings, "cursor_rotation_mode") or "None"
    self.cursor_angle_offset = obs.obs_data_get_double(settings, "cursor_angle_offset")
    self.cursor_tilt_strength = obs.obs_data_get_double(settings, "cursor_tilt_strength")
end

-- Cleanup
function CursorRenderer:cleanup()
    if self.sceneitem then
        obs.obs_sceneitem_remove(self.sceneitem)
        self.sceneitem = nil
    end

    if self.source then
        local source_name = obs.obs_source_get_name(self.source)
        obs.obs_source_release(self.source)

        -- Remove from OBS source list
        local s = obs.obs_get_source_by_name(source_name)
        if s then
            obs.obs_source_remove(s)
            obs.obs_source_release(s)
        end
        self.source = nil
    end

    self.enabled = false
    self.initialized = false
end

-- Check if active
function CursorRenderer:is_active()
    return self.enabled and self.initialized
end

-- Global convenience functions
function cursor_renderer_init()
    return CursorRenderer:init()
end

function cursor_renderer_update(dt, raw_mouse, camera_crop)
    return CursorRenderer:update(dt, raw_mouse, camera_crop)
end

function cursor_renderer_update_config(settings)
    return CursorRenderer:update_config(settings)
end

function cursor_renderer_cleanup()
    return CursorRenderer:cleanup()
end

function cursor_renderer_is_active()
    return CursorRenderer:is_active()
end

--================================================
-- MODULE: Bookmark Manager (M17)
--================================================
-- Manages saved zoom positions (bookmarks)

local BookmarkManager = {
    -- Saved bookmarks: { name = { zoom_level, x, y, w, h, source } }
    bookmarks = {},

    -- Maximum bookmarks
    max_bookmarks = 20,

    -- Hotkey IDs
    hotkeys = {},
}

-- Save current zoom position as a bookmark
function BookmarkManager:save(name)
    if not name or name == "" then
        return false
    end

    -- Check limit
    local count = 0
    for _, _ in pairs(self.bookmarks) do count = count + 1 end

    if count >= self.max_bookmarks and not self.bookmarks[name] then
        log("Bookmark: Max bookmarks reached (" .. self.max_bookmarks .. ")")
        return false
    end

    -- Get current crop
    local crop = crop_filter_get_crop()
    if not crop then
        return false
    end

    -- Save bookmark
    self.bookmarks[name] = {
        zoom_level = SM.zoom_level,
        x = crop.x,
        y = crop.y,
        w = crop.w,
        h = crop.h,
        source = cfg.source_name,
    }

    log("Bookmark: Saved '" .. name .. "' (zoom=" .. string.format("%.2f", SM.zoom_level) .. ")")
    return true
end

-- Recall a bookmark
function BookmarkManager:recall(name)
    local bm = self.bookmarks[name]
    if not bm then
        log("Bookmark: Not found: " .. name)
        return false
    end

    if not SM:can_jump() then
        return false
    end

    if not source_manager_is_valid() then
        return false
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        return false
    end

    -- Get current crop as start
    local start_crop = crop_filter_get_crop() or { x = 0, y = 0, w = source_w, h = source_h }

    -- Set target
    local target_crop = {
        x = bm.x,
        y = bm.y,
        w = bm.w,
        h = bm.h,
    }

    -- Transition to bookmark
    SM:transition(ZoomState.JUMPING, {
        start_crop = start_crop,
        target_crop = target_crop,
        target_level = bm.zoom_level
    })

    start_timer()
    log("Bookmark: Recall '" .. name .. "'")
    return true
end

-- Delete a bookmark
function BookmarkManager:delete(name)
    if self.bookmarks[name] then
        self.bookmarks[name] = nil
        log("Bookmark: Deleted '" .. name .. "'")
        return true
    end
    return false
end

-- Rename a bookmark
function BookmarkManager:rename(old_name, new_name)
    if not self.bookmarks[old_name] then
        return false
    end

    if self.bookmarks[new_name] then
        return false
    end

    self.bookmarks[new_name] = self.bookmarks[old_name]
    self.bookmarks[old_name] = nil
    log("Bookmark: Renamed '" .. old_name .. "' to '" .. new_name .. "'")
    return true
end

-- Get all bookmark names
function BookmarkManager:get_names()
    local names = {}
    for k, _ in pairs(self.bookmarks) do
        table.insert(names, k)
    end
    table.sort(names)
    return names
end

-- Get bookmark info
function BookmarkManager:get(name)
    return self.bookmarks[name]
end

-- Persist bookmarks to settings
function BookmarkManager:persist(settings)
    local array = obs.obs_data_array_create()

    for name, bm in pairs(self.bookmarks) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "name", name)
        obs.obs_data_set_double(item, "zoom_level", bm.zoom_level)
        obs.obs_data_set_double(item, "x", bm.x)
        obs.obs_data_set_double(item, "y", bm.y)
        obs.obs_data_set_double(item, "w", bm.w)
        obs.obs_data_set_double(item, "h", bm.h)
        obs.obs_data_set_string(item, "source", bm.source or "")
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "zoom_bookmarks", array)
    obs.obs_data_array_release(array)
end

-- Load bookmarks from settings
function BookmarkManager:load(settings)
    self.bookmarks = {}

    local array = obs.obs_data_get_array(settings, "zoom_bookmarks")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local name = obs.obs_data_get_string(item, "name")

        if name and name ~= "" then
            self.bookmarks[name] = {
                zoom_level = obs.obs_data_get_double(item, "zoom_level"),
                x = obs.obs_data_get_double(item, "x"),
                y = obs.obs_data_get_double(item, "y"),
                w = obs.obs_data_get_double(item, "w"),
                h = obs.obs_data_get_double(item, "h"),
                source = obs.obs_data_get_string(item, "source"),
            }
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)

    local count = 0
    for _, _ in pairs(self.bookmarks) do count = count + 1 end
    log("Bookmark: Loaded " .. count .. " bookmarks")
end

-- Register bookmark hotkeys
function BookmarkManager:register_hotkeys(settings)
    for i = 1, 5 do
        self.hotkeys[i] = obs.obs_hotkey_register_frontend(
            "obs_zoom_pro.bookmark_" .. i,
            "Zoom to Bookmark " .. i,
            function(pressed)
                if not pressed then return end
                local names = self:get_names()
                if names[i] then
                    self:recall(names[i])
                end
            end
        )

        -- Load saved bindings
        local key = "obs_zoom_pro.hotkey.bookmark_" .. i
        local save_array = obs.obs_data_get_array(settings, key)
        if save_array then
            obs.obs_hotkey_load(self.hotkeys[i], save_array)
            obs.obs_data_array_release(save_array)
        end
    end
end

-- Save bookmark hotkeys
function BookmarkManager:save_hotkeys(settings)
    for i = 1, 5 do
        if self.hotkeys[i] then
            local save_array = obs.obs_hotkey_save(self.hotkeys[i])
            obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.bookmark_" .. i, save_array)
            obs.obs_data_array_release(save_array)
        end
    end
end

-- Global convenience functions
function bookmark_save(name)
    return BookmarkManager:save(name)
end

function bookmark_recall(name)
    return BookmarkManager:recall(name)
end

function bookmark_delete(name)
    return BookmarkManager:delete(name)
end

function bookmark_get_names()
    return BookmarkManager:get_names()
end

function bookmark_get(name)
    return BookmarkManager:get(name)
end

--================================================
-- MODULE: UDP API Server (M18)
--================================================
-- Provides external control via UDP for Stream Deck integration

local APIServer = {
    enabled = false,
    port = 12345,
    socket = nil,
}

-- Command handlers
local API_COMMANDS = {
    ZOOM_IN = function(args)
        local level = tonumber(args[1]) or cfg.zoom_value
        on_scroll_zoom_to(level)
        return "OK"
    end,

    ZOOM_OUT = function(args)
        if SM:is_zoomed() then
            on_toggle_zoom(true)
        end
        return "OK"
    end,

    ZOOM_SET = function(args)
        local level = tonumber(args[1])
        if not level then return "ERROR: Missing level" end
        on_scroll_zoom_to(level)
        return "OK"
    end,

    ZOOM_TOGGLE = function(args)
        on_toggle_zoom(true)
        return "OK"
    end,

    FOLLOW_ON = function(args)
        if SM:is_zoomed() then SM.following = true end
        return "OK"
    end,

    FOLLOW_OFF = function(args)
        SM.following = false
        return "OK"
    end,

    FOLLOW_TOGGLE = function(args)
        if SM:is_zoomed() then SM.following = not SM.following end
        return "OK"
    end,

    PRESET = function(args)
        local name = args[1]
        if not name then return "ERROR: Missing preset name" end
        local ok = preset_apply(name)
        return ok and "OK" or "ERROR: Unknown preset"
    end,

    BOOKMARK = function(args)
        local name = args[1]
        if not name then return "ERROR: Missing bookmark name" end
        local ok = bookmark_recall(name)
        return ok and "OK" or "ERROR: Bookmark not found"
    end,

    STATUS = function(args)
        local crop = crop_filter_get_crop()
        return string.format(
            '{"version":"%s","zoom_level":%.2f,"state":"%s","following":%s,"position":{"x":%.0f,"y":%.0f},"preset":"%s"}',
            VERSION,
            SM.zoom_level,
            SM.state,
            tostring(SM.following),
            crop and crop.x or 0,
            crop and crop.y or 0,
            cfg.zoom_preset or ""
        )
    end,

    HELP = function(args)
        return "Commands: ZOOM_IN [level], ZOOM_OUT, ZOOM_SET level, ZOOM_TOGGLE, FOLLOW_ON, FOLLOW_OFF, FOLLOW_TOGGLE, PRESET name, BOOKMARK name, STATUS"
    end,
}

-- Start the API server
function APIServer:start(port)
    self:stop()

    self.port = port or self.port

    -- Try to use luasocket if available
    local socket_ok, socket = pcall(require, "socket")
    if not socket_ok then
        log("API: Socket library not available")
        return false
    end

    -- Try UDP
    local udp, err = socket.udp()
    if not udp then
        log("API: Failed to create UDP socket: " .. tostring(err))
        return false
    end

    -- Set socket options
    udp:setoption("reuseaddr", true)
    udp:settimeout(0)  -- Non-blocking

    -- Bind to port
    local bind_ok, err = udp:setsockname("*", self.port)
    if not bind_ok then
        log("API: Failed to bind to port " .. self.port .. ": " .. tostring(err))
        udp:close()
        return false
    end

    self.socket = udp
    self.enabled = true

    -- Start polling timer
    obs.timer_add(function() self:poll() end, 50)  -- 20Hz polling

    log("API: Listening on port " .. self.port)
    return true
end

-- Stop the API server
function APIServer:stop()
    if self.socket then
        self.socket:close()
        self.socket = nil
    end
    self.enabled = false
    log("API: Stopped")
end

-- Poll for incoming commands
function APIServer:poll()
    if not self.enabled or not self.socket then
        return
    end

    repeat
        local data, err = self.socket:receivefrom()
        if data then
            local response = self:handle_command(data)
            if response then
                -- Note: UDP response requires sender address
                log("API: " .. data:gsub("%s+", " ") .. " Ã¢â€ â€™ " .. response)
            end
        elseif err ~= "timeout" then
            log("API: Error: " .. tostring(err))
        end
    until not data
end

-- Handle a command
function APIServer:handle_command(raw)
    -- Parse command
    local parts = {}
    for word in raw:gmatch("%S+") do
        table.insert(parts, word)
    end

    if #parts == 0 then
        return "ERROR: Empty command"
    end

    local cmd = parts[1]:upper()
    local args = {}
    for i = 2, #parts do
        table.insert(args, parts[i])
    end

    -- Look up handler
    local handler = API_COMMANDS[cmd]
    if handler then
        local ok, result = pcall(handler, args)
        if ok then
            return result
        else
            return "ERROR: " .. tostring(result)
        end
    end

    return "ERROR: Unknown command: " .. cmd
end

-- Check if enabled
function APIServer:is_enabled()
    return self.enabled
end

-- Global convenience functions
function api_start(port)
    return APIServer:start(port)
end

function api_stop()
    return APIServer:stop()
end

function api_is_enabled()
    return APIServer:is_enabled()
end

--================================================
-- OBS SCRIPT REGISTRATION
--================================================

--[[ Called when the script is loaded
--[[ @param data table Script data
function script_load(data)
    log("Script loaded - OBS Zoom Pro v" .. VERSION)

    -- Load custom presets
    PresetManager:load(data)

    -- Load scene memory
    SceneMemory:load(data)

    -- Load bookmarks
    BookmarkManager:load(data)

    -- Register hotkeys
    register_hotkeys(data)

    -- Register bookmark hotkeys
    BookmarkManager:register_hotkeys(data)

    -- Register frontend event handler
    obs.obs_frontend_add_event_callback(on_frontend_event)

    -- Start API server if enabled
    local api_enabled = obs.obs_data_get_bool(data, "api_enabled")
    if api_enabled then
        local api_port = obs.obs_data_get_int(data, "api_port")
        APIServer:start(api_port)
    end
end

--[[ Called when the script is unloaded
function script_unload()
    log("Script unloaded - OBS Zoom Pro")

    -- Stop timer and cleanup
    stop_timer()
    unregister_hotkeys()
    source_manager_release()

    -- Stop API server
    APIServer:stop()

    -- Remove frontend event handler
    obs.obs_frontend_remove_event_callback(on_frontend_event)
end

--[[ Called when settings are updated
--[[ @param data table Settings data
function script_update(data)
    log("Settings updated")

    -- Update legacy settings
    debug_logs = obs.obs_data_get_bool(data, "debug_logging") or false
    settings.debug_logging = debug_logs
    settings.easing_type = obs.obs_data_get_string(data, "easing_type") or defaults.easing_type
    settings.smooth_time = obs.obs_data_get_double(data, "smooth_time") or defaults.smooth_time
    settings.max_speed = obs.obs_data_get_double(data, "max_speed") or defaults.max_speed

    -- Update M09 configuration
    update_config(data)

    -- Update API server settings
    local api_enabled = obs.obs_data_get_bool(data, "api_enabled")
    local api_port = obs.obs_data_get_int(data, "api_port")

    if api_enabled and not APIServer:is_enabled() then
        APIServer:start(api_port)
    elseif not api_enabled and APIServer:is_enabled() then
        APIServer:stop()
    elseif APIServer:is_enabled() and APIServer.port ~= api_port then
        APIServer:start(api_port)
    end
end

--[[ Called to save settings
--[[ @param data table Settings data to save
function script_save(data)
    log("Settings saved")

    -- Save custom presets
    PresetManager:persist(data)

    -- Save scene memory
    SceneMemory:persist(data)

    -- Save bookmarks
    BookmarkManager:persist(data)

    -- Save hotkey bindings
    save_hotkeys(data)

    -- Save bookmark hotkeys
    BookmarkManager:save_hotkeys(data)
end

--[[ Called to create the properties UI
--[[ @return obs.obs_properties_t Properties object
function script_properties()
    local props = obs.obs_properties_create()

    --==========================
    -- QUICK SETUP (always expanded)
    --==========================
    local grp_quick = obs.obs_properties_create()

    -- Source dropdown
    local src_list = obs.obs_properties_add_list(grp_quick, "source", "Zoom Source",
        obs.OBS_COMBO_TYPE_LIST, obs.OBS_COMBO_FORMAT_STRING)
    obs.obs_property_list_add_string(src_list, "-- Select Source --", "")

    -- Populate with available capture sources
    local sources = source_manager_get_available_sources()
    for _, src in ipairs(sources) do
        obs.obs_property_list_add_string(src_list, src.name, src.name)
    end

    -- Zoom Factor
    obs.obs_properties_add_float_slider(grp_quick, "zoom_value", "Zoom Factor", 1.0, 10.0, 0.1)

    -- Duration
    obs.obs_properties_add_float_slider(grp_quick, "zoom_duration", "Duration (s)", 0.05, 3.0, 0.05)

    obs.obs_properties_add_group(props, "quick_setup", "Ã¢Å¡Â¡ Quick Setup", obs.OBS_GROUP_NORMAL, grp_quick)

    --==========================
    -- ANIMATION (collapsed)
    --==========================
    local grp_anim = obs.obs_properties_create()

    -- Overshoot/Bounce
    obs.obs_properties_add_float_slider(grp_anim, "zoom_overshoot", "Bounce", 0.0, 1.0, 0.01)

    -- Easing Curve
    local p_easing = obs.obs_properties_add_list(grp_anim, "zoom_easing", "Easing Curve",
        obs.OBS_COMBO_TYPE_LIST, obs.OBS_COMBO_FORMAT_STRING)
    for _, name in ipairs(Easing.NAMES) do
        obs.obs_property_list_add_string(p_easing, name, name)
    end

    obs.obs_properties_add_group(props, "animation", "Ã°Å¸Å½Â¬ Animation", obs.OBS_GROUP_NORMAL, grp_anim)

    --==========================
    -- MOUSE FOLLOW (collapsed)
    --==========================
    local grp_follow = obs.obs_properties_create()

    obs.obs_properties_add_bool(grp_follow, "auto_follow", "Auto-Follow Mouse")
    obs.obs_properties_add_float_slider(grp_follow, "follow_smooth_time", "Smoothness", 0.01, 1.0, 0.01)
    obs.obs_properties_add_int_slider(grp_follow, "follow_dead_zone", "Dead Zone (px)", 0, 500, 1)

    obs.obs_properties_add_group(props, "follow", "Ã°Å¸Å½Â¯ Mouse Follow", obs.OBS_GROUP_NORMAL, grp_follow)

    --==========================
    -- ADVANCED (collapsed)
    --==========================
    local grp_adv = obs.obs_properties_create()
    obs.obs_properties_add_float_slider(grp_adv, "scroll_step", "Scroll Zoom Step", 0.1, 1.0, 0.05)
    obs.obs_properties_add_bool(grp_adv, "debug_logs", "Debug Logging")
    obs.obs_properties_add_group(props, "advanced", "Ã¢Å¡â„¢Ã¯Â¸Â Advanced", obs.OBS_GROUP_NORMAL, grp_adv)

    --==========================
    -- API SERVER (collapsed)
    --==========================
    local grp_api = obs.obs_properties_create()
    obs.obs_properties_add_bool(grp_api, "api_enabled", "Enable UDP API Server")
    obs.obs_properties_add_int(grp_api, "api_port", "API Port", 1024, 65535, 1)
    obs.obs_properties_add_group(props, "api_server", "Ã°Å¸Å’Â UDP API Server", obs.OBS_GROUP_NORMAL, grp_api)

    --==========================
    -- HELP (collapsed)
    --==========================
    local grp_help = obs.obs_properties_create()
    obs.obs_properties_add_text(grp_help, "help_text",
        "QUICK START:\n" ..
        "1. Select your capture source above\n" ..
        "2. Set hotkeys in OBS Settings Ã¢â€ â€™ Hotkeys\n" ..
        "   Ã¢â‚¬Â¢ 'Toggle Zoom to Mouse' Ã¢â‚¬â€ Main zoom\n" ..
        "   Ã¢â‚¬Â¢ 'Toggle Mouse Follow' Ã¢â‚¬â€ Enable/disable follow\n" ..
        "3. Press the hotkey to zoom!\n\n" ..
        "TIPS:\n" ..
        "Ã¢â‚¬Â¢ Zoom centers on mouse position\n" ..
        "Ã¢â‚¬Â¢ Enable Auto-Follow for smooth tracking\n" ..
        "Ã¢â‚¬Â¢ Adjust Dead Zone to reduce jitter",
        obs.OBS_TEXT_INFO)
    obs.obs_properties_add_group(props, "help", "Ã¢Ââ€œ Help", obs.OBS_GROUP_NORMAL, grp_help)

    return props
end

--[[ Called to set default values
--[[ @param data table Settings data
function script_defaults(data)
    obs.obs_data_set_default_string(data, "source", "")
    obs.obs_data_set_default_double(data, "zoom_value", 2.0)
    obs.obs_data_set_default_double(data, "zoom_duration", 0.6)
    obs.obs_data_set_default_double(data, "zoom_overshoot", 0.0)
    obs.obs_data_set_default_string(data, "zoom_easing", "Cubic.Out")
    obs.obs_data_set_default_bool(data, "auto_follow", true)
    obs.obs_data_set_default_double(data, "follow_smooth_time", 0.15)
    obs.obs_data_set_default_int(data, "follow_dead_zone", 5)
    obs.obs_data_set_default_double(data, "scroll_step", 0.25)
    obs.obs_data_set_default_bool(data, "debug_logs", false)
    obs.obs_data_set_default_bool(data, "api_enabled", false)
    obs.obs_data_set_default_int(data, "api_port", 12345)
end

--================================================
-- SCRIPT METADATA
--================================================
script_info = {
    name = "OBS Zoom Pro",
    version = VERSION,
    description = "Intelligent camera zoom functionality with smooth transitions and easing curves.",
    author = "OBS Zoom Pro Team"
}
)
        handle:close()
        if uname == 'Darwin' then
            is_macos = true
            is_linux = false
        end
    end

    return {
        WINDOWS = is_windows,
        LINUX = is_linux,
        MACOS = is_macos
    }
end

local platform = detect_platform()
local IS_WINDOWS = platform.WINDOWS
local IS_LINUX = platform.LINUX
local IS_MACOS = platform.MACOS

-- Log platform detection
log("Platform detected: " .. (jit and jit.os or "Unknown") .. (IS_WINDOWS and " (Full support)" or " (Basic support)"))

-- Virtual key codes (Lua constants instead of C #define)
local VK_LBUTTON = 0x01
local VK_RBUTTON = 0x02
local VK_MBUTTON = 0x04
local VK_CONTROL = 0x11
local VK_SHIFT = 0x10
local VK_MENU = 0x12  -- Alt

-- FFI declarations for Windows (only if FFI is available)


-- Cursor shape constants (Windows)
local CURSOR_ARROW = 1
local CURSOR_IBEAM = 2
local CURSOR_HAND = 3
local CURSOR_WAIT = 4

-- Module state
local Platform = {
    cursor_shape_available = IS_WINDOWS,
    last_mouse = { x = 0, y = 0 },
    last_click = false,
}

-- Get mouse position (cross-platform)
function Platform.get_mouse_pos()
    if IS_WINDOWS then
        local success, pt = pcall(function()
            local pt = ffi.new("POINT")
            if ffi.C.GetCursorPos(pt) ~= 0 then
                return { x = tonumber(pt.x), y = tonumber(pt.y) }
            end
            return nil
        end)
        if success and pt then
            return pt
        end
    elseif IS_LINUX then
        -- Linux: Use xdotool if available, fallback to X11
        local success, result = pcall(function()
            local handle = io.popen("xdotool getmouselocation 2>/dev/null || echo 'x:0 y:0'")
            if handle then
                local output = handle:read("*a")
                handle:close()
                local x, y = output:match("x:(%d+)%s+y:(%d+)")
                if x and y then
                    return { x = tonumber(x), y = tonumber(y) }
                end
            end
            return nil
        end)
        if success and result then
            return result
        end
    elseif IS_MACOS then
        -- macOS: Use osascript
        local success, result = pcall(function()
            local handle = io.popen(--[[osascript -e 'tell application "System Events" to get position of the mouse' 2>/dev/null || echo "0, 0"]])
            if handle then
                local output = handle:read("*a")
                handle:close()
                local x, y = output:match("(%d+),%s*(%d+)")
                if x and y then
                    return { x = tonumber(x), y = tonumber(y) }
                end
            end
            return nil
        end)
        if success and result then
            return result
        end
    end

    -- Fallback
    return { x = 0, y = 0 }
end

-- Check if left mouse button is clicked (Windows only, others return false)
function Platform.is_clicking()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x01) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if a modifier key is held (Windows only)
function Platform.is_key_held(vk_code)
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(vk_code) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if cursor is a pointer/hand (Windows only)
function Platform.is_cursor_pointer()
    if IS_WINDOWS then
        local success, result = pcall(function()
            local ci = ffi.new("CURSORINFO")
            ci.cbSize = ffi.sizeof("CURSORINFO")
            if ffi.C.GetCursorInfo(ci) ~= 0 then
                -- Check if hCursor is a hand pointer
                -- This is a simplified check; real implementation would compare cursor handles
                return ci.flags ~= 0  -- Simplified; actual implementation needs cursor handle comparison
            end
            return false
        end)
        return success and result or false
    end
    return false
end

-- Get cursor shape (Windows only, returns "arrow" for others)
function Platform.get_cursor_shape()
    if IS_WINDOWS then
        local success, result = pcall(function()
            local ci = ffi.new("CURSORINFO")
            ci.cbSize = ffi.sizeof("CURSORINFO")
            if ffi.C.GetCursorInfo(ci) ~= 0 and ci.hCursor ~= nil then
                local addr = tonumber(ffi.cast("uintptr_t", ci.hCursor))
                -- Common cursor IDs (these are typical values, may vary)
                -- IDC_ARROW = 32512, IDC_IBEAM = 32513, IDC_HAND = 32649
                -- We use address ranges as heuristic
                return "arrow"  -- Simplified; actual implementation would map handles
            end
            return "arrow"
        end)
        return success and result or "arrow"
    end
    return "arrow"
end

-- Check if Control key is held
function Platform.is_ctrl_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x11) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if Shift key is held
function Platform.is_shift_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x10) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if Alt key is held
function Platform.is_alt_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x12) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Convenience wrapper functions
function platform_get_mouse_pos()
    return Platform.get_mouse_pos()
end

function platform_is_clicking()
    return Platform.is_clicking()
end

function platform_is_cursor_pointer()
    return Platform.is_cursor_pointer()
end

function platform_cursor_shape_available()
    return Platform.cursor_shape_available
end

function platform_is_ctrl_held()
    return Platform.is_ctrl_held()
end

function platform_is_shift_held()
    return Platform.is_shift_held()
end

function platform_is_alt_held()
    return Platform.is_alt_held()
end

--================================================
-- MODULE: State Machine (M05)
--================================================
-- Manages zoom states and transitions
-- States: IDLE, ZOOMING_IN, ZOOMED_IN, ZOOMING_OUT, SCROLLING, JUMPING

local ZoomState = {
    IDLE         = "idle",
    ZOOMING_IN   = "zooming_in",
    ZOOMED_IN    = "zoomed_in",
    ZOOMING_OUT  = "zooming_out",
    SCROLLING    = "scrolling",    -- Scroll wheel mid-transition
    JUMPING      = "jumping",      -- Bookmark transition
}

local StateMachine = {
    state = ZoomState.IDLE,
    zoom_time = 0,          -- Animation progress (0 Ã¢â€ â€™ 1)
    zoom_level = 1.0,       -- Current zoom factor
    target_level = 1.0,     -- Target zoom factor
    start_crop = nil,       -- Crop at animation start {x, y, w, h}
    target_crop = nil,      -- Crop at animation end {x, y, w, h}
    following = false,      -- Mouse follow active

    -- Transition guards
    can_zoom_in = function(self)
        return self.state == ZoomState.IDLE
    end,

    can_zoom_out = function(self)
        return self.state == ZoomState.ZOOMED_IN
            or self.state == ZoomState.SCROLLING
    end,

    can_scroll = function(self)
        return self.state == ZoomState.ZOOMED_IN
            or self.state == ZoomState.IDLE
            or self.state == ZoomState.SCROLLING
    end,

    can_jump = function(self)
        return self.state ~= ZoomState.ZOOMING_IN
           and self.state ~= ZoomState.ZOOMING_OUT
           and self.state ~= ZoomState.JUMPING
    end,

    is_animating = function(self)
        return self.state == ZoomState.ZOOMING_IN
            or self.state == ZoomState.ZOOMING_OUT
            or self.state == ZoomState.SCROLLING
            or self.state == ZoomState.JUMPING
    end,

    is_zoomed = function(self)
        return self.state ~= ZoomState.IDLE
    end,
}

-- Transition to a new state
function StateMachine:transition(new_state, params)
    local old = self.state
    self.state = new_state
    self.zoom_time = 0

    if params then
        if params.start_crop then self.start_crop = params.start_crop end
        if params.target_crop then self.target_crop = params.target_crop end
        if params.target_level then self.target_level = params.target_level end
    end

    log("State: " .. old .. " Ã¢â€ â€™ " .. new_state)
end

-- Complete the current animation
function StateMachine:complete()
    if self.state == ZoomState.ZOOMING_IN
       or self.state == ZoomState.SCROLLING
       or self.state == ZoomState.JUMPING then
        self.zoom_level = self.target_level
        self.state = ZoomState.ZOOMED_IN
        self.zoom_time = 0
        log("State: " .. self.state .. " Ã¢â€ â€™ ZOOMED_IN (complete)")
    elseif self.state == ZoomState.ZOOMING_OUT then
        self.zoom_level = 1.0
        self.target_level = 1.0
        self.start_crop = nil
        self.target_crop = nil
        self.following = false
        self.state = ZoomState.IDLE
        self.zoom_time = 0
        log("State: ZOOMING_OUT Ã¢â€ â€™ IDLE (complete)")
    end
end

-- Reset to initial state
function StateMachine:reset()
    self.state = ZoomState.IDLE
    self.zoom_time = 0
    self.zoom_level = 1.0
    self.target_level = 1.0
    self.start_crop = nil
    self.target_crop = nil
    self.following = false
    log("StateMachine: Reset to IDLE")
end

-- Get current animation progress (0-1)
function StateMachine:get_progress()
    return clamp(0, 1, self.zoom_time)
end

-- Check if in a specific state
function StateMachine:is_state(state)
    return self.state == state
end

-- Get state name for display
function StateMachine:get_state_name()
    return self.state
end

-- Create a new state machine instance (for testing/isolation)
function StateMachine:new()
    local sm = {}
    setmetatable(sm, { __index = self })
    sm.state = ZoomState.IDLE
    sm.zoom_time = 0
    sm.zoom_level = 1.0
    sm.target_level = 1.0
    sm.start_crop = nil
    sm.target_crop = nil
    sm.following = false
    return sm
end

-- Global state machine instance
local SM = StateMachine:new()

--================================================
-- MODULE: Crop Filter Manager (M07)
--================================================
-- Manages the crop/pad filter used to simulate zoom
-- Creates, updates, and destroys the filter automatically

local FILTER_PREFIX = "[ZoomPro] "
local CROP_FILTER_NAME = FILTER_PREFIX .. "Crop"

local CropFilterManager = {
    filter = nil,           -- The crop filter source
    source = nil,           -- The parent source
    original_crop = nil,    -- Original crop values for restoration
    current_crop = { x = 0, y = 0, w = 0, h = 0 },
    initialized = false,
}

-- Create the crop filter on a source
function CropFilterManager:create(source)
    if not source then
        log("CropFilter: No source provided")
        return false
    end

    self:cleanup()  -- Clean up any existing filter
    self.source = source

    -- Check if our filter already exists
    local existing = obs.obs_source_get_filter_by_name(source, CROP_FILTER_NAME)
    if existing then
        log("CropFilter: Found existing filter")
        self.filter = existing
        self.initialized = true
        return true
    end

    -- Create new crop/pad filter
    local settings = obs.obs_data_create()
    obs.obs_data_set_int(settings, "left", 0)
    obs.obs_data_set_int(settings, "top", 0)
    obs.obs_data_set_int(settings, "right", 0)
    obs.obs_data_set_int(settings, "bottom", 0)
    obs.obs_data_set_bool(settings, "relative", false)  -- Absolute positioning

    self.filter = obs.obs_source_create_private(
        "crop_filter",      -- Filter type
        CROP_FILTER_NAME,   -- Filter name
        settings            -- Settings
    )

    obs.obs_data_release(settings)

    if not self.filter then
        log("CropFilter: Failed to create filter")
        return false
    end

    -- Add filter to source
    obs.obs_source_filter_add(source, self.filter)

    -- Store original crop (none)
    self.original_crop = { x = 0, y = 0, w = 0, h = 0 }

    self.initialized = true
    log("CropFilter: Created successfully")
    return true
end

-- Update the crop filter with new values
function CropFilterManager:update(x, y, w, h)
    if not self.filter or not self.initialized then
        return false
    end

    -- Store current crop
    self.current_crop = { x = x, y = y, w = w, h = h }

    -- Get filter settings
    local settings = obs.obs_source_get_settings(self.filter)
    if not settings then
        return false
    end

    -- Calculate crop values
    -- For crop_filter: left, top are absolute position
    -- right, bottom are width/height from right/bottom edge
    -- We need to convert our x, y, w, h to this format

    -- Get source dimensions
    local source_w = obs.obs_source_get_width(self.source)
    local source_h = obs.obs_source_get_height(self.source)

    if source_w == 0 or source_h == 0 then
        obs.obs_data_release(settings)
        return false
    end

    -- Set crop values
    -- left = x offset from left
    -- top = y offset from top
    -- right = source_w - (x + w) = remaining width on right
    -- bottom = source_h - (y + h) = remaining height on bottom
    local left = math.floor(x)
    local top = math.floor(y)
    local right = math.floor(source_w - (x + w))
    local bottom = math.floor(source_h - (y + h))

    -- Clamp to valid values
    left = math.max(0, left)
    top = math.max(0, top)
    right = math.max(0, right)
    bottom = math.max(0, bottom)

    obs.obs_data_set_int(settings, "left", left)
    obs.obs_data_set_int(settings, "top", top)
    obs.obs_data_set_int(settings, "right", right)
    obs.obs_data_set_int(settings, "bottom", bottom)

    -- Update the filter
    obs.obs_source_update(self.filter, settings)
    obs.obs_data_release(settings)

    return true
end

-- Get current crop values
function CropFilterManager:get_crop()
    return self.current_crop
end

-- Reset crop to original (no crop)
function CropFilterManager:reset()
    if not self.filter or not self.initialized then
        return false
    end

    local settings = obs.obs_source_get_settings(self.filter)
    if settings then
        obs.obs_data_set_int(settings, "left", 0)
        obs.obs_data_set_int(settings, "top", 0)
        obs.obs_data_set_int(settings, "right", 0)
        obs.obs_data_set_int(settings, "bottom", 0)
        obs.obs_source_update(self.filter, settings)
        obs.obs_data_release(settings)
    end

    self.current_crop = { x = 0, y = 0, w = 0, h = 0 }
    return true
end

-- Remove the filter and restore original state
function CropFilterManager:cleanup()
    if self.filter and self.source then
        -- Reset to no crop first
        self:reset()

        -- Remove filter from source
        obs.obs_source_filter_remove(self.source, self.filter)
        obs.obs_source_release(self.filter)
        self.filter = nil
        log("CropFilter: Removed from source")
    end

    self.source = nil
    self.original_crop = nil
    self.current_crop = { x = 0, y = 0, w = 0, h = 0 }
    self.initialized = false
end

-- Check if filter is ready
function CropFilterManager:is_ready()
    return self.initialized and self.filter ~= nil
end

-- Get source dimensions
function CropFilterManager:get_source_size()
    if not self.source then
        return 0, 0
    end
    return obs.obs_source_get_width(self.source), obs.obs_source_get_height(self.source)
end

-- Convenience wrapper functions
function crop_filter_create(source)
    return CropFilterManager:create(source)
end

function crop_filter_update(x, y, w, h)
    return CropFilterManager:update(x, y, w, h)
end

function crop_filter_reset()
    return CropFilterManager:reset()
end

function crop_filter_cleanup()
    return CropFilterManager:cleanup()
end

function crop_filter_is_ready()
    return CropFilterManager:is_ready()
end

function crop_filter_get_crop()
    return CropFilterManager:get_crop()
end

function crop_filter_get_source_size()
    return CropFilterManager:get_source_size()
end

--================================================
-- MODULE: Source Manager (M08)
--================================================
-- Handles finding sources in scenes, capturing transforms,
-- and managing source state for zoom operations

local SourceManager = {
    source = nil,           -- Current zoom source
    sceneitem = nil,        -- Scene item reference
    scene = nil,            -- Current scene
    original_transform = nil, -- Saved original transform
    source_name = "",       -- Source name for settings
    initialized = false,
}

-- Transform data structure
local TransformData = {
    pos = { x = 0, y = 0 },
    scale = { x = 1.0, y = 1.0 },
    rot = 0,
    bounds_type = 0,
    bounds = { x = 0, y = 0 },
    crop = { left = 0, top = 0, right = 0, bottom = 0 },
}

-- Find a source in a scene (BFS through groups)
function SourceManager:find_sceneitem(scene, source_name)
    if not scene or not source_name then
        return nil
    end

    local scene_source = obs.obs_scene_from_source(scene)
    if not scene_source then
        return nil
    end

    -- BFS queue
    local queue = {}
    table.insert(queue, scene_source)

    while #queue > 0 do
        local current_scene = table.remove(queue, 1)

        -- Iterate through items
        local items = obs.obs_scene_enum_items(current_scene)
        if items then
            for _, item in ipairs(items) do
                local item_source = obs.obs_sceneitem_get_source(item)
                if item_source then
                    local name = obs.obs_source_get_name(item_source)

                    -- Check if this is our target
                    if name == source_name then
                        obs.sceneitem_list_release(items)
                        return item
                    end

                    -- Check if this is a group (nested scene)
                    if obs.obs_source_get_type(item_source) == obs.OBS_SOURCE_TYPE_INPUT then
                        local id = obs.obs_source_get_id(item_source)
                        if id == "group" then
                            local group_scene = obs.obs_group_from_source(item_source)
                            if group_scene then
                                table.insert(queue, group_scene)
                            end
                        end
                    end
                end
            end
            obs.sceneitem_list_release(items)
        end
    end

    return nil
end

-- Capture the current transform of a scene item
function SourceManager:capture_transform(sceneitem)
    if not sceneitem then
        return nil
    end

    local transform = {}

    -- Position
    local pos = obs.vec2()
    obs.obs_sceneitem_get_pos(sceneitem, pos)
    transform.pos = { x = pos.x, y = pos.y }

    -- Scale
    local scale = obs.vec2()
    obs.obs_sceneitem_get_scale(sceneitem, scale)
    transform.scale = { x = scale.x, y = scale.y }

    -- Rotation
    transform.rot = obs.obs_sceneitem_get_rot(sceneitem)

    -- Bounds
    transform.bounds_type = obs.obs_sceneitem_get_bounds_type(sceneitem)
    local bounds = obs.vec2()
    obs.obs_sceneitem_get_bounds(sceneitem, bounds)
    transform.bounds = { x = bounds.x, y = bounds.y }

    -- Crop
    local crop = obs.obs_sceneitem_crop()
    obs.obs_sceneitem_get_crop(sceneitem, crop)
    transform.crop = {
        left = crop.left,
        top = crop.top,
        right = crop.right,
        bottom = crop.bottom
    }

    return transform
end

-- Restore a saved transform to a scene item
function SourceManager:restore_transform(sceneitem, transform)
    if not sceneitem or not transform then
        return false
    end

    -- Position
    local pos = obs.vec2()
    pos.x = transform.pos.x
    pos.y = transform.pos.y
    obs.obs_sceneitem_set_pos(sceneitem, pos)

    -- Scale
    local scale = obs.vec2()
    scale.x = transform.scale.x
    scale.y = transform.scale.y
    obs.obs_sceneitem_set_scale(sceneitem, scale)

    -- Rotation
    obs.obs_sceneitem_set_rot(sceneitem, transform.rot)

    -- Bounds
    obs.obs_sceneitem_set_bounds_type(sceneitem, transform.bounds_type)
    local bounds = obs.vec2()
    bounds.x = transform.bounds.x
    bounds.y = transform.bounds.y
    obs.obs_sceneitem_set_bounds(sceneitem, bounds)

    -- Crop
    local crop = obs.obs_sceneitem_crop()
    crop.left = transform.crop.left
    crop.top = transform.crop.top
    crop.right = transform.crop.right
    crop.bottom = transform.crop.bottom
    obs.obs_sceneitem_set_crop(sceneitem, crop)

    return true
end

-- Initialize with a source name
function SourceManager:init(source_name)
    self:release()  -- Clean up any existing state

    if not source_name or source_name == "" then
        log("SourceManager: No source name provided")
        return false
    end

    self.source_name = source_name

    -- Get current scene
    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then
        log("SourceManager: No current scene")
        return false
    end

    self.scene = scene_source

    -- Find the scene item
    self.sceneitem = self:find_sceneitem(scene_source, source_name)
    if not self.sceneitem then
        log("SourceManager: Source not found in scene: " .. source_name)
        obs.obs_source_release(scene_source)
        return false
    end

    -- Get the source
    self.source = obs.obs_sceneitem_get_source(self.sceneitem)
    if not self.source then
        log("SourceManager: Failed to get source from sceneitem")
        obs.obs_source_release(scene_source)
        return false
    end

    -- Capture original transform
    self.original_transform = self:capture_transform(self.sceneitem)

    -- Create crop filter
    if not crop_filter_create(self.source) then
        log("SourceManager: Failed to create crop filter")
        obs.obs_source_release(scene_source)
        return false
    end

    self.initialized = true
    log("SourceManager: Initialized with source: " .. source_name)

    obs.obs_source_release(scene_source)
    return true
end

-- Release all resources
function SourceManager:release()
    -- Clean up crop filter
    crop_filter_cleanup()

    -- Restore original transform if we have it
    if self.sceneitem and self.original_transform then
        self:restore_transform(self.sceneitem, self.original_transform)
        log("SourceManager: Restored original transform")
    end

    self.source = nil
    self.sceneitem = nil
    self.scene = nil
    self.original_transform = nil
    self.initialized = false

    log("SourceManager: Released")
end

-- Get source dimensions
function SourceManager:get_source_size()
    if not self.source then
        return 0, 0
    end
    return obs.obs_source_get_width(self.source), obs.obs_source_get_height(self.source)
end

-- Check if source is valid
function SourceManager:is_valid()
    return self.initialized and self.source ~= nil and self.sceneitem ~= nil
end

-- Get source info
function SourceManager:get_info()
    if not self:is_valid() then
        return nil
    end

    return {
        name = self.source_name,
        width = obs.obs_source_get_width(self.source),
        height = obs.obs_source_get_height(self.source),
    }
end

-- Get list of available capture sources
function SourceManager.get_available_sources()
    local sources = {}

    -- Get all sources
    local source_list = obs.obs_enum_sources()
    if source_list then
        for _, source in ipairs(source_list) do
            local source_id = obs.obs_source_get_id(source)
            local name = obs.obs_source_get_name(source)

            -- Filter for capture sources
            local is_capture = false
            if source_id == "monitor_capture" or      -- Display capture
               source_id == "window_capture" or       -- Window capture
               source_id == "game_capture" or         -- Game capture
               source_id == "xshm_input" or           -- Linux X11 capture
               source_id == "av_capture_input" then   -- macOS capture
                is_capture = true
            end

            if is_capture then
                table.insert(sources, {
                    name = name,
                    id = source_id,
                })
            end
        end
        obs.source_list_release(source_list)
    end

    return sources
end

-- Convenience wrapper functions
function source_manager_init(source_name)
    return SourceManager:init(source_name)
end

function source_manager_release()
    return SourceManager:release()
end

function source_manager_is_valid()
    return SourceManager:is_valid()
end

function source_manager_get_source()
    return SourceManager.source
end

function source_manager_get_sceneitem()
    return SourceManager.sceneitem
end

function source_manager_get_size()
    return SourceManager:get_source_size()
end

function source_manager_get_available_sources()
    return SourceManager.get_available_sources()
end

--================================================
-- MODULE: Camera Physics (M06)
--================================================
-- Handles camera position calculations, dead zones,
-- and SmoothDamp-based camera movement

local CameraPhysics = {
    -- Smoothed camera position
    pos = { x = 0, y = 0 },

    -- Velocities for SmoothDamp
    vel_x = { val = 0 },
    vel_y = { val = 0 },

    -- Dead zone state
    tracked_pos = { x = 0, y = 0 },
    dead_zone_active = false,

    -- Last camera position (for velocity calculation)
    last_pos = { x = 0, y = 0 },

    -- Monitor offset (for multi-monitor setups)
    monitor_offset = { x = 0, y = 0 },
}

-- Initialize camera tracking with starting position
function CameraPhysics:init(mouse_pos)
    if mouse_pos then
        self.pos.x = mouse_pos.x
        self.pos.y = mouse_pos.y
        self.tracked_pos.x = mouse_pos.x
        self.tracked_pos.y = mouse_pos.y
    end
    self.vel_x.val = 0
    self.vel_y.val = 0
    self.last_pos.x = self.pos.x
    self.last_pos.y = self.pos.y
end

-- Apply dead zone to mouse input
-- Returns the position the camera should track
function CameraPhysics:apply_dead_zone(mouse_pos, dead_zone_radius)
    if not mouse_pos then
        return self.tracked_pos
    end

    if dead_zone_radius <= 0 then
        self.tracked_pos.x = mouse_pos.x
        self.tracked_pos.y = mouse_pos.y
        return self.tracked_pos
    end

    -- Calculate distance from tracked position to mouse
    local dx = mouse_pos.x - self.tracked_pos.x
    local dy = mouse_pos.y - self.tracked_pos.y
    local dist = math.sqrt(dx * dx + dy * dy)

    if dist <= dead_zone_radius then
        -- Mouse is within dead zone, don't move tracked position
        self.dead_zone_active = true
        return self.tracked_pos
    end

    -- Mouse is outside dead zone
    -- Move tracked position so it stays exactly dead_zone_radius from mouse
    self.dead_zone_active = false
    local excess = dist - dead_zone_radius
    local nx = dx / dist  -- Normalized direction
    local ny = dy / dist

    self.tracked_pos.x = self.tracked_pos.x + nx * excess
    self.tracked_pos.y = self.tracked_pos.y + ny * excess

    return self.tracked_pos
end

-- Smooth the input position using SmoothDamp
function CameraPhysics:smooth_input(target_pos, smooth_time, dt)
    if not target_pos then
        return self.pos
    end

    local max_speed = 100000  -- Very high max speed for smooth camera

    self.pos.x = SmoothDamp(self.pos.x, target_pos.x, self.vel_x, smooth_time, max_speed, dt)
    self.pos.y = SmoothDamp(self.pos.y, target_pos.y, self.vel_y, smooth_time, max_speed, dt)

    return self.pos
end

-- Calculate the crop rectangle for a given zoom level and center position
function CameraPhysics:compute_crop(center_x, center_y, zoom_level, source_w, source_h)
    if zoom_level <= 1.0 then
        -- No zoom, return full source
        return {
            x = 0,
            y = 0,
            w = source_w,
            h = source_h,
        }
    end

    -- Calculate crop dimensions
    local crop_w = source_w / zoom_level
    local crop_h = source_h / zoom_level

    -- Center the crop on the target position
    local crop_x = center_x - crop_w / 2
    local crop_y = center_y - crop_h / 2

    -- Clamp to source bounds
    crop_x = clamp(0, source_w - crop_w, crop_x)
    crop_y = clamp(0, source_h - crop_h, crop_y)

    return {
        x = crop_x,
        y = crop_y,
        w = crop_w,
        h = crop_h,
    }
end

-- Calculate target crop for zoom animation
-- mouse_pos: current mouse position
-- zoom_level: target zoom level
-- source_w, source_h: source dimensions
-- monitor_offset: offset for multi-monitor (optional)
function CameraPhysics:get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
    if not mouse_pos then
        return nil
    end

    -- Apply monitor offset if provided
    local target_x = mouse_pos.x
    local target_y = mouse_pos.y

    if monitor_offset then
        target_x = target_x - monitor_offset.x
        target_y = target_y - monitor_offset.y
    end

    -- Clamp to source bounds
    target_x = clamp(0, source_w, target_x)
    target_y = clamp(0, source_h, target_y)

    return self:compute_crop(target_x, target_y, zoom_level, source_w, source_h)
end

-- Interpolate between two crop rectangles
function CameraPhysics:lerp_crop(start_crop, end_crop, t, easing_fn)
    if not start_crop or not end_crop then
        return nil
    end

    t = clamp(0, 1, t)

    -- Apply easing
    local eased_t = easing_fn and easing_fn(t) or t

    return {
        x = lerp(start_crop.x, end_crop.x, eased_t),
        y = lerp(start_crop.y, end_crop.y, eased_t),
        w = lerp(start_crop.w, end_crop.w, eased_t),
        h = lerp(start_crop.h, end_crop.h, eased_t),
    }
end

-- Get camera velocity (for motion blur)
function CameraPhysics:get_velocity()
    return {
        x = self.pos.x - self.last_pos.x,
        y = self.pos.y - self.last_pos.y,
    }
end

-- Update last position (call at end of frame)
function CameraPhysics:update_last_pos()
    self.last_pos.x = self.pos.x
    self.last_pos.y = self.pos.y
end

-- Set monitor offset
function CameraPhysics:set_monitor_offset(offset)
    self.monitor_offset = offset or { x = 0, y = 0 }
end

-- Reset camera state
function CameraPhysics:reset()
    self.pos = { x = 0, y = 0 }
    self.vel_x = { val = 0 }
    self.vel_y = { val = 0 }
    self.tracked_pos = { x = 0, y = 0 }
    self.dead_zone_active = false
    self.last_pos = { x = 0, y = 0 }
end

-- Convenience wrapper functions
function camera_physics_init(mouse_pos)
    return CameraPhysics:init(mouse_pos)
end

function camera_physics_apply_dead_zone(mouse_pos, dead_zone_radius)
    return CameraPhysics:apply_dead_zone(mouse_pos, dead_zone_radius)
end

function camera_physics_smooth_input(target_pos, smooth_time, dt)
    return CameraPhysics:smooth_input(target_pos, smooth_time, dt)
end

function camera_physics_compute_crop(center_x, center_y, zoom_level, source_w, source_h)
    return CameraPhysics:compute_crop(center_x, center_y, zoom_level, source_w, source_h)
end

function camera_physics_get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
    return CameraPhysics:get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
end

function camera_physics_lerp_crop(start_crop, end_crop, t, easing_fn)
    return CameraPhysics:lerp_crop(start_crop, end_crop, t, easing_fn)
end

function camera_physics_get_velocity()
    return CameraPhysics:get_velocity()
end

function camera_physics_update_last_pos()
    return CameraPhysics:update_last_pos()
end

function camera_physics_reset()
    return CameraPhysics:reset()
end

--================================================
-- MODULE: Timer & Main Loop (M09)
--================================================
-- Core integration module that handles frame-by-frame updates,
-- input processing, state machine updates, and output

-- Configuration (will be populated from settings)
local cfg = {
    source_name = "",
    zoom_value = 2.0,
    max_zoom = 10.0,
    zoom_duration = 0.6,
    zoom_overshoot = 0.0,
    zoom_easing = "Cubic.Out",

    auto_follow = true,
    follow_smooth_time = 0.15,
    follow_dead_zone = 5,

    debug_logs = false,
}

-- Timing
local last_tick_time = 0
local timer_running = false

-- Frame diff tracking (skip updates if nothing changed)
local last_output = { x = -1, y = -1, w = -1, h = -1 }

-- Original crop for zoom out
local original_crop = { x = 0, y = 0, w = 0, h = 0 }

-- Hotkey IDs
local hotkey_toggle_zoom = nil
local hotkey_toggle_follow = nil

-- Get reliable delta time
local function get_dt()
    local now = os.clock()
    local dt = now - last_tick_time
    last_tick_time = now
    return clamp(0.001, 0.1, dt)  -- Guard against freezes and div/zero
end

-- Start the timer
local function start_timer()
    if not timer_running then
        timer_running = true
        last_tick_time = os.clock()
        -- Use frame-synced interval
        local interval = 16  -- Default to ~60fps
        obs.timer_add(on_timer, interval)
        log("Timer: Started")
    end
end

-- Stop the timer
local function stop_timer()
    if timer_running then
        timer_running = false
        obs.timer_remove(on_timer)
        log("Timer: Stopped")
    end
end

-- Initialize mouse tracking
local function init_mouse_tracking(mouse_pos)
    camera_physics_init(mouse_pos)
    original_crop = {
        x = 0,
        y = 0,
        w = 0,
        h = 0,
    }
end

-- Main timer callback
function on_timer()
    local dt = get_dt()

    -- Guard: No valid source
    if not source_manager_is_valid() then
        return
    end

    --==========================
    -- 1. INPUT
    --==========================
    local raw_mouse = platform_get_mouse_pos()

    --==========================
    -- 2. STATE MACHINE UPDATE
    --==========================
    if SM:is_animating() then
        SM.zoom_time = SM.zoom_time + (dt / cfg.zoom_duration)

        -- Check for completion
        if SM.zoom_time >= 1.0 then
            SM:complete()

            -- Auto-enable follow after zoom in
            if SM.state == ZoomState.ZOOMED_IN and cfg.auto_follow then
                SM.following = true
            end

            -- Stop timer if idle
            if SM.state == ZoomState.IDLE then
                stop_timer()
            end
        end
    end

    --==========================
    -- 3. CAMERA POSITION
    --==========================
    local crop = nil
    local source_w, source_h = source_manager_get_size()

    if source_w == 0 or source_h == 0 then
        return
    end

    if SM:is_animating() then
        -- Animate between start and target crop
        local easing_fn = Easing.get(cfg.zoom_easing, cfg.zoom_overshoot)
        crop = camera_physics_lerp_crop(SM.start_crop, SM.target_crop, SM.zoom_time, easing_fn)
    elseif SM:is_zoomed() and SM.following then
        -- Follow mouse with dead zone and smoothing
        local tracked = camera_physics_apply_dead_zone(raw_mouse, cfg.follow_dead_zone)
        local smoothed = camera_physics_smooth_input(tracked, cfg.follow_smooth_time, dt)
        crop = camera_physics_compute_crop(smoothed.x, smoothed.y, SM.zoom_level, source_w, source_h)
        camera_physics_update_last_pos()
    elseif SM:is_zoomed() then
        -- Static zoom (not following)
        crop = camera_physics_get_target_crop(
            { x = SM.target_crop.x + SM.target_crop.w / 2, y = SM.target_crop.y + SM.target_crop.h / 2 },
            SM.zoom_level, source_w, source_h, nil
        )
    end

    --==========================
    -- 4. OUTPUT (Diff-based)
    --==========================
    if crop then
        local cx = math.floor(crop.x)
        local cy = math.floor(crop.y)
        local cw = math.floor(crop.w)
        local ch = math.floor(crop.h)

        if cx ~= last_output.x or cy ~= last_output.y or
           cw ~= last_output.w or ch ~= last_output.h then
            crop_filter_update(cx, cy, cw, ch)
            last_output.x = cx
            last_output.y = cy
            last_output.w = cw
            last_output.h = ch
        end
    end
end

--==========================
-- HOTKEY HANDLERS
--==========================

function on_toggle_zoom(pressed)
    if not pressed then return end

    if not source_manager_is_valid() then
        log("Toggle Zoom: No valid source")
        return
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        log("Toggle Zoom: Invalid source dimensions")
        return
    end

    if SM.state == ZoomState.IDLE then
        -- ZOOM IN
        local mouse = platform_get_mouse_pos()
        init_mouse_tracking(mouse)

        -- Store original crop
        original_crop = { x = 0, y = 0, w = source_w, h = source_h }

        -- Calculate target crop
        local target_crop = camera_physics_get_target_crop(mouse, cfg.zoom_value, source_w, source_h, nil)

        SM:transition(ZoomState.ZOOMING_IN, {
            start_crop = original_crop,
            target_crop = target_crop,
            target_level = cfg.zoom_value
        })

        start_timer()

    elseif SM.state == ZoomState.ZOOMED_IN then
        -- ZOOM OUT
        SM.following = false

        local current = crop_filter_get_crop()
        SM:transition(ZoomState.ZOOMING_OUT, {
            start_crop = current,
            target_crop = original_crop,
            target_level = 1.0
        })

        start_timer()
    end
    -- Ignore if already animating (guard against rapid presses)
end

function on_toggle_follow(pressed)
    if not pressed then return end
    if not SM:is_zoomed() then return end

    SM.following = not SM.following
    log("Follow: " .. tostring(SM.following))

    if SM.following and not timer_running then
        start_timer()
    end
end

--==========================
-- HOTKEY REGISTRATION
--==========================

local function register_hotkeys(settings)
    -- Toggle Zoom hotkey
    hotkey_toggle_zoom = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.toggle_zoom",
        "Toggle Zoom to Mouse",
        on_toggle_zoom
    )

    -- Toggle Follow hotkey
    hotkey_toggle_follow = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.toggle_follow",
        "Toggle Mouse Follow",
        on_toggle_follow
    )

    -- Load saved hotkey bindings
    local toggle_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.toggle_zoom")
    if toggle_array then
        obs.obs_hotkey_load(hotkey_toggle_zoom, toggle_array)
        obs.obs_data_array_release(toggle_array)
    end

    local follow_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.toggle_follow")
    if follow_array then
        obs.obs_hotkey_load(hotkey_toggle_follow, follow_array)
        obs.obs_data_array_release(follow_array)
    end

    -- Register scroll zoom hotkeys
    register_scroll_hotkeys(settings)

    log("Hotkeys: Registered")
end

local function save_hotkeys(settings)
    if hotkey_toggle_zoom then
        local array = obs.obs_hotkey_save(hotkey_toggle_zoom)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.toggle_zoom", array)
        obs.obs_data_array_release(array)
    end

    if hotkey_toggle_follow then
        local array = obs.obs_hotkey_save(hotkey_toggle_follow)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.toggle_follow", array)
        obs.obs_data_array_release(array)
    end

    -- Save scroll zoom hotkeys
    save_scroll_hotkeys(settings)
end

local function unregister_hotkeys()
    if hotkey_toggle_zoom then
        obs.obs_hotkey_unregister(hotkey_toggle_zoom)
        hotkey_toggle_zoom = nil
    end
    if hotkey_toggle_follow then
        obs.obs_hotkey_unregister(hotkey_toggle_follow)
        hotkey_toggle_follow = nil
    end
    -- Unregister scroll zoom hotkeys
    unregister_scroll_hotkeys()
    log("Hotkeys: Unregistered")
end

--==========================
-- SCENE EVENT HANDLERS
--==========================

function on_frontend_event(event)
    if event == obs.OBS_FRONTEND_EVENT_SCENE_CHANGED then
        -- Scene changed, re-acquire source
        log("Event: Scene changed")

        -- Handle scene memory
        scene_memory_on_scene_change()

        if cfg.source_name and cfg.source_name ~= "" then
            source_manager_release()
            source_manager_init(cfg.source_name)
        end
    elseif event == obs.OBS_FRONTEND_EVENT_EXIT then
        -- OBS is closing
        log("Event: OBS exiting")
        stop_timer()
        source_manager_release()
    end
end

--==========================
-- CONFIGURATION UPDATE
--==========================

local function update_config(settings)
    cfg.source_name = obs.obs_data_get_string(settings, "source") or ""
    cfg.zoom_value = obs.obs_data_get_double(settings, "zoom_value")
    cfg.zoom_duration = obs.obs_data_get_double(settings, "zoom_duration")
    cfg.zoom_overshoot = obs.obs_data_get_double(settings, "zoom_overshoot")
    cfg.zoom_easing = obs.obs_data_get_string(settings, "zoom_easing") or "Cubic.Out"

    cfg.auto_follow = obs.obs_data_get_bool(settings, "auto_follow")
    cfg.follow_smooth_time = obs.obs_data_get_double(settings, "follow_smooth_time")
    cfg.follow_dead_zone = obs.obs_data_get_int(settings, "follow_dead_zone")

    cfg.debug_logs = obs.obs_data_get_bool(settings, "debug_logs")
    debug_logs = cfg.debug_logs

    -- Update scroll zoom config
    update_scroll_config(settings)

    -- Check if source changed
    local current_source = source_manager_is_valid() and cfg.source_name
    if cfg.source_name ~= "" and cfg.source_name ~= current_source then
        -- Reset state and reinitialize
        SM:reset()
        stop_timer()
        source_manager_release()
        source_manager_init(cfg.source_name)
    end
end

--================================================
-- MODULE: Scroll Zoom (M10)
--================================================
-- Enables gradual zoom control via scroll wheel with modifier key
-- Provides dynamic zoom level adjustment during zoomed state

local ScrollZoom = {
    -- Hotkey IDs for scroll zoom
    hotkey_scroll_up = nil,
    hotkey_scroll_down = nil,

    -- Configuration (populated from settings)
    scroll_step = 0.25,
    scroll_modifier = "ctrl",  -- "ctrl", "alt", "shift"
}

-- Check if modifier key is held
local function is_modifier_held()
    if ScrollZoom.scroll_modifier == "ctrl" then
        return platform_is_ctrl_held()
    elseif ScrollZoom.scroll_modifier == "alt" then
        return platform_is_alt_held()
    elseif ScrollZoom.scroll_modifier == "shift" then
        return platform_is_shift_held()
    end
    return false
end

-- Handle scroll zoom in
function on_scroll_zoom_up(pressed)
    if not pressed then return end
    on_scroll_zoom(1)
end

-- Handle scroll zoom out
function on_scroll_zoom_down(pressed)
    if not pressed then return end
    on_scroll_zoom(-1)
end

-- Main scroll zoom handler
function on_scroll_zoom(direction)
    -- Check if we can scroll
    if not SM:can_scroll() then return end

    -- Check modifier (optional - can be configured)
    -- For now, we rely on OBS hotkey bindings which can include modifiers

    if not source_manager_is_valid() then
        log("Scroll Zoom: No valid source")
        return
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        return
    end

    -- Calculate new zoom level
    local step = ScrollZoom.scroll_step * direction  -- e.g., 0.25
    local new_level

    if SM.state == ZoomState.IDLE then
        -- Starting from unzoomed
        new_level = 1.0 + step
    else
        -- Already zoomed, adjust level
        new_level = SM.target_level + step
    end

    -- Clamp to valid range
    new_level = clamp(1.0, cfg.max_zoom, new_level)

    -- If we hit 1.0, fully zoom out
    if new_level <= 1.0 then
        if SM:is_zoomed() then
            -- Trigger full zoom out
            local current = crop_filter_get_crop()
            SM.following = false
            SM:transition(ZoomState.ZOOMING_OUT, {
                start_crop = current,
                target_crop = original_crop,
                target_level = 1.0
            })
            start_timer()
        end
        return
    end

    -- Get current mouse position
    local mouse = platform_get_mouse_pos()

    -- Calculate new target crop for new zoom level
    local target_crop = camera_physics_get_target_crop(mouse, new_level, source_w, source_h, nil)

    -- Get current crop as start
    local start_crop
    if SM:is_animating() then
        -- Use current interpolated crop
        start_crop = crop_filter_get_crop()
    elseif SM:is_zoomed() then
        -- Use current crop
        start_crop = crop_filter_get_crop()
    else
        -- Starting from unzoomed
        start_crop = { x = 0, y = 0, w = source_w, h = source_h }
        original_crop = start_crop
        camera_physics_init(mouse)
    end

    -- Transition to new zoom level
    if SM.state == ZoomState.IDLE then
        -- First scroll from unzoomed
        SM:transition(ZoomState.SCROLLING, {
            start_crop = start_crop,
            target_crop = target_crop,
            target_level = new_level
        })
    else
        -- Already zoomed, adjust level (interrupt current animation)
        SM:transition(ZoomState.SCROLLING, {
            start_crop = start_crop,
            target_crop = target_crop,
            target_level = new_level
        })
    end

    start_timer()
    log("Scroll Zoom: Level " .. string.format("%.2f", new_level))
end

-- Zoom to a specific level (for API calls)
function on_scroll_zoom_to(level)
    if not source_manager_is_valid() then return end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then return end

    level = clamp(1.0, cfg.max_zoom, level)

    if level <= 1.0 then
        -- Zoom out
        if SM:is_zoomed() then
            local current = crop_filter_get_crop()
            SM.following = false
            SM:transition(ZoomState.ZOOMING_OUT, {
                start_crop = current,
                target_crop = original_crop,
                target_level = 1.0
            })
            start_timer()
        end
        return
    end

    local mouse = platform_get_mouse_pos()
    local target_crop = camera_physics_get_target_crop(mouse, level, source_w, source_h, nil)

    local start_crop
    if SM:is_zoomed() then
        start_crop = crop_filter_get_crop()
    else
        start_crop = { x = 0, y = 0, w = source_w, h = source_h }
        original_crop = start_crop
        camera_physics_init(mouse)
    end

    SM:transition(ZoomState.SCROLLING, {
        start_crop = start_crop,
        target_crop = target_crop,
        target_level = level
    })

    start_timer()
end

-- Register scroll zoom hotkeys
local function register_scroll_hotkeys(settings)
    -- Scroll Up hotkey
    ScrollZoom.hotkey_scroll_up = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.scroll_up",
        "Zoom In (Scroll)",
        on_scroll_zoom_up
    )

    -- Scroll Down hotkey
    ScrollZoom.hotkey_scroll_down = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.scroll_down",
        "Zoom Out (Scroll)",
        on_scroll_zoom_down
    )

    -- Load saved bindings
    local up_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.scroll_up")
    if up_array then
        obs.obs_hotkey_load(ScrollZoom.hotkey_scroll_up, up_array)
        obs.obs_data_array_release(up_array)
    end

    local down_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.scroll_down")
    if down_array then
        obs.obs_hotkey_load(ScrollZoom.hotkey_scroll_down, down_array)
        obs.obs_data_array_release(down_array)
    end

    log("Scroll Zoom: Hotkeys registered")
end

-- Save scroll hotkey bindings
local function save_scroll_hotkeys(settings)
    if ScrollZoom.hotkey_scroll_up then
        local array = obs.obs_hotkey_save(ScrollZoom.hotkey_scroll_up)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.scroll_up", array)
        obs.obs_data_array_release(array)
    end

    if ScrollZoom.hotkey_scroll_down then
        local array = obs.obs_hotkey_save(ScrollZoom.hotkey_scroll_down)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.scroll_down", array)
        obs.obs_data_array_release(array)
    end
end

-- Unregister scroll hotkeys
local function unregister_scroll_hotkeys()
    if ScrollZoom.hotkey_scroll_up then
        obs.obs_hotkey_unregister(ScrollZoom.hotkey_scroll_up)
        ScrollZoom.hotkey_scroll_up = nil
    end
    if ScrollZoom.hotkey_scroll_down then
        obs.obs_hotkey_unregister(ScrollZoom.hotkey_scroll_down)
        ScrollZoom.hotkey_scroll_down = nil
    end
end

-- Update scroll zoom config
local function update_scroll_config(settings)
    ScrollZoom.scroll_step = obs.obs_data_get_double(settings, "scroll_step")
    ScrollZoom.scroll_modifier = obs.obs_data_get_string(settings, "scroll_modifier") or "ctrl"
end

--================================================
-- PLACEHOLDER: Future Modules
--================================================

-- M01: Configuration & Settings (TODO)
-- M05: Scene Manager (TODO)
-- M06: Source Manager (TODO)
-- M07: Crop/Zoom Controller (TODO)
-- M08: Motion Tracker (TODO)
-- M09: Face Detection (TODO)
-- M11: Audio Reactor (TODO)
-- M12: Transition Manager (TODO)
-- M13: Animation Controller (TODO)
-- M14: Preset Manager (TODO)
-- M15: Hotkey Manager (TODO)
-- M16: UI Components (TODO)
-- M17: Timer/Scheduler (TODO)
-- M18: State Machine (TODO)
-- M19: Performance Monitor (TODO)

--================================================
-- SCRIPT SETTINGS
--================================================
local settings = {}

-- Default settings
local defaults = {
    debug_logging = false,
    easing_type = "QuadInOut",
    smooth_time = 0.3,
    max_speed = 100.0
}

--================================================
-- MODULE: Preset Manager (M13)
--================================================
-- Manages built-in and custom animation presets

local PresetManager = {
    -- Built-in presets (read-only)
    built_in = {
        {
            name = "Smooth",
            duration = 0.8,
            overshoot = 0.0,
            smoothness = 0.25,
            easing = "Cubic.Out",
        },
        {
            name = "Bounce",
            duration = 0.6,
            overshoot = 0.35,
            smoothness = 0.15,
            easing = "Back.Out",
        },
        {
            name = "Snappy",
            duration = 0.3,
            overshoot = 0.0,
            smoothness = 0.05,
            easing = "Expo.Out",
        },
        {
            name = "Cinematic",
            duration = 1.2,
            overshoot = 0.05,
            smoothness = 0.4,
            easing = "Sine.Out",
        },
    },

    -- Custom user presets
    custom = {},

    -- Currently selected preset name
    current_preset = "Smooth",
}

-- Get all preset names (built-in + custom)
function PresetManager:get_all_names()
    local names = {}

    -- Add built-in presets
    for _, preset in ipairs(self.built_in) do
        table.insert(names, preset.name)
    end

    -- Add custom presets
    for name, _ in pairs(self.custom) do
        table.insert(names, name)
    end

    table.sort(names)
    return names
end

-- Get preset by name
function PresetManager:get_preset(name)
    -- Check built-in first
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            return preset
        end
    end

    -- Check custom
    if self.custom[name] then
        return self.custom[name]
    end

    -- Default to Smooth
    return self.built_in[1]
end

-- Apply preset to configuration
function PresetManager:apply_preset(name)
    local preset = self:get_preset(name)
    if not preset then
        log("Preset: Unknown preset: " .. name)
        return false
    end

    cfg.zoom_duration = preset.duration
    cfg.zoom_overshoot = preset.overshoot
    cfg.follow_smooth_time = preset.smoothness

    if preset.easing then
        cfg.zoom_easing = preset.easing
    end

    self.current_preset = name
    log("Preset: Applied '" .. name .. "'")
    return true
end

-- Save a custom preset
function PresetManager:save_preset(name, duration, overshoot, smoothness, easing)
    if not name or name == "" then
        return false
    end

    -- Check if it's a built-in preset (can't override)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            log("Preset: Cannot override built-in preset: " .. name)
            return false
        end
    end

    -- Save custom preset
    self.custom[name] = {
        name = name,
        duration = duration or cfg.zoom_duration,
        overshoot = overshoot or cfg.zoom_overshoot,
        smoothness = smoothness or cfg.follow_smooth_time,
        easing = easing or cfg.zoom_easing,
    }

    log("Preset: Saved custom preset '" .. name .. "'")
    return true
end

-- Delete a custom preset
function PresetManager:delete_preset(name)
    -- Check if it's a built-in preset (can't delete)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            log("Preset: Cannot delete built-in preset: " .. name)
            return false
        end
    end

    -- Delete custom preset
    if self.custom[name] then
        self.custom[name] = nil
        log("Preset: Deleted custom preset '" .. name .. "'")
        return true
    end

    return false
end

-- Check if a preset is built-in
function PresetManager:is_built_in(name)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            return true
        end
    end
    return false
end

-- Persist custom presets to settings
function PresetManager:persist(settings)
    local array = obs.obs_data_array_create()

    for name, preset in pairs(self.custom) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "name", name)
        obs.obs_data_set_double(item, "duration", preset.duration)
        obs.obs_data_set_double(item, "overshoot", preset.overshoot)
        obs.obs_data_set_double(item, "smoothness", preset.smoothness)
        obs.obs_data_set_string(item, "easing", preset.easing)
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "custom_presets", array)
    obs.obs_data_array_release(array)
end

-- Load custom presets from settings
function PresetManager:load(settings)
    self.custom = {}

    local array = obs.obs_data_get_array(settings, "custom_presets")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local name = obs.obs_data_get_string(item, "name")

        if name and name ~= "" then
            self.custom[name] = {
                name = name,
                duration = obs.obs_data_get_double(item, "duration"),
                overshoot = obs.obs_data_get_double(item, "overshoot"),
                smoothness = obs.obs_data_get_double(item, "smoothness"),
                easing = obs.obs_data_get_string(item, "easing"),
            }
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)
    log("Preset: Loaded " .. self:get_custom_count() .. " custom presets")
end

-- Get count of custom presets
function PresetManager:get_custom_count()
    local count = 0
    for _, _ in pairs(self.custom) do
        count = count + 1
    end
    return count
end

-- Get current preset name
function PresetManager:get_current_name()
    return self.current_preset
end

-- Set current preset name
function PresetManager:set_current_name(name)
    self.current_preset = name
end

-- Check if current preset is custom
function PresetManager:is_current_custom()
    return not self:is_built_in(self.current_preset)
end

-- Global convenience functions
function preset_get_all_names()
    return PresetManager:get_all_names()
end

function preset_apply(name)
    return PresetManager:apply_preset(name)
end

function preset_save(name, duration, overshoot, smoothness, easing)
    return PresetManager:save_preset(name, duration, overshoot, smoothness, easing)
end

function preset_delete(name)
    return PresetManager:delete_preset(name)
end

function preset_is_built_in(name)
    return PresetManager:is_built_in(name)
end

function preset_get_current()
    return PresetManager:get_current_name()
end

--================================================
-- MODULE: Auto Source Detection (M11)
--================================================
-- Automatically detects and selects the best zoom source on first run

local AutoSourceDetector = {
    -- Source type priorities (higher = more likely to be the main display)
    type_priorities = {
        ["monitor_capture"] = 100,     -- Display capture (highest priority)
        ["game_capture"] = 80,          -- Game capture
        ["window_capture"] = 60,        -- Window capture
        ["xshm_input"] = 40,           -- Linux X11 capture
        ["av_capture_input"] = 20,     -- macOS capture
    },

    -- Whether auto-detection has been run
    auto_detected = false,
}

-- Get all capture sources sorted by priority
function AutoSourceDetector:get_capture_sources()
    local sources = {}
    local source_list = obs.obs_enum_sources()

    if not source_list then
        return sources
    end

    for _, source in ipairs(source_list) do
        local source_id = obs.obs_source_get_id(source)
        local name = obs.obs_source_get_name(source)

        -- Check if it's a capture source
        local priority = self.type_priorities[source_id]
        if priority then
            table.insert(sources, {
                name = name,
                id = source_id,
                priority = priority,
            })
        end
    end

    obs.source_list_release(source_list)

    -- Sort by priority (highest first)
    table.sort(sources, function(a, b)
        return a.priority > b.priority
    end)

    return sources
end

-- Auto-detect the best source
function AutoSourceDetector:auto_detect()
    local sources = self:get_capture_sources()

    if #sources == 0 then
        log("AutoSource: No capture sources found")
        return nil
    end

    if #sources == 1 then
        -- Only one source, use it
        log("AutoSource: Found single source: " .. sources[1].name)
        return sources[1].name
    end

    -- Multiple sources - prioritize by type
    -- Prefer monitor_capture > game_capture > window_capture
    local best = sources[1]

    log("AutoSource: Found " .. #sources .. " sources, selecting: " .. best.name)
    return best.name
end

-- Get monitor geometry from a source (if available)
function AutoSourceDetector:get_monitor_geometry(source_name)
    local source = obs.obs_get_source_by_name(source_name)
    if not source then
        return nil
    end

    local settings = obs.obs_source_get_settings(source)
    if not settings then
        obs.obs_source_release(source)
        return nil
    end

    -- Try to get monitor info from settings
    local monitor = obs.obs_data_get_int(settings, "monitor")
    local x = obs.obs_data_get_int(settings, "x")
    local y = obs.obs_data_get_int(settings, "y")
    local width = obs.obs_data_get_int(settings, "width")
    local height = obs.obs_data_get_int(settings, "height")

    obs.obs_data_release(settings)
    obs.obs_source_release(source)

    -- Return geometry if available
    if monitor >= 0 or width > 0 then
        return {
            monitor = monitor,
            x = x,
            y = y,
            width = width or 1920,
            height = height or 1080,
        }
    end

    return nil
end

-- Check if we should auto-detect on first run
function AutoSourceDetector:should_auto_detect(settings)
    -- Check if source has ever been set
    local last_source = obs.obs_data_get_string(settings, "source")
    if last_source and last_source ~= "" then
        return false
    end

    -- Check if auto-detect has been done
    return not self.auto_detected
end

-- Run auto-detection and return the source name
function AutoSourceDetector:run(settings)
    local source_name = self:auto_detect()

    if source_name then
        -- Save the detected source
        obs.obs_data_set_string(settings, "source", source_name)
        self.auto_detected = true
    end

    return source_name
end

-- Global convenience functions
function auto_source_detect()
    return AutoSourceDetector:auto_detect()
end

function auto_source_should_detect(settings)
    return AutoSourceDetector:should_auto_detect(settings)
end

function auto_source_run(settings)
    return AutoSourceDetector:run(settings)
end

--================================================
-- MODULE: Scene Memory (M12)
--================================================
-- Remembers which zoom source to use for each OBS scene

local SceneMemory = {
    -- Scene to source mapping
    scene_source_map = {},

    -- Maximum number of mappings to store
    max_mappings = 50,
}

-- Get the current scene name
function SceneMemory:get_current_scene_name()
    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then
        return nil
    end

    local name = obs.obs_source_get_name(scene_source)
    obs.obs_source_release(scene_source)
    return name
end

-- Get the source to use for the current scene
function SceneMemory:get_source_for_current_scene()
    local scene_name = self:get_current_scene_name()
    if not scene_name then
        return nil
    end

    -- 1. Check explicit mapping for this scene
    if self.scene_source_map[scene_name] then
        return self.scene_source_map[scene_name]
    end

    -- 2. Fall back to global source from config
    return cfg.source_name
end

-- Set the source for a specific scene
function SceneMemory:set(scene_name, source_name)
    if not scene_name or scene_name == "" then
        return false
    end

    -- Check if we're at capacity
    local count = 0
    for _, _ in pairs(self.scene_source_map) do
        count = count + 1
    end

    if count >= self.max_mappings and not self.scene_source_map[scene_name] then
        log("SceneMemory: At capacity (" .. self.max_mappings .. "), cannot add: " .. scene_name)
        return false
    end

    self.scene_source_map[scene_name] = source_name
    log("SceneMemory: " .. scene_name .. " Ã¢â€ â€™ " .. source_name)
    return true
end

-- Remove a scene mapping
function SceneMemory:remove(scene_name)
    if self.scene_source_map[scene_name] then
        self.scene_source_map[scene_name] = nil
        log("SceneMemory: Removed mapping for " .. scene_name)
        return true
    end
    return false
end

-- Get all scene mappings
function SceneMemory:get_all()
    local mappings = {}
    for scene, source in pairs(self.scene_source_map) do
        table.insert(mappings, { scene = scene, source = source })
    end
    table.sort(mappings, function(a, b)
        return a.scene < b.scene
    end)
    return mappings
end

-- Check if a scene has a mapping
function SceneMemory:has_mapping(scene_name)
    return self.scene_source_map[scene_name] ~= nil
end

-- Persist mappings to settings
function SceneMemory:persist(settings)
    local array = obs.obs_data_array_create()

    for scene, source in pairs(self.scene_source_map) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "scene", scene)
        obs.obs_data_set_string(item, "source", source)
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "scene_source_map", array)
    obs.obs_data_array_release(array)
end

-- Load mappings from settings
function SceneMemory:load(settings)
    self.scene_source_map = {}

    local array = obs.obs_data_get_array(settings, "scene_source_map")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local scene = obs.obs_data_get_string(item, "scene")
        local source = obs.obs_data_get_string(item, "source")

        if scene and scene ~= "" and source and source ~= "" then
            self.scene_source_map[scene] = source
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)

    local count = 0
    for _, _ in pairs(self.scene_source_map) do count = count + 1 end
    log("SceneMemory: Loaded " .. count .. " scene mappings")
end

-- Handle scene change
function SceneMemory:on_scene_change()
    local scene_name = self:get_current_scene_name()
    if not scene_name then
        return
    end

    -- Get the source for this scene
    local source_name = self:get_source_for_current_scene()

    if source_name and source_name ~= "" then
        -- Check if source changed
        local current = source_manager_is_valid() and cfg.source_name

        if source_name ~= current then
            log("SceneMemory: Scene changed to " .. scene_name)

            -- Release current source
            source_manager_release()

            -- Initialize with new source
            cfg.source_name = source_name
            source_manager_init(source_name)
        end
    end
end

-- Global convenience functions
function scene_memory_get_source()
    return SceneMemory:get_source_for_current_scene()
end

function scene_memory_set(scene_name, source_name)
    return SceneMemory:set(scene_name, source_name)
end

function scene_memory_remove(scene_name)
    return SceneMemory:remove(scene_name)
end

function scene_memory_get_all()
    return SceneMemory:get_all()
end

function scene_memory_on_scene_change()
    return SceneMemory:on_scene_change()
end

--================================================
-- MODULE: Blur Manager (M14)
--================================================
-- Provides built-in blur effects without external plugins
-- Supports multiple strategies: shader, composite_blur plugin, or none

local BlurManager = {
    -- Current strategy: "shader", "composite_blur", "none"
    strategy = "none",

    -- Filter references
    zoom_blur_filter = nil,
    motion_blur_filter = nil,

    -- Settings references
    zoom_blur_settings = nil,
    motion_blur_settings = nil,

    -- State
    initialized = false,

    -- Configuration
    zoom_blur_enabled = false,
    zoom_blur_intensity = 5,
    zoom_blur_clear_radius = 150,
    motion_blur_enabled = false,
    motion_blur_intensity = 1.0,
}

-- Try to use custom shader (if effect files exist)
function BlurManager:try_shader_strategy(source)
    -- This would require .effect files in assets/shaders/
    -- For now, we'll use a simpler approach
    log("Blur: Shader strategy not implemented (requires effect files)")
    return false
end

-- Try to auto-create Composite Blur filters
function BlurManager:try_composite_blur_strategy(source)
    if not source then return false end

    -- Check if composite_blur filter type exists
    local test_filter = obs.obs_source_create_private("composite_blur", "__test_blur__", nil)
    if test_filter then
        obs.obs_source_release(test_filter)
    else
        log("Blur: Composite Blur plugin not available")
        return false
    end

    -- Create Zoom Blur filter
    local zs = obs.obs_data_create()
    obs.obs_data_set_double(zs, "radius", 0)
    obs.obs_data_set_int(zs, "blur_type", 2) -- Zoom type
    self.zoom_blur_filter = obs.obs_source_create_private(
        "composite_blur",
        FILTER_PREFIX .. "Zoom Blur",
        zs
    )

    if self.zoom_blur_filter then
        obs.obs_source_filter_add(source, self.zoom_blur_filter)
        self.zoom_blur_settings = zs
    else
        obs.obs_data_release(zs)
        return false
    end

    -- Create Motion Blur filter
    local ms = obs.obs_data_create()
    obs.obs_data_set_double(ms, "radius", 0)
    obs.obs_data_set_int(ms, "blur_type", 3) -- Motion/directional type
    self.motion_blur_filter = obs.obs_source_create_private(
        "composite_blur",
        FILTER_PREFIX .. "Motion Blur",
        ms
    )

    if self.motion_blur_filter then
        obs.obs_source_filter_add(source, self.motion_blur_filter)
        self.motion_blur_settings = ms
    else
        obs.obs_data_release(ms)
    end

    self.initialized = true
    return true
end

-- Initialize blur manager
function BlurManager:init(source)
    if not source then
        return false
    end

    self:cleanup()

    -- Try composite_blur strategy
    if self:try_composite_blur_strategy(source) then
        self.strategy = "composite_blur"
        log("Blur: Using Composite Blur plugin (auto-configured)")
        return true
    end

    -- No blur available
    self.strategy = "none"
    log("Blur: No blur backend available. Blur effects disabled.")
    return false
end

-- Update blur based on zoom state
function BlurManager:update(state_machine, crop, camera_velocity)
    if not self.initialized then return end
    if self.strategy == "none" then return end

    -- Zoom Blur: Active during zoom transitions
    if self.zoom_blur_enabled and self.zoom_blur_filter then
        local radius = 0

        if state_machine:is_animating() and
           (state_machine.state == ZoomState.ZOOMING_IN or
            state_machine.state == ZoomState.ZOOMING_OUT) then
            -- Bell curve: 0 at start Ã¢â€ â€™ peak at 50% Ã¢â€ â€™ 0 at end
            local t = clamp(0, 1, state_machine.zoom_time)
            local curve = math.sin(t * math.pi)
            radius = curve * curve * self.zoom_blur_intensity
        end

        self:set_zoom_blur(radius, crop)
    end

    -- Motion Blur: Active during camera panning (not during zoom transition)
    if self.motion_blur_enabled and self.motion_blur_filter then
        if not state_machine:is_animating() and state_machine:is_zoomed() and camera_velocity then
            local speed = math.sqrt(
                camera_velocity.x * camera_velocity.x +
                camera_velocity.y * camera_velocity.y
            )

            if speed > 1.0 then
                local radius = math.min(10, speed * self.motion_blur_intensity * 0.5)
                local angle = math.deg(math.atan2(camera_velocity.y, camera_velocity.x))
                self:set_motion_blur(radius, angle)
            else
                self:set_motion_blur(0, 0)
            end
        else
            self:set_motion_blur(0, 0)
        end
    end
end

-- Set zoom blur parameters
function BlurManager:set_zoom_blur(radius, crop)
    if self.strategy == "composite_blur" and self.zoom_blur_settings then
        obs.obs_data_set_double(self.zoom_blur_settings, "radius", radius)

        if crop then
            local cx = crop.x + (crop.w / 2)
            local cy = crop.y + (crop.h / 2)
            obs.obs_data_set_double(self.zoom_blur_settings, "center_x", cx)
            obs.obs_data_set_double(self.zoom_blur_settings, "center_y", cy)
        end

        obs.obs_data_set_double(self.zoom_blur_settings, "inactive_radius", self.zoom_blur_clear_radius)
        obs.obs_source_update(self.zoom_blur_filter, self.zoom_blur_settings)
    end
end

-- Set motion blur parameters
function BlurManager:set_motion_blur(radius, angle)
    if self.strategy == "composite_blur" and self.motion_blur_settings then
        obs.obs_data_set_double(self.motion_blur_settings, "radius", radius)
        obs.obs_data_set_double(self.motion_blur_settings, "angle", angle)
        obs.obs_source_update(self.motion_blur_filter, self.motion_blur_settings)
    end
end

-- Update configuration
function BlurManager:update_config(settings)
    self.zoom_blur_enabled = obs.obs_data_get_bool(settings, "zoom_blur_enabled")
    self.zoom_blur_intensity = obs.obs_data_get_double(settings, "zoom_blur_intensity")
    self.zoom_blur_clear_radius = obs.obs_data_get_double(settings, "zoom_blur_clear_radius")
    self.motion_blur_enabled = obs.obs_data_get_bool(settings, "motion_blur_enabled")
    self.motion_blur_intensity = obs.obs_data_get_double(settings, "motion_blur_intensity")
end

-- Cleanup filters
function BlurManager:cleanup()
    local source = source_manager_get_source()

    if self.zoom_blur_filter and source then
        obs.obs_source_filter_remove(source, self.zoom_blur_filter)
        obs.obs_source_release(self.zoom_blur_filter)
        self.zoom_blur_filter = nil
    end

    if self.motion_blur_filter and source then
        obs.obs_source_filter_remove(source, self.motion_blur_filter)
        obs.obs_source_release(self.motion_blur_filter)
        self.motion_blur_filter = nil
    end

    if self.zoom_blur_settings then
        obs.obs_data_release(self.zoom_blur_settings)
        self.zoom_blur_settings = nil
    end

    if self.motion_blur_settings then
        obs.obs_data_release(self.motion_blur_settings)
        self.motion_blur_settings = nil
    end

    self.initialized = false
    self.strategy = "none"
end

-- Check if blur is available
function BlurManager:is_available()
    return self.strategy ~= "none"
end

-- Global convenience functions
function blur_manager_init(source)
    return BlurManager:init(source)
end

function blur_manager_update(state_machine, crop, camera_velocity)
    return BlurManager:update(state_machine, crop, camera_velocity)
end

function blur_manager_update_config(settings)
    return BlurManager:update_config(settings)
end

function blur_manager_cleanup()
    return BlurManager:cleanup()
end

function blur_manager_is_available()
    return BlurManager:is_available()
end

--================================================
-- MODULE: Cursor Asset Manager (M16)
--================================================
-- Handles extracting and managing cursor image assets

local CursorAssets = {
    extracted = false,
    dir = nil,
}

-- Get the platform-specific asset directory
function CursorAssets:get_platform_dir()
    if IS_WINDOWS then
        local appdata = os.getenv("APPDATA")
        return appdata and (appdata .. "\\obs-studio\\obs-zoom-pro\\cursors") or nil
    elseif IS_LINUX then
        local home = os.getenv("HOME")
        return home and (home .. "/.config/obs-studio/obs-zoom-pro/cursors") or nil
    elseif IS_MACOS then
        local home = os.getenv("HOME")
        return home and (home .. "/Library/Application Support/obs-studio/obs-zoom-pro/cursors") or nil
    end
    -- Fallback for non-FFI environments
    return "cursors"
end

-- Ensure assets are extracted
function CursorAssets:ensure_extracted()
    if self.extracted then
        return self.dir
    end

    local dir = self:get_platform_dir()
    if not dir then
        log("CursorAssets: Could not determine asset directory")
        return nil
    end

    -- Create directory
    local cmd
    if IS_WINDOWS then
        cmd = 'mkdir "' .. dir .. '" 2>nul'
    else
        cmd = 'mkdir -p "' .. dir .. '"'
    end
    os.execute(cmd)

    -- Check if assets exist
    local sep = IS_WINDOWS and "\\" or "/"
    local arrow_path = dir .. sep .. "arrow.png"

    local f = io.open(arrow_path, "rb")
    if f then
        f:close()
        self.dir = dir
        self.extracted = true
        log("CursorAssets: Using existing assets from " .. dir)
        return dir
    end

    -- Try to copy from script directory
    local script_dir = get_script_directory()
    local assets_src = script_dir .. "assets" .. sep .. "cursors" .. sep

    local files = { "arrow.png", "pointer.png", "ibeam.png" }
    for _, filename in ipairs(files) do
        local src_path = assets_src .. filename
        local dst_path = dir .. sep .. filename

        local src = io.open(src_path, "rb")
        if src then
            local data = src:read("*a")
            src:close()

            local dst = io.open(dst_path, "wb")
            if dst then
                dst:write(data)
                dst:close()
                log("CursorAssets: Copied " .. filename)
            end
        end
    end

    self.dir = dir
    self.extracted = true
    return dir
end

-- Get the asset directory
function CursorAssets:get_dir()
    return self.dir
end

-- Check if assets are available
function CursorAssets:is_available()
    if not self.extracted then
        self:ensure_extracted()
    end
    return self.dir ~= nil
end

-- Get cursor image path
function CursorAssets:get_cursor_path(cursor_type)
    if not self:is_available() then
        return nil
    end

    local sep = IS_WINDOWS and "\\" or "/"
    local filename = (cursor_type or "arrow") .. ".png"
    return self.dir .. sep .. filename
end

-- Global convenience functions
function cursor_assets_ensure_extracted()
    return CursorAssets:ensure_extracted()
end

function cursor_assets_get_dir()
    return CursorAssets:get_dir()
end

function cursor_assets_is_available()
    return CursorAssets:is_available()
end

function cursor_assets_get_cursor_path(cursor_type)
    return CursorAssets:get_cursor_path(cursor_type)
end

--================================================
-- MODULE: Cursor Renderer (M15)
--================================================
-- Provides automatic cursor overlay rendering

local CursorRenderer = {
    enabled = false,
    source = nil,
    sceneitem = nil,

    -- Smoothed state
    pos = { x = 0, y = 0 },
    current_scale = 1.0,
    current_rot = 0,
    swap_pulse = 1.0,

    -- Velocities (SmoothDamp)
    vel_x = { val = 0 },
    vel_y = { val = 0 },
    vel_scale = { val = 0 },
    vel_rot = { val = 0 },
    vel_swap = { val = 0 },

    -- State
    was_pointer = false,
    initialized = false,

    -- Configuration
    cursor_scale = 1.0,
    cursor_click_scale = 0.78,
    cursor_smooth_time = 0.1,
    cursor_offset_x = -6,
    cursor_offset_y = -2,
    cursor_rotation_mode = "None",
    cursor_angle_offset = 0,
    cursor_tilt_strength = 0,
}

-- Initialize cursor renderer
function CursorRenderer:init()
    if not cfg.cursor_enabled then
        self.enabled = false
        return false
    end

    -- Ensure cursor assets are available
    local asset_dir = cursor_assets_ensure_extracted()
    if not asset_dir then
        log("CursorRenderer: Failed to extract cursor assets")
        self.enabled = false
        return false
    end

    -- Get or create the cursor image source
    local source_name = FILTER_PREFIX .. "Cursor"
    self.source = obs.obs_get_source_by_name(source_name)

    if not self.source then
        -- Create new image source
        local settings = obs.obs_data_create()
        local cursor_path = cursor_assets_get_cursor_path("arrow")
        if cursor_path then
            obs.obs_data_set_string(settings, "file", cursor_path)
        end
        self.source = obs.obs_source_create("image_source", source_name, settings, nil)
        obs.obs_data_release(settings)

        if not self.source then
            log("CursorRenderer: Failed to create image source")
            self.enabled = false
            return false
        end
    end

    -- Add to current scene
    self:add_to_scene()

    -- Initialize position
    local mouse = platform_get_mouse_pos()
    self.pos.x = mouse.x
    self.pos.y = mouse.y

    self.enabled = true
    self.initialized = true
    log("CursorRenderer: Initialized")
    return true
end

-- Add cursor source to scene
function CursorRenderer:add_to_scene()
    if not self.source then return false end

    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then return false end

    local scene = obs.obs_scene_from_source(scene_source)
    if not scene then
        obs.obs_source_release(scene_source)
        return false
    end

    -- Check if already in scene
    local source_name = obs.obs_source_get_name(self.source)
    self.sceneitem = obs.obs_scene_find_source(scene, source_name)

    if not self.sceneitem then
        -- Add to scene
        self.sceneitem = obs.obs_scene_add(scene, self.source)
        if self.sceneitem then
            -- Move to top (render last = on top)
            obs.obs_sceneitem_set_order(self.sceneitem, obs.OBS_ORDER_MOVE_TOP)
        end
    end

    obs.obs_source_release(scene_source)
    return true
end

-- Update cursor position and state
function CursorRenderer:update(dt, raw_mouse, camera_crop)
    if not self.enabled or not self.sceneitem then return end

    -- Smooth cursor position
    self.pos.x = SmoothDamp(self.pos.x, raw_mouse.x, self.vel_x, self.cursor_smooth_time, 100000, dt)
    self.pos.y = SmoothDamp(self.pos.y, raw_mouse.y, self.vel_y, self.cursor_smooth_time, 100000, dt)

    -- Snap when very close
    if math.abs(self.pos.x - raw_mouse.x) < 0.5 then
        self.pos.x = raw_mouse.x
        self.vel_x.val = 0
    end
    if math.abs(self.pos.y - raw_mouse.y) < 0.5 then
        self.pos.y = raw_mouse.y
        self.vel_y.val = 0
    end

    -- Cursor shape detection (Windows only)
    local is_pointer = false
    if platform_cursor_shape_available() then
        is_pointer = platform_is_cursor_pointer()
    end

    -- Swap cursor image if needed
    if is_pointer ~= self.was_pointer then
        local asset_dir = cursor_assets_get_dir()
        local sep = IS_WINDOWS and "\\" or "/"
        local new_file = is_pointer and (asset_dir .. sep .. "pointer.png") or (asset_dir .. sep .. "arrow.png")

        local s = obs.obs_source_get_settings(self.source)
        if s then
            obs.obs_data_set_string(s, "file", new_file)
            obs.obs_source_update(self.source, s)
            obs.obs_data_release(s)
        end

        -- Trigger swap pulse
        self.swap_pulse = 0.75
        self.vel_swap.val = 1
        self.was_pointer = is_pointer
    end

    self.swap_pulse = SmoothDamp(self.swap_pulse, 1.0, self.vel_swap, 0.12, 100000, dt)

    -- Click animation
    local is_clicking = platform_is_clicking()
    local target_scale = is_clicking and (self.cursor_scale * self.cursor_click_scale) or self.cursor_scale
    self.current_scale = SmoothDamp(self.current_scale, target_scale, self.vel_scale, 0.1, 100000, dt)

    -- Calculate position relative to zoom
    local zoom_factor = 1.0
    local crop_x, crop_y = 0, 0

    if camera_crop and SM:is_zoomed() then
        zoom_factor = source_manager_get_size() / camera_crop.w
        crop_x = camera_crop.x
        crop_y = camera_crop.y
    end

    local final_x = (self.pos.x - crop_x) * zoom_factor + (self.cursor_offset_x * zoom_factor)
    local final_y = (self.pos.y - crop_y) * zoom_factor + (self.cursor_offset_y * zoom_factor)

    -- Apply to scene item
    local pos = obs.vec2()
    pos.x = final_x
    pos.y = final_y
    obs.obs_sceneitem_set_pos(self.sceneitem, pos)

    local scale = obs.vec2()
    local s = self.current_scale * zoom_factor * self.swap_pulse
    scale.x = s
    scale.y = s
    obs.obs_sceneitem_set_scale(self.sceneitem, scale)

    -- Rotation
    local dynamic_rot = self:compute_rotation(dt)
    obs.obs_sceneitem_set_rot(self.sceneitem, dynamic_rot)
end

-- Compute rotation based on mode
function CursorRenderer:compute_rotation(dt)
    local vx = self.vel_x.val
    local vy = self.vel_y.val
    local speed = math.sqrt(vx * vx + vy * vy)

    if self.cursor_rotation_mode == "Directional" then
        if speed > 20 then
            local angle = math.atan2(vy, vx) * (180 / math.pi)
            local target = angle + self.cursor_angle_offset
            local diff = (target - self.current_rot + 180) % 360 - 180
            self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.05, 100000, dt)
        end
        return self.current_rot

    elseif self.cursor_rotation_mode == "Lean" then
        local lean = clamp(-40, 40, vx * 0.05 * self.cursor_tilt_strength) + self.cursor_angle_offset
        local diff = (lean - self.current_rot + 180) % 360 - 180
        self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.08, 100000, dt)
        return self.current_rot
    end

    -- "None" mode
    local diff = (self.cursor_angle_offset - self.current_rot + 180) % 360 - 180
    self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.15, 100000, dt)
    return self.current_rot
end

-- Update configuration
function CursorRenderer:update_config(settings)
    self.cursor_scale = obs.obs_data_get_double(settings, "cursor_scale")
    self.cursor_click_scale = obs.obs_data_get_double(settings, "cursor_click_scale")
    self.cursor_smooth_time = obs.obs_data_get_double(settings, "cursor_smooth_time")
    self.cursor_offset_x = obs.obs_data_get_int(settings, "cursor_offset_x")
    self.cursor_offset_y = obs.obs_data_get_int(settings, "cursor_offset_y")
    self.cursor_rotation_mode = obs.obs_data_get_string(settings, "cursor_rotation_mode") or "None"
    self.cursor_angle_offset = obs.obs_data_get_double(settings, "cursor_angle_offset")
    self.cursor_tilt_strength = obs.obs_data_get_double(settings, "cursor_tilt_strength")
end

-- Cleanup
function CursorRenderer:cleanup()
    if self.sceneitem then
        obs.obs_sceneitem_remove(self.sceneitem)
        self.sceneitem = nil
    end

    if self.source then
        local source_name = obs.obs_source_get_name(self.source)
        obs.obs_source_release(self.source)

        -- Remove from OBS source list
        local s = obs.obs_get_source_by_name(source_name)
        if s then
            obs.obs_source_remove(s)
            obs.obs_source_release(s)
        end
        self.source = nil
    end

    self.enabled = false
    self.initialized = false
end

-- Check if active
function CursorRenderer:is_active()
    return self.enabled and self.initialized
end

-- Global convenience functions
function cursor_renderer_init()
    return CursorRenderer:init()
end

function cursor_renderer_update(dt, raw_mouse, camera_crop)
    return CursorRenderer:update(dt, raw_mouse, camera_crop)
end

function cursor_renderer_update_config(settings)
    return CursorRenderer:update_config(settings)
end

function cursor_renderer_cleanup()
    return CursorRenderer:cleanup()
end

function cursor_renderer_is_active()
    return CursorRenderer:is_active()
end

--================================================
-- MODULE: Bookmark Manager (M17)
--================================================
-- Manages saved zoom positions (bookmarks)

local BookmarkManager = {
    -- Saved bookmarks: { name = { zoom_level, x, y, w, h, source } }
    bookmarks = {},

    -- Maximum bookmarks
    max_bookmarks = 20,

    -- Hotkey IDs
    hotkeys = {},
}

-- Save current zoom position as a bookmark
function BookmarkManager:save(name)
    if not name or name == "" then
        return false
    end

    -- Check limit
    local count = 0
    for _, _ in pairs(self.bookmarks) do count = count + 1 end

    if count >= self.max_bookmarks and not self.bookmarks[name] then
        log("Bookmark: Max bookmarks reached (" .. self.max_bookmarks .. ")")
        return false
    end

    -- Get current crop
    local crop = crop_filter_get_crop()
    if not crop then
        return false
    end

    -- Save bookmark
    self.bookmarks[name] = {
        zoom_level = SM.zoom_level,
        x = crop.x,
        y = crop.y,
        w = crop.w,
        h = crop.h,
        source = cfg.source_name,
    }

    log("Bookmark: Saved '" .. name .. "' (zoom=" .. string.format("%.2f", SM.zoom_level) .. ")")
    return true
end

-- Recall a bookmark
function BookmarkManager:recall(name)
    local bm = self.bookmarks[name]
    if not bm then
        log("Bookmark: Not found: " .. name)
        return false
    end

    if not SM:can_jump() then
        return false
    end

    if not source_manager_is_valid() then
        return false
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        return false
    end

    -- Get current crop as start
    local start_crop = crop_filter_get_crop() or { x = 0, y = 0, w = source_w, h = source_h }

    -- Set target
    local target_crop = {
        x = bm.x,
        y = bm.y,
        w = bm.w,
        h = bm.h,
    }

    -- Transition to bookmark
    SM:transition(ZoomState.JUMPING, {
        start_crop = start_crop,
        target_crop = target_crop,
        target_level = bm.zoom_level
    })

    start_timer()
    log("Bookmark: Recall '" .. name .. "'")
    return true
end

-- Delete a bookmark
function BookmarkManager:delete(name)
    if self.bookmarks[name] then
        self.bookmarks[name] = nil
        log("Bookmark: Deleted '" .. name .. "'")
        return true
    end
    return false
end

-- Rename a bookmark
function BookmarkManager:rename(old_name, new_name)
    if not self.bookmarks[old_name] then
        return false
    end

    if self.bookmarks[new_name] then
        return false
    end

    self.bookmarks[new_name] = self.bookmarks[old_name]
    self.bookmarks[old_name] = nil
    log("Bookmark: Renamed '" .. old_name .. "' to '" .. new_name .. "'")
    return true
end

-- Get all bookmark names
function BookmarkManager:get_names()
    local names = {}
    for k, _ in pairs(self.bookmarks) do
        table.insert(names, k)
    end
    table.sort(names)
    return names
end

-- Get bookmark info
function BookmarkManager:get(name)
    return self.bookmarks[name]
end

-- Persist bookmarks to settings
function BookmarkManager:persist(settings)
    local array = obs.obs_data_array_create()

    for name, bm in pairs(self.bookmarks) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "name", name)
        obs.obs_data_set_double(item, "zoom_level", bm.zoom_level)
        obs.obs_data_set_double(item, "x", bm.x)
        obs.obs_data_set_double(item, "y", bm.y)
        obs.obs_data_set_double(item, "w", bm.w)
        obs.obs_data_set_double(item, "h", bm.h)
        obs.obs_data_set_string(item, "source", bm.source or "")
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "zoom_bookmarks", array)
    obs.obs_data_array_release(array)
end

-- Load bookmarks from settings
function BookmarkManager:load(settings)
    self.bookmarks = {}

    local array = obs.obs_data_get_array(settings, "zoom_bookmarks")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local name = obs.obs_data_get_string(item, "name")

        if name and name ~= "" then
            self.bookmarks[name] = {
                zoom_level = obs.obs_data_get_double(item, "zoom_level"),
                x = obs.obs_data_get_double(item, "x"),
                y = obs.obs_data_get_double(item, "y"),
                w = obs.obs_data_get_double(item, "w"),
                h = obs.obs_data_get_double(item, "h"),
                source = obs.obs_data_get_string(item, "source"),
            }
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)

    local count = 0
    for _, _ in pairs(self.bookmarks) do count = count + 1 end
    log("Bookmark: Loaded " .. count .. " bookmarks")
end

-- Register bookmark hotkeys
function BookmarkManager:register_hotkeys(settings)
    for i = 1, 5 do
        self.hotkeys[i] = obs.obs_hotkey_register_frontend(
            "obs_zoom_pro.bookmark_" .. i,
            "Zoom to Bookmark " .. i,
            function(pressed)
                if not pressed then return end
                local names = self:get_names()
                if names[i] then
                    self:recall(names[i])
                end
            end
        )

        -- Load saved bindings
        local key = "obs_zoom_pro.hotkey.bookmark_" .. i
        local save_array = obs.obs_data_get_array(settings, key)
        if save_array then
            obs.obs_hotkey_load(self.hotkeys[i], save_array)
            obs.obs_data_array_release(save_array)
        end
    end
end

-- Save bookmark hotkeys
function BookmarkManager:save_hotkeys(settings)
    for i = 1, 5 do
        if self.hotkeys[i] then
            local save_array = obs.obs_hotkey_save(self.hotkeys[i])
            obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.bookmark_" .. i, save_array)
            obs.obs_data_array_release(save_array)
        end
    end
end

-- Global convenience functions
function bookmark_save(name)
    return BookmarkManager:save(name)
end

function bookmark_recall(name)
    return BookmarkManager:recall(name)
end

function bookmark_delete(name)
    return BookmarkManager:delete(name)
end

function bookmark_get_names()
    return BookmarkManager:get_names()
end

function bookmark_get(name)
    return BookmarkManager:get(name)
end

--================================================
-- MODULE: UDP API Server (M18)
--================================================
-- Provides external control via UDP for Stream Deck integration

local APIServer = {
    enabled = false,
    port = 12345,
    socket = nil,
}

-- Command handlers
local API_COMMANDS = {
    ZOOM_IN = function(args)
        local level = tonumber(args[1]) or cfg.zoom_value
        on_scroll_zoom_to(level)
        return "OK"
    end,

    ZOOM_OUT = function(args)
        if SM:is_zoomed() then
            on_toggle_zoom(true)
        end
        return "OK"
    end,

    ZOOM_SET = function(args)
        local level = tonumber(args[1])
        if not level then return "ERROR: Missing level" end
        on_scroll_zoom_to(level)
        return "OK"
    end,

    ZOOM_TOGGLE = function(args)
        on_toggle_zoom(true)
        return "OK"
    end,

    FOLLOW_ON = function(args)
        if SM:is_zoomed() then SM.following = true end
        return "OK"
    end,

    FOLLOW_OFF = function(args)
        SM.following = false
        return "OK"
    end,

    FOLLOW_TOGGLE = function(args)
        if SM:is_zoomed() then SM.following = not SM.following end
        return "OK"
    end,

    PRESET = function(args)
        local name = args[1]
        if not name then return "ERROR: Missing preset name" end
        local ok = preset_apply(name)
        return ok and "OK" or "ERROR: Unknown preset"
    end,

    BOOKMARK = function(args)
        local name = args[1]
        if not name then return "ERROR: Missing bookmark name" end
        local ok = bookmark_recall(name)
        return ok and "OK" or "ERROR: Bookmark not found"
    end,

    STATUS = function(args)
        local crop = crop_filter_get_crop()
        return string.format(
            '{"version":"%s","zoom_level":%.2f,"state":"%s","following":%s,"position":{"x":%.0f,"y":%.0f},"preset":"%s"}',
            VERSION,
            SM.zoom_level,
            SM.state,
            tostring(SM.following),
            crop and crop.x or 0,
            crop and crop.y or 0,
            cfg.zoom_preset or ""
        )
    end,

    HELP = function(args)
        return "Commands: ZOOM_IN [level], ZOOM_OUT, ZOOM_SET level, ZOOM_TOGGLE, FOLLOW_ON, FOLLOW_OFF, FOLLOW_TOGGLE, PRESET name, BOOKMARK name, STATUS"
    end,
}

-- Start the API server
function APIServer:start(port)
    self:stop()

    self.port = port or self.port

    -- Try to use luasocket if available
    local socket_ok, socket = pcall(require, "socket")
    if not socket_ok then
        log("API: Socket library not available")
        return false
    end

    -- Try UDP
    local udp, err = socket.udp()
    if not udp then
        log("API: Failed to create UDP socket: " .. tostring(err))
        return false
    end

    -- Set socket options
    udp:setoption("reuseaddr", true)
    udp:settimeout(0)  -- Non-blocking

    -- Bind to port
    local bind_ok, err = udp:setsockname("*", self.port)
    if not bind_ok then
        log("API: Failed to bind to port " .. self.port .. ": " .. tostring(err))
        udp:close()
        return false
    end

    self.socket = udp
    self.enabled = true

    -- Start polling timer
    obs.timer_add(function() self:poll() end, 50)  -- 20Hz polling

    log("API: Listening on port " .. self.port)
    return true
end

-- Stop the API server
function APIServer:stop()
    if self.socket then
        self.socket:close()
        self.socket = nil
    end
    self.enabled = false
    log("API: Stopped")
end

-- Poll for incoming commands
function APIServer:poll()
    if not self.enabled or not self.socket then
        return
    end

    repeat
        local data, err = self.socket:receivefrom()
        if data then
            local response = self:handle_command(data)
            if response then
                -- Note: UDP response requires sender address
                log("API: " .. data:gsub("%s+", " ") .. " Ã¢â€ â€™ " .. response)
            end
        elseif err ~= "timeout" then
            log("API: Error: " .. tostring(err))
        end
    until not data
end

-- Handle a command
function APIServer:handle_command(raw)
    -- Parse command
    local parts = {}
    for word in raw:gmatch("%S+") do
        table.insert(parts, word)
    end

    if #parts == 0 then
        return "ERROR: Empty command"
    end

    local cmd = parts[1]:upper()
    local args = {}
    for i = 2, #parts do
        table.insert(args, parts[i])
    end

    -- Look up handler
    local handler = API_COMMANDS[cmd]
    if handler then
        local ok, result = pcall(handler, args)
        if ok then
            return result
        else
            return "ERROR: " .. tostring(result)
        end
    end

    return "ERROR: Unknown command: " .. cmd
end

-- Check if enabled
function APIServer:is_enabled()
    return self.enabled
end

-- Global convenience functions
function api_start(port)
    return APIServer:start(port)
end

function api_stop()
    return APIServer:stop()
end

function api_is_enabled()
    return APIServer:is_enabled()
end

--================================================
-- OBS SCRIPT REGISTRATION
--================================================

--[[ Called when the script is loaded
--[[ @param data table Script data
function script_load(data)
    log("Script loaded - OBS Zoom Pro v" .. VERSION)

    -- Load custom presets
    PresetManager:load(data)

    -- Load scene memory
    SceneMemory:load(data)

    -- Load bookmarks
    BookmarkManager:load(data)

    -- Register hotkeys
    register_hotkeys(data)

    -- Register bookmark hotkeys
    BookmarkManager:register_hotkeys(data)

    -- Register frontend event handler
    obs.obs_frontend_add_event_callback(on_frontend_event)

    -- Start API server if enabled
    local api_enabled = obs.obs_data_get_bool(data, "api_enabled")
    if api_enabled then
        local api_port = obs.obs_data_get_int(data, "api_port")
        APIServer:start(api_port)
    end
end

--[[ Called when the script is unloaded
function script_unload()
    log("Script unloaded - OBS Zoom Pro")

    -- Stop timer and cleanup
    stop_timer()
    unregister_hotkeys()
    source_manager_release()

    -- Stop API server
    APIServer:stop()

    -- Remove frontend event handler
    obs.obs_frontend_remove_event_callback(on_frontend_event)
end

--[[ Called when settings are updated
--[[ @param data table Settings data
function script_update(data)
    log("Settings updated")

    -- Update legacy settings
    debug_logs = obs.obs_data_get_bool(data, "debug_logging") or false
    settings.debug_logging = debug_logs
    settings.easing_type = obs.obs_data_get_string(data, "easing_type") or defaults.easing_type
    settings.smooth_time = obs.obs_data_get_double(data, "smooth_time") or defaults.smooth_time
    settings.max_speed = obs.obs_data_get_double(data, "max_speed") or defaults.max_speed

    -- Update M09 configuration
    update_config(data)

    -- Update API server settings
    local api_enabled = obs.obs_data_get_bool(data, "api_enabled")
    local api_port = obs.obs_data_get_int(data, "api_port")

    if api_enabled and not APIServer:is_enabled() then
        APIServer:start(api_port)
    elseif not api_enabled and APIServer:is_enabled() then
        APIServer:stop()
    elseif APIServer:is_enabled() and APIServer.port ~= api_port then
        APIServer:start(api_port)
    end
end

--[[ Called to save settings
--[[ @param data table Settings data to save
function script_save(data)
    log("Settings saved")

    -- Save custom presets
    PresetManager:persist(data)

    -- Save scene memory
    SceneMemory:persist(data)

    -- Save bookmarks
    BookmarkManager:persist(data)

    -- Save hotkey bindings
    save_hotkeys(data)

    -- Save bookmark hotkeys
    BookmarkManager:save_hotkeys(data)
end

--[[ Called to create the properties UI
--[[ @return obs.obs_properties_t Properties object
function script_properties()
    local props = obs.obs_properties_create()

    --==========================
    -- QUICK SETUP (always expanded)
    --==========================
    local grp_quick = obs.obs_properties_create()

    -- Source dropdown
    local src_list = obs.obs_properties_add_list(grp_quick, "source", "Zoom Source",
        obs.OBS_COMBO_TYPE_LIST, obs.OBS_COMBO_FORMAT_STRING)
    obs.obs_property_list_add_string(src_list, "-- Select Source --", "")

    -- Populate with available capture sources
    local sources = source_manager_get_available_sources()
    for _, src in ipairs(sources) do
        obs.obs_property_list_add_string(src_list, src.name, src.name)
    end

    -- Zoom Factor
    obs.obs_properties_add_float_slider(grp_quick, "zoom_value", "Zoom Factor", 1.0, 10.0, 0.1)

    -- Duration
    obs.obs_properties_add_float_slider(grp_quick, "zoom_duration", "Duration (s)", 0.05, 3.0, 0.05)

    obs.obs_properties_add_group(props, "quick_setup", "Ã¢Å¡Â¡ Quick Setup", obs.OBS_GROUP_NORMAL, grp_quick)

    --==========================
    -- ANIMATION (collapsed)
    --==========================
    local grp_anim = obs.obs_properties_create()

    -- Overshoot/Bounce
    obs.obs_properties_add_float_slider(grp_anim, "zoom_overshoot", "Bounce", 0.0, 1.0, 0.01)

    -- Easing Curve
    local p_easing = obs.obs_properties_add_list(grp_anim, "zoom_easing", "Easing Curve",
        obs.OBS_COMBO_TYPE_LIST, obs.OBS_COMBO_FORMAT_STRING)
    for _, name in ipairs(Easing.NAMES) do
        obs.obs_property_list_add_string(p_easing, name, name)
    end

    obs.obs_properties_add_group(props, "animation", "Ã°Å¸Å½Â¬ Animation", obs.OBS_GROUP_NORMAL, grp_anim)

    --==========================
    -- MOUSE FOLLOW (collapsed)
    --==========================
    local grp_follow = obs.obs_properties_create()

    obs.obs_properties_add_bool(grp_follow, "auto_follow", "Auto-Follow Mouse")
    obs.obs_properties_add_float_slider(grp_follow, "follow_smooth_time", "Smoothness", 0.01, 1.0, 0.01)
    obs.obs_properties_add_int_slider(grp_follow, "follow_dead_zone", "Dead Zone (px)", 0, 500, 1)

    obs.obs_properties_add_group(props, "follow", "Ã°Å¸Å½Â¯ Mouse Follow", obs.OBS_GROUP_NORMAL, grp_follow)

    --==========================
    -- ADVANCED (collapsed)
    --==========================
    local grp_adv = obs.obs_properties_create()
    obs.obs_properties_add_float_slider(grp_adv, "scroll_step", "Scroll Zoom Step", 0.1, 1.0, 0.05)
    obs.obs_properties_add_bool(grp_adv, "debug_logs", "Debug Logging")
    obs.obs_properties_add_group(props, "advanced", "Ã¢Å¡â„¢Ã¯Â¸Â Advanced", obs.OBS_GROUP_NORMAL, grp_adv)

    --==========================
    -- API SERVER (collapsed)
    --==========================
    local grp_api = obs.obs_properties_create()
    obs.obs_properties_add_bool(grp_api, "api_enabled", "Enable UDP API Server")
    obs.obs_properties_add_int(grp_api, "api_port", "API Port", 1024, 65535, 1)
    obs.obs_properties_add_group(props, "api_server", "Ã°Å¸Å’Â UDP API Server", obs.OBS_GROUP_NORMAL, grp_api)

    --==========================
    -- HELP (collapsed)
    --==========================
    local grp_help = obs.obs_properties_create()
    obs.obs_properties_add_text(grp_help, "help_text",
        "QUICK START:\n" ..
        "1. Select your capture source above\n" ..
        "2. Set hotkeys in OBS Settings Ã¢â€ â€™ Hotkeys\n" ..
        "   Ã¢â‚¬Â¢ 'Toggle Zoom to Mouse' Ã¢â‚¬â€ Main zoom\n" ..
        "   Ã¢â‚¬Â¢ 'Toggle Mouse Follow' Ã¢â‚¬â€ Enable/disable follow\n" ..
        "3. Press the hotkey to zoom!\n\n" ..
        "TIPS:\n" ..
        "Ã¢â‚¬Â¢ Zoom centers on mouse position\n" ..
        "Ã¢â‚¬Â¢ Enable Auto-Follow for smooth tracking\n" ..
        "Ã¢â‚¬Â¢ Adjust Dead Zone to reduce jitter",
        obs.OBS_TEXT_INFO)
    obs.obs_properties_add_group(props, "help", "Ã¢Ââ€œ Help", obs.OBS_GROUP_NORMAL, grp_help)

    return props
end

--[[ Called to set default values
--[[ @param data table Settings data
function script_defaults(data)
    obs.obs_data_set_default_string(data, "source", "")
    obs.obs_data_set_default_double(data, "zoom_value", 2.0)
    obs.obs_data_set_default_double(data, "zoom_duration", 0.6)
    obs.obs_data_set_default_double(data, "zoom_overshoot", 0.0)
    obs.obs_data_set_default_string(data, "zoom_easing", "Cubic.Out")
    obs.obs_data_set_default_bool(data, "auto_follow", true)
    obs.obs_data_set_default_double(data, "follow_smooth_time", 0.15)
    obs.obs_data_set_default_int(data, "follow_dead_zone", 5)
    obs.obs_data_set_default_double(data, "scroll_step", 0.25)
    obs.obs_data_set_default_bool(data, "debug_logs", false)
    obs.obs_data_set_default_bool(data, "api_enabled", false)
    obs.obs_data_set_default_int(data, "api_port", 12345)
end

--================================================
-- SCRIPT METADATA
--================================================
script_info = {
    name = "OBS Zoom Pro",
    version = VERSION,
    description = "Intelligent camera zoom functionality with smooth transitions and easing curves.",
    author = "OBS Zoom Pro Team"
}
)
        handle:close()
        if uname == 'Darwin' then
            is_macos = true
        elseif uname == 'Linux' then
            is_linux = true
        end
    end

    return {
        WINDOWS = is_windows,
        LINUX = is_linux,
        MACOS = is_macos
    }
end

local platform = detect_platform()
local IS_WINDOWS = platform.WINDOWS
local IS_LINUX = platform.LINUX
local IS_MACOS = platform.MACOS

-- Log platform detection
local os_name = IS_WINDOWS and 'Windows' or (IS_LINUX and 'Linux' or (IS_MACOS and 'macOS' or 'Unknown'))
log("Platform detected: " .. os_name .. (IS_WINDOWS and " (Full support)" or " (Basic support)"))

-- Virtual key codes
local VK_LBUTTON = 0x01
local VK_RBUTTON = 0x02
local VK_MBUTTON = 0x04
local VK_CONTROL = 0x11
local VK_SHIFT = 0x10
local VK_MENU = 0x12  -- Alt

-- Module state
local Platform = {
    cursor_shape_available = false,  -- Disabled (requires FFI)
    last_mouse = { x = 0, y = 0 },
    last_click = false,
}

-- Get mouse position (cross-platform using command line)
function Platform.get_mouse_pos()
    if IS_WINDOWS then
        -- Windows: Use PowerShell to get mouse position
        local success, result = pcall(function()
            local handle = io.popen('powershell -Command "[System.Windows.Forms.Cursor]::Position.X, [System.Windows.Forms.Cursor]::Position.Y" 2>NUL')
            if handle then
                local output = handle:read('*a'):match('(%d+),(%d+)')
                handle:close()
                if output then
                    local x, y = output:match('(%d+),(%d+)')
                    return { x = tonumber(x), y = tonumber(y) }
                end
            end
            return nil
        end)
        if success and result then
            return result
        end
    elseif IS_LINUX then
        -- Linux: Use xdotool if available, fallback to X11
        local success, result = pcall(function()
            local handle = io.popen("xdotool getmouselocation 2>/dev/null || echo 'x:0 y:0'")
            if handle then
                local output = handle:read("*a")
                handle:close()
                local x, y = output:match("x:(%d+)%s+y:(%d+)")
                if x and y then
                    return { x = tonumber(x), y = tonumber(y) }
                end
            end
            return nil
        end)
        if success and result then
            return result
        end
    elseif IS_MACOS then
        -- macOS: Use osascript
        local success, result = pcall(function()
            local handle = io.popen(--[[osascript -e 'tell application "System Events" to get position of the mouse' 2>/dev/null || echo "0, 0"]])
            if handle then
                local output = handle:read("*a")
                handle:close()
                local x, y = output:match("(%d+),%s*(%d+)")
                if x and y then
                    return { x = tonumber(x), y = tonumber(y) }
                end
            end
            return nil
        end)
        if success and result then
            return result
        end
    end

    -- Fallback
    return { x = 0, y = 0 }
end

-- Check if left mouse button is clicked (Windows only, others return false)
function Platform.is_clicking()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x01) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if a modifier key is held (Windows only)
function Platform.is_key_held(vk_code)
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(vk_code) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if cursor is a pointer/hand (Windows only)
function Platform.is_cursor_pointer()
    if IS_WINDOWS then
        local success, result = pcall(function()
            local ci = ffi.new("CURSORINFO")
            ci.cbSize = ffi.sizeof("CURSORINFO")
            if ffi.C.GetCursorInfo(ci) ~= 0 then
                -- Check if hCursor is a hand pointer
                -- This is a simplified check; real implementation would compare cursor handles
                return ci.flags ~= 0  -- Simplified; actual implementation needs cursor handle comparison
            end
            return false
        end)
        return success and result or false
    end
    return false
end

-- Get cursor shape (Windows only, returns "arrow" for others)
function Platform.get_cursor_shape()
    if IS_WINDOWS then
        local success, result = pcall(function()
            local ci = ffi.new("CURSORINFO")
            ci.cbSize = ffi.sizeof("CURSORINFO")
            if ffi.C.GetCursorInfo(ci) ~= 0 and ci.hCursor ~= nil then
                local addr = tonumber(ffi.cast("uintptr_t", ci.hCursor))
                -- Common cursor IDs (these are typical values, may vary)
                -- IDC_ARROW = 32512, IDC_IBEAM = 32513, IDC_HAND = 32649
                -- We use address ranges as heuristic
                return "arrow"  -- Simplified; actual implementation would map handles
            end
            return "arrow"
        end)
        return success and result or "arrow"
    end
    return "arrow"
end

-- Check if Control key is held
function Platform.is_ctrl_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x11) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if Shift key is held
function Platform.is_shift_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x10) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if Alt key is held
function Platform.is_alt_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x12) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Convenience wrapper functions
function platform_get_mouse_pos()
    return Platform.get_mouse_pos()
end

function platform_is_clicking()
    return Platform.is_clicking()
end

function platform_is_cursor_pointer()
    return Platform.is_cursor_pointer()
end

function platform_cursor_shape_available()
    return Platform.cursor_shape_available
end

function platform_is_ctrl_held()
    return Platform.is_ctrl_held()
end

function platform_is_shift_held()
    return Platform.is_shift_held()
end

function platform_is_alt_held()
    return Platform.is_alt_held()
end

--================================================
-- MODULE: State Machine (M05)
--================================================
-- Manages zoom states and transitions
-- States: IDLE, ZOOMING_IN, ZOOMED_IN, ZOOMING_OUT, SCROLLING, JUMPING

local ZoomState = {
    IDLE         = "idle",
    ZOOMING_IN   = "zooming_in",
    ZOOMED_IN    = "zoomed_in",
    ZOOMING_OUT  = "zooming_out",
    SCROLLING    = "scrolling",    -- Scroll wheel mid-transition
    JUMPING      = "jumping",      -- Bookmark transition
}

local StateMachine = {
    state = ZoomState.IDLE,
    zoom_time = 0,          -- Animation progress (0 Ã¢â€ â€™ 1)
    zoom_level = 1.0,       -- Current zoom factor
    target_level = 1.0,     -- Target zoom factor
    start_crop = nil,       -- Crop at animation start {x, y, w, h}
    target_crop = nil,      -- Crop at animation end {x, y, w, h}
    following = false,      -- Mouse follow active

    -- Transition guards
    can_zoom_in = function(self)
        return self.state == ZoomState.IDLE
    end,

    can_zoom_out = function(self)
        return self.state == ZoomState.ZOOMED_IN
            or self.state == ZoomState.SCROLLING
    end,

    can_scroll = function(self)
        return self.state == ZoomState.ZOOMED_IN
            or self.state == ZoomState.IDLE
            or self.state == ZoomState.SCROLLING
    end,

    can_jump = function(self)
        return self.state ~= ZoomState.ZOOMING_IN
           and self.state ~= ZoomState.ZOOMING_OUT
           and self.state ~= ZoomState.JUMPING
    end,

    is_animating = function(self)
        return self.state == ZoomState.ZOOMING_IN
            or self.state == ZoomState.ZOOMING_OUT
            or self.state == ZoomState.SCROLLING
            or self.state == ZoomState.JUMPING
    end,

    is_zoomed = function(self)
        return self.state ~= ZoomState.IDLE
    end,
}

-- Transition to a new state
function StateMachine:transition(new_state, params)
    local old = self.state
    self.state = new_state
    self.zoom_time = 0

    if params then
        if params.start_crop then self.start_crop = params.start_crop end
        if params.target_crop then self.target_crop = params.target_crop end
        if params.target_level then self.target_level = params.target_level end
    end

    log("State: " .. old .. " Ã¢â€ â€™ " .. new_state)
end

-- Complete the current animation
function StateMachine:complete()
    if self.state == ZoomState.ZOOMING_IN
       or self.state == ZoomState.SCROLLING
       or self.state == ZoomState.JUMPING then
        self.zoom_level = self.target_level
        self.state = ZoomState.ZOOMED_IN
        self.zoom_time = 0
        log("State: " .. self.state .. " Ã¢â€ â€™ ZOOMED_IN (complete)")
    elseif self.state == ZoomState.ZOOMING_OUT then
        self.zoom_level = 1.0
        self.target_level = 1.0
        self.start_crop = nil
        self.target_crop = nil
        self.following = false
        self.state = ZoomState.IDLE
        self.zoom_time = 0
        log("State: ZOOMING_OUT Ã¢â€ â€™ IDLE (complete)")
    end
end

-- Reset to initial state
function StateMachine:reset()
    self.state = ZoomState.IDLE
    self.zoom_time = 0
    self.zoom_level = 1.0
    self.target_level = 1.0
    self.start_crop = nil
    self.target_crop = nil
    self.following = false
    log("StateMachine: Reset to IDLE")
end

-- Get current animation progress (0-1)
function StateMachine:get_progress()
    return clamp(0, 1, self.zoom_time)
end

-- Check if in a specific state
function StateMachine:is_state(state)
    return self.state == state
end

-- Get state name for display
function StateMachine:get_state_name()
    return self.state
end

-- Create a new state machine instance (for testing/isolation)
function StateMachine:new()
    local sm = {}
    setmetatable(sm, { __index = self })
    sm.state = ZoomState.IDLE
    sm.zoom_time = 0
    sm.zoom_level = 1.0
    sm.target_level = 1.0
    sm.start_crop = nil
    sm.target_crop = nil
    sm.following = false
    return sm
end

-- Global state machine instance
local SM = StateMachine:new()

--================================================
-- MODULE: Crop Filter Manager (M07)
--================================================
-- Manages the crop/pad filter used to simulate zoom
-- Creates, updates, and destroys the filter automatically

local FILTER_PREFIX = "[ZoomPro] "
local CROP_FILTER_NAME = FILTER_PREFIX .. "Crop"

local CropFilterManager = {
    filter = nil,           -- The crop filter source
    source = nil,           -- The parent source
    original_crop = nil,    -- Original crop values for restoration
    current_crop = { x = 0, y = 0, w = 0, h = 0 },
    initialized = false,
}

-- Create the crop filter on a source
function CropFilterManager:create(source)
    if not source then
        log("CropFilter: No source provided")
        return false
    end

    self:cleanup()  -- Clean up any existing filter
    self.source = source

    -- Check if our filter already exists
    local existing = obs.obs_source_get_filter_by_name(source, CROP_FILTER_NAME)
    if existing then
        log("CropFilter: Found existing filter")
        self.filter = existing
        self.initialized = true
        return true
    end

    -- Create new crop/pad filter
    local settings = obs.obs_data_create()
    obs.obs_data_set_int(settings, "left", 0)
    obs.obs_data_set_int(settings, "top", 0)
    obs.obs_data_set_int(settings, "right", 0)
    obs.obs_data_set_int(settings, "bottom", 0)
    obs.obs_data_set_bool(settings, "relative", false)  -- Absolute positioning

    self.filter = obs.obs_source_create_private(
        "crop_filter",      -- Filter type
        CROP_FILTER_NAME,   -- Filter name
        settings            -- Settings
    )

    obs.obs_data_release(settings)

    if not self.filter then
        log("CropFilter: Failed to create filter")
        return false
    end

    -- Add filter to source
    obs.obs_source_filter_add(source, self.filter)

    -- Store original crop (none)
    self.original_crop = { x = 0, y = 0, w = 0, h = 0 }

    self.initialized = true
    log("CropFilter: Created successfully")
    return true
end

-- Update the crop filter with new values
function CropFilterManager:update(x, y, w, h)
    if not self.filter or not self.initialized then
        return false
    end

    -- Store current crop
    self.current_crop = { x = x, y = y, w = w, h = h }

    -- Get filter settings
    local settings = obs.obs_source_get_settings(self.filter)
    if not settings then
        return false
    end

    -- Calculate crop values
    -- For crop_filter: left, top are absolute position
    -- right, bottom are width/height from right/bottom edge
    -- We need to convert our x, y, w, h to this format

    -- Get source dimensions
    local source_w = obs.obs_source_get_width(self.source)
    local source_h = obs.obs_source_get_height(self.source)

    if source_w == 0 or source_h == 0 then
        obs.obs_data_release(settings)
        return false
    end

    -- Set crop values
    -- left = x offset from left
    -- top = y offset from top
    -- right = source_w - (x + w) = remaining width on right
    -- bottom = source_h - (y + h) = remaining height on bottom
    local left = math.floor(x)
    local top = math.floor(y)
    local right = math.floor(source_w - (x + w))
    local bottom = math.floor(source_h - (y + h))

    -- Clamp to valid values
    left = math.max(0, left)
    top = math.max(0, top)
    right = math.max(0, right)
    bottom = math.max(0, bottom)

    obs.obs_data_set_int(settings, "left", left)
    obs.obs_data_set_int(settings, "top", top)
    obs.obs_data_set_int(settings, "right", right)
    obs.obs_data_set_int(settings, "bottom", bottom)

    -- Update the filter
    obs.obs_source_update(self.filter, settings)
    obs.obs_data_release(settings)

    return true
end

-- Get current crop values
function CropFilterManager:get_crop()
    return self.current_crop
end

-- Reset crop to original (no crop)
function CropFilterManager:reset()
    if not self.filter or not self.initialized then
        return false
    end

    local settings = obs.obs_source_get_settings(self.filter)
    if settings then
        obs.obs_data_set_int(settings, "left", 0)
        obs.obs_data_set_int(settings, "top", 0)
        obs.obs_data_set_int(settings, "right", 0)
        obs.obs_data_set_int(settings, "bottom", 0)
        obs.obs_source_update(self.filter, settings)
        obs.obs_data_release(settings)
    end

    self.current_crop = { x = 0, y = 0, w = 0, h = 0 }
    return true
end

-- Remove the filter and restore original state
function CropFilterManager:cleanup()
    if self.filter and self.source then
        -- Reset to no crop first
        self:reset()

        -- Remove filter from source
        obs.obs_source_filter_remove(self.source, self.filter)
        obs.obs_source_release(self.filter)
        self.filter = nil
        log("CropFilter: Removed from source")
    end

    self.source = nil
    self.original_crop = nil
    self.current_crop = { x = 0, y = 0, w = 0, h = 0 }
    self.initialized = false
end

-- Check if filter is ready
function CropFilterManager:is_ready()
    return self.initialized and self.filter ~= nil
end

-- Get source dimensions
function CropFilterManager:get_source_size()
    if not self.source then
        return 0, 0
    end
    return obs.obs_source_get_width(self.source), obs.obs_source_get_height(self.source)
end

-- Convenience wrapper functions
function crop_filter_create(source)
    return CropFilterManager:create(source)
end

function crop_filter_update(x, y, w, h)
    return CropFilterManager:update(x, y, w, h)
end

function crop_filter_reset()
    return CropFilterManager:reset()
end

function crop_filter_cleanup()
    return CropFilterManager:cleanup()
end

function crop_filter_is_ready()
    return CropFilterManager:is_ready()
end

function crop_filter_get_crop()
    return CropFilterManager:get_crop()
end

function crop_filter_get_source_size()
    return CropFilterManager:get_source_size()
end

--================================================
-- MODULE: Source Manager (M08)
--================================================
-- Handles finding sources in scenes, capturing transforms,
-- and managing source state for zoom operations

local SourceManager = {
    source = nil,           -- Current zoom source
    sceneitem = nil,        -- Scene item reference
    scene = nil,            -- Current scene
    original_transform = nil, -- Saved original transform
    source_name = "",       -- Source name for settings
    initialized = false,
}

-- Transform data structure
local TransformData = {
    pos = { x = 0, y = 0 },
    scale = { x = 1.0, y = 1.0 },
    rot = 0,
    bounds_type = 0,
    bounds = { x = 0, y = 0 },
    crop = { left = 0, top = 0, right = 0, bottom = 0 },
}

-- Find a source in a scene (BFS through groups)
function SourceManager:find_sceneitem(scene, source_name)
    if not scene or not source_name then
        return nil
    end

    local scene_source = obs.obs_scene_from_source(scene)
    if not scene_source then
        return nil
    end

    -- BFS queue
    local queue = {}
    table.insert(queue, scene_source)

    while #queue > 0 do
        local current_scene = table.remove(queue, 1)

        -- Iterate through items
        local items = obs.obs_scene_enum_items(current_scene)
        if items then
            for _, item in ipairs(items) do
                local item_source = obs.obs_sceneitem_get_source(item)
                if item_source then
                    local name = obs.obs_source_get_name(item_source)

                    -- Check if this is our target
                    if name == source_name then
                        obs.sceneitem_list_release(items)
                        return item
                    end

                    -- Check if this is a group (nested scene)
                    if obs.obs_source_get_type(item_source) == obs.OBS_SOURCE_TYPE_INPUT then
                        local id = obs.obs_source_get_id(item_source)
                        if id == "group" then
                            local group_scene = obs.obs_group_from_source(item_source)
                            if group_scene then
                                table.insert(queue, group_scene)
                            end
                        end
                    end
                end
            end
            obs.sceneitem_list_release(items)
        end
    end

    return nil
end

-- Capture the current transform of a scene item
function SourceManager:capture_transform(sceneitem)
    if not sceneitem then
        return nil
    end

    local transform = {}

    -- Position
    local pos = obs.vec2()
    obs.obs_sceneitem_get_pos(sceneitem, pos)
    transform.pos = { x = pos.x, y = pos.y }

    -- Scale
    local scale = obs.vec2()
    obs.obs_sceneitem_get_scale(sceneitem, scale)
    transform.scale = { x = scale.x, y = scale.y }

    -- Rotation
    transform.rot = obs.obs_sceneitem_get_rot(sceneitem)

    -- Bounds
    transform.bounds_type = obs.obs_sceneitem_get_bounds_type(sceneitem)
    local bounds = obs.vec2()
    obs.obs_sceneitem_get_bounds(sceneitem, bounds)
    transform.bounds = { x = bounds.x, y = bounds.y }

    -- Crop
    local crop = obs.obs_sceneitem_crop()
    obs.obs_sceneitem_get_crop(sceneitem, crop)
    transform.crop = {
        left = crop.left,
        top = crop.top,
        right = crop.right,
        bottom = crop.bottom
    }

    return transform
end

-- Restore a saved transform to a scene item
function SourceManager:restore_transform(sceneitem, transform)
    if not sceneitem or not transform then
        return false
    end

    -- Position
    local pos = obs.vec2()
    pos.x = transform.pos.x
    pos.y = transform.pos.y
    obs.obs_sceneitem_set_pos(sceneitem, pos)

    -- Scale
    local scale = obs.vec2()
    scale.x = transform.scale.x
    scale.y = transform.scale.y
    obs.obs_sceneitem_set_scale(sceneitem, scale)

    -- Rotation
    obs.obs_sceneitem_set_rot(sceneitem, transform.rot)

    -- Bounds
    obs.obs_sceneitem_set_bounds_type(sceneitem, transform.bounds_type)
    local bounds = obs.vec2()
    bounds.x = transform.bounds.x
    bounds.y = transform.bounds.y
    obs.obs_sceneitem_set_bounds(sceneitem, bounds)

    -- Crop
    local crop = obs.obs_sceneitem_crop()
    crop.left = transform.crop.left
    crop.top = transform.crop.top
    crop.right = transform.crop.right
    crop.bottom = transform.crop.bottom
    obs.obs_sceneitem_set_crop(sceneitem, crop)

    return true
end

-- Initialize with a source name
function SourceManager:init(source_name)
    self:release()  -- Clean up any existing state

    if not source_name or source_name == "" then
        log("SourceManager: No source name provided")
        return false
    end

    self.source_name = source_name

    -- Get current scene
    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then
        log("SourceManager: No current scene")
        return false
    end

    self.scene = scene_source

    -- Find the scene item
    self.sceneitem = self:find_sceneitem(scene_source, source_name)
    if not self.sceneitem then
        log("SourceManager: Source not found in scene: " .. source_name)
        obs.obs_source_release(scene_source)
        return false
    end

    -- Get the source
    self.source = obs.obs_sceneitem_get_source(self.sceneitem)
    if not self.source then
        log("SourceManager: Failed to get source from sceneitem")
        obs.obs_source_release(scene_source)
        return false
    end

    -- Capture original transform
    self.original_transform = self:capture_transform(self.sceneitem)

    -- Create crop filter
    if not crop_filter_create(self.source) then
        log("SourceManager: Failed to create crop filter")
        obs.obs_source_release(scene_source)
        return false
    end

    self.initialized = true
    log("SourceManager: Initialized with source: " .. source_name)

    obs.obs_source_release(scene_source)
    return true
end

-- Release all resources
function SourceManager:release()
    -- Clean up crop filter
    crop_filter_cleanup()

    -- Restore original transform if we have it
    if self.sceneitem and self.original_transform then
        self:restore_transform(self.sceneitem, self.original_transform)
        log("SourceManager: Restored original transform")
    end

    self.source = nil
    self.sceneitem = nil
    self.scene = nil
    self.original_transform = nil
    self.initialized = false

    log("SourceManager: Released")
end

-- Get source dimensions
function SourceManager:get_source_size()
    if not self.source then
        return 0, 0
    end
    return obs.obs_source_get_width(self.source), obs.obs_source_get_height(self.source)
end

-- Check if source is valid
function SourceManager:is_valid()
    return self.initialized and self.source ~= nil and self.sceneitem ~= nil
end

-- Get source info
function SourceManager:get_info()
    if not self:is_valid() then
        return nil
    end

    return {
        name = self.source_name,
        width = obs.obs_source_get_width(self.source),
        height = obs.obs_source_get_height(self.source),
    }
end

-- Get list of available capture sources
function SourceManager.get_available_sources()
    local sources = {}

    -- Get all sources
    local source_list = obs.obs_enum_sources()
    if source_list then
        for _, source in ipairs(source_list) do
            local source_id = obs.obs_source_get_id(source)
            local name = obs.obs_source_get_name(source)

            -- Filter for capture sources
            local is_capture = false
            if source_id == "monitor_capture" or      -- Display capture
               source_id == "window_capture" or       -- Window capture
               source_id == "game_capture" or         -- Game capture
               source_id == "xshm_input" or           -- Linux X11 capture
               source_id == "av_capture_input" then   -- macOS capture
                is_capture = true
            end

            if is_capture then
                table.insert(sources, {
                    name = name,
                    id = source_id,
                })
            end
        end
        obs.source_list_release(source_list)
    end

    return sources
end

-- Convenience wrapper functions
function source_manager_init(source_name)
    return SourceManager:init(source_name)
end

function source_manager_release()
    return SourceManager:release()
end

function source_manager_is_valid()
    return SourceManager:is_valid()
end

function source_manager_get_source()
    return SourceManager.source
end

function source_manager_get_sceneitem()
    return SourceManager.sceneitem
end

function source_manager_get_size()
    return SourceManager:get_source_size()
end

function source_manager_get_available_sources()
    return SourceManager.get_available_sources()
end

--================================================
-- MODULE: Camera Physics (M06)
--================================================
-- Handles camera position calculations, dead zones,
-- and SmoothDamp-based camera movement

local CameraPhysics = {
    -- Smoothed camera position
    pos = { x = 0, y = 0 },

    -- Velocities for SmoothDamp
    vel_x = { val = 0 },
    vel_y = { val = 0 },

    -- Dead zone state
    tracked_pos = { x = 0, y = 0 },
    dead_zone_active = false,

    -- Last camera position (for velocity calculation)
    last_pos = { x = 0, y = 0 },

    -- Monitor offset (for multi-monitor setups)
    monitor_offset = { x = 0, y = 0 },
}

-- Initialize camera tracking with starting position
function CameraPhysics:init(mouse_pos)
    if mouse_pos then
        self.pos.x = mouse_pos.x
        self.pos.y = mouse_pos.y
        self.tracked_pos.x = mouse_pos.x
        self.tracked_pos.y = mouse_pos.y
    end
    self.vel_x.val = 0
    self.vel_y.val = 0
    self.last_pos.x = self.pos.x
    self.last_pos.y = self.pos.y
end

-- Apply dead zone to mouse input
-- Returns the position the camera should track
function CameraPhysics:apply_dead_zone(mouse_pos, dead_zone_radius)
    if not mouse_pos then
        return self.tracked_pos
    end

    if dead_zone_radius <= 0 then
        self.tracked_pos.x = mouse_pos.x
        self.tracked_pos.y = mouse_pos.y
        return self.tracked_pos
    end

    -- Calculate distance from tracked position to mouse
    local dx = mouse_pos.x - self.tracked_pos.x
    local dy = mouse_pos.y - self.tracked_pos.y
    local dist = math.sqrt(dx * dx + dy * dy)

    if dist <= dead_zone_radius then
        -- Mouse is within dead zone, don't move tracked position
        self.dead_zone_active = true
        return self.tracked_pos
    end

    -- Mouse is outside dead zone
    -- Move tracked position so it stays exactly dead_zone_radius from mouse
    self.dead_zone_active = false
    local excess = dist - dead_zone_radius
    local nx = dx / dist  -- Normalized direction
    local ny = dy / dist

    self.tracked_pos.x = self.tracked_pos.x + nx * excess
    self.tracked_pos.y = self.tracked_pos.y + ny * excess

    return self.tracked_pos
end

-- Smooth the input position using SmoothDamp
function CameraPhysics:smooth_input(target_pos, smooth_time, dt)
    if not target_pos then
        return self.pos
    end

    local max_speed = 100000  -- Very high max speed for smooth camera

    self.pos.x = SmoothDamp(self.pos.x, target_pos.x, self.vel_x, smooth_time, max_speed, dt)
    self.pos.y = SmoothDamp(self.pos.y, target_pos.y, self.vel_y, smooth_time, max_speed, dt)

    return self.pos
end

-- Calculate the crop rectangle for a given zoom level and center position
function CameraPhysics:compute_crop(center_x, center_y, zoom_level, source_w, source_h)
    if zoom_level <= 1.0 then
        -- No zoom, return full source
        return {
            x = 0,
            y = 0,
            w = source_w,
            h = source_h,
        }
    end

    -- Calculate crop dimensions
    local crop_w = source_w / zoom_level
    local crop_h = source_h / zoom_level

    -- Center the crop on the target position
    local crop_x = center_x - crop_w / 2
    local crop_y = center_y - crop_h / 2

    -- Clamp to source bounds
    crop_x = clamp(0, source_w - crop_w, crop_x)
    crop_y = clamp(0, source_h - crop_h, crop_y)

    return {
        x = crop_x,
        y = crop_y,
        w = crop_w,
        h = crop_h,
    }
end

-- Calculate target crop for zoom animation
-- mouse_pos: current mouse position
-- zoom_level: target zoom level
-- source_w, source_h: source dimensions
-- monitor_offset: offset for multi-monitor (optional)
function CameraPhysics:get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
    if not mouse_pos then
        return nil
    end

    -- Apply monitor offset if provided
    local target_x = mouse_pos.x
    local target_y = mouse_pos.y

    if monitor_offset then
        target_x = target_x - monitor_offset.x
        target_y = target_y - monitor_offset.y
    end

    -- Clamp to source bounds
    target_x = clamp(0, source_w, target_x)
    target_y = clamp(0, source_h, target_y)

    return self:compute_crop(target_x, target_y, zoom_level, source_w, source_h)
end

-- Interpolate between two crop rectangles
function CameraPhysics:lerp_crop(start_crop, end_crop, t, easing_fn)
    if not start_crop or not end_crop then
        return nil
    end

    t = clamp(0, 1, t)

    -- Apply easing
    local eased_t = easing_fn and easing_fn(t) or t

    return {
        x = lerp(start_crop.x, end_crop.x, eased_t),
        y = lerp(start_crop.y, end_crop.y, eased_t),
        w = lerp(start_crop.w, end_crop.w, eased_t),
        h = lerp(start_crop.h, end_crop.h, eased_t),
    }
end

-- Get camera velocity (for motion blur)
function CameraPhysics:get_velocity()
    return {
        x = self.pos.x - self.last_pos.x,
        y = self.pos.y - self.last_pos.y,
    }
end

-- Update last position (call at end of frame)
function CameraPhysics:update_last_pos()
    self.last_pos.x = self.pos.x
    self.last_pos.y = self.pos.y
end

-- Set monitor offset
function CameraPhysics:set_monitor_offset(offset)
    self.monitor_offset = offset or { x = 0, y = 0 }
end

-- Reset camera state
function CameraPhysics:reset()
    self.pos = { x = 0, y = 0 }
    self.vel_x = { val = 0 }
    self.vel_y = { val = 0 }
    self.tracked_pos = { x = 0, y = 0 }
    self.dead_zone_active = false
    self.last_pos = { x = 0, y = 0 }
end

-- Convenience wrapper functions
function camera_physics_init(mouse_pos)
    return CameraPhysics:init(mouse_pos)
end

function camera_physics_apply_dead_zone(mouse_pos, dead_zone_radius)
    return CameraPhysics:apply_dead_zone(mouse_pos, dead_zone_radius)
end

function camera_physics_smooth_input(target_pos, smooth_time, dt)
    return CameraPhysics:smooth_input(target_pos, smooth_time, dt)
end

function camera_physics_compute_crop(center_x, center_y, zoom_level, source_w, source_h)
    return CameraPhysics:compute_crop(center_x, center_y, zoom_level, source_w, source_h)
end

function camera_physics_get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
    return CameraPhysics:get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
end

function camera_physics_lerp_crop(start_crop, end_crop, t, easing_fn)
    return CameraPhysics:lerp_crop(start_crop, end_crop, t, easing_fn)
end

function camera_physics_get_velocity()
    return CameraPhysics:get_velocity()
end

function camera_physics_update_last_pos()
    return CameraPhysics:update_last_pos()
end

function camera_physics_reset()
    return CameraPhysics:reset()
end

--================================================
-- MODULE: Timer & Main Loop (M09)
--================================================
-- Core integration module that handles frame-by-frame updates,
-- input processing, state machine updates, and output

-- Configuration (will be populated from settings)
local cfg = {
    source_name = "",
    zoom_value = 2.0,
    max_zoom = 10.0,
    zoom_duration = 0.6,
    zoom_overshoot = 0.0,
    zoom_easing = "Cubic.Out",

    auto_follow = true,
    follow_smooth_time = 0.15,
    follow_dead_zone = 5,

    debug_logs = false,
}

-- Timing
local last_tick_time = 0
local timer_running = false

-- Frame diff tracking (skip updates if nothing changed)
local last_output = { x = -1, y = -1, w = -1, h = -1 }

-- Original crop for zoom out
local original_crop = { x = 0, y = 0, w = 0, h = 0 }

-- Hotkey IDs
local hotkey_toggle_zoom = nil
local hotkey_toggle_follow = nil

-- Get reliable delta time
local function get_dt()
    local now = os.clock()
    local dt = now - last_tick_time
    last_tick_time = now
    return clamp(0.001, 0.1, dt)  -- Guard against freezes and div/zero
end

-- Start the timer
local function start_timer()
    if not timer_running then
        timer_running = true
        last_tick_time = os.clock()
        -- Use frame-synced interval
        local interval = 16  -- Default to ~60fps
        obs.timer_add(on_timer, interval)
        log("Timer: Started")
    end
end

-- Stop the timer
local function stop_timer()
    if timer_running then
        timer_running = false
        obs.timer_remove(on_timer)
        log("Timer: Stopped")
    end
end

-- Initialize mouse tracking
local function init_mouse_tracking(mouse_pos)
    camera_physics_init(mouse_pos)
    original_crop = {
        x = 0,
        y = 0,
        w = 0,
        h = 0,
    }
end

-- Main timer callback
function on_timer()
    local dt = get_dt()

    -- Guard: No valid source
    if not source_manager_is_valid() then
        return
    end

    --==========================
    -- 1. INPUT
    --==========================
    local raw_mouse = platform_get_mouse_pos()

    --==========================
    -- 2. STATE MACHINE UPDATE
    --==========================
    if SM:is_animating() then
        SM.zoom_time = SM.zoom_time + (dt / cfg.zoom_duration)

        -- Check for completion
        if SM.zoom_time >= 1.0 then
            SM:complete()

            -- Auto-enable follow after zoom in
            if SM.state == ZoomState.ZOOMED_IN and cfg.auto_follow then
                SM.following = true
            end

            -- Stop timer if idle
            if SM.state == ZoomState.IDLE then
                stop_timer()
            end
        end
    end

    --==========================
    -- 3. CAMERA POSITION
    --==========================
    local crop = nil
    local source_w, source_h = source_manager_get_size()

    if source_w == 0 or source_h == 0 then
        return
    end

    if SM:is_animating() then
        -- Animate between start and target crop
        local easing_fn = Easing.get(cfg.zoom_easing, cfg.zoom_overshoot)
        crop = camera_physics_lerp_crop(SM.start_crop, SM.target_crop, SM.zoom_time, easing_fn)
    elseif SM:is_zoomed() and SM.following then
        -- Follow mouse with dead zone and smoothing
        local tracked = camera_physics_apply_dead_zone(raw_mouse, cfg.follow_dead_zone)
        local smoothed = camera_physics_smooth_input(tracked, cfg.follow_smooth_time, dt)
        crop = camera_physics_compute_crop(smoothed.x, smoothed.y, SM.zoom_level, source_w, source_h)
        camera_physics_update_last_pos()
    elseif SM:is_zoomed() then
        -- Static zoom (not following)
        crop = camera_physics_get_target_crop(
            { x = SM.target_crop.x + SM.target_crop.w / 2, y = SM.target_crop.y + SM.target_crop.h / 2 },
            SM.zoom_level, source_w, source_h, nil
        )
    end

    --==========================
    -- 4. OUTPUT (Diff-based)
    --==========================
    if crop then
        local cx = math.floor(crop.x)
        local cy = math.floor(crop.y)
        local cw = math.floor(crop.w)
        local ch = math.floor(crop.h)

        if cx ~= last_output.x or cy ~= last_output.y or
           cw ~= last_output.w or ch ~= last_output.h then
            crop_filter_update(cx, cy, cw, ch)
            last_output.x = cx
            last_output.y = cy
            last_output.w = cw
            last_output.h = ch
        end
    end
end

--==========================
-- HOTKEY HANDLERS
--==========================

function on_toggle_zoom(pressed)
    if not pressed then return end

    if not source_manager_is_valid() then
        log("Toggle Zoom: No valid source")
        return
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        log("Toggle Zoom: Invalid source dimensions")
        return
    end

    if SM.state == ZoomState.IDLE then
        -- ZOOM IN
        local mouse = platform_get_mouse_pos()
        init_mouse_tracking(mouse)

        -- Store original crop
        original_crop = { x = 0, y = 0, w = source_w, h = source_h }

        -- Calculate target crop
        local target_crop = camera_physics_get_target_crop(mouse, cfg.zoom_value, source_w, source_h, nil)

        SM:transition(ZoomState.ZOOMING_IN, {
            start_crop = original_crop,
            target_crop = target_crop,
            target_level = cfg.zoom_value
        })

        start_timer()

    elseif SM.state == ZoomState.ZOOMED_IN then
        -- ZOOM OUT
        SM.following = false

        local current = crop_filter_get_crop()
        SM:transition(ZoomState.ZOOMING_OUT, {
            start_crop = current,
            target_crop = original_crop,
            target_level = 1.0
        })

        start_timer()
    end
    -- Ignore if already animating (guard against rapid presses)
end

function on_toggle_follow(pressed)
    if not pressed then return end
    if not SM:is_zoomed() then return end

    SM.following = not SM.following
    log("Follow: " .. tostring(SM.following))

    if SM.following and not timer_running then
        start_timer()
    end
end

--==========================
-- HOTKEY REGISTRATION
--==========================

local function register_hotkeys(settings)
    -- Toggle Zoom hotkey
    hotkey_toggle_zoom = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.toggle_zoom",
        "Toggle Zoom to Mouse",
        on_toggle_zoom
    )

    -- Toggle Follow hotkey
    hotkey_toggle_follow = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.toggle_follow",
        "Toggle Mouse Follow",
        on_toggle_follow
    )

    -- Load saved hotkey bindings
    local toggle_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.toggle_zoom")
    if toggle_array then
        obs.obs_hotkey_load(hotkey_toggle_zoom, toggle_array)
        obs.obs_data_array_release(toggle_array)
    end

    local follow_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.toggle_follow")
    if follow_array then
        obs.obs_hotkey_load(hotkey_toggle_follow, follow_array)
        obs.obs_data_array_release(follow_array)
    end

    -- Register scroll zoom hotkeys
    register_scroll_hotkeys(settings)

    log("Hotkeys: Registered")
end

local function save_hotkeys(settings)
    if hotkey_toggle_zoom then
        local array = obs.obs_hotkey_save(hotkey_toggle_zoom)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.toggle_zoom", array)
        obs.obs_data_array_release(array)
    end

    if hotkey_toggle_follow then
        local array = obs.obs_hotkey_save(hotkey_toggle_follow)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.toggle_follow", array)
        obs.obs_data_array_release(array)
    end

    -- Save scroll zoom hotkeys
    save_scroll_hotkeys(settings)
end

local function unregister_hotkeys()
    if hotkey_toggle_zoom then
        obs.obs_hotkey_unregister(hotkey_toggle_zoom)
        hotkey_toggle_zoom = nil
    end
    if hotkey_toggle_follow then
        obs.obs_hotkey_unregister(hotkey_toggle_follow)
        hotkey_toggle_follow = nil
    end
    -- Unregister scroll zoom hotkeys
    unregister_scroll_hotkeys()
    log("Hotkeys: Unregistered")
end

--==========================
-- SCENE EVENT HANDLERS
--==========================

function on_frontend_event(event)
    if event == obs.OBS_FRONTEND_EVENT_SCENE_CHANGED then
        -- Scene changed, re-acquire source
        log("Event: Scene changed")

        -- Handle scene memory
        scene_memory_on_scene_change()

        if cfg.source_name and cfg.source_name ~= "" then
            source_manager_release()
            source_manager_init(cfg.source_name)
        end
    elseif event == obs.OBS_FRONTEND_EVENT_EXIT then
        -- OBS is closing
        log("Event: OBS exiting")
        stop_timer()
        source_manager_release()
    end
end

--==========================
-- CONFIGURATION UPDATE
--==========================

local function update_config(settings)
    cfg.source_name = obs.obs_data_get_string(settings, "source") or ""
    cfg.zoom_value = obs.obs_data_get_double(settings, "zoom_value")
    cfg.zoom_duration = obs.obs_data_get_double(settings, "zoom_duration")
    cfg.zoom_overshoot = obs.obs_data_get_double(settings, "zoom_overshoot")
    cfg.zoom_easing = obs.obs_data_get_string(settings, "zoom_easing") or "Cubic.Out"

    cfg.auto_follow = obs.obs_data_get_bool(settings, "auto_follow")
    cfg.follow_smooth_time = obs.obs_data_get_double(settings, "follow_smooth_time")
    cfg.follow_dead_zone = obs.obs_data_get_int(settings, "follow_dead_zone")

    cfg.debug_logs = obs.obs_data_get_bool(settings, "debug_logs")
    debug_logs = cfg.debug_logs

    -- Update scroll zoom config
    update_scroll_config(settings)

    -- Check if source changed
    local current_source = source_manager_is_valid() and cfg.source_name
    if cfg.source_name ~= "" and cfg.source_name ~= current_source then
        -- Reset state and reinitialize
        SM:reset()
        stop_timer()
        source_manager_release()
        source_manager_init(cfg.source_name)
    end
end

--================================================
-- MODULE: Scroll Zoom (M10)
--================================================
-- Enables gradual zoom control via scroll wheel with modifier key
-- Provides dynamic zoom level adjustment during zoomed state

local ScrollZoom = {
    -- Hotkey IDs for scroll zoom
    hotkey_scroll_up = nil,
    hotkey_scroll_down = nil,

    -- Configuration (populated from settings)
    scroll_step = 0.25,
    scroll_modifier = "ctrl",  -- "ctrl", "alt", "shift"
}

-- Check if modifier key is held
local function is_modifier_held()
    if ScrollZoom.scroll_modifier == "ctrl" then
        return platform_is_ctrl_held()
    elseif ScrollZoom.scroll_modifier == "alt" then
        return platform_is_alt_held()
    elseif ScrollZoom.scroll_modifier == "shift" then
        return platform_is_shift_held()
    end
    return false
end

-- Handle scroll zoom in
function on_scroll_zoom_up(pressed)
    if not pressed then return end
    on_scroll_zoom(1)
end

-- Handle scroll zoom out
function on_scroll_zoom_down(pressed)
    if not pressed then return end
    on_scroll_zoom(-1)
end

-- Main scroll zoom handler
function on_scroll_zoom(direction)
    -- Check if we can scroll
    if not SM:can_scroll() then return end

    -- Check modifier (optional - can be configured)
    -- For now, we rely on OBS hotkey bindings which can include modifiers

    if not source_manager_is_valid() then
        log("Scroll Zoom: No valid source")
        return
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        return
    end

    -- Calculate new zoom level
    local step = ScrollZoom.scroll_step * direction  -- e.g., 0.25
    local new_level

    if SM.state == ZoomState.IDLE then
        -- Starting from unzoomed
        new_level = 1.0 + step
    else
        -- Already zoomed, adjust level
        new_level = SM.target_level + step
    end

    -- Clamp to valid range
    new_level = clamp(1.0, cfg.max_zoom, new_level)

    -- If we hit 1.0, fully zoom out
    if new_level <= 1.0 then
        if SM:is_zoomed() then
            -- Trigger full zoom out
            local current = crop_filter_get_crop()
            SM.following = false
            SM:transition(ZoomState.ZOOMING_OUT, {
                start_crop = current,
                target_crop = original_crop,
                target_level = 1.0
            })
            start_timer()
        end
        return
    end

    -- Get current mouse position
    local mouse = platform_get_mouse_pos()

    -- Calculate new target crop for new zoom level
    local target_crop = camera_physics_get_target_crop(mouse, new_level, source_w, source_h, nil)

    -- Get current crop as start
    local start_crop
    if SM:is_animating() then
        -- Use current interpolated crop
        start_crop = crop_filter_get_crop()
    elseif SM:is_zoomed() then
        -- Use current crop
        start_crop = crop_filter_get_crop()
    else
        -- Starting from unzoomed
        start_crop = { x = 0, y = 0, w = source_w, h = source_h }
        original_crop = start_crop
        camera_physics_init(mouse)
    end

    -- Transition to new zoom level
    if SM.state == ZoomState.IDLE then
        -- First scroll from unzoomed
        SM:transition(ZoomState.SCROLLING, {
            start_crop = start_crop,
            target_crop = target_crop,
            target_level = new_level
        })
    else
        -- Already zoomed, adjust level (interrupt current animation)
        SM:transition(ZoomState.SCROLLING, {
            start_crop = start_crop,
            target_crop = target_crop,
            target_level = new_level
        })
    end

    start_timer()
    log("Scroll Zoom: Level " .. string.format("%.2f", new_level))
end

-- Zoom to a specific level (for API calls)
function on_scroll_zoom_to(level)
    if not source_manager_is_valid() then return end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then return end

    level = clamp(1.0, cfg.max_zoom, level)

    if level <= 1.0 then
        -- Zoom out
        if SM:is_zoomed() then
            local current = crop_filter_get_crop()
            SM.following = false
            SM:transition(ZoomState.ZOOMING_OUT, {
                start_crop = current,
                target_crop = original_crop,
                target_level = 1.0
            })
            start_timer()
        end
        return
    end

    local mouse = platform_get_mouse_pos()
    local target_crop = camera_physics_get_target_crop(mouse, level, source_w, source_h, nil)

    local start_crop
    if SM:is_zoomed() then
        start_crop = crop_filter_get_crop()
    else
        start_crop = { x = 0, y = 0, w = source_w, h = source_h }
        original_crop = start_crop
        camera_physics_init(mouse)
    end

    SM:transition(ZoomState.SCROLLING, {
        start_crop = start_crop,
        target_crop = target_crop,
        target_level = level
    })

    start_timer()
end

-- Register scroll zoom hotkeys
local function register_scroll_hotkeys(settings)
    -- Scroll Up hotkey
    ScrollZoom.hotkey_scroll_up = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.scroll_up",
        "Zoom In (Scroll)",
        on_scroll_zoom_up
    )

    -- Scroll Down hotkey
    ScrollZoom.hotkey_scroll_down = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.scroll_down",
        "Zoom Out (Scroll)",
        on_scroll_zoom_down
    )

    -- Load saved bindings
    local up_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.scroll_up")
    if up_array then
        obs.obs_hotkey_load(ScrollZoom.hotkey_scroll_up, up_array)
        obs.obs_data_array_release(up_array)
    end

    local down_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.scroll_down")
    if down_array then
        obs.obs_hotkey_load(ScrollZoom.hotkey_scroll_down, down_array)
        obs.obs_data_array_release(down_array)
    end

    log("Scroll Zoom: Hotkeys registered")
end

-- Save scroll hotkey bindings
local function save_scroll_hotkeys(settings)
    if ScrollZoom.hotkey_scroll_up then
        local array = obs.obs_hotkey_save(ScrollZoom.hotkey_scroll_up)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.scroll_up", array)
        obs.obs_data_array_release(array)
    end

    if ScrollZoom.hotkey_scroll_down then
        local array = obs.obs_hotkey_save(ScrollZoom.hotkey_scroll_down)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.scroll_down", array)
        obs.obs_data_array_release(array)
    end
end

-- Unregister scroll hotkeys
local function unregister_scroll_hotkeys()
    if ScrollZoom.hotkey_scroll_up then
        obs.obs_hotkey_unregister(ScrollZoom.hotkey_scroll_up)
        ScrollZoom.hotkey_scroll_up = nil
    end
    if ScrollZoom.hotkey_scroll_down then
        obs.obs_hotkey_unregister(ScrollZoom.hotkey_scroll_down)
        ScrollZoom.hotkey_scroll_down = nil
    end
end

-- Update scroll zoom config
local function update_scroll_config(settings)
    ScrollZoom.scroll_step = obs.obs_data_get_double(settings, "scroll_step")
    ScrollZoom.scroll_modifier = obs.obs_data_get_string(settings, "scroll_modifier") or "ctrl"
end

--================================================
-- PLACEHOLDER: Future Modules
--================================================

-- M01: Configuration & Settings (TODO)
-- M05: Scene Manager (TODO)
-- M06: Source Manager (TODO)
-- M07: Crop/Zoom Controller (TODO)
-- M08: Motion Tracker (TODO)
-- M09: Face Detection (TODO)
-- M11: Audio Reactor (TODO)
-- M12: Transition Manager (TODO)
-- M13: Animation Controller (TODO)
-- M14: Preset Manager (TODO)
-- M15: Hotkey Manager (TODO)
-- M16: UI Components (TODO)
-- M17: Timer/Scheduler (TODO)
-- M18: State Machine (TODO)
-- M19: Performance Monitor (TODO)

--================================================
-- SCRIPT SETTINGS
--================================================
local settings = {}

-- Default settings
local defaults = {
    debug_logging = false,
    easing_type = "QuadInOut",
    smooth_time = 0.3,
    max_speed = 100.0
}

--================================================
-- MODULE: Preset Manager (M13)
--================================================
-- Manages built-in and custom animation presets

local PresetManager = {
    -- Built-in presets (read-only)
    built_in = {
        {
            name = "Smooth",
            duration = 0.8,
            overshoot = 0.0,
            smoothness = 0.25,
            easing = "Cubic.Out",
        },
        {
            name = "Bounce",
            duration = 0.6,
            overshoot = 0.35,
            smoothness = 0.15,
            easing = "Back.Out",
        },
        {
            name = "Snappy",
            duration = 0.3,
            overshoot = 0.0,
            smoothness = 0.05,
            easing = "Expo.Out",
        },
        {
            name = "Cinematic",
            duration = 1.2,
            overshoot = 0.05,
            smoothness = 0.4,
            easing = "Sine.Out",
        },
    },

    -- Custom user presets
    custom = {},

    -- Currently selected preset name
    current_preset = "Smooth",
}

-- Get all preset names (built-in + custom)
function PresetManager:get_all_names()
    local names = {}

    -- Add built-in presets
    for _, preset in ipairs(self.built_in) do
        table.insert(names, preset.name)
    end

    -- Add custom presets
    for name, _ in pairs(self.custom) do
        table.insert(names, name)
    end

    table.sort(names)
    return names
end

-- Get preset by name
function PresetManager:get_preset(name)
    -- Check built-in first
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            return preset
        end
    end

    -- Check custom
    if self.custom[name] then
        return self.custom[name]
    end

    -- Default to Smooth
    return self.built_in[1]
end

-- Apply preset to configuration
function PresetManager:apply_preset(name)
    local preset = self:get_preset(name)
    if not preset then
        log("Preset: Unknown preset: " .. name)
        return false
    end

    cfg.zoom_duration = preset.duration
    cfg.zoom_overshoot = preset.overshoot
    cfg.follow_smooth_time = preset.smoothness

    if preset.easing then
        cfg.zoom_easing = preset.easing
    end

    self.current_preset = name
    log("Preset: Applied '" .. name .. "'")
    return true
end

-- Save a custom preset
function PresetManager:save_preset(name, duration, overshoot, smoothness, easing)
    if not name or name == "" then
        return false
    end

    -- Check if it's a built-in preset (can't override)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            log("Preset: Cannot override built-in preset: " .. name)
            return false
        end
    end

    -- Save custom preset
    self.custom[name] = {
        name = name,
        duration = duration or cfg.zoom_duration,
        overshoot = overshoot or cfg.zoom_overshoot,
        smoothness = smoothness or cfg.follow_smooth_time,
        easing = easing or cfg.zoom_easing,
    }

    log("Preset: Saved custom preset '" .. name .. "'")
    return true
end

-- Delete a custom preset
function PresetManager:delete_preset(name)
    -- Check if it's a built-in preset (can't delete)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            log("Preset: Cannot delete built-in preset: " .. name)
            return false
        end
    end

    -- Delete custom preset
    if self.custom[name] then
        self.custom[name] = nil
        log("Preset: Deleted custom preset '" .. name .. "'")
        return true
    end

    return false
end

-- Check if a preset is built-in
function PresetManager:is_built_in(name)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            return true
        end
    end
    return false
end

-- Persist custom presets to settings
function PresetManager:persist(settings)
    local array = obs.obs_data_array_create()

    for name, preset in pairs(self.custom) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "name", name)
        obs.obs_data_set_double(item, "duration", preset.duration)
        obs.obs_data_set_double(item, "overshoot", preset.overshoot)
        obs.obs_data_set_double(item, "smoothness", preset.smoothness)
        obs.obs_data_set_string(item, "easing", preset.easing)
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "custom_presets", array)
    obs.obs_data_array_release(array)
end

-- Load custom presets from settings
function PresetManager:load(settings)
    self.custom = {}

    local array = obs.obs_data_get_array(settings, "custom_presets")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local name = obs.obs_data_get_string(item, "name")

        if name and name ~= "" then
            self.custom[name] = {
                name = name,
                duration = obs.obs_data_get_double(item, "duration"),
                overshoot = obs.obs_data_get_double(item, "overshoot"),
                smoothness = obs.obs_data_get_double(item, "smoothness"),
                easing = obs.obs_data_get_string(item, "easing"),
            }
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)
    log("Preset: Loaded " .. self:get_custom_count() .. " custom presets")
end

-- Get count of custom presets
function PresetManager:get_custom_count()
    local count = 0
    for _, _ in pairs(self.custom) do
        count = count + 1
    end
    return count
end

-- Get current preset name
function PresetManager:get_current_name()
    return self.current_preset
end

-- Set current preset name
function PresetManager:set_current_name(name)
    self.current_preset = name
end

-- Check if current preset is custom
function PresetManager:is_current_custom()
    return not self:is_built_in(self.current_preset)
end

-- Global convenience functions
function preset_get_all_names()
    return PresetManager:get_all_names()
end

function preset_apply(name)
    return PresetManager:apply_preset(name)
end

function preset_save(name, duration, overshoot, smoothness, easing)
    return PresetManager:save_preset(name, duration, overshoot, smoothness, easing)
end

function preset_delete(name)
    return PresetManager:delete_preset(name)
end

function preset_is_built_in(name)
    return PresetManager:is_built_in(name)
end

function preset_get_current()
    return PresetManager:get_current_name()
end

--================================================
-- MODULE: Auto Source Detection (M11)
--================================================
-- Automatically detects and selects the best zoom source on first run

local AutoSourceDetector = {
    -- Source type priorities (higher = more likely to be the main display)
    type_priorities = {
        ["monitor_capture"] = 100,     -- Display capture (highest priority)
        ["game_capture"] = 80,          -- Game capture
        ["window_capture"] = 60,        -- Window capture
        ["xshm_input"] = 40,           -- Linux X11 capture
        ["av_capture_input"] = 20,     -- macOS capture
    },

    -- Whether auto-detection has been run
    auto_detected = false,
}

-- Get all capture sources sorted by priority
function AutoSourceDetector:get_capture_sources()
    local sources = {}
    local source_list = obs.obs_enum_sources()

    if not source_list then
        return sources
    end

    for _, source in ipairs(source_list) do
        local source_id = obs.obs_source_get_id(source)
        local name = obs.obs_source_get_name(source)

        -- Check if it's a capture source
        local priority = self.type_priorities[source_id]
        if priority then
            table.insert(sources, {
                name = name,
                id = source_id,
                priority = priority,
            })
        end
    end

    obs.source_list_release(source_list)

    -- Sort by priority (highest first)
    table.sort(sources, function(a, b)
        return a.priority > b.priority
    end)

    return sources
end

-- Auto-detect the best source
function AutoSourceDetector:auto_detect()
    local sources = self:get_capture_sources()

    if #sources == 0 then
        log("AutoSource: No capture sources found")
        return nil
    end

    if #sources == 1 then
        -- Only one source, use it
        log("AutoSource: Found single source: " .. sources[1].name)
        return sources[1].name
    end

    -- Multiple sources - prioritize by type
    -- Prefer monitor_capture > game_capture > window_capture
    local best = sources[1]

    log("AutoSource: Found " .. #sources .. " sources, selecting: " .. best.name)
    return best.name
end

-- Get monitor geometry from a source (if available)
function AutoSourceDetector:get_monitor_geometry(source_name)
    local source = obs.obs_get_source_by_name(source_name)
    if not source then
        return nil
    end

    local settings = obs.obs_source_get_settings(source)
    if not settings then
        obs.obs_source_release(source)
        return nil
    end

    -- Try to get monitor info from settings
    local monitor = obs.obs_data_get_int(settings, "monitor")
    local x = obs.obs_data_get_int(settings, "x")
    local y = obs.obs_data_get_int(settings, "y")
    local width = obs.obs_data_get_int(settings, "width")
    local height = obs.obs_data_get_int(settings, "height")

    obs.obs_data_release(settings)
    obs.obs_source_release(source)

    -- Return geometry if available
    if monitor >= 0 or width > 0 then
        return {
            monitor = monitor,
            x = x,
            y = y,
            width = width or 1920,
            height = height or 1080,
        }
    end

    return nil
end

-- Check if we should auto-detect on first run
function AutoSourceDetector:should_auto_detect(settings)
    -- Check if source has ever been set
    local last_source = obs.obs_data_get_string(settings, "source")
    if last_source and last_source ~= "" then
        return false
    end

    -- Check if auto-detect has been done
    return not self.auto_detected
end

-- Run auto-detection and return the source name
function AutoSourceDetector:run(settings)
    local source_name = self:auto_detect()

    if source_name then
        -- Save the detected source
        obs.obs_data_set_string(settings, "source", source_name)
        self.auto_detected = true
    end

    return source_name
end

-- Global convenience functions
function auto_source_detect()
    return AutoSourceDetector:auto_detect()
end

function auto_source_should_detect(settings)
    return AutoSourceDetector:should_auto_detect(settings)
end

function auto_source_run(settings)
    return AutoSourceDetector:run(settings)
end

--================================================
-- MODULE: Scene Memory (M12)
--================================================
-- Remembers which zoom source to use for each OBS scene

local SceneMemory = {
    -- Scene to source mapping
    scene_source_map = {},

    -- Maximum number of mappings to store
    max_mappings = 50,
}

-- Get the current scene name
function SceneMemory:get_current_scene_name()
    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then
        return nil
    end

    local name = obs.obs_source_get_name(scene_source)
    obs.obs_source_release(scene_source)
    return name
end

-- Get the source to use for the current scene
function SceneMemory:get_source_for_current_scene()
    local scene_name = self:get_current_scene_name()
    if not scene_name then
        return nil
    end

    -- 1. Check explicit mapping for this scene
    if self.scene_source_map[scene_name] then
        return self.scene_source_map[scene_name]
    end

    -- 2. Fall back to global source from config
    return cfg.source_name
end

-- Set the source for a specific scene
function SceneMemory:set(scene_name, source_name)
    if not scene_name or scene_name == "" then
        return false
    end

    -- Check if we're at capacity
    local count = 0
    for _, _ in pairs(self.scene_source_map) do
        count = count + 1
    end

    if count >= self.max_mappings and not self.scene_source_map[scene_name] then
        log("SceneMemory: At capacity (" .. self.max_mappings .. "), cannot add: " .. scene_name)
        return false
    end

    self.scene_source_map[scene_name] = source_name
    log("SceneMemory: " .. scene_name .. " Ã¢â€ â€™ " .. source_name)
    return true
end

-- Remove a scene mapping
function SceneMemory:remove(scene_name)
    if self.scene_source_map[scene_name] then
        self.scene_source_map[scene_name] = nil
        log("SceneMemory: Removed mapping for " .. scene_name)
        return true
    end
    return false
end

-- Get all scene mappings
function SceneMemory:get_all()
    local mappings = {}
    for scene, source in pairs(self.scene_source_map) do
        table.insert(mappings, { scene = scene, source = source })
    end
    table.sort(mappings, function(a, b)
        return a.scene < b.scene
    end)
    return mappings
end

-- Check if a scene has a mapping
function SceneMemory:has_mapping(scene_name)
    return self.scene_source_map[scene_name] ~= nil
end

-- Persist mappings to settings
function SceneMemory:persist(settings)
    local array = obs.obs_data_array_create()

    for scene, source in pairs(self.scene_source_map) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "scene", scene)
        obs.obs_data_set_string(item, "source", source)
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "scene_source_map", array)
    obs.obs_data_array_release(array)
end

-- Load mappings from settings
function SceneMemory:load(settings)
    self.scene_source_map = {}

    local array = obs.obs_data_get_array(settings, "scene_source_map")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local scene = obs.obs_data_get_string(item, "scene")
        local source = obs.obs_data_get_string(item, "source")

        if scene and scene ~= "" and source and source ~= "" then
            self.scene_source_map[scene] = source
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)

    local count = 0
    for _, _ in pairs(self.scene_source_map) do count = count + 1 end
    log("SceneMemory: Loaded " .. count .. " scene mappings")
end

-- Handle scene change
function SceneMemory:on_scene_change()
    local scene_name = self:get_current_scene_name()
    if not scene_name then
        return
    end

    -- Get the source for this scene
    local source_name = self:get_source_for_current_scene()

    if source_name and source_name ~= "" then
        -- Check if source changed
        local current = source_manager_is_valid() and cfg.source_name

        if source_name ~= current then
            log("SceneMemory: Scene changed to " .. scene_name)

            -- Release current source
            source_manager_release()

            -- Initialize with new source
            cfg.source_name = source_name
            source_manager_init(source_name)
        end
    end
end

-- Global convenience functions
function scene_memory_get_source()
    return SceneMemory:get_source_for_current_scene()
end

function scene_memory_set(scene_name, source_name)
    return SceneMemory:set(scene_name, source_name)
end

function scene_memory_remove(scene_name)
    return SceneMemory:remove(scene_name)
end

function scene_memory_get_all()
    return SceneMemory:get_all()
end

function scene_memory_on_scene_change()
    return SceneMemory:on_scene_change()
end

--================================================
-- MODULE: Blur Manager (M14)
--================================================
-- Provides built-in blur effects without external plugins
-- Supports multiple strategies: shader, composite_blur plugin, or none

local BlurManager = {
    -- Current strategy: "shader", "composite_blur", "none"
    strategy = "none",

    -- Filter references
    zoom_blur_filter = nil,
    motion_blur_filter = nil,

    -- Settings references
    zoom_blur_settings = nil,
    motion_blur_settings = nil,

    -- State
    initialized = false,

    -- Configuration
    zoom_blur_enabled = false,
    zoom_blur_intensity = 5,
    zoom_blur_clear_radius = 150,
    motion_blur_enabled = false,
    motion_blur_intensity = 1.0,
}

-- Try to use custom shader (if effect files exist)
function BlurManager:try_shader_strategy(source)
    -- This would require .effect files in assets/shaders/
    -- For now, we'll use a simpler approach
    log("Blur: Shader strategy not implemented (requires effect files)")
    return false
end

-- Try to auto-create Composite Blur filters
function BlurManager:try_composite_blur_strategy(source)
    if not source then return false end

    -- Check if composite_blur filter type exists
    local test_filter = obs.obs_source_create_private("composite_blur", "__test_blur__", nil)
    if test_filter then
        obs.obs_source_release(test_filter)
    else
        log("Blur: Composite Blur plugin not available")
        return false
    end

    -- Create Zoom Blur filter
    local zs = obs.obs_data_create()
    obs.obs_data_set_double(zs, "radius", 0)
    obs.obs_data_set_int(zs, "blur_type", 2) -- Zoom type
    self.zoom_blur_filter = obs.obs_source_create_private(
        "composite_blur",
        FILTER_PREFIX .. "Zoom Blur",
        zs
    )

    if self.zoom_blur_filter then
        obs.obs_source_filter_add(source, self.zoom_blur_filter)
        self.zoom_blur_settings = zs
    else
        obs.obs_data_release(zs)
        return false
    end

    -- Create Motion Blur filter
    local ms = obs.obs_data_create()
    obs.obs_data_set_double(ms, "radius", 0)
    obs.obs_data_set_int(ms, "blur_type", 3) -- Motion/directional type
    self.motion_blur_filter = obs.obs_source_create_private(
        "composite_blur",
        FILTER_PREFIX .. "Motion Blur",
        ms
    )

    if self.motion_blur_filter then
        obs.obs_source_filter_add(source, self.motion_blur_filter)
        self.motion_blur_settings = ms
    else
        obs.obs_data_release(ms)
    end

    self.initialized = true
    return true
end

-- Initialize blur manager
function BlurManager:init(source)
    if not source then
        return false
    end

    self:cleanup()

    -- Try composite_blur strategy
    if self:try_composite_blur_strategy(source) then
        self.strategy = "composite_blur"
        log("Blur: Using Composite Blur plugin (auto-configured)")
        return true
    end

    -- No blur available
    self.strategy = "none"
    log("Blur: No blur backend available. Blur effects disabled.")
    return false
end

-- Update blur based on zoom state
function BlurManager:update(state_machine, crop, camera_velocity)
    if not self.initialized then return end
    if self.strategy == "none" then return end

    -- Zoom Blur: Active during zoom transitions
    if self.zoom_blur_enabled and self.zoom_blur_filter then
        local radius = 0

        if state_machine:is_animating() and
           (state_machine.state == ZoomState.ZOOMING_IN or
            state_machine.state == ZoomState.ZOOMING_OUT) then
            -- Bell curve: 0 at start Ã¢â€ â€™ peak at 50% Ã¢â€ â€™ 0 at end
            local t = clamp(0, 1, state_machine.zoom_time)
            local curve = math.sin(t * math.pi)
            radius = curve * curve * self.zoom_blur_intensity
        end

        self:set_zoom_blur(radius, crop)
    end

    -- Motion Blur: Active during camera panning (not during zoom transition)
    if self.motion_blur_enabled and self.motion_blur_filter then
        if not state_machine:is_animating() and state_machine:is_zoomed() and camera_velocity then
            local speed = math.sqrt(
                camera_velocity.x * camera_velocity.x +
                camera_velocity.y * camera_velocity.y
            )

            if speed > 1.0 then
                local radius = math.min(10, speed * self.motion_blur_intensity * 0.5)
                local angle = math.deg(math.atan2(camera_velocity.y, camera_velocity.x))
                self:set_motion_blur(radius, angle)
            else
                self:set_motion_blur(0, 0)
            end
        else
            self:set_motion_blur(0, 0)
        end
    end
end

-- Set zoom blur parameters
function BlurManager:set_zoom_blur(radius, crop)
    if self.strategy == "composite_blur" and self.zoom_blur_settings then
        obs.obs_data_set_double(self.zoom_blur_settings, "radius", radius)

        if crop then
            local cx = crop.x + (crop.w / 2)
            local cy = crop.y + (crop.h / 2)
            obs.obs_data_set_double(self.zoom_blur_settings, "center_x", cx)
            obs.obs_data_set_double(self.zoom_blur_settings, "center_y", cy)
        end

        obs.obs_data_set_double(self.zoom_blur_settings, "inactive_radius", self.zoom_blur_clear_radius)
        obs.obs_source_update(self.zoom_blur_filter, self.zoom_blur_settings)
    end
end

-- Set motion blur parameters
function BlurManager:set_motion_blur(radius, angle)
    if self.strategy == "composite_blur" and self.motion_blur_settings then
        obs.obs_data_set_double(self.motion_blur_settings, "radius", radius)
        obs.obs_data_set_double(self.motion_blur_settings, "angle", angle)
        obs.obs_source_update(self.motion_blur_filter, self.motion_blur_settings)
    end
end

-- Update configuration
function BlurManager:update_config(settings)
    self.zoom_blur_enabled = obs.obs_data_get_bool(settings, "zoom_blur_enabled")
    self.zoom_blur_intensity = obs.obs_data_get_double(settings, "zoom_blur_intensity")
    self.zoom_blur_clear_radius = obs.obs_data_get_double(settings, "zoom_blur_clear_radius")
    self.motion_blur_enabled = obs.obs_data_get_bool(settings, "motion_blur_enabled")
    self.motion_blur_intensity = obs.obs_data_get_double(settings, "motion_blur_intensity")
end

-- Cleanup filters
function BlurManager:cleanup()
    local source = source_manager_get_source()

    if self.zoom_blur_filter and source then
        obs.obs_source_filter_remove(source, self.zoom_blur_filter)
        obs.obs_source_release(self.zoom_blur_filter)
        self.zoom_blur_filter = nil
    end

    if self.motion_blur_filter and source then
        obs.obs_source_filter_remove(source, self.motion_blur_filter)
        obs.obs_source_release(self.motion_blur_filter)
        self.motion_blur_filter = nil
    end

    if self.zoom_blur_settings then
        obs.obs_data_release(self.zoom_blur_settings)
        self.zoom_blur_settings = nil
    end

    if self.motion_blur_settings then
        obs.obs_data_release(self.motion_blur_settings)
        self.motion_blur_settings = nil
    end

    self.initialized = false
    self.strategy = "none"
end

-- Check if blur is available
function BlurManager:is_available()
    return self.strategy ~= "none"
end

-- Global convenience functions
function blur_manager_init(source)
    return BlurManager:init(source)
end

function blur_manager_update(state_machine, crop, camera_velocity)
    return BlurManager:update(state_machine, crop, camera_velocity)
end

function blur_manager_update_config(settings)
    return BlurManager:update_config(settings)
end

function blur_manager_cleanup()
    return BlurManager:cleanup()
end

function blur_manager_is_available()
    return BlurManager:is_available()
end

--================================================
-- MODULE: Cursor Asset Manager (M16)
--================================================
-- Handles extracting and managing cursor image assets

local CursorAssets = {
    extracted = false,
    dir = nil,
}

-- Get the platform-specific asset directory
function CursorAssets:get_platform_dir()
    if IS_WINDOWS then
        local appdata = os.getenv("APPDATA")
        return appdata and (appdata .. "\\obs-studio\\obs-zoom-pro\\cursors") or nil
    elseif IS_LINUX then
        local home = os.getenv("HOME")
        return home and (home .. "/.config/obs-studio/obs-zoom-pro/cursors") or nil
    elseif IS_MACOS then
        local home = os.getenv("HOME")
        return home and (home .. "/Library/Application Support/obs-studio/obs-zoom-pro/cursors") or nil
    end
    -- Fallback for non-FFI environments
    return "cursors"
end

-- Ensure assets are extracted
function CursorAssets:ensure_extracted()
    if self.extracted then
        return self.dir
    end

    local dir = self:get_platform_dir()
    if not dir then
        log("CursorAssets: Could not determine asset directory")
        return nil
    end

    -- Create directory
    local cmd
    if IS_WINDOWS then
        cmd = 'mkdir "' .. dir .. '" 2>nul'
    else
        cmd = 'mkdir -p "' .. dir .. '"'
    end
    os.execute(cmd)

    -- Check if assets exist
    local sep = IS_WINDOWS and "\\" or "/"
    local arrow_path = dir .. sep .. "arrow.png"

    local f = io.open(arrow_path, "rb")
    if f then
        f:close()
        self.dir = dir
        self.extracted = true
        log("CursorAssets: Using existing assets from " .. dir)
        return dir
    end

    -- Try to copy from script directory
    local script_dir = get_script_directory()
    local assets_src = script_dir .. "assets" .. sep .. "cursors" .. sep

    local files = { "arrow.png", "pointer.png", "ibeam.png" }
    for _, filename in ipairs(files) do
        local src_path = assets_src .. filename
        local dst_path = dir .. sep .. filename

        local src = io.open(src_path, "rb")
        if src then
            local data = src:read("*a")
            src:close()

            local dst = io.open(dst_path, "wb")
            if dst then
                dst:write(data)
                dst:close()
                log("CursorAssets: Copied " .. filename)
            end
        end
    end

    self.dir = dir
    self.extracted = true
    return dir
end

-- Get the asset directory
function CursorAssets:get_dir()
    return self.dir
end

-- Check if assets are available
function CursorAssets:is_available()
    if not self.extracted then
        self:ensure_extracted()
    end
    return self.dir ~= nil
end

-- Get cursor image path
function CursorAssets:get_cursor_path(cursor_type)
    if not self:is_available() then
        return nil
    end

    local sep = IS_WINDOWS and "\\" or "/"
    local filename = (cursor_type or "arrow") .. ".png"
    return self.dir .. sep .. filename
end

-- Global convenience functions
function cursor_assets_ensure_extracted()
    return CursorAssets:ensure_extracted()
end

function cursor_assets_get_dir()
    return CursorAssets:get_dir()
end

function cursor_assets_is_available()
    return CursorAssets:is_available()
end

function cursor_assets_get_cursor_path(cursor_type)
    return CursorAssets:get_cursor_path(cursor_type)
end

--================================================
-- MODULE: Cursor Renderer (M15)
--================================================
-- Provides automatic cursor overlay rendering

local CursorRenderer = {
    enabled = false,
    source = nil,
    sceneitem = nil,

    -- Smoothed state
    pos = { x = 0, y = 0 },
    current_scale = 1.0,
    current_rot = 0,
    swap_pulse = 1.0,

    -- Velocities (SmoothDamp)
    vel_x = { val = 0 },
    vel_y = { val = 0 },
    vel_scale = { val = 0 },
    vel_rot = { val = 0 },
    vel_swap = { val = 0 },

    -- State
    was_pointer = false,
    initialized = false,

    -- Configuration
    cursor_scale = 1.0,
    cursor_click_scale = 0.78,
    cursor_smooth_time = 0.1,
    cursor_offset_x = -6,
    cursor_offset_y = -2,
    cursor_rotation_mode = "None",
    cursor_angle_offset = 0,
    cursor_tilt_strength = 0,
}

-- Initialize cursor renderer
function CursorRenderer:init()
    if not cfg.cursor_enabled then
        self.enabled = false
        return false
    end

    -- Ensure cursor assets are available
    local asset_dir = cursor_assets_ensure_extracted()
    if not asset_dir then
        log("CursorRenderer: Failed to extract cursor assets")
        self.enabled = false
        return false
    end

    -- Get or create the cursor image source
    local source_name = FILTER_PREFIX .. "Cursor"
    self.source = obs.obs_get_source_by_name(source_name)

    if not self.source then
        -- Create new image source
        local settings = obs.obs_data_create()
        local cursor_path = cursor_assets_get_cursor_path("arrow")
        if cursor_path then
            obs.obs_data_set_string(settings, "file", cursor_path)
        end
        self.source = obs.obs_source_create("image_source", source_name, settings, nil)
        obs.obs_data_release(settings)

        if not self.source then
            log("CursorRenderer: Failed to create image source")
            self.enabled = false
            return false
        end
    end

    -- Add to current scene
    self:add_to_scene()

    -- Initialize position
    local mouse = platform_get_mouse_pos()
    self.pos.x = mouse.x
    self.pos.y = mouse.y

    self.enabled = true
    self.initialized = true
    log("CursorRenderer: Initialized")
    return true
end

-- Add cursor source to scene
function CursorRenderer:add_to_scene()
    if not self.source then return false end

    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then return false end

    local scene = obs.obs_scene_from_source(scene_source)
    if not scene then
        obs.obs_source_release(scene_source)
        return false
    end

    -- Check if already in scene
    local source_name = obs.obs_source_get_name(self.source)
    self.sceneitem = obs.obs_scene_find_source(scene, source_name)

    if not self.sceneitem then
        -- Add to scene
        self.sceneitem = obs.obs_scene_add(scene, self.source)
        if self.sceneitem then
            -- Move to top (render last = on top)
            obs.obs_sceneitem_set_order(self.sceneitem, obs.OBS_ORDER_MOVE_TOP)
        end
    end

    obs.obs_source_release(scene_source)
    return true
end

-- Update cursor position and state
function CursorRenderer:update(dt, raw_mouse, camera_crop)
    if not self.enabled or not self.sceneitem then return end

    -- Smooth cursor position
    self.pos.x = SmoothDamp(self.pos.x, raw_mouse.x, self.vel_x, self.cursor_smooth_time, 100000, dt)
    self.pos.y = SmoothDamp(self.pos.y, raw_mouse.y, self.vel_y, self.cursor_smooth_time, 100000, dt)

    -- Snap when very close
    if math.abs(self.pos.x - raw_mouse.x) < 0.5 then
        self.pos.x = raw_mouse.x
        self.vel_x.val = 0
    end
    if math.abs(self.pos.y - raw_mouse.y) < 0.5 then
        self.pos.y = raw_mouse.y
        self.vel_y.val = 0
    end

    -- Cursor shape detection (Windows only)
    local is_pointer = false
    if platform_cursor_shape_available() then
        is_pointer = platform_is_cursor_pointer()
    end

    -- Swap cursor image if needed
    if is_pointer ~= self.was_pointer then
        local asset_dir = cursor_assets_get_dir()
        local sep = IS_WINDOWS and "\\" or "/"
        local new_file = is_pointer and (asset_dir .. sep .. "pointer.png") or (asset_dir .. sep .. "arrow.png")

        local s = obs.obs_source_get_settings(self.source)
        if s then
            obs.obs_data_set_string(s, "file", new_file)
            obs.obs_source_update(self.source, s)
            obs.obs_data_release(s)
        end

        -- Trigger swap pulse
        self.swap_pulse = 0.75
        self.vel_swap.val = 1
        self.was_pointer = is_pointer
    end

    self.swap_pulse = SmoothDamp(self.swap_pulse, 1.0, self.vel_swap, 0.12, 100000, dt)

    -- Click animation
    local is_clicking = platform_is_clicking()
    local target_scale = is_clicking and (self.cursor_scale * self.cursor_click_scale) or self.cursor_scale
    self.current_scale = SmoothDamp(self.current_scale, target_scale, self.vel_scale, 0.1, 100000, dt)

    -- Calculate position relative to zoom
    local zoom_factor = 1.0
    local crop_x, crop_y = 0, 0

    if camera_crop and SM:is_zoomed() then
        zoom_factor = source_manager_get_size() / camera_crop.w
        crop_x = camera_crop.x
        crop_y = camera_crop.y
    end

    local final_x = (self.pos.x - crop_x) * zoom_factor + (self.cursor_offset_x * zoom_factor)
    local final_y = (self.pos.y - crop_y) * zoom_factor + (self.cursor_offset_y * zoom_factor)

    -- Apply to scene item
    local pos = obs.vec2()
    pos.x = final_x
    pos.y = final_y
    obs.obs_sceneitem_set_pos(self.sceneitem, pos)

    local scale = obs.vec2()
    local s = self.current_scale * zoom_factor * self.swap_pulse
    scale.x = s
    scale.y = s
    obs.obs_sceneitem_set_scale(self.sceneitem, scale)

    -- Rotation
    local dynamic_rot = self:compute_rotation(dt)
    obs.obs_sceneitem_set_rot(self.sceneitem, dynamic_rot)
end

-- Compute rotation based on mode
function CursorRenderer:compute_rotation(dt)
    local vx = self.vel_x.val
    local vy = self.vel_y.val
    local speed = math.sqrt(vx * vx + vy * vy)

    if self.cursor_rotation_mode == "Directional" then
        if speed > 20 then
            local angle = math.atan2(vy, vx) * (180 / math.pi)
            local target = angle + self.cursor_angle_offset
            local diff = (target - self.current_rot + 180) % 360 - 180
            self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.05, 100000, dt)
        end
        return self.current_rot

    elseif self.cursor_rotation_mode == "Lean" then
        local lean = clamp(-40, 40, vx * 0.05 * self.cursor_tilt_strength) + self.cursor_angle_offset
        local diff = (lean - self.current_rot + 180) % 360 - 180
        self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.08, 100000, dt)
        return self.current_rot
    end

    -- "None" mode
    local diff = (self.cursor_angle_offset - self.current_rot + 180) % 360 - 180
    self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.15, 100000, dt)
    return self.current_rot
end

-- Update configuration
function CursorRenderer:update_config(settings)
    self.cursor_scale = obs.obs_data_get_double(settings, "cursor_scale")
    self.cursor_click_scale = obs.obs_data_get_double(settings, "cursor_click_scale")
    self.cursor_smooth_time = obs.obs_data_get_double(settings, "cursor_smooth_time")
    self.cursor_offset_x = obs.obs_data_get_int(settings, "cursor_offset_x")
    self.cursor_offset_y = obs.obs_data_get_int(settings, "cursor_offset_y")
    self.cursor_rotation_mode = obs.obs_data_get_string(settings, "cursor_rotation_mode") or "None"
    self.cursor_angle_offset = obs.obs_data_get_double(settings, "cursor_angle_offset")
    self.cursor_tilt_strength = obs.obs_data_get_double(settings, "cursor_tilt_strength")
end

-- Cleanup
function CursorRenderer:cleanup()
    if self.sceneitem then
        obs.obs_sceneitem_remove(self.sceneitem)
        self.sceneitem = nil
    end

    if self.source then
        local source_name = obs.obs_source_get_name(self.source)
        obs.obs_source_release(self.source)

        -- Remove from OBS source list
        local s = obs.obs_get_source_by_name(source_name)
        if s then
            obs.obs_source_remove(s)
            obs.obs_source_release(s)
        end
        self.source = nil
    end

    self.enabled = false
    self.initialized = false
end

-- Check if active
function CursorRenderer:is_active()
    return self.enabled and self.initialized
end

-- Global convenience functions
function cursor_renderer_init()
    return CursorRenderer:init()
end

function cursor_renderer_update(dt, raw_mouse, camera_crop)
    return CursorRenderer:update(dt, raw_mouse, camera_crop)
end

function cursor_renderer_update_config(settings)
    return CursorRenderer:update_config(settings)
end

function cursor_renderer_cleanup()
    return CursorRenderer:cleanup()
end

function cursor_renderer_is_active()
    return CursorRenderer:is_active()
end

--================================================
-- MODULE: Bookmark Manager (M17)
--================================================
-- Manages saved zoom positions (bookmarks)

local BookmarkManager = {
    -- Saved bookmarks: { name = { zoom_level, x, y, w, h, source } }
    bookmarks = {},

    -- Maximum bookmarks
    max_bookmarks = 20,

    -- Hotkey IDs
    hotkeys = {},
}

-- Save current zoom position as a bookmark
function BookmarkManager:save(name)
    if not name or name == "" then
        return false
    end

    -- Check limit
    local count = 0
    for _, _ in pairs(self.bookmarks) do count = count + 1 end

    if count >= self.max_bookmarks and not self.bookmarks[name] then
        log("Bookmark: Max bookmarks reached (" .. self.max_bookmarks .. ")")
        return false
    end

    -- Get current crop
    local crop = crop_filter_get_crop()
    if not crop then
        return false
    end

    -- Save bookmark
    self.bookmarks[name] = {
        zoom_level = SM.zoom_level,
        x = crop.x,
        y = crop.y,
        w = crop.w,
        h = crop.h,
        source = cfg.source_name,
    }

    log("Bookmark: Saved '" .. name .. "' (zoom=" .. string.format("%.2f", SM.zoom_level) .. ")")
    return true
end

-- Recall a bookmark
function BookmarkManager:recall(name)
    local bm = self.bookmarks[name]
    if not bm then
        log("Bookmark: Not found: " .. name)
        return false
    end

    if not SM:can_jump() then
        return false
    end

    if not source_manager_is_valid() then
        return false
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        return false
    end

    -- Get current crop as start
    local start_crop = crop_filter_get_crop() or { x = 0, y = 0, w = source_w, h = source_h }

    -- Set target
    local target_crop = {
        x = bm.x,
        y = bm.y,
        w = bm.w,
        h = bm.h,
    }

    -- Transition to bookmark
    SM:transition(ZoomState.JUMPING, {
        start_crop = start_crop,
        target_crop = target_crop,
        target_level = bm.zoom_level
    })

    start_timer()
    log("Bookmark: Recall '" .. name .. "'")
    return true
end

-- Delete a bookmark
function BookmarkManager:delete(name)
    if self.bookmarks[name] then
        self.bookmarks[name] = nil
        log("Bookmark: Deleted '" .. name .. "'")
        return true
    end
    return false
end

-- Rename a bookmark
function BookmarkManager:rename(old_name, new_name)
    if not self.bookmarks[old_name] then
        return false
    end

    if self.bookmarks[new_name] then
        return false
    end

    self.bookmarks[new_name] = self.bookmarks[old_name]
    self.bookmarks[old_name] = nil
    log("Bookmark: Renamed '" .. old_name .. "' to '" .. new_name .. "'")
    return true
end

-- Get all bookmark names
function BookmarkManager:get_names()
    local names = {}
    for k, _ in pairs(self.bookmarks) do
        table.insert(names, k)
    end
    table.sort(names)
    return names
end

-- Get bookmark info
function BookmarkManager:get(name)
    return self.bookmarks[name]
end

-- Persist bookmarks to settings
function BookmarkManager:persist(settings)
    local array = obs.obs_data_array_create()

    for name, bm in pairs(self.bookmarks) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "name", name)
        obs.obs_data_set_double(item, "zoom_level", bm.zoom_level)
        obs.obs_data_set_double(item, "x", bm.x)
        obs.obs_data_set_double(item, "y", bm.y)
        obs.obs_data_set_double(item, "w", bm.w)
        obs.obs_data_set_double(item, "h", bm.h)
        obs.obs_data_set_string(item, "source", bm.source or "")
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "zoom_bookmarks", array)
    obs.obs_data_array_release(array)
end

-- Load bookmarks from settings
function BookmarkManager:load(settings)
    self.bookmarks = {}

    local array = obs.obs_data_get_array(settings, "zoom_bookmarks")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local name = obs.obs_data_get_string(item, "name")

        if name and name ~= "" then
            self.bookmarks[name] = {
                zoom_level = obs.obs_data_get_double(item, "zoom_level"),
                x = obs.obs_data_get_double(item, "x"),
                y = obs.obs_data_get_double(item, "y"),
                w = obs.obs_data_get_double(item, "w"),
                h = obs.obs_data_get_double(item, "h"),
                source = obs.obs_data_get_string(item, "source"),
            }
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)

    local count = 0
    for _, _ in pairs(self.bookmarks) do count = count + 1 end
    log("Bookmark: Loaded " .. count .. " bookmarks")
end

-- Register bookmark hotkeys
function BookmarkManager:register_hotkeys(settings)
    for i = 1, 5 do
        self.hotkeys[i] = obs.obs_hotkey_register_frontend(
            "obs_zoom_pro.bookmark_" .. i,
            "Zoom to Bookmark " .. i,
            function(pressed)
                if not pressed then return end
                local names = self:get_names()
                if names[i] then
                    self:recall(names[i])
                end
            end
        )

        -- Load saved bindings
        local key = "obs_zoom_pro.hotkey.bookmark_" .. i
        local save_array = obs.obs_data_get_array(settings, key)
        if save_array then
            obs.obs_hotkey_load(self.hotkeys[i], save_array)
            obs.obs_data_array_release(save_array)
        end
    end
end

-- Save bookmark hotkeys
function BookmarkManager:save_hotkeys(settings)
    for i = 1, 5 do
        if self.hotkeys[i] then
            local save_array = obs.obs_hotkey_save(self.hotkeys[i])
            obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.bookmark_" .. i, save_array)
            obs.obs_data_array_release(save_array)
        end
    end
end

-- Global convenience functions
function bookmark_save(name)
    return BookmarkManager:save(name)
end

function bookmark_recall(name)
    return BookmarkManager:recall(name)
end

function bookmark_delete(name)
    return BookmarkManager:delete(name)
end

function bookmark_get_names()
    return BookmarkManager:get_names()
end

function bookmark_get(name)
    return BookmarkManager:get(name)
end

--================================================
-- MODULE: UDP API Server (M18)
--================================================
-- Provides external control via UDP for Stream Deck integration

local APIServer = {
    enabled = false,
    port = 12345,
    socket = nil,
}

-- Command handlers
local API_COMMANDS = {
    ZOOM_IN = function(args)
        local level = tonumber(args[1]) or cfg.zoom_value
        on_scroll_zoom_to(level)
        return "OK"
    end,

    ZOOM_OUT = function(args)
        if SM:is_zoomed() then
            on_toggle_zoom(true)
        end
        return "OK"
    end,

    ZOOM_SET = function(args)
        local level = tonumber(args[1])
        if not level then return "ERROR: Missing level" end
        on_scroll_zoom_to(level)
        return "OK"
    end,

    ZOOM_TOGGLE = function(args)
        on_toggle_zoom(true)
        return "OK"
    end,

    FOLLOW_ON = function(args)
        if SM:is_zoomed() then SM.following = true end
        return "OK"
    end,

    FOLLOW_OFF = function(args)
        SM.following = false
        return "OK"
    end,

    FOLLOW_TOGGLE = function(args)
        if SM:is_zoomed() then SM.following = not SM.following end
        return "OK"
    end,

    PRESET = function(args)
        local name = args[1]
        if not name then return "ERROR: Missing preset name" end
        local ok = preset_apply(name)
        return ok and "OK" or "ERROR: Unknown preset"
    end,

    BOOKMARK = function(args)
        local name = args[1]
        if not name then return "ERROR: Missing bookmark name" end
        local ok = bookmark_recall(name)
        return ok and "OK" or "ERROR: Bookmark not found"
    end,

    STATUS = function(args)
        local crop = crop_filter_get_crop()
        return string.format(
            '{"version":"%s","zoom_level":%.2f,"state":"%s","following":%s,"position":{"x":%.0f,"y":%.0f},"preset":"%s"}',
            VERSION,
            SM.zoom_level,
            SM.state,
            tostring(SM.following),
            crop and crop.x or 0,
            crop and crop.y or 0,
            cfg.zoom_preset or ""
        )
    end,

    HELP = function(args)
        return "Commands: ZOOM_IN [level], ZOOM_OUT, ZOOM_SET level, ZOOM_TOGGLE, FOLLOW_ON, FOLLOW_OFF, FOLLOW_TOGGLE, PRESET name, BOOKMARK name, STATUS"
    end,
}

-- Start the API server
function APIServer:start(port)
    self:stop()

    self.port = port or self.port

    -- Try to use luasocket if available
    local socket_ok, socket = pcall(require, "socket")
    if not socket_ok then
        log("API: Socket library not available")
        return false
    end

    -- Try UDP
    local udp, err = socket.udp()
    if not udp then
        log("API: Failed to create UDP socket: " .. tostring(err))
        return false
    end

    -- Set socket options
    udp:setoption("reuseaddr", true)
    udp:settimeout(0)  -- Non-blocking

    -- Bind to port
    local bind_ok, err = udp:setsockname("*", self.port)
    if not bind_ok then
        log("API: Failed to bind to port " .. self.port .. ": " .. tostring(err))
        udp:close()
        return false
    end

    self.socket = udp
    self.enabled = true

    -- Start polling timer
    obs.timer_add(function() self:poll() end, 50)  -- 20Hz polling

    log("API: Listening on port " .. self.port)
    return true
end

-- Stop the API server
function APIServer:stop()
    if self.socket then
        self.socket:close()
        self.socket = nil
    end
    self.enabled = false
    log("API: Stopped")
end

-- Poll for incoming commands
function APIServer:poll()
    if not self.enabled or not self.socket then
        return
    end

    repeat
        local data, err = self.socket:receivefrom()
        if data then
            local response = self:handle_command(data)
            if response then
                -- Note: UDP response requires sender address
                log("API: " .. data:gsub("%s+", " ") .. " Ã¢â€ â€™ " .. response)
            end
        elseif err ~= "timeout" then
            log("API: Error: " .. tostring(err))
        end
    until not data
end

-- Handle a command
function APIServer:handle_command(raw)
    -- Parse command
    local parts = {}
    for word in raw:gmatch("%S+") do
        table.insert(parts, word)
    end

    if #parts == 0 then
        return "ERROR: Empty command"
    end

    local cmd = parts[1]:upper()
    local args = {}
    for i = 2, #parts do
        table.insert(args, parts[i])
    end

    -- Look up handler
    local handler = API_COMMANDS[cmd]
    if handler then
        local ok, result = pcall(handler, args)
        if ok then
            return result
        else
            return "ERROR: " .. tostring(result)
        end
    end

    return "ERROR: Unknown command: " .. cmd
end

-- Check if enabled
function APIServer:is_enabled()
    return self.enabled
end

-- Global convenience functions
function api_start(port)
    return APIServer:start(port)
end

function api_stop()
    return APIServer:stop()
end

function api_is_enabled()
    return APIServer:is_enabled()
end

--================================================
-- OBS SCRIPT REGISTRATION
--================================================

--[[ Called when the script is loaded
--[[ @param data table Script data
function script_load(data)
    log("Script loaded - OBS Zoom Pro v" .. VERSION)

    -- Load custom presets
    PresetManager:load(data)

    -- Load scene memory
    SceneMemory:load(data)

    -- Load bookmarks
    BookmarkManager:load(data)

    -- Register hotkeys
    register_hotkeys(data)

    -- Register bookmark hotkeys
    BookmarkManager:register_hotkeys(data)

    -- Register frontend event handler
    obs.obs_frontend_add_event_callback(on_frontend_event)

    -- Start API server if enabled
    local api_enabled = obs.obs_data_get_bool(data, "api_enabled")
    if api_enabled then
        local api_port = obs.obs_data_get_int(data, "api_port")
        APIServer:start(api_port)
    end
end

--[[ Called when the script is unloaded
function script_unload()
    log("Script unloaded - OBS Zoom Pro")

    -- Stop timer and cleanup
    stop_timer()
    unregister_hotkeys()
    source_manager_release()

    -- Stop API server
    APIServer:stop()

    -- Remove frontend event handler
    obs.obs_frontend_remove_event_callback(on_frontend_event)
end

--[[ Called when settings are updated
--[[ @param data table Settings data
function script_update(data)
    log("Settings updated")

    -- Update legacy settings
    debug_logs = obs.obs_data_get_bool(data, "debug_logging") or false
    settings.debug_logging = debug_logs
    settings.easing_type = obs.obs_data_get_string(data, "easing_type") or defaults.easing_type
    settings.smooth_time = obs.obs_data_get_double(data, "smooth_time") or defaults.smooth_time
    settings.max_speed = obs.obs_data_get_double(data, "max_speed") or defaults.max_speed

    -- Update M09 configuration
    update_config(data)

    -- Update API server settings
    local api_enabled = obs.obs_data_get_bool(data, "api_enabled")
    local api_port = obs.obs_data_get_int(data, "api_port")

    if api_enabled and not APIServer:is_enabled() then
        APIServer:start(api_port)
    elseif not api_enabled and APIServer:is_enabled() then
        APIServer:stop()
    elseif APIServer:is_enabled() and APIServer.port ~= api_port then
        APIServer:start(api_port)
    end
end

--[[ Called to save settings
--[[ @param data table Settings data to save
function script_save(data)
    log("Settings saved")

    -- Save custom presets
    PresetManager:persist(data)

    -- Save scene memory
    SceneMemory:persist(data)

    -- Save bookmarks
    BookmarkManager:persist(data)

    -- Save hotkey bindings
    save_hotkeys(data)

    -- Save bookmark hotkeys
    BookmarkManager:save_hotkeys(data)
end

--[[ Called to create the properties UI
--[[ @return obs.obs_properties_t Properties object
function script_properties()
    local props = obs.obs_properties_create()

    --==========================
    -- QUICK SETUP (always expanded)
    --==========================
    local grp_quick = obs.obs_properties_create()

    -- Source dropdown
    local src_list = obs.obs_properties_add_list(grp_quick, "source", "Zoom Source",
        obs.OBS_COMBO_TYPE_LIST, obs.OBS_COMBO_FORMAT_STRING)
    obs.obs_property_list_add_string(src_list, "-- Select Source --", "")

    -- Populate with available capture sources
    local sources = source_manager_get_available_sources()
    for _, src in ipairs(sources) do
        obs.obs_property_list_add_string(src_list, src.name, src.name)
    end

    -- Zoom Factor
    obs.obs_properties_add_float_slider(grp_quick, "zoom_value", "Zoom Factor", 1.0, 10.0, 0.1)

    -- Duration
    obs.obs_properties_add_float_slider(grp_quick, "zoom_duration", "Duration (s)", 0.05, 3.0, 0.05)

    obs.obs_properties_add_group(props, "quick_setup", "Ã¢Å¡Â¡ Quick Setup", obs.OBS_GROUP_NORMAL, grp_quick)

    --==========================
    -- ANIMATION (collapsed)
    --==========================
    local grp_anim = obs.obs_properties_create()

    -- Overshoot/Bounce
    obs.obs_properties_add_float_slider(grp_anim, "zoom_overshoot", "Bounce", 0.0, 1.0, 0.01)

    -- Easing Curve
    local p_easing = obs.obs_properties_add_list(grp_anim, "zoom_easing", "Easing Curve",
        obs.OBS_COMBO_TYPE_LIST, obs.OBS_COMBO_FORMAT_STRING)
    for _, name in ipairs(Easing.NAMES) do
        obs.obs_property_list_add_string(p_easing, name, name)
    end

    obs.obs_properties_add_group(props, "animation", "Ã°Å¸Å½Â¬ Animation", obs.OBS_GROUP_NORMAL, grp_anim)

    --==========================
    -- MOUSE FOLLOW (collapsed)
    --==========================
    local grp_follow = obs.obs_properties_create()

    obs.obs_properties_add_bool(grp_follow, "auto_follow", "Auto-Follow Mouse")
    obs.obs_properties_add_float_slider(grp_follow, "follow_smooth_time", "Smoothness", 0.01, 1.0, 0.01)
    obs.obs_properties_add_int_slider(grp_follow, "follow_dead_zone", "Dead Zone (px)", 0, 500, 1)

    obs.obs_properties_add_group(props, "follow", "Ã°Å¸Å½Â¯ Mouse Follow", obs.OBS_GROUP_NORMAL, grp_follow)

    --==========================
    -- ADVANCED (collapsed)
    --==========================
    local grp_adv = obs.obs_properties_create()
    obs.obs_properties_add_float_slider(grp_adv, "scroll_step", "Scroll Zoom Step", 0.1, 1.0, 0.05)
    obs.obs_properties_add_bool(grp_adv, "debug_logs", "Debug Logging")
    obs.obs_properties_add_group(props, "advanced", "Ã¢Å¡â„¢Ã¯Â¸Â Advanced", obs.OBS_GROUP_NORMAL, grp_adv)

    --==========================
    -- API SERVER (collapsed)
    --==========================
    local grp_api = obs.obs_properties_create()
    obs.obs_properties_add_bool(grp_api, "api_enabled", "Enable UDP API Server")
    obs.obs_properties_add_int(grp_api, "api_port", "API Port", 1024, 65535, 1)
    obs.obs_properties_add_group(props, "api_server", "Ã°Å¸Å’Â UDP API Server", obs.OBS_GROUP_NORMAL, grp_api)

    --==========================
    -- HELP (collapsed)
    --==========================
    local grp_help = obs.obs_properties_create()
    obs.obs_properties_add_text(grp_help, "help_text",
        "QUICK START:\n" ..
        "1. Select your capture source above\n" ..
        "2. Set hotkeys in OBS Settings Ã¢â€ â€™ Hotkeys\n" ..
        "   Ã¢â‚¬Â¢ 'Toggle Zoom to Mouse' Ã¢â‚¬â€ Main zoom\n" ..
        "   Ã¢â‚¬Â¢ 'Toggle Mouse Follow' Ã¢â‚¬â€ Enable/disable follow\n" ..
        "3. Press the hotkey to zoom!\n\n" ..
        "TIPS:\n" ..
        "Ã¢â‚¬Â¢ Zoom centers on mouse position\n" ..
        "Ã¢â‚¬Â¢ Enable Auto-Follow for smooth tracking\n" ..
        "Ã¢â‚¬Â¢ Adjust Dead Zone to reduce jitter",
        obs.OBS_TEXT_INFO)
    obs.obs_properties_add_group(props, "help", "Ã¢Ââ€œ Help", obs.OBS_GROUP_NORMAL, grp_help)

    return props
end

--[[ Called to set default values
--[[ @param data table Settings data
function script_defaults(data)
    obs.obs_data_set_default_string(data, "source", "")
    obs.obs_data_set_default_double(data, "zoom_value", 2.0)
    obs.obs_data_set_default_double(data, "zoom_duration", 0.6)
    obs.obs_data_set_default_double(data, "zoom_overshoot", 0.0)
    obs.obs_data_set_default_string(data, "zoom_easing", "Cubic.Out")
    obs.obs_data_set_default_bool(data, "auto_follow", true)
    obs.obs_data_set_default_double(data, "follow_smooth_time", 0.15)
    obs.obs_data_set_default_int(data, "follow_dead_zone", 5)
    obs.obs_data_set_default_double(data, "scroll_step", 0.25)
    obs.obs_data_set_default_bool(data, "debug_logs", false)
    obs.obs_data_set_default_bool(data, "api_enabled", false)
    obs.obs_data_set_default_int(data, "api_port", 12345)
end

--================================================
-- SCRIPT METADATA
--================================================
script_info = {
    name = "OBS Zoom Pro",
    version = VERSION,
    description = "Intelligent camera zoom functionality with smooth transitions and easing curves.",
    author = "OBS Zoom Pro Team"
}
)
        handle:close()
        if uname == 'Darwin' then
            is_macos = true
            is_linux = false
        end
    end

    return {
        WINDOWS = is_windows,
        LINUX = is_linux,
        MACOS = is_macos
    }
end

local platform = detect_platform()
local IS_WINDOWS = platform.WINDOWS
local IS_LINUX = platform.LINUX
local IS_MACOS = platform.MACOS

-- Log platform detection
log("Platform detected: " .. (jit and jit.os or "Unknown") .. (IS_WINDOWS and " (Full support)" or " (Basic support)"))

-- Virtual key codes (Lua constants instead of C #define)
local VK_LBUTTON = 0x01
local VK_RBUTTON = 0x02
local VK_MBUTTON = 0x04
local VK_CONTROL = 0x11
local VK_SHIFT = 0x10
local VK_MENU = 0x12  -- Alt

-- FFI declarations for Windows (only if FFI is available)


-- Cursor shape constants (Windows)
local CURSOR_ARROW = 1
local CURSOR_IBEAM = 2
local CURSOR_HAND = 3
local CURSOR_WAIT = 4

-- Module state
local Platform = {
    cursor_shape_available = IS_WINDOWS,
    last_mouse = { x = 0, y = 0 },
    last_click = false,
}

-- Get mouse position (cross-platform)
function Platform.get_mouse_pos()
    if IS_WINDOWS then
        local success, pt = pcall(function()
            local pt = ffi.new("POINT")
            if ffi.C.GetCursorPos(pt) ~= 0 then
                return { x = tonumber(pt.x), y = tonumber(pt.y) }
            end
            return nil
        end)
        if success and pt then
            return pt
        end
    elseif IS_LINUX then
        -- Linux: Use xdotool if available, fallback to X11
        local success, result = pcall(function()
            local handle = io.popen("xdotool getmouselocation 2>/dev/null || echo 'x:0 y:0'")
            if handle then
                local output = handle:read("*a")
                handle:close()
                local x, y = output:match("x:(%d+)%s+y:(%d+)")
                if x and y then
                    return { x = tonumber(x), y = tonumber(y) }
                end
            end
            return nil
        end)
        if success and result then
            return result
        end
    elseif IS_MACOS then
        -- macOS: Use osascript
        local success, result = pcall(function()
            local handle = io.popen(--[[osascript -e 'tell application "System Events" to get position of the mouse' 2>/dev/null || echo "0, 0"]])
            if handle then
                local output = handle:read("*a")
                handle:close()
                local x, y = output:match("(%d+),%s*(%d+)")
                if x and y then
                    return { x = tonumber(x), y = tonumber(y) }
                end
            end
            return nil
        end)
        if success and result then
            return result
        end
    end

    -- Fallback
    return { x = 0, y = 0 }
end

-- Check if left mouse button is clicked (Windows only, others return false)
function Platform.is_clicking()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x01) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if a modifier key is held (Windows only)
function Platform.is_key_held(vk_code)
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(vk_code) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if cursor is a pointer/hand (Windows only)
function Platform.is_cursor_pointer()
    if IS_WINDOWS then
        local success, result = pcall(function()
            local ci = ffi.new("CURSORINFO")
            ci.cbSize = ffi.sizeof("CURSORINFO")
            if ffi.C.GetCursorInfo(ci) ~= 0 then
                -- Check if hCursor is a hand pointer
                -- This is a simplified check; real implementation would compare cursor handles
                return ci.flags ~= 0  -- Simplified; actual implementation needs cursor handle comparison
            end
            return false
        end)
        return success and result or false
    end
    return false
end

-- Get cursor shape (Windows only, returns "arrow" for others)
function Platform.get_cursor_shape()
    if IS_WINDOWS then
        local success, result = pcall(function()
            local ci = ffi.new("CURSORINFO")
            ci.cbSize = ffi.sizeof("CURSORINFO")
            if ffi.C.GetCursorInfo(ci) ~= 0 and ci.hCursor ~= nil then
                local addr = tonumber(ffi.cast("uintptr_t", ci.hCursor))
                -- Common cursor IDs (these are typical values, may vary)
                -- IDC_ARROW = 32512, IDC_IBEAM = 32513, IDC_HAND = 32649
                -- We use address ranges as heuristic
                return "arrow"  -- Simplified; actual implementation would map handles
            end
            return "arrow"
        end)
        return success and result or "arrow"
    end
    return "arrow"
end

-- Check if Control key is held
function Platform.is_ctrl_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x11) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if Shift key is held
function Platform.is_shift_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x10) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if Alt key is held
function Platform.is_alt_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x12) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Convenience wrapper functions
function platform_get_mouse_pos()
    return Platform.get_mouse_pos()
end

function platform_is_clicking()
    return Platform.is_clicking()
end

function platform_is_cursor_pointer()
    return Platform.is_cursor_pointer()
end

function platform_cursor_shape_available()
    return Platform.cursor_shape_available
end

function platform_is_ctrl_held()
    return Platform.is_ctrl_held()
end

function platform_is_shift_held()
    return Platform.is_shift_held()
end

function platform_is_alt_held()
    return Platform.is_alt_held()
end

--================================================
-- MODULE: State Machine (M05)
--================================================
-- Manages zoom states and transitions
-- States: IDLE, ZOOMING_IN, ZOOMED_IN, ZOOMING_OUT, SCROLLING, JUMPING

local ZoomState = {
    IDLE         = "idle",
    ZOOMING_IN   = "zooming_in",
    ZOOMED_IN    = "zoomed_in",
    ZOOMING_OUT  = "zooming_out",
    SCROLLING    = "scrolling",    -- Scroll wheel mid-transition
    JUMPING      = "jumping",      -- Bookmark transition
}

local StateMachine = {
    state = ZoomState.IDLE,
    zoom_time = 0,          -- Animation progress (0 Ã¢â€ â€™ 1)
    zoom_level = 1.0,       -- Current zoom factor
    target_level = 1.0,     -- Target zoom factor
    start_crop = nil,       -- Crop at animation start {x, y, w, h}
    target_crop = nil,      -- Crop at animation end {x, y, w, h}
    following = false,      -- Mouse follow active

    -- Transition guards
    can_zoom_in = function(self)
        return self.state == ZoomState.IDLE
    end,

    can_zoom_out = function(self)
        return self.state == ZoomState.ZOOMED_IN
            or self.state == ZoomState.SCROLLING
    end,

    can_scroll = function(self)
        return self.state == ZoomState.ZOOMED_IN
            or self.state == ZoomState.IDLE
            or self.state == ZoomState.SCROLLING
    end,

    can_jump = function(self)
        return self.state ~= ZoomState.ZOOMING_IN
           and self.state ~= ZoomState.ZOOMING_OUT
           and self.state ~= ZoomState.JUMPING
    end,

    is_animating = function(self)
        return self.state == ZoomState.ZOOMING_IN
            or self.state == ZoomState.ZOOMING_OUT
            or self.state == ZoomState.SCROLLING
            or self.state == ZoomState.JUMPING
    end,

    is_zoomed = function(self)
        return self.state ~= ZoomState.IDLE
    end,
}

-- Transition to a new state
function StateMachine:transition(new_state, params)
    local old = self.state
    self.state = new_state
    self.zoom_time = 0

    if params then
        if params.start_crop then self.start_crop = params.start_crop end
        if params.target_crop then self.target_crop = params.target_crop end
        if params.target_level then self.target_level = params.target_level end
    end

    log("State: " .. old .. " Ã¢â€ â€™ " .. new_state)
end

-- Complete the current animation
function StateMachine:complete()
    if self.state == ZoomState.ZOOMING_IN
       or self.state == ZoomState.SCROLLING
       or self.state == ZoomState.JUMPING then
        self.zoom_level = self.target_level
        self.state = ZoomState.ZOOMED_IN
        self.zoom_time = 0
        log("State: " .. self.state .. " Ã¢â€ â€™ ZOOMED_IN (complete)")
    elseif self.state == ZoomState.ZOOMING_OUT then
        self.zoom_level = 1.0
        self.target_level = 1.0
        self.start_crop = nil
        self.target_crop = nil
        self.following = false
        self.state = ZoomState.IDLE
        self.zoom_time = 0
        log("State: ZOOMING_OUT Ã¢â€ â€™ IDLE (complete)")
    end
end

-- Reset to initial state
function StateMachine:reset()
    self.state = ZoomState.IDLE
    self.zoom_time = 0
    self.zoom_level = 1.0
    self.target_level = 1.0
    self.start_crop = nil
    self.target_crop = nil
    self.following = false
    log("StateMachine: Reset to IDLE")
end

-- Get current animation progress (0-1)
function StateMachine:get_progress()
    return clamp(0, 1, self.zoom_time)
end

-- Check if in a specific state
function StateMachine:is_state(state)
    return self.state == state
end

-- Get state name for display
function StateMachine:get_state_name()
    return self.state
end

-- Create a new state machine instance (for testing/isolation)
function StateMachine:new()
    local sm = {}
    setmetatable(sm, { __index = self })
    sm.state = ZoomState.IDLE
    sm.zoom_time = 0
    sm.zoom_level = 1.0
    sm.target_level = 1.0
    sm.start_crop = nil
    sm.target_crop = nil
    sm.following = false
    return sm
end

-- Global state machine instance
local SM = StateMachine:new()

--================================================
-- MODULE: Crop Filter Manager (M07)
--================================================
-- Manages the crop/pad filter used to simulate zoom
-- Creates, updates, and destroys the filter automatically

local FILTER_PREFIX = "[ZoomPro] "
local CROP_FILTER_NAME = FILTER_PREFIX .. "Crop"

local CropFilterManager = {
    filter = nil,           -- The crop filter source
    source = nil,           -- The parent source
    original_crop = nil,    -- Original crop values for restoration
    current_crop = { x = 0, y = 0, w = 0, h = 0 },
    initialized = false,
}

-- Create the crop filter on a source
function CropFilterManager:create(source)
    if not source then
        log("CropFilter: No source provided")
        return false
    end

    self:cleanup()  -- Clean up any existing filter
    self.source = source

    -- Check if our filter already exists
    local existing = obs.obs_source_get_filter_by_name(source, CROP_FILTER_NAME)
    if existing then
        log("CropFilter: Found existing filter")
        self.filter = existing
        self.initialized = true
        return true
    end

    -- Create new crop/pad filter
    local settings = obs.obs_data_create()
    obs.obs_data_set_int(settings, "left", 0)
    obs.obs_data_set_int(settings, "top", 0)
    obs.obs_data_set_int(settings, "right", 0)
    obs.obs_data_set_int(settings, "bottom", 0)
    obs.obs_data_set_bool(settings, "relative", false)  -- Absolute positioning

    self.filter = obs.obs_source_create_private(
        "crop_filter",      -- Filter type
        CROP_FILTER_NAME,   -- Filter name
        settings            -- Settings
    )

    obs.obs_data_release(settings)

    if not self.filter then
        log("CropFilter: Failed to create filter")
        return false
    end

    -- Add filter to source
    obs.obs_source_filter_add(source, self.filter)

    -- Store original crop (none)
    self.original_crop = { x = 0, y = 0, w = 0, h = 0 }

    self.initialized = true
    log("CropFilter: Created successfully")
    return true
end

-- Update the crop filter with new values
function CropFilterManager:update(x, y, w, h)
    if not self.filter or not self.initialized then
        return false
    end

    -- Store current crop
    self.current_crop = { x = x, y = y, w = w, h = h }

    -- Get filter settings
    local settings = obs.obs_source_get_settings(self.filter)
    if not settings then
        return false
    end

    -- Calculate crop values
    -- For crop_filter: left, top are absolute position
    -- right, bottom are width/height from right/bottom edge
    -- We need to convert our x, y, w, h to this format

    -- Get source dimensions
    local source_w = obs.obs_source_get_width(self.source)
    local source_h = obs.obs_source_get_height(self.source)

    if source_w == 0 or source_h == 0 then
        obs.obs_data_release(settings)
        return false
    end

    -- Set crop values
    -- left = x offset from left
    -- top = y offset from top
    -- right = source_w - (x + w) = remaining width on right
    -- bottom = source_h - (y + h) = remaining height on bottom
    local left = math.floor(x)
    local top = math.floor(y)
    local right = math.floor(source_w - (x + w))
    local bottom = math.floor(source_h - (y + h))

    -- Clamp to valid values
    left = math.max(0, left)
    top = math.max(0, top)
    right = math.max(0, right)
    bottom = math.max(0, bottom)

    obs.obs_data_set_int(settings, "left", left)
    obs.obs_data_set_int(settings, "top", top)
    obs.obs_data_set_int(settings, "right", right)
    obs.obs_data_set_int(settings, "bottom", bottom)

    -- Update the filter
    obs.obs_source_update(self.filter, settings)
    obs.obs_data_release(settings)

    return true
end

-- Get current crop values
function CropFilterManager:get_crop()
    return self.current_crop
end

-- Reset crop to original (no crop)
function CropFilterManager:reset()
    if not self.filter or not self.initialized then
        return false
    end

    local settings = obs.obs_source_get_settings(self.filter)
    if settings then
        obs.obs_data_set_int(settings, "left", 0)
        obs.obs_data_set_int(settings, "top", 0)
        obs.obs_data_set_int(settings, "right", 0)
        obs.obs_data_set_int(settings, "bottom", 0)
        obs.obs_source_update(self.filter, settings)
        obs.obs_data_release(settings)
    end

    self.current_crop = { x = 0, y = 0, w = 0, h = 0 }
    return true
end

-- Remove the filter and restore original state
function CropFilterManager:cleanup()
    if self.filter and self.source then
        -- Reset to no crop first
        self:reset()

        -- Remove filter from source
        obs.obs_source_filter_remove(self.source, self.filter)
        obs.obs_source_release(self.filter)
        self.filter = nil
        log("CropFilter: Removed from source")
    end

    self.source = nil
    self.original_crop = nil
    self.current_crop = { x = 0, y = 0, w = 0, h = 0 }
    self.initialized = false
end

-- Check if filter is ready
function CropFilterManager:is_ready()
    return self.initialized and self.filter ~= nil
end

-- Get source dimensions
function CropFilterManager:get_source_size()
    if not self.source then
        return 0, 0
    end
    return obs.obs_source_get_width(self.source), obs.obs_source_get_height(self.source)
end

-- Convenience wrapper functions
function crop_filter_create(source)
    return CropFilterManager:create(source)
end

function crop_filter_update(x, y, w, h)
    return CropFilterManager:update(x, y, w, h)
end

function crop_filter_reset()
    return CropFilterManager:reset()
end

function crop_filter_cleanup()
    return CropFilterManager:cleanup()
end

function crop_filter_is_ready()
    return CropFilterManager:is_ready()
end

function crop_filter_get_crop()
    return CropFilterManager:get_crop()
end

function crop_filter_get_source_size()
    return CropFilterManager:get_source_size()
end

--================================================
-- MODULE: Source Manager (M08)
--================================================
-- Handles finding sources in scenes, capturing transforms,
-- and managing source state for zoom operations

local SourceManager = {
    source = nil,           -- Current zoom source
    sceneitem = nil,        -- Scene item reference
    scene = nil,            -- Current scene
    original_transform = nil, -- Saved original transform
    source_name = "",       -- Source name for settings
    initialized = false,
}

-- Transform data structure
local TransformData = {
    pos = { x = 0, y = 0 },
    scale = { x = 1.0, y = 1.0 },
    rot = 0,
    bounds_type = 0,
    bounds = { x = 0, y = 0 },
    crop = { left = 0, top = 0, right = 0, bottom = 0 },
}

-- Find a source in a scene (BFS through groups)
function SourceManager:find_sceneitem(scene, source_name)
    if not scene or not source_name then
        return nil
    end

    local scene_source = obs.obs_scene_from_source(scene)
    if not scene_source then
        return nil
    end

    -- BFS queue
    local queue = {}
    table.insert(queue, scene_source)

    while #queue > 0 do
        local current_scene = table.remove(queue, 1)

        -- Iterate through items
        local items = obs.obs_scene_enum_items(current_scene)
        if items then
            for _, item in ipairs(items) do
                local item_source = obs.obs_sceneitem_get_source(item)
                if item_source then
                    local name = obs.obs_source_get_name(item_source)

                    -- Check if this is our target
                    if name == source_name then
                        obs.sceneitem_list_release(items)
                        return item
                    end

                    -- Check if this is a group (nested scene)
                    if obs.obs_source_get_type(item_source) == obs.OBS_SOURCE_TYPE_INPUT then
                        local id = obs.obs_source_get_id(item_source)
                        if id == "group" then
                            local group_scene = obs.obs_group_from_source(item_source)
                            if group_scene then
                                table.insert(queue, group_scene)
                            end
                        end
                    end
                end
            end
            obs.sceneitem_list_release(items)
        end
    end

    return nil
end

-- Capture the current transform of a scene item
function SourceManager:capture_transform(sceneitem)
    if not sceneitem then
        return nil
    end

    local transform = {}

    -- Position
    local pos = obs.vec2()
    obs.obs_sceneitem_get_pos(sceneitem, pos)
    transform.pos = { x = pos.x, y = pos.y }

    -- Scale
    local scale = obs.vec2()
    obs.obs_sceneitem_get_scale(sceneitem, scale)
    transform.scale = { x = scale.x, y = scale.y }

    -- Rotation
    transform.rot = obs.obs_sceneitem_get_rot(sceneitem)

    -- Bounds
    transform.bounds_type = obs.obs_sceneitem_get_bounds_type(sceneitem)
    local bounds = obs.vec2()
    obs.obs_sceneitem_get_bounds(sceneitem, bounds)
    transform.bounds = { x = bounds.x, y = bounds.y }

    -- Crop
    local crop = obs.obs_sceneitem_crop()
    obs.obs_sceneitem_get_crop(sceneitem, crop)
    transform.crop = {
        left = crop.left,
        top = crop.top,
        right = crop.right,
        bottom = crop.bottom
    }

    return transform
end

-- Restore a saved transform to a scene item
function SourceManager:restore_transform(sceneitem, transform)
    if not sceneitem or not transform then
        return false
    end

    -- Position
    local pos = obs.vec2()
    pos.x = transform.pos.x
    pos.y = transform.pos.y
    obs.obs_sceneitem_set_pos(sceneitem, pos)

    -- Scale
    local scale = obs.vec2()
    scale.x = transform.scale.x
    scale.y = transform.scale.y
    obs.obs_sceneitem_set_scale(sceneitem, scale)

    -- Rotation
    obs.obs_sceneitem_set_rot(sceneitem, transform.rot)

    -- Bounds
    obs.obs_sceneitem_set_bounds_type(sceneitem, transform.bounds_type)
    local bounds = obs.vec2()
    bounds.x = transform.bounds.x
    bounds.y = transform.bounds.y
    obs.obs_sceneitem_set_bounds(sceneitem, bounds)

    -- Crop
    local crop = obs.obs_sceneitem_crop()
    crop.left = transform.crop.left
    crop.top = transform.crop.top
    crop.right = transform.crop.right
    crop.bottom = transform.crop.bottom
    obs.obs_sceneitem_set_crop(sceneitem, crop)

    return true
end

-- Initialize with a source name
function SourceManager:init(source_name)
    self:release()  -- Clean up any existing state

    if not source_name or source_name == "" then
        log("SourceManager: No source name provided")
        return false
    end

    self.source_name = source_name

    -- Get current scene
    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then
        log("SourceManager: No current scene")
        return false
    end

    self.scene = scene_source

    -- Find the scene item
    self.sceneitem = self:find_sceneitem(scene_source, source_name)
    if not self.sceneitem then
        log("SourceManager: Source not found in scene: " .. source_name)
        obs.obs_source_release(scene_source)
        return false
    end

    -- Get the source
    self.source = obs.obs_sceneitem_get_source(self.sceneitem)
    if not self.source then
        log("SourceManager: Failed to get source from sceneitem")
        obs.obs_source_release(scene_source)
        return false
    end

    -- Capture original transform
    self.original_transform = self:capture_transform(self.sceneitem)

    -- Create crop filter
    if not crop_filter_create(self.source) then
        log("SourceManager: Failed to create crop filter")
        obs.obs_source_release(scene_source)
        return false
    end

    self.initialized = true
    log("SourceManager: Initialized with source: " .. source_name)

    obs.obs_source_release(scene_source)
    return true
end

-- Release all resources
function SourceManager:release()
    -- Clean up crop filter
    crop_filter_cleanup()

    -- Restore original transform if we have it
    if self.sceneitem and self.original_transform then
        self:restore_transform(self.sceneitem, self.original_transform)
        log("SourceManager: Restored original transform")
    end

    self.source = nil
    self.sceneitem = nil
    self.scene = nil
    self.original_transform = nil
    self.initialized = false

    log("SourceManager: Released")
end

-- Get source dimensions
function SourceManager:get_source_size()
    if not self.source then
        return 0, 0
    end
    return obs.obs_source_get_width(self.source), obs.obs_source_get_height(self.source)
end

-- Check if source is valid
function SourceManager:is_valid()
    return self.initialized and self.source ~= nil and self.sceneitem ~= nil
end

-- Get source info
function SourceManager:get_info()
    if not self:is_valid() then
        return nil
    end

    return {
        name = self.source_name,
        width = obs.obs_source_get_width(self.source),
        height = obs.obs_source_get_height(self.source),
    }
end

-- Get list of available capture sources
function SourceManager.get_available_sources()
    local sources = {}

    -- Get all sources
    local source_list = obs.obs_enum_sources()
    if source_list then
        for _, source in ipairs(source_list) do
            local source_id = obs.obs_source_get_id(source)
            local name = obs.obs_source_get_name(source)

            -- Filter for capture sources
            local is_capture = false
            if source_id == "monitor_capture" or      -- Display capture
               source_id == "window_capture" or       -- Window capture
               source_id == "game_capture" or         -- Game capture
               source_id == "xshm_input" or           -- Linux X11 capture
               source_id == "av_capture_input" then   -- macOS capture
                is_capture = true
            end

            if is_capture then
                table.insert(sources, {
                    name = name,
                    id = source_id,
                })
            end
        end
        obs.source_list_release(source_list)
    end

    return sources
end

-- Convenience wrapper functions
function source_manager_init(source_name)
    return SourceManager:init(source_name)
end

function source_manager_release()
    return SourceManager:release()
end

function source_manager_is_valid()
    return SourceManager:is_valid()
end

function source_manager_get_source()
    return SourceManager.source
end

function source_manager_get_sceneitem()
    return SourceManager.sceneitem
end

function source_manager_get_size()
    return SourceManager:get_source_size()
end

function source_manager_get_available_sources()
    return SourceManager.get_available_sources()
end

--================================================
-- MODULE: Camera Physics (M06)
--================================================
-- Handles camera position calculations, dead zones,
-- and SmoothDamp-based camera movement

local CameraPhysics = {
    -- Smoothed camera position
    pos = { x = 0, y = 0 },

    -- Velocities for SmoothDamp
    vel_x = { val = 0 },
    vel_y = { val = 0 },

    -- Dead zone state
    tracked_pos = { x = 0, y = 0 },
    dead_zone_active = false,

    -- Last camera position (for velocity calculation)
    last_pos = { x = 0, y = 0 },

    -- Monitor offset (for multi-monitor setups)
    monitor_offset = { x = 0, y = 0 },
}

-- Initialize camera tracking with starting position
function CameraPhysics:init(mouse_pos)
    if mouse_pos then
        self.pos.x = mouse_pos.x
        self.pos.y = mouse_pos.y
        self.tracked_pos.x = mouse_pos.x
        self.tracked_pos.y = mouse_pos.y
    end
    self.vel_x.val = 0
    self.vel_y.val = 0
    self.last_pos.x = self.pos.x
    self.last_pos.y = self.pos.y
end

-- Apply dead zone to mouse input
-- Returns the position the camera should track
function CameraPhysics:apply_dead_zone(mouse_pos, dead_zone_radius)
    if not mouse_pos then
        return self.tracked_pos
    end

    if dead_zone_radius <= 0 then
        self.tracked_pos.x = mouse_pos.x
        self.tracked_pos.y = mouse_pos.y
        return self.tracked_pos
    end

    -- Calculate distance from tracked position to mouse
    local dx = mouse_pos.x - self.tracked_pos.x
    local dy = mouse_pos.y - self.tracked_pos.y
    local dist = math.sqrt(dx * dx + dy * dy)

    if dist <= dead_zone_radius then
        -- Mouse is within dead zone, don't move tracked position
        self.dead_zone_active = true
        return self.tracked_pos
    end

    -- Mouse is outside dead zone
    -- Move tracked position so it stays exactly dead_zone_radius from mouse
    self.dead_zone_active = false
    local excess = dist - dead_zone_radius
    local nx = dx / dist  -- Normalized direction
    local ny = dy / dist

    self.tracked_pos.x = self.tracked_pos.x + nx * excess
    self.tracked_pos.y = self.tracked_pos.y + ny * excess

    return self.tracked_pos
end

-- Smooth the input position using SmoothDamp
function CameraPhysics:smooth_input(target_pos, smooth_time, dt)
    if not target_pos then
        return self.pos
    end

    local max_speed = 100000  -- Very high max speed for smooth camera

    self.pos.x = SmoothDamp(self.pos.x, target_pos.x, self.vel_x, smooth_time, max_speed, dt)
    self.pos.y = SmoothDamp(self.pos.y, target_pos.y, self.vel_y, smooth_time, max_speed, dt)

    return self.pos
end

-- Calculate the crop rectangle for a given zoom level and center position
function CameraPhysics:compute_crop(center_x, center_y, zoom_level, source_w, source_h)
    if zoom_level <= 1.0 then
        -- No zoom, return full source
        return {
            x = 0,
            y = 0,
            w = source_w,
            h = source_h,
        }
    end

    -- Calculate crop dimensions
    local crop_w = source_w / zoom_level
    local crop_h = source_h / zoom_level

    -- Center the crop on the target position
    local crop_x = center_x - crop_w / 2
    local crop_y = center_y - crop_h / 2

    -- Clamp to source bounds
    crop_x = clamp(0, source_w - crop_w, crop_x)
    crop_y = clamp(0, source_h - crop_h, crop_y)

    return {
        x = crop_x,
        y = crop_y,
        w = crop_w,
        h = crop_h,
    }
end

-- Calculate target crop for zoom animation
-- mouse_pos: current mouse position
-- zoom_level: target zoom level
-- source_w, source_h: source dimensions
-- monitor_offset: offset for multi-monitor (optional)
function CameraPhysics:get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
    if not mouse_pos then
        return nil
    end

    -- Apply monitor offset if provided
    local target_x = mouse_pos.x
    local target_y = mouse_pos.y

    if monitor_offset then
        target_x = target_x - monitor_offset.x
        target_y = target_y - monitor_offset.y
    end

    -- Clamp to source bounds
    target_x = clamp(0, source_w, target_x)
    target_y = clamp(0, source_h, target_y)

    return self:compute_crop(target_x, target_y, zoom_level, source_w, source_h)
end

-- Interpolate between two crop rectangles
function CameraPhysics:lerp_crop(start_crop, end_crop, t, easing_fn)
    if not start_crop or not end_crop then
        return nil
    end

    t = clamp(0, 1, t)

    -- Apply easing
    local eased_t = easing_fn and easing_fn(t) or t

    return {
        x = lerp(start_crop.x, end_crop.x, eased_t),
        y = lerp(start_crop.y, end_crop.y, eased_t),
        w = lerp(start_crop.w, end_crop.w, eased_t),
        h = lerp(start_crop.h, end_crop.h, eased_t),
    }
end

-- Get camera velocity (for motion blur)
function CameraPhysics:get_velocity()
    return {
        x = self.pos.x - self.last_pos.x,
        y = self.pos.y - self.last_pos.y,
    }
end

-- Update last position (call at end of frame)
function CameraPhysics:update_last_pos()
    self.last_pos.x = self.pos.x
    self.last_pos.y = self.pos.y
end

-- Set monitor offset
function CameraPhysics:set_monitor_offset(offset)
    self.monitor_offset = offset or { x = 0, y = 0 }
end

-- Reset camera state
function CameraPhysics:reset()
    self.pos = { x = 0, y = 0 }
    self.vel_x = { val = 0 }
    self.vel_y = { val = 0 }
    self.tracked_pos = { x = 0, y = 0 }
    self.dead_zone_active = false
    self.last_pos = { x = 0, y = 0 }
end

-- Convenience wrapper functions
function camera_physics_init(mouse_pos)
    return CameraPhysics:init(mouse_pos)
end

function camera_physics_apply_dead_zone(mouse_pos, dead_zone_radius)
    return CameraPhysics:apply_dead_zone(mouse_pos, dead_zone_radius)
end

function camera_physics_smooth_input(target_pos, smooth_time, dt)
    return CameraPhysics:smooth_input(target_pos, smooth_time, dt)
end

function camera_physics_compute_crop(center_x, center_y, zoom_level, source_w, source_h)
    return CameraPhysics:compute_crop(center_x, center_y, zoom_level, source_w, source_h)
end

function camera_physics_get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
    return CameraPhysics:get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
end

function camera_physics_lerp_crop(start_crop, end_crop, t, easing_fn)
    return CameraPhysics:lerp_crop(start_crop, end_crop, t, easing_fn)
end

function camera_physics_get_velocity()
    return CameraPhysics:get_velocity()
end

function camera_physics_update_last_pos()
    return CameraPhysics:update_last_pos()
end

function camera_physics_reset()
    return CameraPhysics:reset()
end

--================================================
-- MODULE: Timer & Main Loop (M09)
--================================================
-- Core integration module that handles frame-by-frame updates,
-- input processing, state machine updates, and output

-- Configuration (will be populated from settings)
local cfg = {
    source_name = "",
    zoom_value = 2.0,
    max_zoom = 10.0,
    zoom_duration = 0.6,
    zoom_overshoot = 0.0,
    zoom_easing = "Cubic.Out",

    auto_follow = true,
    follow_smooth_time = 0.15,
    follow_dead_zone = 5,

    debug_logs = false,
}

-- Timing
local last_tick_time = 0
local timer_running = false

-- Frame diff tracking (skip updates if nothing changed)
local last_output = { x = -1, y = -1, w = -1, h = -1 }

-- Original crop for zoom out
local original_crop = { x = 0, y = 0, w = 0, h = 0 }

-- Hotkey IDs
local hotkey_toggle_zoom = nil
local hotkey_toggle_follow = nil

-- Get reliable delta time
local function get_dt()
    local now = os.clock()
    local dt = now - last_tick_time
    last_tick_time = now
    return clamp(0.001, 0.1, dt)  -- Guard against freezes and div/zero
end

-- Start the timer
local function start_timer()
    if not timer_running then
        timer_running = true
        last_tick_time = os.clock()
        -- Use frame-synced interval
        local interval = 16  -- Default to ~60fps
        obs.timer_add(on_timer, interval)
        log("Timer: Started")
    end
end

-- Stop the timer
local function stop_timer()
    if timer_running then
        timer_running = false
        obs.timer_remove(on_timer)
        log("Timer: Stopped")
    end
end

-- Initialize mouse tracking
local function init_mouse_tracking(mouse_pos)
    camera_physics_init(mouse_pos)
    original_crop = {
        x = 0,
        y = 0,
        w = 0,
        h = 0,
    }
end

-- Main timer callback
function on_timer()
    local dt = get_dt()

    -- Guard: No valid source
    if not source_manager_is_valid() then
        return
    end

    --==========================
    -- 1. INPUT
    --==========================
    local raw_mouse = platform_get_mouse_pos()

    --==========================
    -- 2. STATE MACHINE UPDATE
    --==========================
    if SM:is_animating() then
        SM.zoom_time = SM.zoom_time + (dt / cfg.zoom_duration)

        -- Check for completion
        if SM.zoom_time >= 1.0 then
            SM:complete()

            -- Auto-enable follow after zoom in
            if SM.state == ZoomState.ZOOMED_IN and cfg.auto_follow then
                SM.following = true
            end

            -- Stop timer if idle
            if SM.state == ZoomState.IDLE then
                stop_timer()
            end
        end
    end

    --==========================
    -- 3. CAMERA POSITION
    --==========================
    local crop = nil
    local source_w, source_h = source_manager_get_size()

    if source_w == 0 or source_h == 0 then
        return
    end

    if SM:is_animating() then
        -- Animate between start and target crop
        local easing_fn = Easing.get(cfg.zoom_easing, cfg.zoom_overshoot)
        crop = camera_physics_lerp_crop(SM.start_crop, SM.target_crop, SM.zoom_time, easing_fn)
    elseif SM:is_zoomed() and SM.following then
        -- Follow mouse with dead zone and smoothing
        local tracked = camera_physics_apply_dead_zone(raw_mouse, cfg.follow_dead_zone)
        local smoothed = camera_physics_smooth_input(tracked, cfg.follow_smooth_time, dt)
        crop = camera_physics_compute_crop(smoothed.x, smoothed.y, SM.zoom_level, source_w, source_h)
        camera_physics_update_last_pos()
    elseif SM:is_zoomed() then
        -- Static zoom (not following)
        crop = camera_physics_get_target_crop(
            { x = SM.target_crop.x + SM.target_crop.w / 2, y = SM.target_crop.y + SM.target_crop.h / 2 },
            SM.zoom_level, source_w, source_h, nil
        )
    end

    --==========================
    -- 4. OUTPUT (Diff-based)
    --==========================
    if crop then
        local cx = math.floor(crop.x)
        local cy = math.floor(crop.y)
        local cw = math.floor(crop.w)
        local ch = math.floor(crop.h)

        if cx ~= last_output.x or cy ~= last_output.y or
           cw ~= last_output.w or ch ~= last_output.h then
            crop_filter_update(cx, cy, cw, ch)
            last_output.x = cx
            last_output.y = cy
            last_output.w = cw
            last_output.h = ch
        end
    end
end

--==========================
-- HOTKEY HANDLERS
--==========================

function on_toggle_zoom(pressed)
    if not pressed then return end

    if not source_manager_is_valid() then
        log("Toggle Zoom: No valid source")
        return
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        log("Toggle Zoom: Invalid source dimensions")
        return
    end

    if SM.state == ZoomState.IDLE then
        -- ZOOM IN
        local mouse = platform_get_mouse_pos()
        init_mouse_tracking(mouse)

        -- Store original crop
        original_crop = { x = 0, y = 0, w = source_w, h = source_h }

        -- Calculate target crop
        local target_crop = camera_physics_get_target_crop(mouse, cfg.zoom_value, source_w, source_h, nil)

        SM:transition(ZoomState.ZOOMING_IN, {
            start_crop = original_crop,
            target_crop = target_crop,
            target_level = cfg.zoom_value
        })

        start_timer()

    elseif SM.state == ZoomState.ZOOMED_IN then
        -- ZOOM OUT
        SM.following = false

        local current = crop_filter_get_crop()
        SM:transition(ZoomState.ZOOMING_OUT, {
            start_crop = current,
            target_crop = original_crop,
            target_level = 1.0
        })

        start_timer()
    end
    -- Ignore if already animating (guard against rapid presses)
end

function on_toggle_follow(pressed)
    if not pressed then return end
    if not SM:is_zoomed() then return end

    SM.following = not SM.following
    log("Follow: " .. tostring(SM.following))

    if SM.following and not timer_running then
        start_timer()
    end
end

--==========================
-- HOTKEY REGISTRATION
--==========================

local function register_hotkeys(settings)
    -- Toggle Zoom hotkey
    hotkey_toggle_zoom = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.toggle_zoom",
        "Toggle Zoom to Mouse",
        on_toggle_zoom
    )

    -- Toggle Follow hotkey
    hotkey_toggle_follow = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.toggle_follow",
        "Toggle Mouse Follow",
        on_toggle_follow
    )

    -- Load saved hotkey bindings
    local toggle_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.toggle_zoom")
    if toggle_array then
        obs.obs_hotkey_load(hotkey_toggle_zoom, toggle_array)
        obs.obs_data_array_release(toggle_array)
    end

    local follow_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.toggle_follow")
    if follow_array then
        obs.obs_hotkey_load(hotkey_toggle_follow, follow_array)
        obs.obs_data_array_release(follow_array)
    end

    -- Register scroll zoom hotkeys
    register_scroll_hotkeys(settings)

    log("Hotkeys: Registered")
end

local function save_hotkeys(settings)
    if hotkey_toggle_zoom then
        local array = obs.obs_hotkey_save(hotkey_toggle_zoom)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.toggle_zoom", array)
        obs.obs_data_array_release(array)
    end

    if hotkey_toggle_follow then
        local array = obs.obs_hotkey_save(hotkey_toggle_follow)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.toggle_follow", array)
        obs.obs_data_array_release(array)
    end

    -- Save scroll zoom hotkeys
    save_scroll_hotkeys(settings)
end

local function unregister_hotkeys()
    if hotkey_toggle_zoom then
        obs.obs_hotkey_unregister(hotkey_toggle_zoom)
        hotkey_toggle_zoom = nil
    end
    if hotkey_toggle_follow then
        obs.obs_hotkey_unregister(hotkey_toggle_follow)
        hotkey_toggle_follow = nil
    end
    -- Unregister scroll zoom hotkeys
    unregister_scroll_hotkeys()
    log("Hotkeys: Unregistered")
end

--==========================
-- SCENE EVENT HANDLERS
--==========================

function on_frontend_event(event)
    if event == obs.OBS_FRONTEND_EVENT_SCENE_CHANGED then
        -- Scene changed, re-acquire source
        log("Event: Scene changed")

        -- Handle scene memory
        scene_memory_on_scene_change()

        if cfg.source_name and cfg.source_name ~= "" then
            source_manager_release()
            source_manager_init(cfg.source_name)
        end
    elseif event == obs.OBS_FRONTEND_EVENT_EXIT then
        -- OBS is closing
        log("Event: OBS exiting")
        stop_timer()
        source_manager_release()
    end
end

--==========================
-- CONFIGURATION UPDATE
--==========================

local function update_config(settings)
    cfg.source_name = obs.obs_data_get_string(settings, "source") or ""
    cfg.zoom_value = obs.obs_data_get_double(settings, "zoom_value")
    cfg.zoom_duration = obs.obs_data_get_double(settings, "zoom_duration")
    cfg.zoom_overshoot = obs.obs_data_get_double(settings, "zoom_overshoot")
    cfg.zoom_easing = obs.obs_data_get_string(settings, "zoom_easing") or "Cubic.Out"

    cfg.auto_follow = obs.obs_data_get_bool(settings, "auto_follow")
    cfg.follow_smooth_time = obs.obs_data_get_double(settings, "follow_smooth_time")
    cfg.follow_dead_zone = obs.obs_data_get_int(settings, "follow_dead_zone")

    cfg.debug_logs = obs.obs_data_get_bool(settings, "debug_logs")
    debug_logs = cfg.debug_logs

    -- Update scroll zoom config
    update_scroll_config(settings)

    -- Check if source changed
    local current_source = source_manager_is_valid() and cfg.source_name
    if cfg.source_name ~= "" and cfg.source_name ~= current_source then
        -- Reset state and reinitialize
        SM:reset()
        stop_timer()
        source_manager_release()
        source_manager_init(cfg.source_name)
    end
end

--================================================
-- MODULE: Scroll Zoom (M10)
--================================================
-- Enables gradual zoom control via scroll wheel with modifier key
-- Provides dynamic zoom level adjustment during zoomed state

local ScrollZoom = {
    -- Hotkey IDs for scroll zoom
    hotkey_scroll_up = nil,
    hotkey_scroll_down = nil,

    -- Configuration (populated from settings)
    scroll_step = 0.25,
    scroll_modifier = "ctrl",  -- "ctrl", "alt", "shift"
}

-- Check if modifier key is held
local function is_modifier_held()
    if ScrollZoom.scroll_modifier == "ctrl" then
        return platform_is_ctrl_held()
    elseif ScrollZoom.scroll_modifier == "alt" then
        return platform_is_alt_held()
    elseif ScrollZoom.scroll_modifier == "shift" then
        return platform_is_shift_held()
    end
    return false
end

-- Handle scroll zoom in
function on_scroll_zoom_up(pressed)
    if not pressed then return end
    on_scroll_zoom(1)
end

-- Handle scroll zoom out
function on_scroll_zoom_down(pressed)
    if not pressed then return end
    on_scroll_zoom(-1)
end

-- Main scroll zoom handler
function on_scroll_zoom(direction)
    -- Check if we can scroll
    if not SM:can_scroll() then return end

    -- Check modifier (optional - can be configured)
    -- For now, we rely on OBS hotkey bindings which can include modifiers

    if not source_manager_is_valid() then
        log("Scroll Zoom: No valid source")
        return
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        return
    end

    -- Calculate new zoom level
    local step = ScrollZoom.scroll_step * direction  -- e.g., 0.25
    local new_level

    if SM.state == ZoomState.IDLE then
        -- Starting from unzoomed
        new_level = 1.0 + step
    else
        -- Already zoomed, adjust level
        new_level = SM.target_level + step
    end

    -- Clamp to valid range
    new_level = clamp(1.0, cfg.max_zoom, new_level)

    -- If we hit 1.0, fully zoom out
    if new_level <= 1.0 then
        if SM:is_zoomed() then
            -- Trigger full zoom out
            local current = crop_filter_get_crop()
            SM.following = false
            SM:transition(ZoomState.ZOOMING_OUT, {
                start_crop = current,
                target_crop = original_crop,
                target_level = 1.0
            })
            start_timer()
        end
        return
    end

    -- Get current mouse position
    local mouse = platform_get_mouse_pos()

    -- Calculate new target crop for new zoom level
    local target_crop = camera_physics_get_target_crop(mouse, new_level, source_w, source_h, nil)

    -- Get current crop as start
    local start_crop
    if SM:is_animating() then
        -- Use current interpolated crop
        start_crop = crop_filter_get_crop()
    elseif SM:is_zoomed() then
        -- Use current crop
        start_crop = crop_filter_get_crop()
    else
        -- Starting from unzoomed
        start_crop = { x = 0, y = 0, w = source_w, h = source_h }
        original_crop = start_crop
        camera_physics_init(mouse)
    end

    -- Transition to new zoom level
    if SM.state == ZoomState.IDLE then
        -- First scroll from unzoomed
        SM:transition(ZoomState.SCROLLING, {
            start_crop = start_crop,
            target_crop = target_crop,
            target_level = new_level
        })
    else
        -- Already zoomed, adjust level (interrupt current animation)
        SM:transition(ZoomState.SCROLLING, {
            start_crop = start_crop,
            target_crop = target_crop,
            target_level = new_level
        })
    end

    start_timer()
    log("Scroll Zoom: Level " .. string.format("%.2f", new_level))
end

-- Zoom to a specific level (for API calls)
function on_scroll_zoom_to(level)
    if not source_manager_is_valid() then return end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then return end

    level = clamp(1.0, cfg.max_zoom, level)

    if level <= 1.0 then
        -- Zoom out
        if SM:is_zoomed() then
            local current = crop_filter_get_crop()
            SM.following = false
            SM:transition(ZoomState.ZOOMING_OUT, {
                start_crop = current,
                target_crop = original_crop,
                target_level = 1.0
            })
            start_timer()
        end
        return
    end

    local mouse = platform_get_mouse_pos()
    local target_crop = camera_physics_get_target_crop(mouse, level, source_w, source_h, nil)

    local start_crop
    if SM:is_zoomed() then
        start_crop = crop_filter_get_crop()
    else
        start_crop = { x = 0, y = 0, w = source_w, h = source_h }
        original_crop = start_crop
        camera_physics_init(mouse)
    end

    SM:transition(ZoomState.SCROLLING, {
        start_crop = start_crop,
        target_crop = target_crop,
        target_level = level
    })

    start_timer()
end

-- Register scroll zoom hotkeys
local function register_scroll_hotkeys(settings)
    -- Scroll Up hotkey
    ScrollZoom.hotkey_scroll_up = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.scroll_up",
        "Zoom In (Scroll)",
        on_scroll_zoom_up
    )

    -- Scroll Down hotkey
    ScrollZoom.hotkey_scroll_down = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.scroll_down",
        "Zoom Out (Scroll)",
        on_scroll_zoom_down
    )

    -- Load saved bindings
    local up_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.scroll_up")
    if up_array then
        obs.obs_hotkey_load(ScrollZoom.hotkey_scroll_up, up_array)
        obs.obs_data_array_release(up_array)
    end

    local down_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.scroll_down")
    if down_array then
        obs.obs_hotkey_load(ScrollZoom.hotkey_scroll_down, down_array)
        obs.obs_data_array_release(down_array)
    end

    log("Scroll Zoom: Hotkeys registered")
end

-- Save scroll hotkey bindings
local function save_scroll_hotkeys(settings)
    if ScrollZoom.hotkey_scroll_up then
        local array = obs.obs_hotkey_save(ScrollZoom.hotkey_scroll_up)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.scroll_up", array)
        obs.obs_data_array_release(array)
    end

    if ScrollZoom.hotkey_scroll_down then
        local array = obs.obs_hotkey_save(ScrollZoom.hotkey_scroll_down)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.scroll_down", array)
        obs.obs_data_array_release(array)
    end
end

-- Unregister scroll hotkeys
local function unregister_scroll_hotkeys()
    if ScrollZoom.hotkey_scroll_up then
        obs.obs_hotkey_unregister(ScrollZoom.hotkey_scroll_up)
        ScrollZoom.hotkey_scroll_up = nil
    end
    if ScrollZoom.hotkey_scroll_down then
        obs.obs_hotkey_unregister(ScrollZoom.hotkey_scroll_down)
        ScrollZoom.hotkey_scroll_down = nil
    end
end

-- Update scroll zoom config
local function update_scroll_config(settings)
    ScrollZoom.scroll_step = obs.obs_data_get_double(settings, "scroll_step")
    ScrollZoom.scroll_modifier = obs.obs_data_get_string(settings, "scroll_modifier") or "ctrl"
end

--================================================
-- PLACEHOLDER: Future Modules
--================================================

-- M01: Configuration & Settings (TODO)
-- M05: Scene Manager (TODO)
-- M06: Source Manager (TODO)
-- M07: Crop/Zoom Controller (TODO)
-- M08: Motion Tracker (TODO)
-- M09: Face Detection (TODO)
-- M11: Audio Reactor (TODO)
-- M12: Transition Manager (TODO)
-- M13: Animation Controller (TODO)
-- M14: Preset Manager (TODO)
-- M15: Hotkey Manager (TODO)
-- M16: UI Components (TODO)
-- M17: Timer/Scheduler (TODO)
-- M18: State Machine (TODO)
-- M19: Performance Monitor (TODO)

--================================================
-- SCRIPT SETTINGS
--================================================
local settings = {}

-- Default settings
local defaults = {
    debug_logging = false,
    easing_type = "QuadInOut",
    smooth_time = 0.3,
    max_speed = 100.0
}

--================================================
-- MODULE: Preset Manager (M13)
--================================================
-- Manages built-in and custom animation presets

local PresetManager = {
    -- Built-in presets (read-only)
    built_in = {
        {
            name = "Smooth",
            duration = 0.8,
            overshoot = 0.0,
            smoothness = 0.25,
            easing = "Cubic.Out",
        },
        {
            name = "Bounce",
            duration = 0.6,
            overshoot = 0.35,
            smoothness = 0.15,
            easing = "Back.Out",
        },
        {
            name = "Snappy",
            duration = 0.3,
            overshoot = 0.0,
            smoothness = 0.05,
            easing = "Expo.Out",
        },
        {
            name = "Cinematic",
            duration = 1.2,
            overshoot = 0.05,
            smoothness = 0.4,
            easing = "Sine.Out",
        },
    },

    -- Custom user presets
    custom = {},

    -- Currently selected preset name
    current_preset = "Smooth",
}

-- Get all preset names (built-in + custom)
function PresetManager:get_all_names()
    local names = {}

    -- Add built-in presets
    for _, preset in ipairs(self.built_in) do
        table.insert(names, preset.name)
    end

    -- Add custom presets
    for name, _ in pairs(self.custom) do
        table.insert(names, name)
    end

    table.sort(names)
    return names
end

-- Get preset by name
function PresetManager:get_preset(name)
    -- Check built-in first
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            return preset
        end
    end

    -- Check custom
    if self.custom[name] then
        return self.custom[name]
    end

    -- Default to Smooth
    return self.built_in[1]
end

-- Apply preset to configuration
function PresetManager:apply_preset(name)
    local preset = self:get_preset(name)
    if not preset then
        log("Preset: Unknown preset: " .. name)
        return false
    end

    cfg.zoom_duration = preset.duration
    cfg.zoom_overshoot = preset.overshoot
    cfg.follow_smooth_time = preset.smoothness

    if preset.easing then
        cfg.zoom_easing = preset.easing
    end

    self.current_preset = name
    log("Preset: Applied '" .. name .. "'")
    return true
end

-- Save a custom preset
function PresetManager:save_preset(name, duration, overshoot, smoothness, easing)
    if not name or name == "" then
        return false
    end

    -- Check if it's a built-in preset (can't override)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            log("Preset: Cannot override built-in preset: " .. name)
            return false
        end
    end

    -- Save custom preset
    self.custom[name] = {
        name = name,
        duration = duration or cfg.zoom_duration,
        overshoot = overshoot or cfg.zoom_overshoot,
        smoothness = smoothness or cfg.follow_smooth_time,
        easing = easing or cfg.zoom_easing,
    }

    log("Preset: Saved custom preset '" .. name .. "'")
    return true
end

-- Delete a custom preset
function PresetManager:delete_preset(name)
    -- Check if it's a built-in preset (can't delete)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            log("Preset: Cannot delete built-in preset: " .. name)
            return false
        end
    end

    -- Delete custom preset
    if self.custom[name] then
        self.custom[name] = nil
        log("Preset: Deleted custom preset '" .. name .. "'")
        return true
    end

    return false
end

-- Check if a preset is built-in
function PresetManager:is_built_in(name)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            return true
        end
    end
    return false
end

-- Persist custom presets to settings
function PresetManager:persist(settings)
    local array = obs.obs_data_array_create()

    for name, preset in pairs(self.custom) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "name", name)
        obs.obs_data_set_double(item, "duration", preset.duration)
        obs.obs_data_set_double(item, "overshoot", preset.overshoot)
        obs.obs_data_set_double(item, "smoothness", preset.smoothness)
        obs.obs_data_set_string(item, "easing", preset.easing)
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "custom_presets", array)
    obs.obs_data_array_release(array)
end

-- Load custom presets from settings
function PresetManager:load(settings)
    self.custom = {}

    local array = obs.obs_data_get_array(settings, "custom_presets")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local name = obs.obs_data_get_string(item, "name")

        if name and name ~= "" then
            self.custom[name] = {
                name = name,
                duration = obs.obs_data_get_double(item, "duration"),
                overshoot = obs.obs_data_get_double(item, "overshoot"),
                smoothness = obs.obs_data_get_double(item, "smoothness"),
                easing = obs.obs_data_get_string(item, "easing"),
            }
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)
    log("Preset: Loaded " .. self:get_custom_count() .. " custom presets")
end

-- Get count of custom presets
function PresetManager:get_custom_count()
    local count = 0
    for _, _ in pairs(self.custom) do
        count = count + 1
    end
    return count
end

-- Get current preset name
function PresetManager:get_current_name()
    return self.current_preset
end

-- Set current preset name
function PresetManager:set_current_name(name)
    self.current_preset = name
end

-- Check if current preset is custom
function PresetManager:is_current_custom()
    return not self:is_built_in(self.current_preset)
end

-- Global convenience functions
function preset_get_all_names()
    return PresetManager:get_all_names()
end

function preset_apply(name)
    return PresetManager:apply_preset(name)
end

function preset_save(name, duration, overshoot, smoothness, easing)
    return PresetManager:save_preset(name, duration, overshoot, smoothness, easing)
end

function preset_delete(name)
    return PresetManager:delete_preset(name)
end

function preset_is_built_in(name)
    return PresetManager:is_built_in(name)
end

function preset_get_current()
    return PresetManager:get_current_name()
end

--================================================
-- MODULE: Auto Source Detection (M11)
--================================================
-- Automatically detects and selects the best zoom source on first run

local AutoSourceDetector = {
    -- Source type priorities (higher = more likely to be the main display)
    type_priorities = {
        ["monitor_capture"] = 100,     -- Display capture (highest priority)
        ["game_capture"] = 80,          -- Game capture
        ["window_capture"] = 60,        -- Window capture
        ["xshm_input"] = 40,           -- Linux X11 capture
        ["av_capture_input"] = 20,     -- macOS capture
    },

    -- Whether auto-detection has been run
    auto_detected = false,
}

-- Get all capture sources sorted by priority
function AutoSourceDetector:get_capture_sources()
    local sources = {}
    local source_list = obs.obs_enum_sources()

    if not source_list then
        return sources
    end

    for _, source in ipairs(source_list) do
        local source_id = obs.obs_source_get_id(source)
        local name = obs.obs_source_get_name(source)

        -- Check if it's a capture source
        local priority = self.type_priorities[source_id]
        if priority then
            table.insert(sources, {
                name = name,
                id = source_id,
                priority = priority,
            })
        end
    end

    obs.source_list_release(source_list)

    -- Sort by priority (highest first)
    table.sort(sources, function(a, b)
        return a.priority > b.priority
    end)

    return sources
end

-- Auto-detect the best source
function AutoSourceDetector:auto_detect()
    local sources = self:get_capture_sources()

    if #sources == 0 then
        log("AutoSource: No capture sources found")
        return nil
    end

    if #sources == 1 then
        -- Only one source, use it
        log("AutoSource: Found single source: " .. sources[1].name)
        return sources[1].name
    end

    -- Multiple sources - prioritize by type
    -- Prefer monitor_capture > game_capture > window_capture
    local best = sources[1]

    log("AutoSource: Found " .. #sources .. " sources, selecting: " .. best.name)
    return best.name
end

-- Get monitor geometry from a source (if available)
function AutoSourceDetector:get_monitor_geometry(source_name)
    local source = obs.obs_get_source_by_name(source_name)
    if not source then
        return nil
    end

    local settings = obs.obs_source_get_settings(source)
    if not settings then
        obs.obs_source_release(source)
        return nil
    end

    -- Try to get monitor info from settings
    local monitor = obs.obs_data_get_int(settings, "monitor")
    local x = obs.obs_data_get_int(settings, "x")
    local y = obs.obs_data_get_int(settings, "y")
    local width = obs.obs_data_get_int(settings, "width")
    local height = obs.obs_data_get_int(settings, "height")

    obs.obs_data_release(settings)
    obs.obs_source_release(source)

    -- Return geometry if available
    if monitor >= 0 or width > 0 then
        return {
            monitor = monitor,
            x = x,
            y = y,
            width = width or 1920,
            height = height or 1080,
        }
    end

    return nil
end

-- Check if we should auto-detect on first run
function AutoSourceDetector:should_auto_detect(settings)
    -- Check if source has ever been set
    local last_source = obs.obs_data_get_string(settings, "source")
    if last_source and last_source ~= "" then
        return false
    end

    -- Check if auto-detect has been done
    return not self.auto_detected
end

-- Run auto-detection and return the source name
function AutoSourceDetector:run(settings)
    local source_name = self:auto_detect()

    if source_name then
        -- Save the detected source
        obs.obs_data_set_string(settings, "source", source_name)
        self.auto_detected = true
    end

    return source_name
end

-- Global convenience functions
function auto_source_detect()
    return AutoSourceDetector:auto_detect()
end

function auto_source_should_detect(settings)
    return AutoSourceDetector:should_auto_detect(settings)
end

function auto_source_run(settings)
    return AutoSourceDetector:run(settings)
end

--================================================
-- MODULE: Scene Memory (M12)
--================================================
-- Remembers which zoom source to use for each OBS scene

local SceneMemory = {
    -- Scene to source mapping
    scene_source_map = {},

    -- Maximum number of mappings to store
    max_mappings = 50,
}

-- Get the current scene name
function SceneMemory:get_current_scene_name()
    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then
        return nil
    end

    local name = obs.obs_source_get_name(scene_source)
    obs.obs_source_release(scene_source)
    return name
end

-- Get the source to use for the current scene
function SceneMemory:get_source_for_current_scene()
    local scene_name = self:get_current_scene_name()
    if not scene_name then
        return nil
    end

    -- 1. Check explicit mapping for this scene
    if self.scene_source_map[scene_name] then
        return self.scene_source_map[scene_name]
    end

    -- 2. Fall back to global source from config
    return cfg.source_name
end

-- Set the source for a specific scene
function SceneMemory:set(scene_name, source_name)
    if not scene_name or scene_name == "" then
        return false
    end

    -- Check if we're at capacity
    local count = 0
    for _, _ in pairs(self.scene_source_map) do
        count = count + 1
    end

    if count >= self.max_mappings and not self.scene_source_map[scene_name] then
        log("SceneMemory: At capacity (" .. self.max_mappings .. "), cannot add: " .. scene_name)
        return false
    end

    self.scene_source_map[scene_name] = source_name
    log("SceneMemory: " .. scene_name .. " Ã¢â€ â€™ " .. source_name)
    return true
end

-- Remove a scene mapping
function SceneMemory:remove(scene_name)
    if self.scene_source_map[scene_name] then
        self.scene_source_map[scene_name] = nil
        log("SceneMemory: Removed mapping for " .. scene_name)
        return true
    end
    return false
end

-- Get all scene mappings
function SceneMemory:get_all()
    local mappings = {}
    for scene, source in pairs(self.scene_source_map) do
        table.insert(mappings, { scene = scene, source = source })
    end
    table.sort(mappings, function(a, b)
        return a.scene < b.scene
    end)
    return mappings
end

-- Check if a scene has a mapping
function SceneMemory:has_mapping(scene_name)
    return self.scene_source_map[scene_name] ~= nil
end

-- Persist mappings to settings
function SceneMemory:persist(settings)
    local array = obs.obs_data_array_create()

    for scene, source in pairs(self.scene_source_map) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "scene", scene)
        obs.obs_data_set_string(item, "source", source)
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "scene_source_map", array)
    obs.obs_data_array_release(array)
end

-- Load mappings from settings
function SceneMemory:load(settings)
    self.scene_source_map = {}

    local array = obs.obs_data_get_array(settings, "scene_source_map")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local scene = obs.obs_data_get_string(item, "scene")
        local source = obs.obs_data_get_string(item, "source")

        if scene and scene ~= "" and source and source ~= "" then
            self.scene_source_map[scene] = source
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)

    local count = 0
    for _, _ in pairs(self.scene_source_map) do count = count + 1 end
    log("SceneMemory: Loaded " .. count .. " scene mappings")
end

-- Handle scene change
function SceneMemory:on_scene_change()
    local scene_name = self:get_current_scene_name()
    if not scene_name then
        return
    end

    -- Get the source for this scene
    local source_name = self:get_source_for_current_scene()

    if source_name and source_name ~= "" then
        -- Check if source changed
        local current = source_manager_is_valid() and cfg.source_name

        if source_name ~= current then
            log("SceneMemory: Scene changed to " .. scene_name)

            -- Release current source
            source_manager_release()

            -- Initialize with new source
            cfg.source_name = source_name
            source_manager_init(source_name)
        end
    end
end

-- Global convenience functions
function scene_memory_get_source()
    return SceneMemory:get_source_for_current_scene()
end

function scene_memory_set(scene_name, source_name)
    return SceneMemory:set(scene_name, source_name)
end

function scene_memory_remove(scene_name)
    return SceneMemory:remove(scene_name)
end

function scene_memory_get_all()
    return SceneMemory:get_all()
end

function scene_memory_on_scene_change()
    return SceneMemory:on_scene_change()
end

--================================================
-- MODULE: Blur Manager (M14)
--================================================
-- Provides built-in blur effects without external plugins
-- Supports multiple strategies: shader, composite_blur plugin, or none

local BlurManager = {
    -- Current strategy: "shader", "composite_blur", "none"
    strategy = "none",

    -- Filter references
    zoom_blur_filter = nil,
    motion_blur_filter = nil,

    -- Settings references
    zoom_blur_settings = nil,
    motion_blur_settings = nil,

    -- State
    initialized = false,

    -- Configuration
    zoom_blur_enabled = false,
    zoom_blur_intensity = 5,
    zoom_blur_clear_radius = 150,
    motion_blur_enabled = false,
    motion_blur_intensity = 1.0,
}

-- Try to use custom shader (if effect files exist)
function BlurManager:try_shader_strategy(source)
    -- This would require .effect files in assets/shaders/
    -- For now, we'll use a simpler approach
    log("Blur: Shader strategy not implemented (requires effect files)")
    return false
end

-- Try to auto-create Composite Blur filters
function BlurManager:try_composite_blur_strategy(source)
    if not source then return false end

    -- Check if composite_blur filter type exists
    local test_filter = obs.obs_source_create_private("composite_blur", "__test_blur__", nil)
    if test_filter then
        obs.obs_source_release(test_filter)
    else
        log("Blur: Composite Blur plugin not available")
        return false
    end

    -- Create Zoom Blur filter
    local zs = obs.obs_data_create()
    obs.obs_data_set_double(zs, "radius", 0)
    obs.obs_data_set_int(zs, "blur_type", 2) -- Zoom type
    self.zoom_blur_filter = obs.obs_source_create_private(
        "composite_blur",
        FILTER_PREFIX .. "Zoom Blur",
        zs
    )

    if self.zoom_blur_filter then
        obs.obs_source_filter_add(source, self.zoom_blur_filter)
        self.zoom_blur_settings = zs
    else
        obs.obs_data_release(zs)
        return false
    end

    -- Create Motion Blur filter
    local ms = obs.obs_data_create()
    obs.obs_data_set_double(ms, "radius", 0)
    obs.obs_data_set_int(ms, "blur_type", 3) -- Motion/directional type
    self.motion_blur_filter = obs.obs_source_create_private(
        "composite_blur",
        FILTER_PREFIX .. "Motion Blur",
        ms
    )

    if self.motion_blur_filter then
        obs.obs_source_filter_add(source, self.motion_blur_filter)
        self.motion_blur_settings = ms
    else
        obs.obs_data_release(ms)
    end

    self.initialized = true
    return true
end

-- Initialize blur manager
function BlurManager:init(source)
    if not source then
        return false
    end

    self:cleanup()

    -- Try composite_blur strategy
    if self:try_composite_blur_strategy(source) then
        self.strategy = "composite_blur"
        log("Blur: Using Composite Blur plugin (auto-configured)")
        return true
    end

    -- No blur available
    self.strategy = "none"
    log("Blur: No blur backend available. Blur effects disabled.")
    return false
end

-- Update blur based on zoom state
function BlurManager:update(state_machine, crop, camera_velocity)
    if not self.initialized then return end
    if self.strategy == "none" then return end

    -- Zoom Blur: Active during zoom transitions
    if self.zoom_blur_enabled and self.zoom_blur_filter then
        local radius = 0

        if state_machine:is_animating() and
           (state_machine.state == ZoomState.ZOOMING_IN or
            state_machine.state == ZoomState.ZOOMING_OUT) then
            -- Bell curve: 0 at start Ã¢â€ â€™ peak at 50% Ã¢â€ â€™ 0 at end
            local t = clamp(0, 1, state_machine.zoom_time)
            local curve = math.sin(t * math.pi)
            radius = curve * curve * self.zoom_blur_intensity
        end

        self:set_zoom_blur(radius, crop)
    end

    -- Motion Blur: Active during camera panning (not during zoom transition)
    if self.motion_blur_enabled and self.motion_blur_filter then
        if not state_machine:is_animating() and state_machine:is_zoomed() and camera_velocity then
            local speed = math.sqrt(
                camera_velocity.x * camera_velocity.x +
                camera_velocity.y * camera_velocity.y
            )

            if speed > 1.0 then
                local radius = math.min(10, speed * self.motion_blur_intensity * 0.5)
                local angle = math.deg(math.atan2(camera_velocity.y, camera_velocity.x))
                self:set_motion_blur(radius, angle)
            else
                self:set_motion_blur(0, 0)
            end
        else
            self:set_motion_blur(0, 0)
        end
    end
end

-- Set zoom blur parameters
function BlurManager:set_zoom_blur(radius, crop)
    if self.strategy == "composite_blur" and self.zoom_blur_settings then
        obs.obs_data_set_double(self.zoom_blur_settings, "radius", radius)

        if crop then
            local cx = crop.x + (crop.w / 2)
            local cy = crop.y + (crop.h / 2)
            obs.obs_data_set_double(self.zoom_blur_settings, "center_x", cx)
            obs.obs_data_set_double(self.zoom_blur_settings, "center_y", cy)
        end

        obs.obs_data_set_double(self.zoom_blur_settings, "inactive_radius", self.zoom_blur_clear_radius)
        obs.obs_source_update(self.zoom_blur_filter, self.zoom_blur_settings)
    end
end

-- Set motion blur parameters
function BlurManager:set_motion_blur(radius, angle)
    if self.strategy == "composite_blur" and self.motion_blur_settings then
        obs.obs_data_set_double(self.motion_blur_settings, "radius", radius)
        obs.obs_data_set_double(self.motion_blur_settings, "angle", angle)
        obs.obs_source_update(self.motion_blur_filter, self.motion_blur_settings)
    end
end

-- Update configuration
function BlurManager:update_config(settings)
    self.zoom_blur_enabled = obs.obs_data_get_bool(settings, "zoom_blur_enabled")
    self.zoom_blur_intensity = obs.obs_data_get_double(settings, "zoom_blur_intensity")
    self.zoom_blur_clear_radius = obs.obs_data_get_double(settings, "zoom_blur_clear_radius")
    self.motion_blur_enabled = obs.obs_data_get_bool(settings, "motion_blur_enabled")
    self.motion_blur_intensity = obs.obs_data_get_double(settings, "motion_blur_intensity")
end

-- Cleanup filters
function BlurManager:cleanup()
    local source = source_manager_get_source()

    if self.zoom_blur_filter and source then
        obs.obs_source_filter_remove(source, self.zoom_blur_filter)
        obs.obs_source_release(self.zoom_blur_filter)
        self.zoom_blur_filter = nil
    end

    if self.motion_blur_filter and source then
        obs.obs_source_filter_remove(source, self.motion_blur_filter)
        obs.obs_source_release(self.motion_blur_filter)
        self.motion_blur_filter = nil
    end

    if self.zoom_blur_settings then
        obs.obs_data_release(self.zoom_blur_settings)
        self.zoom_blur_settings = nil
    end

    if self.motion_blur_settings then
        obs.obs_data_release(self.motion_blur_settings)
        self.motion_blur_settings = nil
    end

    self.initialized = false
    self.strategy = "none"
end

-- Check if blur is available
function BlurManager:is_available()
    return self.strategy ~= "none"
end

-- Global convenience functions
function blur_manager_init(source)
    return BlurManager:init(source)
end

function blur_manager_update(state_machine, crop, camera_velocity)
    return BlurManager:update(state_machine, crop, camera_velocity)
end

function blur_manager_update_config(settings)
    return BlurManager:update_config(settings)
end

function blur_manager_cleanup()
    return BlurManager:cleanup()
end

function blur_manager_is_available()
    return BlurManager:is_available()
end

--================================================
-- MODULE: Cursor Asset Manager (M16)
--================================================
-- Handles extracting and managing cursor image assets

local CursorAssets = {
    extracted = false,
    dir = nil,
}

-- Get the platform-specific asset directory
function CursorAssets:get_platform_dir()
    if IS_WINDOWS then
        local appdata = os.getenv("APPDATA")
        return appdata and (appdata .. "\\obs-studio\\obs-zoom-pro\\cursors") or nil
    elseif IS_LINUX then
        local home = os.getenv("HOME")
        return home and (home .. "/.config/obs-studio/obs-zoom-pro/cursors") or nil
    elseif IS_MACOS then
        local home = os.getenv("HOME")
        return home and (home .. "/Library/Application Support/obs-studio/obs-zoom-pro/cursors") or nil
    end
    -- Fallback for non-FFI environments
    return "cursors"
end

-- Ensure assets are extracted
function CursorAssets:ensure_extracted()
    if self.extracted then
        return self.dir
    end

    local dir = self:get_platform_dir()
    if not dir then
        log("CursorAssets: Could not determine asset directory")
        return nil
    end

    -- Create directory
    local cmd
    if IS_WINDOWS then
        cmd = 'mkdir "' .. dir .. '" 2>nul'
    else
        cmd = 'mkdir -p "' .. dir .. '"'
    end
    os.execute(cmd)

    -- Check if assets exist
    local sep = IS_WINDOWS and "\\" or "/"
    local arrow_path = dir .. sep .. "arrow.png"

    local f = io.open(arrow_path, "rb")
    if f then
        f:close()
        self.dir = dir
        self.extracted = true
        log("CursorAssets: Using existing assets from " .. dir)
        return dir
    end

    -- Try to copy from script directory
    local script_dir = get_script_directory()
    local assets_src = script_dir .. "assets" .. sep .. "cursors" .. sep

    local files = { "arrow.png", "pointer.png", "ibeam.png" }
    for _, filename in ipairs(files) do
        local src_path = assets_src .. filename
        local dst_path = dir .. sep .. filename

        local src = io.open(src_path, "rb")
        if src then
            local data = src:read("*a")
            src:close()

            local dst = io.open(dst_path, "wb")
            if dst then
                dst:write(data)
                dst:close()
                log("CursorAssets: Copied " .. filename)
            end
        end
    end

    self.dir = dir
    self.extracted = true
    return dir
end

-- Get the asset directory
function CursorAssets:get_dir()
    return self.dir
end

-- Check if assets are available
function CursorAssets:is_available()
    if not self.extracted then
        self:ensure_extracted()
    end
    return self.dir ~= nil
end

-- Get cursor image path
function CursorAssets:get_cursor_path(cursor_type)
    if not self:is_available() then
        return nil
    end

    local sep = IS_WINDOWS and "\\" or "/"
    local filename = (cursor_type or "arrow") .. ".png"
    return self.dir .. sep .. filename
end

-- Global convenience functions
function cursor_assets_ensure_extracted()
    return CursorAssets:ensure_extracted()
end

function cursor_assets_get_dir()
    return CursorAssets:get_dir()
end

function cursor_assets_is_available()
    return CursorAssets:is_available()
end

function cursor_assets_get_cursor_path(cursor_type)
    return CursorAssets:get_cursor_path(cursor_type)
end

--================================================
-- MODULE: Cursor Renderer (M15)
--================================================
-- Provides automatic cursor overlay rendering

local CursorRenderer = {
    enabled = false,
    source = nil,
    sceneitem = nil,

    -- Smoothed state
    pos = { x = 0, y = 0 },
    current_scale = 1.0,
    current_rot = 0,
    swap_pulse = 1.0,

    -- Velocities (SmoothDamp)
    vel_x = { val = 0 },
    vel_y = { val = 0 },
    vel_scale = { val = 0 },
    vel_rot = { val = 0 },
    vel_swap = { val = 0 },

    -- State
    was_pointer = false,
    initialized = false,

    -- Configuration
    cursor_scale = 1.0,
    cursor_click_scale = 0.78,
    cursor_smooth_time = 0.1,
    cursor_offset_x = -6,
    cursor_offset_y = -2,
    cursor_rotation_mode = "None",
    cursor_angle_offset = 0,
    cursor_tilt_strength = 0,
}

-- Initialize cursor renderer
function CursorRenderer:init()
    if not cfg.cursor_enabled then
        self.enabled = false
        return false
    end

    -- Ensure cursor assets are available
    local asset_dir = cursor_assets_ensure_extracted()
    if not asset_dir then
        log("CursorRenderer: Failed to extract cursor assets")
        self.enabled = false
        return false
    end

    -- Get or create the cursor image source
    local source_name = FILTER_PREFIX .. "Cursor"
    self.source = obs.obs_get_source_by_name(source_name)

    if not self.source then
        -- Create new image source
        local settings = obs.obs_data_create()
        local cursor_path = cursor_assets_get_cursor_path("arrow")
        if cursor_path then
            obs.obs_data_set_string(settings, "file", cursor_path)
        end
        self.source = obs.obs_source_create("image_source", source_name, settings, nil)
        obs.obs_data_release(settings)

        if not self.source then
            log("CursorRenderer: Failed to create image source")
            self.enabled = false
            return false
        end
    end

    -- Add to current scene
    self:add_to_scene()

    -- Initialize position
    local mouse = platform_get_mouse_pos()
    self.pos.x = mouse.x
    self.pos.y = mouse.y

    self.enabled = true
    self.initialized = true
    log("CursorRenderer: Initialized")
    return true
end

-- Add cursor source to scene
function CursorRenderer:add_to_scene()
    if not self.source then return false end

    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then return false end

    local scene = obs.obs_scene_from_source(scene_source)
    if not scene then
        obs.obs_source_release(scene_source)
        return false
    end

    -- Check if already in scene
    local source_name = obs.obs_source_get_name(self.source)
    self.sceneitem = obs.obs_scene_find_source(scene, source_name)

    if not self.sceneitem then
        -- Add to scene
        self.sceneitem = obs.obs_scene_add(scene, self.source)
        if self.sceneitem then
            -- Move to top (render last = on top)
            obs.obs_sceneitem_set_order(self.sceneitem, obs.OBS_ORDER_MOVE_TOP)
        end
    end

    obs.obs_source_release(scene_source)
    return true
end

-- Update cursor position and state
function CursorRenderer:update(dt, raw_mouse, camera_crop)
    if not self.enabled or not self.sceneitem then return end

    -- Smooth cursor position
    self.pos.x = SmoothDamp(self.pos.x, raw_mouse.x, self.vel_x, self.cursor_smooth_time, 100000, dt)
    self.pos.y = SmoothDamp(self.pos.y, raw_mouse.y, self.vel_y, self.cursor_smooth_time, 100000, dt)

    -- Snap when very close
    if math.abs(self.pos.x - raw_mouse.x) < 0.5 then
        self.pos.x = raw_mouse.x
        self.vel_x.val = 0
    end
    if math.abs(self.pos.y - raw_mouse.y) < 0.5 then
        self.pos.y = raw_mouse.y
        self.vel_y.val = 0
    end

    -- Cursor shape detection (Windows only)
    local is_pointer = false
    if platform_cursor_shape_available() then
        is_pointer = platform_is_cursor_pointer()
    end

    -- Swap cursor image if needed
    if is_pointer ~= self.was_pointer then
        local asset_dir = cursor_assets_get_dir()
        local sep = IS_WINDOWS and "\\" or "/"
        local new_file = is_pointer and (asset_dir .. sep .. "pointer.png") or (asset_dir .. sep .. "arrow.png")

        local s = obs.obs_source_get_settings(self.source)
        if s then
            obs.obs_data_set_string(s, "file", new_file)
            obs.obs_source_update(self.source, s)
            obs.obs_data_release(s)
        end

        -- Trigger swap pulse
        self.swap_pulse = 0.75
        self.vel_swap.val = 1
        self.was_pointer = is_pointer
    end

    self.swap_pulse = SmoothDamp(self.swap_pulse, 1.0, self.vel_swap, 0.12, 100000, dt)

    -- Click animation
    local is_clicking = platform_is_clicking()
    local target_scale = is_clicking and (self.cursor_scale * self.cursor_click_scale) or self.cursor_scale
    self.current_scale = SmoothDamp(self.current_scale, target_scale, self.vel_scale, 0.1, 100000, dt)

    -- Calculate position relative to zoom
    local zoom_factor = 1.0
    local crop_x, crop_y = 0, 0

    if camera_crop and SM:is_zoomed() then
        zoom_factor = source_manager_get_size() / camera_crop.w
        crop_x = camera_crop.x
        crop_y = camera_crop.y
    end

    local final_x = (self.pos.x - crop_x) * zoom_factor + (self.cursor_offset_x * zoom_factor)
    local final_y = (self.pos.y - crop_y) * zoom_factor + (self.cursor_offset_y * zoom_factor)

    -- Apply to scene item
    local pos = obs.vec2()
    pos.x = final_x
    pos.y = final_y
    obs.obs_sceneitem_set_pos(self.sceneitem, pos)

    local scale = obs.vec2()
    local s = self.current_scale * zoom_factor * self.swap_pulse
    scale.x = s
    scale.y = s
    obs.obs_sceneitem_set_scale(self.sceneitem, scale)

    -- Rotation
    local dynamic_rot = self:compute_rotation(dt)
    obs.obs_sceneitem_set_rot(self.sceneitem, dynamic_rot)
end

-- Compute rotation based on mode
function CursorRenderer:compute_rotation(dt)
    local vx = self.vel_x.val
    local vy = self.vel_y.val
    local speed = math.sqrt(vx * vx + vy * vy)

    if self.cursor_rotation_mode == "Directional" then
        if speed > 20 then
            local angle = math.atan2(vy, vx) * (180 / math.pi)
            local target = angle + self.cursor_angle_offset
            local diff = (target - self.current_rot + 180) % 360 - 180
            self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.05, 100000, dt)
        end
        return self.current_rot

    elseif self.cursor_rotation_mode == "Lean" then
        local lean = clamp(-40, 40, vx * 0.05 * self.cursor_tilt_strength) + self.cursor_angle_offset
        local diff = (lean - self.current_rot + 180) % 360 - 180
        self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.08, 100000, dt)
        return self.current_rot
    end

    -- "None" mode
    local diff = (self.cursor_angle_offset - self.current_rot + 180) % 360 - 180
    self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.15, 100000, dt)
    return self.current_rot
end

-- Update configuration
function CursorRenderer:update_config(settings)
    self.cursor_scale = obs.obs_data_get_double(settings, "cursor_scale")
    self.cursor_click_scale = obs.obs_data_get_double(settings, "cursor_click_scale")
    self.cursor_smooth_time = obs.obs_data_get_double(settings, "cursor_smooth_time")
    self.cursor_offset_x = obs.obs_data_get_int(settings, "cursor_offset_x")
    self.cursor_offset_y = obs.obs_data_get_int(settings, "cursor_offset_y")
    self.cursor_rotation_mode = obs.obs_data_get_string(settings, "cursor_rotation_mode") or "None"
    self.cursor_angle_offset = obs.obs_data_get_double(settings, "cursor_angle_offset")
    self.cursor_tilt_strength = obs.obs_data_get_double(settings, "cursor_tilt_strength")
end

-- Cleanup
function CursorRenderer:cleanup()
    if self.sceneitem then
        obs.obs_sceneitem_remove(self.sceneitem)
        self.sceneitem = nil
    end

    if self.source then
        local source_name = obs.obs_source_get_name(self.source)
        obs.obs_source_release(self.source)

        -- Remove from OBS source list
        local s = obs.obs_get_source_by_name(source_name)
        if s then
            obs.obs_source_remove(s)
            obs.obs_source_release(s)
        end
        self.source = nil
    end

    self.enabled = false
    self.initialized = false
end

-- Check if active
function CursorRenderer:is_active()
    return self.enabled and self.initialized
end

-- Global convenience functions
function cursor_renderer_init()
    return CursorRenderer:init()
end

function cursor_renderer_update(dt, raw_mouse, camera_crop)
    return CursorRenderer:update(dt, raw_mouse, camera_crop)
end

function cursor_renderer_update_config(settings)
    return CursorRenderer:update_config(settings)
end

function cursor_renderer_cleanup()
    return CursorRenderer:cleanup()
end

function cursor_renderer_is_active()
    return CursorRenderer:is_active()
end

--================================================
-- MODULE: Bookmark Manager (M17)
--================================================
-- Manages saved zoom positions (bookmarks)

local BookmarkManager = {
    -- Saved bookmarks: { name = { zoom_level, x, y, w, h, source } }
    bookmarks = {},

    -- Maximum bookmarks
    max_bookmarks = 20,

    -- Hotkey IDs
    hotkeys = {},
}

-- Save current zoom position as a bookmark
function BookmarkManager:save(name)
    if not name or name == "" then
        return false
    end

    -- Check limit
    local count = 0
    for _, _ in pairs(self.bookmarks) do count = count + 1 end

    if count >= self.max_bookmarks and not self.bookmarks[name] then
        log("Bookmark: Max bookmarks reached (" .. self.max_bookmarks .. ")")
        return false
    end

    -- Get current crop
    local crop = crop_filter_get_crop()
    if not crop then
        return false
    end

    -- Save bookmark
    self.bookmarks[name] = {
        zoom_level = SM.zoom_level,
        x = crop.x,
        y = crop.y,
        w = crop.w,
        h = crop.h,
        source = cfg.source_name,
    }

    log("Bookmark: Saved '" .. name .. "' (zoom=" .. string.format("%.2f", SM.zoom_level) .. ")")
    return true
end

-- Recall a bookmark
function BookmarkManager:recall(name)
    local bm = self.bookmarks[name]
    if not bm then
        log("Bookmark: Not found: " .. name)
        return false
    end

    if not SM:can_jump() then
        return false
    end

    if not source_manager_is_valid() then
        return false
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        return false
    end

    -- Get current crop as start
    local start_crop = crop_filter_get_crop() or { x = 0, y = 0, w = source_w, h = source_h }

    -- Set target
    local target_crop = {
        x = bm.x,
        y = bm.y,
        w = bm.w,
        h = bm.h,
    }

    -- Transition to bookmark
    SM:transition(ZoomState.JUMPING, {
        start_crop = start_crop,
        target_crop = target_crop,
        target_level = bm.zoom_level
    })

    start_timer()
    log("Bookmark: Recall '" .. name .. "'")
    return true
end

-- Delete a bookmark
function BookmarkManager:delete(name)
    if self.bookmarks[name] then
        self.bookmarks[name] = nil
        log("Bookmark: Deleted '" .. name .. "'")
        return true
    end
    return false
end

-- Rename a bookmark
function BookmarkManager:rename(old_name, new_name)
    if not self.bookmarks[old_name] then
        return false
    end

    if self.bookmarks[new_name] then
        return false
    end

    self.bookmarks[new_name] = self.bookmarks[old_name]
    self.bookmarks[old_name] = nil
    log("Bookmark: Renamed '" .. old_name .. "' to '" .. new_name .. "'")
    return true
end

-- Get all bookmark names
function BookmarkManager:get_names()
    local names = {}
    for k, _ in pairs(self.bookmarks) do
        table.insert(names, k)
    end
    table.sort(names)
    return names
end

-- Get bookmark info
function BookmarkManager:get(name)
    return self.bookmarks[name]
end

-- Persist bookmarks to settings
function BookmarkManager:persist(settings)
    local array = obs.obs_data_array_create()

    for name, bm in pairs(self.bookmarks) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "name", name)
        obs.obs_data_set_double(item, "zoom_level", bm.zoom_level)
        obs.obs_data_set_double(item, "x", bm.x)
        obs.obs_data_set_double(item, "y", bm.y)
        obs.obs_data_set_double(item, "w", bm.w)
        obs.obs_data_set_double(item, "h", bm.h)
        obs.obs_data_set_string(item, "source", bm.source or "")
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "zoom_bookmarks", array)
    obs.obs_data_array_release(array)
end

-- Load bookmarks from settings
function BookmarkManager:load(settings)
    self.bookmarks = {}

    local array = obs.obs_data_get_array(settings, "zoom_bookmarks")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local name = obs.obs_data_get_string(item, "name")

        if name and name ~= "" then
            self.bookmarks[name] = {
                zoom_level = obs.obs_data_get_double(item, "zoom_level"),
                x = obs.obs_data_get_double(item, "x"),
                y = obs.obs_data_get_double(item, "y"),
                w = obs.obs_data_get_double(item, "w"),
                h = obs.obs_data_get_double(item, "h"),
                source = obs.obs_data_get_string(item, "source"),
            }
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)

    local count = 0
    for _, _ in pairs(self.bookmarks) do count = count + 1 end
    log("Bookmark: Loaded " .. count .. " bookmarks")
end

-- Register bookmark hotkeys
function BookmarkManager:register_hotkeys(settings)
    for i = 1, 5 do
        self.hotkeys[i] = obs.obs_hotkey_register_frontend(
            "obs_zoom_pro.bookmark_" .. i,
            "Zoom to Bookmark " .. i,
            function(pressed)
                if not pressed then return end
                local names = self:get_names()
                if names[i] then
                    self:recall(names[i])
                end
            end
        )

        -- Load saved bindings
        local key = "obs_zoom_pro.hotkey.bookmark_" .. i
        local save_array = obs.obs_data_get_array(settings, key)
        if save_array then
            obs.obs_hotkey_load(self.hotkeys[i], save_array)
            obs.obs_data_array_release(save_array)
        end
    end
end

-- Save bookmark hotkeys
function BookmarkManager:save_hotkeys(settings)
    for i = 1, 5 do
        if self.hotkeys[i] then
            local save_array = obs.obs_hotkey_save(self.hotkeys[i])
            obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.bookmark_" .. i, save_array)
            obs.obs_data_array_release(save_array)
        end
    end
end

-- Global convenience functions
function bookmark_save(name)
    return BookmarkManager:save(name)
end

function bookmark_recall(name)
    return BookmarkManager:recall(name)
end

function bookmark_delete(name)
    return BookmarkManager:delete(name)
end

function bookmark_get_names()
    return BookmarkManager:get_names()
end

function bookmark_get(name)
    return BookmarkManager:get(name)
end

--================================================
-- MODULE: UDP API Server (M18)
--================================================
-- Provides external control via UDP for Stream Deck integration

local APIServer = {
    enabled = false,
    port = 12345,
    socket = nil,
}

-- Command handlers
local API_COMMANDS = {
    ZOOM_IN = function(args)
        local level = tonumber(args[1]) or cfg.zoom_value
        on_scroll_zoom_to(level)
        return "OK"
    end,

    ZOOM_OUT = function(args)
        if SM:is_zoomed() then
            on_toggle_zoom(true)
        end
        return "OK"
    end,

    ZOOM_SET = function(args)
        local level = tonumber(args[1])
        if not level then return "ERROR: Missing level" end
        on_scroll_zoom_to(level)
        return "OK"
    end,

    ZOOM_TOGGLE = function(args)
        on_toggle_zoom(true)
        return "OK"
    end,

    FOLLOW_ON = function(args)
        if SM:is_zoomed() then SM.following = true end
        return "OK"
    end,

    FOLLOW_OFF = function(args)
        SM.following = false
        return "OK"
    end,

    FOLLOW_TOGGLE = function(args)
        if SM:is_zoomed() then SM.following = not SM.following end
        return "OK"
    end,

    PRESET = function(args)
        local name = args[1]
        if not name then return "ERROR: Missing preset name" end
        local ok = preset_apply(name)
        return ok and "OK" or "ERROR: Unknown preset"
    end,

    BOOKMARK = function(args)
        local name = args[1]
        if not name then return "ERROR: Missing bookmark name" end
        local ok = bookmark_recall(name)
        return ok and "OK" or "ERROR: Bookmark not found"
    end,

    STATUS = function(args)
        local crop = crop_filter_get_crop()
        return string.format(
            '{"version":"%s","zoom_level":%.2f,"state":"%s","following":%s,"position":{"x":%.0f,"y":%.0f},"preset":"%s"}',
            VERSION,
            SM.zoom_level,
            SM.state,
            tostring(SM.following),
            crop and crop.x or 0,
            crop and crop.y or 0,
            cfg.zoom_preset or ""
        )
    end,

    HELP = function(args)
        return "Commands: ZOOM_IN [level], ZOOM_OUT, ZOOM_SET level, ZOOM_TOGGLE, FOLLOW_ON, FOLLOW_OFF, FOLLOW_TOGGLE, PRESET name, BOOKMARK name, STATUS"
    end,
}

-- Start the API server
function APIServer:start(port)
    self:stop()

    self.port = port or self.port

    -- Try to use luasocket if available
    local socket_ok, socket = pcall(require, "socket")
    if not socket_ok then
        log("API: Socket library not available")
        return false
    end

    -- Try UDP
    local udp, err = socket.udp()
    if not udp then
        log("API: Failed to create UDP socket: " .. tostring(err))
        return false
    end

    -- Set socket options
    udp:setoption("reuseaddr", true)
    udp:settimeout(0)  -- Non-blocking

    -- Bind to port
    local bind_ok, err = udp:setsockname("*", self.port)
    if not bind_ok then
        log("API: Failed to bind to port " .. self.port .. ": " .. tostring(err))
        udp:close()
        return false
    end

    self.socket = udp
    self.enabled = true

    -- Start polling timer
    obs.timer_add(function() self:poll() end, 50)  -- 20Hz polling

    log("API: Listening on port " .. self.port)
    return true
end

-- Stop the API server
function APIServer:stop()
    if self.socket then
        self.socket:close()
        self.socket = nil
    end
    self.enabled = false
    log("API: Stopped")
end

-- Poll for incoming commands
function APIServer:poll()
    if not self.enabled or not self.socket then
        return
    end

    repeat
        local data, err = self.socket:receivefrom()
        if data then
            local response = self:handle_command(data)
            if response then
                -- Note: UDP response requires sender address
                log("API: " .. data:gsub("%s+", " ") .. " Ã¢â€ â€™ " .. response)
            end
        elseif err ~= "timeout" then
            log("API: Error: " .. tostring(err))
        end
    until not data
end

-- Handle a command
function APIServer:handle_command(raw)
    -- Parse command
    local parts = {}
    for word in raw:gmatch("%S+") do
        table.insert(parts, word)
    end

    if #parts == 0 then
        return "ERROR: Empty command"
    end

    local cmd = parts[1]:upper()
    local args = {}
    for i = 2, #parts do
        table.insert(args, parts[i])
    end

    -- Look up handler
    local handler = API_COMMANDS[cmd]
    if handler then
        local ok, result = pcall(handler, args)
        if ok then
            return result
        else
            return "ERROR: " .. tostring(result)
        end
    end

    return "ERROR: Unknown command: " .. cmd
end

-- Check if enabled
function APIServer:is_enabled()
    return self.enabled
end

-- Global convenience functions
function api_start(port)
    return APIServer:start(port)
end

function api_stop()
    return APIServer:stop()
end

function api_is_enabled()
    return APIServer:is_enabled()
end

--================================================
-- OBS SCRIPT REGISTRATION
--================================================

--[[ Called when the script is loaded
--[[ @param data table Script data
function script_load(data)
    log("Script loaded - OBS Zoom Pro v" .. VERSION)

    -- Load custom presets
    PresetManager:load(data)

    -- Load scene memory
    SceneMemory:load(data)

    -- Load bookmarks
    BookmarkManager:load(data)

    -- Register hotkeys
    register_hotkeys(data)

    -- Register bookmark hotkeys
    BookmarkManager:register_hotkeys(data)

    -- Register frontend event handler
    obs.obs_frontend_add_event_callback(on_frontend_event)

    -- Start API server if enabled
    local api_enabled = obs.obs_data_get_bool(data, "api_enabled")
    if api_enabled then
        local api_port = obs.obs_data_get_int(data, "api_port")
        APIServer:start(api_port)
    end
end

--[[ Called when the script is unloaded
function script_unload()
    log("Script unloaded - OBS Zoom Pro")

    -- Stop timer and cleanup
    stop_timer()
    unregister_hotkeys()
    source_manager_release()

    -- Stop API server
    APIServer:stop()

    -- Remove frontend event handler
    obs.obs_frontend_remove_event_callback(on_frontend_event)
end

--[[ Called when settings are updated
--[[ @param data table Settings data
function script_update(data)
    log("Settings updated")

    -- Update legacy settings
    debug_logs = obs.obs_data_get_bool(data, "debug_logging") or false
    settings.debug_logging = debug_logs
    settings.easing_type = obs.obs_data_get_string(data, "easing_type") or defaults.easing_type
    settings.smooth_time = obs.obs_data_get_double(data, "smooth_time") or defaults.smooth_time
    settings.max_speed = obs.obs_data_get_double(data, "max_speed") or defaults.max_speed

    -- Update M09 configuration
    update_config(data)

    -- Update API server settings
    local api_enabled = obs.obs_data_get_bool(data, "api_enabled")
    local api_port = obs.obs_data_get_int(data, "api_port")

    if api_enabled and not APIServer:is_enabled() then
        APIServer:start(api_port)
    elseif not api_enabled and APIServer:is_enabled() then
        APIServer:stop()
    elseif APIServer:is_enabled() and APIServer.port ~= api_port then
        APIServer:start(api_port)
    end
end

--[[ Called to save settings
--[[ @param data table Settings data to save
function script_save(data)
    log("Settings saved")

    -- Save custom presets
    PresetManager:persist(data)

    -- Save scene memory
    SceneMemory:persist(data)

    -- Save bookmarks
    BookmarkManager:persist(data)

    -- Save hotkey bindings
    save_hotkeys(data)

    -- Save bookmark hotkeys
    BookmarkManager:save_hotkeys(data)
end

--[[ Called to create the properties UI
--[[ @return obs.obs_properties_t Properties object
function script_properties()
    local props = obs.obs_properties_create()

    --==========================
    -- QUICK SETUP (always expanded)
    --==========================
    local grp_quick = obs.obs_properties_create()

    -- Source dropdown
    local src_list = obs.obs_properties_add_list(grp_quick, "source", "Zoom Source",
        obs.OBS_COMBO_TYPE_LIST, obs.OBS_COMBO_FORMAT_STRING)
    obs.obs_property_list_add_string(src_list, "-- Select Source --", "")

    -- Populate with available capture sources
    local sources = source_manager_get_available_sources()
    for _, src in ipairs(sources) do
        obs.obs_property_list_add_string(src_list, src.name, src.name)
    end

    -- Zoom Factor
    obs.obs_properties_add_float_slider(grp_quick, "zoom_value", "Zoom Factor", 1.0, 10.0, 0.1)

    -- Duration
    obs.obs_properties_add_float_slider(grp_quick, "zoom_duration", "Duration (s)", 0.05, 3.0, 0.05)

    obs.obs_properties_add_group(props, "quick_setup", "Ã¢Å¡Â¡ Quick Setup", obs.OBS_GROUP_NORMAL, grp_quick)

    --==========================
    -- ANIMATION (collapsed)
    --==========================
    local grp_anim = obs.obs_properties_create()

    -- Overshoot/Bounce
    obs.obs_properties_add_float_slider(grp_anim, "zoom_overshoot", "Bounce", 0.0, 1.0, 0.01)

    -- Easing Curve
    local p_easing = obs.obs_properties_add_list(grp_anim, "zoom_easing", "Easing Curve",
        obs.OBS_COMBO_TYPE_LIST, obs.OBS_COMBO_FORMAT_STRING)
    for _, name in ipairs(Easing.NAMES) do
        obs.obs_property_list_add_string(p_easing, name, name)
    end

    obs.obs_properties_add_group(props, "animation", "Ã°Å¸Å½Â¬ Animation", obs.OBS_GROUP_NORMAL, grp_anim)

    --==========================
    -- MOUSE FOLLOW (collapsed)
    --==========================
    local grp_follow = obs.obs_properties_create()

    obs.obs_properties_add_bool(grp_follow, "auto_follow", "Auto-Follow Mouse")
    obs.obs_properties_add_float_slider(grp_follow, "follow_smooth_time", "Smoothness", 0.01, 1.0, 0.01)
    obs.obs_properties_add_int_slider(grp_follow, "follow_dead_zone", "Dead Zone (px)", 0, 500, 1)

    obs.obs_properties_add_group(props, "follow", "Ã°Å¸Å½Â¯ Mouse Follow", obs.OBS_GROUP_NORMAL, grp_follow)

    --==========================
    -- ADVANCED (collapsed)
    --==========================
    local grp_adv = obs.obs_properties_create()
    obs.obs_properties_add_float_slider(grp_adv, "scroll_step", "Scroll Zoom Step", 0.1, 1.0, 0.05)
    obs.obs_properties_add_bool(grp_adv, "debug_logs", "Debug Logging")
    obs.obs_properties_add_group(props, "advanced", "Ã¢Å¡â„¢Ã¯Â¸Â Advanced", obs.OBS_GROUP_NORMAL, grp_adv)

    --==========================
    -- API SERVER (collapsed)
    --==========================
    local grp_api = obs.obs_properties_create()
    obs.obs_properties_add_bool(grp_api, "api_enabled", "Enable UDP API Server")
    obs.obs_properties_add_int(grp_api, "api_port", "API Port", 1024, 65535, 1)
    obs.obs_properties_add_group(props, "api_server", "Ã°Å¸Å’Â UDP API Server", obs.OBS_GROUP_NORMAL, grp_api)

    --==========================
    -- HELP (collapsed)
    --==========================
    local grp_help = obs.obs_properties_create()
    obs.obs_properties_add_text(grp_help, "help_text",
        "QUICK START:\n" ..
        "1. Select your capture source above\n" ..
        "2. Set hotkeys in OBS Settings Ã¢â€ â€™ Hotkeys\n" ..
        "   Ã¢â‚¬Â¢ 'Toggle Zoom to Mouse' Ã¢â‚¬â€ Main zoom\n" ..
        "   Ã¢â‚¬Â¢ 'Toggle Mouse Follow' Ã¢â‚¬â€ Enable/disable follow\n" ..
        "3. Press the hotkey to zoom!\n\n" ..
        "TIPS:\n" ..
        "Ã¢â‚¬Â¢ Zoom centers on mouse position\n" ..
        "Ã¢â‚¬Â¢ Enable Auto-Follow for smooth tracking\n" ..
        "Ã¢â‚¬Â¢ Adjust Dead Zone to reduce jitter",
        obs.OBS_TEXT_INFO)
    obs.obs_properties_add_group(props, "help", "Ã¢Ââ€œ Help", obs.OBS_GROUP_NORMAL, grp_help)

    return props
end

--[[ Called to set default values
--[[ @param data table Settings data
function script_defaults(data)
    obs.obs_data_set_default_string(data, "source", "")
    obs.obs_data_set_default_double(data, "zoom_value", 2.0)
    obs.obs_data_set_default_double(data, "zoom_duration", 0.6)
    obs.obs_data_set_default_double(data, "zoom_overshoot", 0.0)
    obs.obs_data_set_default_string(data, "zoom_easing", "Cubic.Out")
    obs.obs_data_set_default_bool(data, "auto_follow", true)
    obs.obs_data_set_default_double(data, "follow_smooth_time", 0.15)
    obs.obs_data_set_default_int(data, "follow_dead_zone", 5)
    obs.obs_data_set_default_double(data, "scroll_step", 0.25)
    obs.obs_data_set_default_bool(data, "debug_logs", false)
    obs.obs_data_set_default_bool(data, "api_enabled", false)
    obs.obs_data_set_default_int(data, "api_port", 12345)
end

--================================================
-- SCRIPT METADATA
--================================================
script_info = {
    name = "OBS Zoom Pro",
    version = VERSION,
    description = "Intelligent camera zoom functionality with smooth transitions and easing curves.",
    author = "OBS Zoom Pro Team"
}
)

local platform = detect_platform()
local IS_WINDOWS = platform.WINDOWS
local IS_LINUX = platform.LINUX
local IS_MACOS = platform.MACOS

-- Log platform detection
log("Platform detected: " .. (jit and jit.os or "Unknown") .. (IS_WINDOWS and " (Full support)" or " (Basic support)"))

-- Virtual key codes (Lua constants instead of C #define)
local VK_LBUTTON = 0x01
local VK_RBUTTON = 0x02
local VK_MBUTTON = 0x04
local VK_CONTROL = 0x11
local VK_SHIFT = 0x10
local VK_MENU = 0x12  -- Alt

-- FFI declarations for Windows (only if FFI is available)


-- Cursor shape constants (Windows)
local CURSOR_ARROW = 1
local CURSOR_IBEAM = 2
local CURSOR_HAND = 3
local CURSOR_WAIT = 4

-- Module state
local Platform = {
    cursor_shape_available = IS_WINDOWS,
    last_mouse = { x = 0, y = 0 },
    last_click = false,
}

-- Get mouse position (cross-platform)
function Platform.get_mouse_pos()
    if IS_WINDOWS then
        local success, pt = pcall(function()
            local pt = ffi.new("POINT")
            if ffi.C.GetCursorPos(pt) ~= 0 then
                return { x = tonumber(pt.x), y = tonumber(pt.y) }
            end
            return nil
        end)
        if success and pt then
            return pt
        end
    elseif IS_LINUX then
        -- Linux: Use xdotool if available, fallback to X11
        local success, result = pcall(function()
            local handle = io.popen("xdotool getmouselocation 2>/dev/null || echo 'x:0 y:0'")
            if handle then
                local output = handle:read("*a")
                handle:close()
                local x, y = output:match("x:(%d+)%s+y:(%d+)")
                if x and y then
                    return { x = tonumber(x), y = tonumber(y) }
                end
            end
            return nil
        end)
        if success and result then
            return result
        end
    elseif IS_MACOS then
        -- macOS: Use osascript
        local success, result = pcall(function()
            local handle = io.popen(--[[osascript -e 'tell application "System Events" to get position of the mouse' 2>/dev/null || echo "0, 0"]])
            if handle then
                local output = handle:read("*a")
                handle:close()
                local x, y = output:match("(%d+),%s*(%d+)")
                if x and y then
                    return { x = tonumber(x), y = tonumber(y) }
                end
            end
            return nil
        end)
        if success and result then
            return result
        end
    end

    -- Fallback
    return { x = 0, y = 0 }
end

-- Check if left mouse button is clicked (Windows only, others return false)
function Platform.is_clicking()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x01) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if a modifier key is held (Windows only)
function Platform.is_key_held(vk_code)
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(vk_code) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if cursor is a pointer/hand (Windows only)
function Platform.is_cursor_pointer()
    if IS_WINDOWS then
        local success, result = pcall(function()
            local ci = ffi.new("CURSORINFO")
            ci.cbSize = ffi.sizeof("CURSORINFO")
            if ffi.C.GetCursorInfo(ci) ~= 0 then
                -- Check if hCursor is a hand pointer
                -- This is a simplified check; real implementation would compare cursor handles
                return ci.flags ~= 0  -- Simplified; actual implementation needs cursor handle comparison
            end
            return false
        end)
        return success and result or false
    end
    return false
end

-- Get cursor shape (Windows only, returns "arrow" for others)
function Platform.get_cursor_shape()
    if IS_WINDOWS then
        local success, result = pcall(function()
            local ci = ffi.new("CURSORINFO")
            ci.cbSize = ffi.sizeof("CURSORINFO")
            if ffi.C.GetCursorInfo(ci) ~= 0 and ci.hCursor ~= nil then
                local addr = tonumber(ffi.cast("uintptr_t", ci.hCursor))
                -- Common cursor IDs (these are typical values, may vary)
                -- IDC_ARROW = 32512, IDC_IBEAM = 32513, IDC_HAND = 32649
                -- We use address ranges as heuristic
                return "arrow"  -- Simplified; actual implementation would map handles
            end
            return "arrow"
        end)
        return success and result or "arrow"
    end
    return "arrow"
end

-- Check if Control key is held
function Platform.is_ctrl_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x11) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if Shift key is held
function Platform.is_shift_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x10) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if Alt key is held
function Platform.is_alt_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x12) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Convenience wrapper functions
function platform_get_mouse_pos()
    return Platform.get_mouse_pos()
end

function platform_is_clicking()
    return Platform.is_clicking()
end

function platform_is_cursor_pointer()
    return Platform.is_cursor_pointer()
end

function platform_cursor_shape_available()
    return Platform.cursor_shape_available
end

function platform_is_ctrl_held()
    return Platform.is_ctrl_held()
end

function platform_is_shift_held()
    return Platform.is_shift_held()
end

function platform_is_alt_held()
    return Platform.is_alt_held()
end

--================================================
-- MODULE: State Machine (M05)
--================================================
-- Manages zoom states and transitions
-- States: IDLE, ZOOMING_IN, ZOOMED_IN, ZOOMING_OUT, SCROLLING, JUMPING

local ZoomState = {
    IDLE         = "idle",
    ZOOMING_IN   = "zooming_in",
    ZOOMED_IN    = "zoomed_in",
    ZOOMING_OUT  = "zooming_out",
    SCROLLING    = "scrolling",    -- Scroll wheel mid-transition
    JUMPING      = "jumping",      -- Bookmark transition
}

local StateMachine = {
    state = ZoomState.IDLE,
    zoom_time = 0,          -- Animation progress (0 Ã¢â€ â€™ 1)
    zoom_level = 1.0,       -- Current zoom factor
    target_level = 1.0,     -- Target zoom factor
    start_crop = nil,       -- Crop at animation start {x, y, w, h}
    target_crop = nil,      -- Crop at animation end {x, y, w, h}
    following = false,      -- Mouse follow active

    -- Transition guards
    can_zoom_in = function(self)
        return self.state == ZoomState.IDLE
    end,

    can_zoom_out = function(self)
        return self.state == ZoomState.ZOOMED_IN
            or self.state == ZoomState.SCROLLING
    end,

    can_scroll = function(self)
        return self.state == ZoomState.ZOOMED_IN
            or self.state == ZoomState.IDLE
            or self.state == ZoomState.SCROLLING
    end,

    can_jump = function(self)
        return self.state ~= ZoomState.ZOOMING_IN
           and self.state ~= ZoomState.ZOOMING_OUT
           and self.state ~= ZoomState.JUMPING
    end,

    is_animating = function(self)
        return self.state == ZoomState.ZOOMING_IN
            or self.state == ZoomState.ZOOMING_OUT
            or self.state == ZoomState.SCROLLING
            or self.state == ZoomState.JUMPING
    end,

    is_zoomed = function(self)
        return self.state ~= ZoomState.IDLE
    end,
}

-- Transition to a new state
function StateMachine:transition(new_state, params)
    local old = self.state
    self.state = new_state
    self.zoom_time = 0

    if params then
        if params.start_crop then self.start_crop = params.start_crop end
        if params.target_crop then self.target_crop = params.target_crop end
        if params.target_level then self.target_level = params.target_level end
    end

    log("State: " .. old .. " Ã¢â€ â€™ " .. new_state)
end

-- Complete the current animation
function StateMachine:complete()
    if self.state == ZoomState.ZOOMING_IN
       or self.state == ZoomState.SCROLLING
       or self.state == ZoomState.JUMPING then
        self.zoom_level = self.target_level
        self.state = ZoomState.ZOOMED_IN
        self.zoom_time = 0
        log("State: " .. self.state .. " Ã¢â€ â€™ ZOOMED_IN (complete)")
    elseif self.state == ZoomState.ZOOMING_OUT then
        self.zoom_level = 1.0
        self.target_level = 1.0
        self.start_crop = nil
        self.target_crop = nil
        self.following = false
        self.state = ZoomState.IDLE
        self.zoom_time = 0
        log("State: ZOOMING_OUT Ã¢â€ â€™ IDLE (complete)")
    end
end

-- Reset to initial state
function StateMachine:reset()
    self.state = ZoomState.IDLE
    self.zoom_time = 0
    self.zoom_level = 1.0
    self.target_level = 1.0
    self.start_crop = nil
    self.target_crop = nil
    self.following = false
    log("StateMachine: Reset to IDLE")
end

-- Get current animation progress (0-1)
function StateMachine:get_progress()
    return clamp(0, 1, self.zoom_time)
end

-- Check if in a specific state
function StateMachine:is_state(state)
    return self.state == state
end

-- Get state name for display
function StateMachine:get_state_name()
    return self.state
end

-- Create a new state machine instance (for testing/isolation)
function StateMachine:new()
    local sm = {}
    setmetatable(sm, { __index = self })
    sm.state = ZoomState.IDLE
    sm.zoom_time = 0
    sm.zoom_level = 1.0
    sm.target_level = 1.0
    sm.start_crop = nil
    sm.target_crop = nil
    sm.following = false
    return sm
end

-- Global state machine instance
local SM = StateMachine:new()

--================================================
-- MODULE: Crop Filter Manager (M07)
--================================================
-- Manages the crop/pad filter used to simulate zoom
-- Creates, updates, and destroys the filter automatically

local FILTER_PREFIX = "[ZoomPro] "
local CROP_FILTER_NAME = FILTER_PREFIX .. "Crop"

local CropFilterManager = {
    filter = nil,           -- The crop filter source
    source = nil,           -- The parent source
    original_crop = nil,    -- Original crop values for restoration
    current_crop = { x = 0, y = 0, w = 0, h = 0 },
    initialized = false,
}

-- Create the crop filter on a source
function CropFilterManager:create(source)
    if not source then
        log("CropFilter: No source provided")
        return false
    end

    self:cleanup()  -- Clean up any existing filter
    self.source = source

    -- Check if our filter already exists
    local existing = obs.obs_source_get_filter_by_name(source, CROP_FILTER_NAME)
    if existing then
        log("CropFilter: Found existing filter")
        self.filter = existing
        self.initialized = true
        return true
    end

    -- Create new crop/pad filter
    local settings = obs.obs_data_create()
    obs.obs_data_set_int(settings, "left", 0)
    obs.obs_data_set_int(settings, "top", 0)
    obs.obs_data_set_int(settings, "right", 0)
    obs.obs_data_set_int(settings, "bottom", 0)
    obs.obs_data_set_bool(settings, "relative", false)  -- Absolute positioning

    self.filter = obs.obs_source_create_private(
        "crop_filter",      -- Filter type
        CROP_FILTER_NAME,   -- Filter name
        settings            -- Settings
    )

    obs.obs_data_release(settings)

    if not self.filter then
        log("CropFilter: Failed to create filter")
        return false
    end

    -- Add filter to source
    obs.obs_source_filter_add(source, self.filter)

    -- Store original crop (none)
    self.original_crop = { x = 0, y = 0, w = 0, h = 0 }

    self.initialized = true
    log("CropFilter: Created successfully")
    return true
end

-- Update the crop filter with new values
function CropFilterManager:update(x, y, w, h)
    if not self.filter or not self.initialized then
        return false
    end

    -- Store current crop
    self.current_crop = { x = x, y = y, w = w, h = h }

    -- Get filter settings
    local settings = obs.obs_source_get_settings(self.filter)
    if not settings then
        return false
    end

    -- Calculate crop values
    -- For crop_filter: left, top are absolute position
    -- right, bottom are width/height from right/bottom edge
    -- We need to convert our x, y, w, h to this format

    -- Get source dimensions
    local source_w = obs.obs_source_get_width(self.source)
    local source_h = obs.obs_source_get_height(self.source)

    if source_w == 0 or source_h == 0 then
        obs.obs_data_release(settings)
        return false
    end

    -- Set crop values
    -- left = x offset from left
    -- top = y offset from top
    -- right = source_w - (x + w) = remaining width on right
    -- bottom = source_h - (y + h) = remaining height on bottom
    local left = math.floor(x)
    local top = math.floor(y)
    local right = math.floor(source_w - (x + w))
    local bottom = math.floor(source_h - (y + h))

    -- Clamp to valid values
    left = math.max(0, left)
    top = math.max(0, top)
    right = math.max(0, right)
    bottom = math.max(0, bottom)

    obs.obs_data_set_int(settings, "left", left)
    obs.obs_data_set_int(settings, "top", top)
    obs.obs_data_set_int(settings, "right", right)
    obs.obs_data_set_int(settings, "bottom", bottom)

    -- Update the filter
    obs.obs_source_update(self.filter, settings)
    obs.obs_data_release(settings)

    return true
end

-- Get current crop values
function CropFilterManager:get_crop()
    return self.current_crop
end

-- Reset crop to original (no crop)
function CropFilterManager:reset()
    if not self.filter or not self.initialized then
        return false
    end

    local settings = obs.obs_source_get_settings(self.filter)
    if settings then
        obs.obs_data_set_int(settings, "left", 0)
        obs.obs_data_set_int(settings, "top", 0)
        obs.obs_data_set_int(settings, "right", 0)
        obs.obs_data_set_int(settings, "bottom", 0)
        obs.obs_source_update(self.filter, settings)
        obs.obs_data_release(settings)
    end

    self.current_crop = { x = 0, y = 0, w = 0, h = 0 }
    return true
end

-- Remove the filter and restore original state
function CropFilterManager:cleanup()
    if self.filter and self.source then
        -- Reset to no crop first
        self:reset()

        -- Remove filter from source
        obs.obs_source_filter_remove(self.source, self.filter)
        obs.obs_source_release(self.filter)
        self.filter = nil
        log("CropFilter: Removed from source")
    end

    self.source = nil
    self.original_crop = nil
    self.current_crop = { x = 0, y = 0, w = 0, h = 0 }
    self.initialized = false
end

-- Check if filter is ready
function CropFilterManager:is_ready()
    return self.initialized and self.filter ~= nil
end

-- Get source dimensions
function CropFilterManager:get_source_size()
    if not self.source then
        return 0, 0
    end
    return obs.obs_source_get_width(self.source), obs.obs_source_get_height(self.source)
end

-- Convenience wrapper functions
function crop_filter_create(source)
    return CropFilterManager:create(source)
end

function crop_filter_update(x, y, w, h)
    return CropFilterManager:update(x, y, w, h)
end

function crop_filter_reset()
    return CropFilterManager:reset()
end

function crop_filter_cleanup()
    return CropFilterManager:cleanup()
end

function crop_filter_is_ready()
    return CropFilterManager:is_ready()
end

function crop_filter_get_crop()
    return CropFilterManager:get_crop()
end

function crop_filter_get_source_size()
    return CropFilterManager:get_source_size()
end

--================================================
-- MODULE: Source Manager (M08)
--================================================
-- Handles finding sources in scenes, capturing transforms,
-- and managing source state for zoom operations

local SourceManager = {
    source = nil,           -- Current zoom source
    sceneitem = nil,        -- Scene item reference
    scene = nil,            -- Current scene
    original_transform = nil, -- Saved original transform
    source_name = "",       -- Source name for settings
    initialized = false,
}

-- Transform data structure
local TransformData = {
    pos = { x = 0, y = 0 },
    scale = { x = 1.0, y = 1.0 },
    rot = 0,
    bounds_type = 0,
    bounds = { x = 0, y = 0 },
    crop = { left = 0, top = 0, right = 0, bottom = 0 },
}

-- Find a source in a scene (BFS through groups)
function SourceManager:find_sceneitem(scene, source_name)
    if not scene or not source_name then
        return nil
    end

    local scene_source = obs.obs_scene_from_source(scene)
    if not scene_source then
        return nil
    end

    -- BFS queue
    local queue = {}
    table.insert(queue, scene_source)

    while #queue > 0 do
        local current_scene = table.remove(queue, 1)

        -- Iterate through items
        local items = obs.obs_scene_enum_items(current_scene)
        if items then
            for _, item in ipairs(items) do
                local item_source = obs.obs_sceneitem_get_source(item)
                if item_source then
                    local name = obs.obs_source_get_name(item_source)

                    -- Check if this is our target
                    if name == source_name then
                        obs.sceneitem_list_release(items)
                        return item
                    end

                    -- Check if this is a group (nested scene)
                    if obs.obs_source_get_type(item_source) == obs.OBS_SOURCE_TYPE_INPUT then
                        local id = obs.obs_source_get_id(item_source)
                        if id == "group" then
                            local group_scene = obs.obs_group_from_source(item_source)
                            if group_scene then
                                table.insert(queue, group_scene)
                            end
                        end
                    end
                end
            end
            obs.sceneitem_list_release(items)
        end
    end

    return nil
end

-- Capture the current transform of a scene item
function SourceManager:capture_transform(sceneitem)
    if not sceneitem then
        return nil
    end

    local transform = {}

    -- Position
    local pos = obs.vec2()
    obs.obs_sceneitem_get_pos(sceneitem, pos)
    transform.pos = { x = pos.x, y = pos.y }

    -- Scale
    local scale = obs.vec2()
    obs.obs_sceneitem_get_scale(sceneitem, scale)
    transform.scale = { x = scale.x, y = scale.y }

    -- Rotation
    transform.rot = obs.obs_sceneitem_get_rot(sceneitem)

    -- Bounds
    transform.bounds_type = obs.obs_sceneitem_get_bounds_type(sceneitem)
    local bounds = obs.vec2()
    obs.obs_sceneitem_get_bounds(sceneitem, bounds)
    transform.bounds = { x = bounds.x, y = bounds.y }

    -- Crop
    local crop = obs.obs_sceneitem_crop()
    obs.obs_sceneitem_get_crop(sceneitem, crop)
    transform.crop = {
        left = crop.left,
        top = crop.top,
        right = crop.right,
        bottom = crop.bottom
    }

    return transform
end

-- Restore a saved transform to a scene item
function SourceManager:restore_transform(sceneitem, transform)
    if not sceneitem or not transform then
        return false
    end

    -- Position
    local pos = obs.vec2()
    pos.x = transform.pos.x
    pos.y = transform.pos.y
    obs.obs_sceneitem_set_pos(sceneitem, pos)

    -- Scale
    local scale = obs.vec2()
    scale.x = transform.scale.x
    scale.y = transform.scale.y
    obs.obs_sceneitem_set_scale(sceneitem, scale)

    -- Rotation
    obs.obs_sceneitem_set_rot(sceneitem, transform.rot)

    -- Bounds
    obs.obs_sceneitem_set_bounds_type(sceneitem, transform.bounds_type)
    local bounds = obs.vec2()
    bounds.x = transform.bounds.x
    bounds.y = transform.bounds.y
    obs.obs_sceneitem_set_bounds(sceneitem, bounds)

    -- Crop
    local crop = obs.obs_sceneitem_crop()
    crop.left = transform.crop.left
    crop.top = transform.crop.top
    crop.right = transform.crop.right
    crop.bottom = transform.crop.bottom
    obs.obs_sceneitem_set_crop(sceneitem, crop)

    return true
end

-- Initialize with a source name
function SourceManager:init(source_name)
    self:release()  -- Clean up any existing state

    if not source_name or source_name == "" then
        log("SourceManager: No source name provided")
        return false
    end

    self.source_name = source_name

    -- Get current scene
    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then
        log("SourceManager: No current scene")
        return false
    end

    self.scene = scene_source

    -- Find the scene item
    self.sceneitem = self:find_sceneitem(scene_source, source_name)
    if not self.sceneitem then
        log("SourceManager: Source not found in scene: " .. source_name)
        obs.obs_source_release(scene_source)
        return false
    end

    -- Get the source
    self.source = obs.obs_sceneitem_get_source(self.sceneitem)
    if not self.source then
        log("SourceManager: Failed to get source from sceneitem")
        obs.obs_source_release(scene_source)
        return false
    end

    -- Capture original transform
    self.original_transform = self:capture_transform(self.sceneitem)

    -- Create crop filter
    if not crop_filter_create(self.source) then
        log("SourceManager: Failed to create crop filter")
        obs.obs_source_release(scene_source)
        return false
    end

    self.initialized = true
    log("SourceManager: Initialized with source: " .. source_name)

    obs.obs_source_release(scene_source)
    return true
end

-- Release all resources
function SourceManager:release()
    -- Clean up crop filter
    crop_filter_cleanup()

    -- Restore original transform if we have it
    if self.sceneitem and self.original_transform then
        self:restore_transform(self.sceneitem, self.original_transform)
        log("SourceManager: Restored original transform")
    end

    self.source = nil
    self.sceneitem = nil
    self.scene = nil
    self.original_transform = nil
    self.initialized = false

    log("SourceManager: Released")
end

-- Get source dimensions
function SourceManager:get_source_size()
    if not self.source then
        return 0, 0
    end
    return obs.obs_source_get_width(self.source), obs.obs_source_get_height(self.source)
end

-- Check if source is valid
function SourceManager:is_valid()
    return self.initialized and self.source ~= nil and self.sceneitem ~= nil
end

-- Get source info
function SourceManager:get_info()
    if not self:is_valid() then
        return nil
    end

    return {
        name = self.source_name,
        width = obs.obs_source_get_width(self.source),
        height = obs.obs_source_get_height(self.source),
    }
end

-- Get list of available capture sources
function SourceManager.get_available_sources()
    local sources = {}

    -- Get all sources
    local source_list = obs.obs_enum_sources()
    if source_list then
        for _, source in ipairs(source_list) do
            local source_id = obs.obs_source_get_id(source)
            local name = obs.obs_source_get_name(source)

            -- Filter for capture sources
            local is_capture = false
            if source_id == "monitor_capture" or      -- Display capture
               source_id == "window_capture" or       -- Window capture
               source_id == "game_capture" or         -- Game capture
               source_id == "xshm_input" or           -- Linux X11 capture
               source_id == "av_capture_input" then   -- macOS capture
                is_capture = true
            end

            if is_capture then
                table.insert(sources, {
                    name = name,
                    id = source_id,
                })
            end
        end
        obs.source_list_release(source_list)
    end

    return sources
end

-- Convenience wrapper functions
function source_manager_init(source_name)
    return SourceManager:init(source_name)
end

function source_manager_release()
    return SourceManager:release()
end

function source_manager_is_valid()
    return SourceManager:is_valid()
end

function source_manager_get_source()
    return SourceManager.source
end

function source_manager_get_sceneitem()
    return SourceManager.sceneitem
end

function source_manager_get_size()
    return SourceManager:get_source_size()
end

function source_manager_get_available_sources()
    return SourceManager.get_available_sources()
end

--================================================
-- MODULE: Camera Physics (M06)
--================================================
-- Handles camera position calculations, dead zones,
-- and SmoothDamp-based camera movement

local CameraPhysics = {
    -- Smoothed camera position
    pos = { x = 0, y = 0 },

    -- Velocities for SmoothDamp
    vel_x = { val = 0 },
    vel_y = { val = 0 },

    -- Dead zone state
    tracked_pos = { x = 0, y = 0 },
    dead_zone_active = false,

    -- Last camera position (for velocity calculation)
    last_pos = { x = 0, y = 0 },

    -- Monitor offset (for multi-monitor setups)
    monitor_offset = { x = 0, y = 0 },
}

-- Initialize camera tracking with starting position
function CameraPhysics:init(mouse_pos)
    if mouse_pos then
        self.pos.x = mouse_pos.x
        self.pos.y = mouse_pos.y
        self.tracked_pos.x = mouse_pos.x
        self.tracked_pos.y = mouse_pos.y
    end
    self.vel_x.val = 0
    self.vel_y.val = 0
    self.last_pos.x = self.pos.x
    self.last_pos.y = self.pos.y
end

-- Apply dead zone to mouse input
-- Returns the position the camera should track
function CameraPhysics:apply_dead_zone(mouse_pos, dead_zone_radius)
    if not mouse_pos then
        return self.tracked_pos
    end

    if dead_zone_radius <= 0 then
        self.tracked_pos.x = mouse_pos.x
        self.tracked_pos.y = mouse_pos.y
        return self.tracked_pos
    end

    -- Calculate distance from tracked position to mouse
    local dx = mouse_pos.x - self.tracked_pos.x
    local dy = mouse_pos.y - self.tracked_pos.y
    local dist = math.sqrt(dx * dx + dy * dy)

    if dist <= dead_zone_radius then
        -- Mouse is within dead zone, don't move tracked position
        self.dead_zone_active = true
        return self.tracked_pos
    end

    -- Mouse is outside dead zone
    -- Move tracked position so it stays exactly dead_zone_radius from mouse
    self.dead_zone_active = false
    local excess = dist - dead_zone_radius
    local nx = dx / dist  -- Normalized direction
    local ny = dy / dist

    self.tracked_pos.x = self.tracked_pos.x + nx * excess
    self.tracked_pos.y = self.tracked_pos.y + ny * excess

    return self.tracked_pos
end

-- Smooth the input position using SmoothDamp
function CameraPhysics:smooth_input(target_pos, smooth_time, dt)
    if not target_pos then
        return self.pos
    end

    local max_speed = 100000  -- Very high max speed for smooth camera

    self.pos.x = SmoothDamp(self.pos.x, target_pos.x, self.vel_x, smooth_time, max_speed, dt)
    self.pos.y = SmoothDamp(self.pos.y, target_pos.y, self.vel_y, smooth_time, max_speed, dt)

    return self.pos
end

-- Calculate the crop rectangle for a given zoom level and center position
function CameraPhysics:compute_crop(center_x, center_y, zoom_level, source_w, source_h)
    if zoom_level <= 1.0 then
        -- No zoom, return full source
        return {
            x = 0,
            y = 0,
            w = source_w,
            h = source_h,
        }
    end

    -- Calculate crop dimensions
    local crop_w = source_w / zoom_level
    local crop_h = source_h / zoom_level

    -- Center the crop on the target position
    local crop_x = center_x - crop_w / 2
    local crop_y = center_y - crop_h / 2

    -- Clamp to source bounds
    crop_x = clamp(0, source_w - crop_w, crop_x)
    crop_y = clamp(0, source_h - crop_h, crop_y)

    return {
        x = crop_x,
        y = crop_y,
        w = crop_w,
        h = crop_h,
    }
end

-- Calculate target crop for zoom animation
-- mouse_pos: current mouse position
-- zoom_level: target zoom level
-- source_w, source_h: source dimensions
-- monitor_offset: offset for multi-monitor (optional)
function CameraPhysics:get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
    if not mouse_pos then
        return nil
    end

    -- Apply monitor offset if provided
    local target_x = mouse_pos.x
    local target_y = mouse_pos.y

    if monitor_offset then
        target_x = target_x - monitor_offset.x
        target_y = target_y - monitor_offset.y
    end

    -- Clamp to source bounds
    target_x = clamp(0, source_w, target_x)
    target_y = clamp(0, source_h, target_y)

    return self:compute_crop(target_x, target_y, zoom_level, source_w, source_h)
end

-- Interpolate between two crop rectangles
function CameraPhysics:lerp_crop(start_crop, end_crop, t, easing_fn)
    if not start_crop or not end_crop then
        return nil
    end

    t = clamp(0, 1, t)

    -- Apply easing
    local eased_t = easing_fn and easing_fn(t) or t

    return {
        x = lerp(start_crop.x, end_crop.x, eased_t),
        y = lerp(start_crop.y, end_crop.y, eased_t),
        w = lerp(start_crop.w, end_crop.w, eased_t),
        h = lerp(start_crop.h, end_crop.h, eased_t),
    }
end

-- Get camera velocity (for motion blur)
function CameraPhysics:get_velocity()
    return {
        x = self.pos.x - self.last_pos.x,
        y = self.pos.y - self.last_pos.y,
    }
end

-- Update last position (call at end of frame)
function CameraPhysics:update_last_pos()
    self.last_pos.x = self.pos.x
    self.last_pos.y = self.pos.y
end

-- Set monitor offset
function CameraPhysics:set_monitor_offset(offset)
    self.monitor_offset = offset or { x = 0, y = 0 }
end

-- Reset camera state
function CameraPhysics:reset()
    self.pos = { x = 0, y = 0 }
    self.vel_x = { val = 0 }
    self.vel_y = { val = 0 }
    self.tracked_pos = { x = 0, y = 0 }
    self.dead_zone_active = false
    self.last_pos = { x = 0, y = 0 }
end

-- Convenience wrapper functions
function camera_physics_init(mouse_pos)
    return CameraPhysics:init(mouse_pos)
end

function camera_physics_apply_dead_zone(mouse_pos, dead_zone_radius)
    return CameraPhysics:apply_dead_zone(mouse_pos, dead_zone_radius)
end

function camera_physics_smooth_input(target_pos, smooth_time, dt)
    return CameraPhysics:smooth_input(target_pos, smooth_time, dt)
end

function camera_physics_compute_crop(center_x, center_y, zoom_level, source_w, source_h)
    return CameraPhysics:compute_crop(center_x, center_y, zoom_level, source_w, source_h)
end

function camera_physics_get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
    return CameraPhysics:get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
end

function camera_physics_lerp_crop(start_crop, end_crop, t, easing_fn)
    return CameraPhysics:lerp_crop(start_crop, end_crop, t, easing_fn)
end

function camera_physics_get_velocity()
    return CameraPhysics:get_velocity()
end

function camera_physics_update_last_pos()
    return CameraPhysics:update_last_pos()
end

function camera_physics_reset()
    return CameraPhysics:reset()
end

--================================================
-- MODULE: Timer & Main Loop (M09)
--================================================
-- Core integration module that handles frame-by-frame updates,
-- input processing, state machine updates, and output

-- Configuration (will be populated from settings)
local cfg = {
    source_name = "",
    zoom_value = 2.0,
    max_zoom = 10.0,
    zoom_duration = 0.6,
    zoom_overshoot = 0.0,
    zoom_easing = "Cubic.Out",

    auto_follow = true,
    follow_smooth_time = 0.15,
    follow_dead_zone = 5,

    debug_logs = false,
}

-- Timing
local last_tick_time = 0
local timer_running = false

-- Frame diff tracking (skip updates if nothing changed)
local last_output = { x = -1, y = -1, w = -1, h = -1 }

-- Original crop for zoom out
local original_crop = { x = 0, y = 0, w = 0, h = 0 }

-- Hotkey IDs
local hotkey_toggle_zoom = nil
local hotkey_toggle_follow = nil

-- Get reliable delta time
local function get_dt()
    local now = os.clock()
    local dt = now - last_tick_time
    last_tick_time = now
    return clamp(0.001, 0.1, dt)  -- Guard against freezes and div/zero
end

-- Start the timer
local function start_timer()
    if not timer_running then
        timer_running = true
        last_tick_time = os.clock()
        -- Use frame-synced interval
        local interval = 16  -- Default to ~60fps
        obs.timer_add(on_timer, interval)
        log("Timer: Started")
    end
end

-- Stop the timer
local function stop_timer()
    if timer_running then
        timer_running = false
        obs.timer_remove(on_timer)
        log("Timer: Stopped")
    end
end

-- Initialize mouse tracking
local function init_mouse_tracking(mouse_pos)
    camera_physics_init(mouse_pos)
    original_crop = {
        x = 0,
        y = 0,
        w = 0,
        h = 0,
    }
end

-- Main timer callback
function on_timer()
    local dt = get_dt()

    -- Guard: No valid source
    if not source_manager_is_valid() then
        return
    end

    --==========================
    -- 1. INPUT
    --==========================
    local raw_mouse = platform_get_mouse_pos()

    --==========================
    -- 2. STATE MACHINE UPDATE
    --==========================
    if SM:is_animating() then
        SM.zoom_time = SM.zoom_time + (dt / cfg.zoom_duration)

        -- Check for completion
        if SM.zoom_time >= 1.0 then
            SM:complete()

            -- Auto-enable follow after zoom in
            if SM.state == ZoomState.ZOOMED_IN and cfg.auto_follow then
                SM.following = true
            end

            -- Stop timer if idle
            if SM.state == ZoomState.IDLE then
                stop_timer()
            end
        end
    end

    --==========================
    -- 3. CAMERA POSITION
    --==========================
    local crop = nil
    local source_w, source_h = source_manager_get_size()

    if source_w == 0 or source_h == 0 then
        return
    end

    if SM:is_animating() then
        -- Animate between start and target crop
        local easing_fn = Easing.get(cfg.zoom_easing, cfg.zoom_overshoot)
        crop = camera_physics_lerp_crop(SM.start_crop, SM.target_crop, SM.zoom_time, easing_fn)
    elseif SM:is_zoomed() and SM.following then
        -- Follow mouse with dead zone and smoothing
        local tracked = camera_physics_apply_dead_zone(raw_mouse, cfg.follow_dead_zone)
        local smoothed = camera_physics_smooth_input(tracked, cfg.follow_smooth_time, dt)
        crop = camera_physics_compute_crop(smoothed.x, smoothed.y, SM.zoom_level, source_w, source_h)
        camera_physics_update_last_pos()
    elseif SM:is_zoomed() then
        -- Static zoom (not following)
        crop = camera_physics_get_target_crop(
            { x = SM.target_crop.x + SM.target_crop.w / 2, y = SM.target_crop.y + SM.target_crop.h / 2 },
            SM.zoom_level, source_w, source_h, nil
        )
    end

    --==========================
    -- 4. OUTPUT (Diff-based)
    --==========================
    if crop then
        local cx = math.floor(crop.x)
        local cy = math.floor(crop.y)
        local cw = math.floor(crop.w)
        local ch = math.floor(crop.h)

        if cx ~= last_output.x or cy ~= last_output.y or
           cw ~= last_output.w or ch ~= last_output.h then
            crop_filter_update(cx, cy, cw, ch)
            last_output.x = cx
            last_output.y = cy
            last_output.w = cw
            last_output.h = ch
        end
    end
end

--==========================
-- HOTKEY HANDLERS
--==========================

function on_toggle_zoom(pressed)
    if not pressed then return end

    if not source_manager_is_valid() then
        log("Toggle Zoom: No valid source")
        return
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        log("Toggle Zoom: Invalid source dimensions")
        return
    end

    if SM.state == ZoomState.IDLE then
        -- ZOOM IN
        local mouse = platform_get_mouse_pos()
        init_mouse_tracking(mouse)

        -- Store original crop
        original_crop = { x = 0, y = 0, w = source_w, h = source_h }

        -- Calculate target crop
        local target_crop = camera_physics_get_target_crop(mouse, cfg.zoom_value, source_w, source_h, nil)

        SM:transition(ZoomState.ZOOMING_IN, {
            start_crop = original_crop,
            target_crop = target_crop,
            target_level = cfg.zoom_value
        })

        start_timer()

    elseif SM.state == ZoomState.ZOOMED_IN then
        -- ZOOM OUT
        SM.following = false

        local current = crop_filter_get_crop()
        SM:transition(ZoomState.ZOOMING_OUT, {
            start_crop = current,
            target_crop = original_crop,
            target_level = 1.0
        })

        start_timer()
    end
    -- Ignore if already animating (guard against rapid presses)
end

function on_toggle_follow(pressed)
    if not pressed then return end
    if not SM:is_zoomed() then return end

    SM.following = not SM.following
    log("Follow: " .. tostring(SM.following))

    if SM.following and not timer_running then
        start_timer()
    end
end

--==========================
-- HOTKEY REGISTRATION
--==========================

local function register_hotkeys(settings)
    -- Toggle Zoom hotkey
    hotkey_toggle_zoom = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.toggle_zoom",
        "Toggle Zoom to Mouse",
        on_toggle_zoom
    )

    -- Toggle Follow hotkey
    hotkey_toggle_follow = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.toggle_follow",
        "Toggle Mouse Follow",
        on_toggle_follow
    )

    -- Load saved hotkey bindings
    local toggle_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.toggle_zoom")
    if toggle_array then
        obs.obs_hotkey_load(hotkey_toggle_zoom, toggle_array)
        obs.obs_data_array_release(toggle_array)
    end

    local follow_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.toggle_follow")
    if follow_array then
        obs.obs_hotkey_load(hotkey_toggle_follow, follow_array)
        obs.obs_data_array_release(follow_array)
    end

    -- Register scroll zoom hotkeys
    register_scroll_hotkeys(settings)

    log("Hotkeys: Registered")
end

local function save_hotkeys(settings)
    if hotkey_toggle_zoom then
        local array = obs.obs_hotkey_save(hotkey_toggle_zoom)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.toggle_zoom", array)
        obs.obs_data_array_release(array)
    end

    if hotkey_toggle_follow then
        local array = obs.obs_hotkey_save(hotkey_toggle_follow)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.toggle_follow", array)
        obs.obs_data_array_release(array)
    end

    -- Save scroll zoom hotkeys
    save_scroll_hotkeys(settings)
end

local function unregister_hotkeys()
    if hotkey_toggle_zoom then
        obs.obs_hotkey_unregister(hotkey_toggle_zoom)
        hotkey_toggle_zoom = nil
    end
    if hotkey_toggle_follow then
        obs.obs_hotkey_unregister(hotkey_toggle_follow)
        hotkey_toggle_follow = nil
    end
    -- Unregister scroll zoom hotkeys
    unregister_scroll_hotkeys()
    log("Hotkeys: Unregistered")
end

--==========================
-- SCENE EVENT HANDLERS
--==========================

function on_frontend_event(event)
    if event == obs.OBS_FRONTEND_EVENT_SCENE_CHANGED then
        -- Scene changed, re-acquire source
        log("Event: Scene changed")

        -- Handle scene memory
        scene_memory_on_scene_change()

        if cfg.source_name and cfg.source_name ~= "" then
            source_manager_release()
            source_manager_init(cfg.source_name)
        end
    elseif event == obs.OBS_FRONTEND_EVENT_EXIT then
        -- OBS is closing
        log("Event: OBS exiting")
        stop_timer()
        source_manager_release()
    end
end

--==========================
-- CONFIGURATION UPDATE
--==========================

local function update_config(settings)
    cfg.source_name = obs.obs_data_get_string(settings, "source") or ""
    cfg.zoom_value = obs.obs_data_get_double(settings, "zoom_value")
    cfg.zoom_duration = obs.obs_data_get_double(settings, "zoom_duration")
    cfg.zoom_overshoot = obs.obs_data_get_double(settings, "zoom_overshoot")
    cfg.zoom_easing = obs.obs_data_get_string(settings, "zoom_easing") or "Cubic.Out"

    cfg.auto_follow = obs.obs_data_get_bool(settings, "auto_follow")
    cfg.follow_smooth_time = obs.obs_data_get_double(settings, "follow_smooth_time")
    cfg.follow_dead_zone = obs.obs_data_get_int(settings, "follow_dead_zone")

    cfg.debug_logs = obs.obs_data_get_bool(settings, "debug_logs")
    debug_logs = cfg.debug_logs

    -- Update scroll zoom config
    update_scroll_config(settings)

    -- Check if source changed
    local current_source = source_manager_is_valid() and cfg.source_name
    if cfg.source_name ~= "" and cfg.source_name ~= current_source then
        -- Reset state and reinitialize
        SM:reset()
        stop_timer()
        source_manager_release()
        source_manager_init(cfg.source_name)
    end
end

--================================================
-- MODULE: Scroll Zoom (M10)
--================================================
-- Enables gradual zoom control via scroll wheel with modifier key
-- Provides dynamic zoom level adjustment during zoomed state

local ScrollZoom = {
    -- Hotkey IDs for scroll zoom
    hotkey_scroll_up = nil,
    hotkey_scroll_down = nil,

    -- Configuration (populated from settings)
    scroll_step = 0.25,
    scroll_modifier = "ctrl",  -- "ctrl", "alt", "shift"
}

-- Check if modifier key is held
local function is_modifier_held()
    if ScrollZoom.scroll_modifier == "ctrl" then
        return platform_is_ctrl_held()
    elseif ScrollZoom.scroll_modifier == "alt" then
        return platform_is_alt_held()
    elseif ScrollZoom.scroll_modifier == "shift" then
        return platform_is_shift_held()
    end
    return false
end

-- Handle scroll zoom in
function on_scroll_zoom_up(pressed)
    if not pressed then return end
    on_scroll_zoom(1)
end

-- Handle scroll zoom out
function on_scroll_zoom_down(pressed)
    if not pressed then return end
    on_scroll_zoom(-1)
end

-- Main scroll zoom handler
function on_scroll_zoom(direction)
    -- Check if we can scroll
    if not SM:can_scroll() then return end

    -- Check modifier (optional - can be configured)
    -- For now, we rely on OBS hotkey bindings which can include modifiers

    if not source_manager_is_valid() then
        log("Scroll Zoom: No valid source")
        return
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        return
    end

    -- Calculate new zoom level
    local step = ScrollZoom.scroll_step * direction  -- e.g., 0.25
    local new_level

    if SM.state == ZoomState.IDLE then
        -- Starting from unzoomed
        new_level = 1.0 + step
    else
        -- Already zoomed, adjust level
        new_level = SM.target_level + step
    end

    -- Clamp to valid range
    new_level = clamp(1.0, cfg.max_zoom, new_level)

    -- If we hit 1.0, fully zoom out
    if new_level <= 1.0 then
        if SM:is_zoomed() then
            -- Trigger full zoom out
            local current = crop_filter_get_crop()
            SM.following = false
            SM:transition(ZoomState.ZOOMING_OUT, {
                start_crop = current,
                target_crop = original_crop,
                target_level = 1.0
            })
            start_timer()
        end
        return
    end

    -- Get current mouse position
    local mouse = platform_get_mouse_pos()

    -- Calculate new target crop for new zoom level
    local target_crop = camera_physics_get_target_crop(mouse, new_level, source_w, source_h, nil)

    -- Get current crop as start
    local start_crop
    if SM:is_animating() then
        -- Use current interpolated crop
        start_crop = crop_filter_get_crop()
    elseif SM:is_zoomed() then
        -- Use current crop
        start_crop = crop_filter_get_crop()
    else
        -- Starting from unzoomed
        start_crop = { x = 0, y = 0, w = source_w, h = source_h }
        original_crop = start_crop
        camera_physics_init(mouse)
    end

    -- Transition to new zoom level
    if SM.state == ZoomState.IDLE then
        -- First scroll from unzoomed
        SM:transition(ZoomState.SCROLLING, {
            start_crop = start_crop,
            target_crop = target_crop,
            target_level = new_level
        })
    else
        -- Already zoomed, adjust level (interrupt current animation)
        SM:transition(ZoomState.SCROLLING, {
            start_crop = start_crop,
            target_crop = target_crop,
            target_level = new_level
        })
    end

    start_timer()
    log("Scroll Zoom: Level " .. string.format("%.2f", new_level))
end

-- Zoom to a specific level (for API calls)
function on_scroll_zoom_to(level)
    if not source_manager_is_valid() then return end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then return end

    level = clamp(1.0, cfg.max_zoom, level)

    if level <= 1.0 then
        -- Zoom out
        if SM:is_zoomed() then
            local current = crop_filter_get_crop()
            SM.following = false
            SM:transition(ZoomState.ZOOMING_OUT, {
                start_crop = current,
                target_crop = original_crop,
                target_level = 1.0
            })
            start_timer()
        end
        return
    end

    local mouse = platform_get_mouse_pos()
    local target_crop = camera_physics_get_target_crop(mouse, level, source_w, source_h, nil)

    local start_crop
    if SM:is_zoomed() then
        start_crop = crop_filter_get_crop()
    else
        start_crop = { x = 0, y = 0, w = source_w, h = source_h }
        original_crop = start_crop
        camera_physics_init(mouse)
    end

    SM:transition(ZoomState.SCROLLING, {
        start_crop = start_crop,
        target_crop = target_crop,
        target_level = level
    })

    start_timer()
end

-- Register scroll zoom hotkeys
local function register_scroll_hotkeys(settings)
    -- Scroll Up hotkey
    ScrollZoom.hotkey_scroll_up = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.scroll_up",
        "Zoom In (Scroll)",
        on_scroll_zoom_up
    )

    -- Scroll Down hotkey
    ScrollZoom.hotkey_scroll_down = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.scroll_down",
        "Zoom Out (Scroll)",
        on_scroll_zoom_down
    )

    -- Load saved bindings
    local up_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.scroll_up")
    if up_array then
        obs.obs_hotkey_load(ScrollZoom.hotkey_scroll_up, up_array)
        obs.obs_data_array_release(up_array)
    end

    local down_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.scroll_down")
    if down_array then
        obs.obs_hotkey_load(ScrollZoom.hotkey_scroll_down, down_array)
        obs.obs_data_array_release(down_array)
    end

    log("Scroll Zoom: Hotkeys registered")
end

-- Save scroll hotkey bindings
local function save_scroll_hotkeys(settings)
    if ScrollZoom.hotkey_scroll_up then
        local array = obs.obs_hotkey_save(ScrollZoom.hotkey_scroll_up)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.scroll_up", array)
        obs.obs_data_array_release(array)
    end

    if ScrollZoom.hotkey_scroll_down then
        local array = obs.obs_hotkey_save(ScrollZoom.hotkey_scroll_down)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.scroll_down", array)
        obs.obs_data_array_release(array)
    end
end

-- Unregister scroll hotkeys
local function unregister_scroll_hotkeys()
    if ScrollZoom.hotkey_scroll_up then
        obs.obs_hotkey_unregister(ScrollZoom.hotkey_scroll_up)
        ScrollZoom.hotkey_scroll_up = nil
    end
    if ScrollZoom.hotkey_scroll_down then
        obs.obs_hotkey_unregister(ScrollZoom.hotkey_scroll_down)
        ScrollZoom.hotkey_scroll_down = nil
    end
end

-- Update scroll zoom config
local function update_scroll_config(settings)
    ScrollZoom.scroll_step = obs.obs_data_get_double(settings, "scroll_step")
    ScrollZoom.scroll_modifier = obs.obs_data_get_string(settings, "scroll_modifier") or "ctrl"
end

--================================================
-- PLACEHOLDER: Future Modules
--================================================

-- M01: Configuration & Settings (TODO)
-- M05: Scene Manager (TODO)
-- M06: Source Manager (TODO)
-- M07: Crop/Zoom Controller (TODO)
-- M08: Motion Tracker (TODO)
-- M09: Face Detection (TODO)
-- M11: Audio Reactor (TODO)
-- M12: Transition Manager (TODO)
-- M13: Animation Controller (TODO)
-- M14: Preset Manager (TODO)
-- M15: Hotkey Manager (TODO)
-- M16: UI Components (TODO)
-- M17: Timer/Scheduler (TODO)
-- M18: State Machine (TODO)
-- M19: Performance Monitor (TODO)

--================================================
-- SCRIPT SETTINGS
--================================================
local settings = {}

-- Default settings
local defaults = {
    debug_logging = false,
    easing_type = "QuadInOut",
    smooth_time = 0.3,
    max_speed = 100.0
}

--================================================
-- MODULE: Preset Manager (M13)
--================================================
-- Manages built-in and custom animation presets

local PresetManager = {
    -- Built-in presets (read-only)
    built_in = {
        {
            name = "Smooth",
            duration = 0.8,
            overshoot = 0.0,
            smoothness = 0.25,
            easing = "Cubic.Out",
        },
        {
            name = "Bounce",
            duration = 0.6,
            overshoot = 0.35,
            smoothness = 0.15,
            easing = "Back.Out",
        },
        {
            name = "Snappy",
            duration = 0.3,
            overshoot = 0.0,
            smoothness = 0.05,
            easing = "Expo.Out",
        },
        {
            name = "Cinematic",
            duration = 1.2,
            overshoot = 0.05,
            smoothness = 0.4,
            easing = "Sine.Out",
        },
    },

    -- Custom user presets
    custom = {},

    -- Currently selected preset name
    current_preset = "Smooth",
}

-- Get all preset names (built-in + custom)
function PresetManager:get_all_names()
    local names = {}

    -- Add built-in presets
    for _, preset in ipairs(self.built_in) do
        table.insert(names, preset.name)
    end

    -- Add custom presets
    for name, _ in pairs(self.custom) do
        table.insert(names, name)
    end

    table.sort(names)
    return names
end

-- Get preset by name
function PresetManager:get_preset(name)
    -- Check built-in first
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            return preset
        end
    end

    -- Check custom
    if self.custom[name] then
        return self.custom[name]
    end

    -- Default to Smooth
    return self.built_in[1]
end

-- Apply preset to configuration
function PresetManager:apply_preset(name)
    local preset = self:get_preset(name)
    if not preset then
        log("Preset: Unknown preset: " .. name)
        return false
    end

    cfg.zoom_duration = preset.duration
    cfg.zoom_overshoot = preset.overshoot
    cfg.follow_smooth_time = preset.smoothness

    if preset.easing then
        cfg.zoom_easing = preset.easing
    end

    self.current_preset = name
    log("Preset: Applied '" .. name .. "'")
    return true
end

-- Save a custom preset
function PresetManager:save_preset(name, duration, overshoot, smoothness, easing)
    if not name or name == "" then
        return false
    end

    -- Check if it's a built-in preset (can't override)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            log("Preset: Cannot override built-in preset: " .. name)
            return false
        end
    end

    -- Save custom preset
    self.custom[name] = {
        name = name,
        duration = duration or cfg.zoom_duration,
        overshoot = overshoot or cfg.zoom_overshoot,
        smoothness = smoothness or cfg.follow_smooth_time,
        easing = easing or cfg.zoom_easing,
    }

    log("Preset: Saved custom preset '" .. name .. "'")
    return true
end

-- Delete a custom preset
function PresetManager:delete_preset(name)
    -- Check if it's a built-in preset (can't delete)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            log("Preset: Cannot delete built-in preset: " .. name)
            return false
        end
    end

    -- Delete custom preset
    if self.custom[name] then
        self.custom[name] = nil
        log("Preset: Deleted custom preset '" .. name .. "'")
        return true
    end

    return false
end

-- Check if a preset is built-in
function PresetManager:is_built_in(name)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            return true
        end
    end
    return false
end

-- Persist custom presets to settings
function PresetManager:persist(settings)
    local array = obs.obs_data_array_create()

    for name, preset in pairs(self.custom) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "name", name)
        obs.obs_data_set_double(item, "duration", preset.duration)
        obs.obs_data_set_double(item, "overshoot", preset.overshoot)
        obs.obs_data_set_double(item, "smoothness", preset.smoothness)
        obs.obs_data_set_string(item, "easing", preset.easing)
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "custom_presets", array)
    obs.obs_data_array_release(array)
end

-- Load custom presets from settings
function PresetManager:load(settings)
    self.custom = {}

    local array = obs.obs_data_get_array(settings, "custom_presets")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local name = obs.obs_data_get_string(item, "name")

        if name and name ~= "" then
            self.custom[name] = {
                name = name,
                duration = obs.obs_data_get_double(item, "duration"),
                overshoot = obs.obs_data_get_double(item, "overshoot"),
                smoothness = obs.obs_data_get_double(item, "smoothness"),
                easing = obs.obs_data_get_string(item, "easing"),
            }
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)
    log("Preset: Loaded " .. self:get_custom_count() .. " custom presets")
end

-- Get count of custom presets
function PresetManager:get_custom_count()
    local count = 0
    for _, _ in pairs(self.custom) do
        count = count + 1
    end
    return count
end

-- Get current preset name
function PresetManager:get_current_name()
    return self.current_preset
end

-- Set current preset name
function PresetManager:set_current_name(name)
    self.current_preset = name
end

-- Check if current preset is custom
function PresetManager:is_current_custom()
    return not self:is_built_in(self.current_preset)
end

-- Global convenience functions
function preset_get_all_names()
    return PresetManager:get_all_names()
end

function preset_apply(name)
    return PresetManager:apply_preset(name)
end

function preset_save(name, duration, overshoot, smoothness, easing)
    return PresetManager:save_preset(name, duration, overshoot, smoothness, easing)
end

function preset_delete(name)
    return PresetManager:delete_preset(name)
end

function preset_is_built_in(name)
    return PresetManager:is_built_in(name)
end

function preset_get_current()
    return PresetManager:get_current_name()
end

--================================================
-- MODULE: Auto Source Detection (M11)
--================================================
-- Automatically detects and selects the best zoom source on first run

local AutoSourceDetector = {
    -- Source type priorities (higher = more likely to be the main display)
    type_priorities = {
        ["monitor_capture"] = 100,     -- Display capture (highest priority)
        ["game_capture"] = 80,          -- Game capture
        ["window_capture"] = 60,        -- Window capture
        ["xshm_input"] = 40,           -- Linux X11 capture
        ["av_capture_input"] = 20,     -- macOS capture
    },

    -- Whether auto-detection has been run
    auto_detected = false,
}

-- Get all capture sources sorted by priority
function AutoSourceDetector:get_capture_sources()
    local sources = {}
    local source_list = obs.obs_enum_sources()

    if not source_list then
        return sources
    end

    for _, source in ipairs(source_list) do
        local source_id = obs.obs_source_get_id(source)
        local name = obs.obs_source_get_name(source)

        -- Check if it's a capture source
        local priority = self.type_priorities[source_id]
        if priority then
            table.insert(sources, {
                name = name,
                id = source_id,
                priority = priority,
            })
        end
    end

    obs.source_list_release(source_list)

    -- Sort by priority (highest first)
    table.sort(sources, function(a, b)
        return a.priority > b.priority
    end)

    return sources
end

-- Auto-detect the best source
function AutoSourceDetector:auto_detect()
    local sources = self:get_capture_sources()

    if #sources == 0 then
        log("AutoSource: No capture sources found")
        return nil
    end

    if #sources == 1 then
        -- Only one source, use it
        log("AutoSource: Found single source: " .. sources[1].name)
        return sources[1].name
    end

    -- Multiple sources - prioritize by type
    -- Prefer monitor_capture > game_capture > window_capture
    local best = sources[1]

    log("AutoSource: Found " .. #sources .. " sources, selecting: " .. best.name)
    return best.name
end

-- Get monitor geometry from a source (if available)
function AutoSourceDetector:get_monitor_geometry(source_name)
    local source = obs.obs_get_source_by_name(source_name)
    if not source then
        return nil
    end

    local settings = obs.obs_source_get_settings(source)
    if not settings then
        obs.obs_source_release(source)
        return nil
    end

    -- Try to get monitor info from settings
    local monitor = obs.obs_data_get_int(settings, "monitor")
    local x = obs.obs_data_get_int(settings, "x")
    local y = obs.obs_data_get_int(settings, "y")
    local width = obs.obs_data_get_int(settings, "width")
    local height = obs.obs_data_get_int(settings, "height")

    obs.obs_data_release(settings)
    obs.obs_source_release(source)

    -- Return geometry if available
    if monitor >= 0 or width > 0 then
        return {
            monitor = monitor,
            x = x,
            y = y,
            width = width or 1920,
            height = height or 1080,
        }
    end

    return nil
end

-- Check if we should auto-detect on first run
function AutoSourceDetector:should_auto_detect(settings)
    -- Check if source has ever been set
    local last_source = obs.obs_data_get_string(settings, "source")
    if last_source and last_source ~= "" then
        return false
    end

    -- Check if auto-detect has been done
    return not self.auto_detected
end

-- Run auto-detection and return the source name
function AutoSourceDetector:run(settings)
    local source_name = self:auto_detect()

    if source_name then
        -- Save the detected source
        obs.obs_data_set_string(settings, "source", source_name)
        self.auto_detected = true
    end

    return source_name
end

-- Global convenience functions
function auto_source_detect()
    return AutoSourceDetector:auto_detect()
end

function auto_source_should_detect(settings)
    return AutoSourceDetector:should_auto_detect(settings)
end

function auto_source_run(settings)
    return AutoSourceDetector:run(settings)
end

--================================================
-- MODULE: Scene Memory (M12)
--================================================
-- Remembers which zoom source to use for each OBS scene

local SceneMemory = {
    -- Scene to source mapping
    scene_source_map = {},

    -- Maximum number of mappings to store
    max_mappings = 50,
}

-- Get the current scene name
function SceneMemory:get_current_scene_name()
    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then
        return nil
    end

    local name = obs.obs_source_get_name(scene_source)
    obs.obs_source_release(scene_source)
    return name
end

-- Get the source to use for the current scene
function SceneMemory:get_source_for_current_scene()
    local scene_name = self:get_current_scene_name()
    if not scene_name then
        return nil
    end

    -- 1. Check explicit mapping for this scene
    if self.scene_source_map[scene_name] then
        return self.scene_source_map[scene_name]
    end

    -- 2. Fall back to global source from config
    return cfg.source_name
end

-- Set the source for a specific scene
function SceneMemory:set(scene_name, source_name)
    if not scene_name or scene_name == "" then
        return false
    end

    -- Check if we're at capacity
    local count = 0
    for _, _ in pairs(self.scene_source_map) do
        count = count + 1
    end

    if count >= self.max_mappings and not self.scene_source_map[scene_name] then
        log("SceneMemory: At capacity (" .. self.max_mappings .. "), cannot add: " .. scene_name)
        return false
    end

    self.scene_source_map[scene_name] = source_name
    log("SceneMemory: " .. scene_name .. " Ã¢â€ â€™ " .. source_name)
    return true
end

-- Remove a scene mapping
function SceneMemory:remove(scene_name)
    if self.scene_source_map[scene_name] then
        self.scene_source_map[scene_name] = nil
        log("SceneMemory: Removed mapping for " .. scene_name)
        return true
    end
    return false
end

-- Get all scene mappings
function SceneMemory:get_all()
    local mappings = {}
    for scene, source in pairs(self.scene_source_map) do
        table.insert(mappings, { scene = scene, source = source })
    end
    table.sort(mappings, function(a, b)
        return a.scene < b.scene
    end)
    return mappings
end

-- Check if a scene has a mapping
function SceneMemory:has_mapping(scene_name)
    return self.scene_source_map[scene_name] ~= nil
end

-- Persist mappings to settings
function SceneMemory:persist(settings)
    local array = obs.obs_data_array_create()

    for scene, source in pairs(self.scene_source_map) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "scene", scene)
        obs.obs_data_set_string(item, "source", source)
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "scene_source_map", array)
    obs.obs_data_array_release(array)
end

-- Load mappings from settings
function SceneMemory:load(settings)
    self.scene_source_map = {}

    local array = obs.obs_data_get_array(settings, "scene_source_map")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local scene = obs.obs_data_get_string(item, "scene")
        local source = obs.obs_data_get_string(item, "source")

        if scene and scene ~= "" and source and source ~= "" then
            self.scene_source_map[scene] = source
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)

    local count = 0
    for _, _ in pairs(self.scene_source_map) do count = count + 1 end
    log("SceneMemory: Loaded " .. count .. " scene mappings")
end

-- Handle scene change
function SceneMemory:on_scene_change()
    local scene_name = self:get_current_scene_name()
    if not scene_name then
        return
    end

    -- Get the source for this scene
    local source_name = self:get_source_for_current_scene()

    if source_name and source_name ~= "" then
        -- Check if source changed
        local current = source_manager_is_valid() and cfg.source_name

        if source_name ~= current then
            log("SceneMemory: Scene changed to " .. scene_name)

            -- Release current source
            source_manager_release()

            -- Initialize with new source
            cfg.source_name = source_name
            source_manager_init(source_name)
        end
    end
end

-- Global convenience functions
function scene_memory_get_source()
    return SceneMemory:get_source_for_current_scene()
end

function scene_memory_set(scene_name, source_name)
    return SceneMemory:set(scene_name, source_name)
end

function scene_memory_remove(scene_name)
    return SceneMemory:remove(scene_name)
end

function scene_memory_get_all()
    return SceneMemory:get_all()
end

function scene_memory_on_scene_change()
    return SceneMemory:on_scene_change()
end

--================================================
-- MODULE: Blur Manager (M14)
--================================================
-- Provides built-in blur effects without external plugins
-- Supports multiple strategies: shader, composite_blur plugin, or none

local BlurManager = {
    -- Current strategy: "shader", "composite_blur", "none"
    strategy = "none",

    -- Filter references
    zoom_blur_filter = nil,
    motion_blur_filter = nil,

    -- Settings references
    zoom_blur_settings = nil,
    motion_blur_settings = nil,

    -- State
    initialized = false,

    -- Configuration
    zoom_blur_enabled = false,
    zoom_blur_intensity = 5,
    zoom_blur_clear_radius = 150,
    motion_blur_enabled = false,
    motion_blur_intensity = 1.0,
}

-- Try to use custom shader (if effect files exist)
function BlurManager:try_shader_strategy(source)
    -- This would require .effect files in assets/shaders/
    -- For now, we'll use a simpler approach
    log("Blur: Shader strategy not implemented (requires effect files)")
    return false
end

-- Try to auto-create Composite Blur filters
function BlurManager:try_composite_blur_strategy(source)
    if not source then return false end

    -- Check if composite_blur filter type exists
    local test_filter = obs.obs_source_create_private("composite_blur", "__test_blur__", nil)
    if test_filter then
        obs.obs_source_release(test_filter)
    else
        log("Blur: Composite Blur plugin not available")
        return false
    end

    -- Create Zoom Blur filter
    local zs = obs.obs_data_create()
    obs.obs_data_set_double(zs, "radius", 0)
    obs.obs_data_set_int(zs, "blur_type", 2) -- Zoom type
    self.zoom_blur_filter = obs.obs_source_create_private(
        "composite_blur",
        FILTER_PREFIX .. "Zoom Blur",
        zs
    )

    if self.zoom_blur_filter then
        obs.obs_source_filter_add(source, self.zoom_blur_filter)
        self.zoom_blur_settings = zs
    else
        obs.obs_data_release(zs)
        return false
    end

    -- Create Motion Blur filter
    local ms = obs.obs_data_create()
    obs.obs_data_set_double(ms, "radius", 0)
    obs.obs_data_set_int(ms, "blur_type", 3) -- Motion/directional type
    self.motion_blur_filter = obs.obs_source_create_private(
        "composite_blur",
        FILTER_PREFIX .. "Motion Blur",
        ms
    )

    if self.motion_blur_filter then
        obs.obs_source_filter_add(source, self.motion_blur_filter)
        self.motion_blur_settings = ms
    else
        obs.obs_data_release(ms)
    end

    self.initialized = true
    return true
end

-- Initialize blur manager
function BlurManager:init(source)
    if not source then
        return false
    end

    self:cleanup()

    -- Try composite_blur strategy
    if self:try_composite_blur_strategy(source) then
        self.strategy = "composite_blur"
        log("Blur: Using Composite Blur plugin (auto-configured)")
        return true
    end

    -- No blur available
    self.strategy = "none"
    log("Blur: No blur backend available. Blur effects disabled.")
    return false
end

-- Update blur based on zoom state
function BlurManager:update(state_machine, crop, camera_velocity)
    if not self.initialized then return end
    if self.strategy == "none" then return end

    -- Zoom Blur: Active during zoom transitions
    if self.zoom_blur_enabled and self.zoom_blur_filter then
        local radius = 0

        if state_machine:is_animating() and
           (state_machine.state == ZoomState.ZOOMING_IN or
            state_machine.state == ZoomState.ZOOMING_OUT) then
            -- Bell curve: 0 at start Ã¢â€ â€™ peak at 50% Ã¢â€ â€™ 0 at end
            local t = clamp(0, 1, state_machine.zoom_time)
            local curve = math.sin(t * math.pi)
            radius = curve * curve * self.zoom_blur_intensity
        end

        self:set_zoom_blur(radius, crop)
    end

    -- Motion Blur: Active during camera panning (not during zoom transition)
    if self.motion_blur_enabled and self.motion_blur_filter then
        if not state_machine:is_animating() and state_machine:is_zoomed() and camera_velocity then
            local speed = math.sqrt(
                camera_velocity.x * camera_velocity.x +
                camera_velocity.y * camera_velocity.y
            )

            if speed > 1.0 then
                local radius = math.min(10, speed * self.motion_blur_intensity * 0.5)
                local angle = math.deg(math.atan2(camera_velocity.y, camera_velocity.x))
                self:set_motion_blur(radius, angle)
            else
                self:set_motion_blur(0, 0)
            end
        else
            self:set_motion_blur(0, 0)
        end
    end
end

-- Set zoom blur parameters
function BlurManager:set_zoom_blur(radius, crop)
    if self.strategy == "composite_blur" and self.zoom_blur_settings then
        obs.obs_data_set_double(self.zoom_blur_settings, "radius", radius)

        if crop then
            local cx = crop.x + (crop.w / 2)
            local cy = crop.y + (crop.h / 2)
            obs.obs_data_set_double(self.zoom_blur_settings, "center_x", cx)
            obs.obs_data_set_double(self.zoom_blur_settings, "center_y", cy)
        end

        obs.obs_data_set_double(self.zoom_blur_settings, "inactive_radius", self.zoom_blur_clear_radius)
        obs.obs_source_update(self.zoom_blur_filter, self.zoom_blur_settings)
    end
end

-- Set motion blur parameters
function BlurManager:set_motion_blur(radius, angle)
    if self.strategy == "composite_blur" and self.motion_blur_settings then
        obs.obs_data_set_double(self.motion_blur_settings, "radius", radius)
        obs.obs_data_set_double(self.motion_blur_settings, "angle", angle)
        obs.obs_source_update(self.motion_blur_filter, self.motion_blur_settings)
    end
end

-- Update configuration
function BlurManager:update_config(settings)
    self.zoom_blur_enabled = obs.obs_data_get_bool(settings, "zoom_blur_enabled")
    self.zoom_blur_intensity = obs.obs_data_get_double(settings, "zoom_blur_intensity")
    self.zoom_blur_clear_radius = obs.obs_data_get_double(settings, "zoom_blur_clear_radius")
    self.motion_blur_enabled = obs.obs_data_get_bool(settings, "motion_blur_enabled")
    self.motion_blur_intensity = obs.obs_data_get_double(settings, "motion_blur_intensity")
end

-- Cleanup filters
function BlurManager:cleanup()
    local source = source_manager_get_source()

    if self.zoom_blur_filter and source then
        obs.obs_source_filter_remove(source, self.zoom_blur_filter)
        obs.obs_source_release(self.zoom_blur_filter)
        self.zoom_blur_filter = nil
    end

    if self.motion_blur_filter and source then
        obs.obs_source_filter_remove(source, self.motion_blur_filter)
        obs.obs_source_release(self.motion_blur_filter)
        self.motion_blur_filter = nil
    end

    if self.zoom_blur_settings then
        obs.obs_data_release(self.zoom_blur_settings)
        self.zoom_blur_settings = nil
    end

    if self.motion_blur_settings then
        obs.obs_data_release(self.motion_blur_settings)
        self.motion_blur_settings = nil
    end

    self.initialized = false
    self.strategy = "none"
end

-- Check if blur is available
function BlurManager:is_available()
    return self.strategy ~= "none"
end

-- Global convenience functions
function blur_manager_init(source)
    return BlurManager:init(source)
end

function blur_manager_update(state_machine, crop, camera_velocity)
    return BlurManager:update(state_machine, crop, camera_velocity)
end

function blur_manager_update_config(settings)
    return BlurManager:update_config(settings)
end

function blur_manager_cleanup()
    return BlurManager:cleanup()
end

function blur_manager_is_available()
    return BlurManager:is_available()
end

--================================================
-- MODULE: Cursor Asset Manager (M16)
--================================================
-- Handles extracting and managing cursor image assets

local CursorAssets = {
    extracted = false,
    dir = nil,
}

-- Get the platform-specific asset directory
function CursorAssets:get_platform_dir()
    if IS_WINDOWS then
        local appdata = os.getenv("APPDATA")
        return appdata and (appdata .. "\\obs-studio\\obs-zoom-pro\\cursors") or nil
    elseif IS_LINUX then
        local home = os.getenv("HOME")
        return home and (home .. "/.config/obs-studio/obs-zoom-pro/cursors") or nil
    elseif IS_MACOS then
        local home = os.getenv("HOME")
        return home and (home .. "/Library/Application Support/obs-studio/obs-zoom-pro/cursors") or nil
    end
    -- Fallback for non-FFI environments
    return "cursors"
end

-- Ensure assets are extracted
function CursorAssets:ensure_extracted()
    if self.extracted then
        return self.dir
    end

    local dir = self:get_platform_dir()
    if not dir then
        log("CursorAssets: Could not determine asset directory")
        return nil
    end

    -- Create directory
    local cmd
    if IS_WINDOWS then
        cmd = 'mkdir "' .. dir .. '" 2>nul'
    else
        cmd = 'mkdir -p "' .. dir .. '"'
    end
    os.execute(cmd)

    -- Check if assets exist
    local sep = IS_WINDOWS and "\\" or "/"
    local arrow_path = dir .. sep .. "arrow.png"

    local f = io.open(arrow_path, "rb")
    if f then
        f:close()
        self.dir = dir
        self.extracted = true
        log("CursorAssets: Using existing assets from " .. dir)
        return dir
    end

    -- Try to copy from script directory
    local script_dir = get_script_directory()
    local assets_src = script_dir .. "assets" .. sep .. "cursors" .. sep

    local files = { "arrow.png", "pointer.png", "ibeam.png" }
    for _, filename in ipairs(files) do
        local src_path = assets_src .. filename
        local dst_path = dir .. sep .. filename

        local src = io.open(src_path, "rb")
        if src then
            local data = src:read("*a")
            src:close()

            local dst = io.open(dst_path, "wb")
            if dst then
                dst:write(data)
                dst:close()
                log("CursorAssets: Copied " .. filename)
            end
        end
    end

    self.dir = dir
    self.extracted = true
    return dir
end

-- Get the asset directory
function CursorAssets:get_dir()
    return self.dir
end

-- Check if assets are available
function CursorAssets:is_available()
    if not self.extracted then
        self:ensure_extracted()
    end
    return self.dir ~= nil
end

-- Get cursor image path
function CursorAssets:get_cursor_path(cursor_type)
    if not self:is_available() then
        return nil
    end

    local sep = IS_WINDOWS and "\\" or "/"
    local filename = (cursor_type or "arrow") .. ".png"
    return self.dir .. sep .. filename
end

-- Global convenience functions
function cursor_assets_ensure_extracted()
    return CursorAssets:ensure_extracted()
end

function cursor_assets_get_dir()
    return CursorAssets:get_dir()
end

function cursor_assets_is_available()
    return CursorAssets:is_available()
end

function cursor_assets_get_cursor_path(cursor_type)
    return CursorAssets:get_cursor_path(cursor_type)
end

--================================================
-- MODULE: Cursor Renderer (M15)
--================================================
-- Provides automatic cursor overlay rendering

local CursorRenderer = {
    enabled = false,
    source = nil,
    sceneitem = nil,

    -- Smoothed state
    pos = { x = 0, y = 0 },
    current_scale = 1.0,
    current_rot = 0,
    swap_pulse = 1.0,

    -- Velocities (SmoothDamp)
    vel_x = { val = 0 },
    vel_y = { val = 0 },
    vel_scale = { val = 0 },
    vel_rot = { val = 0 },
    vel_swap = { val = 0 },

    -- State
    was_pointer = false,
    initialized = false,

    -- Configuration
    cursor_scale = 1.0,
    cursor_click_scale = 0.78,
    cursor_smooth_time = 0.1,
    cursor_offset_x = -6,
    cursor_offset_y = -2,
    cursor_rotation_mode = "None",
    cursor_angle_offset = 0,
    cursor_tilt_strength = 0,
}

-- Initialize cursor renderer
function CursorRenderer:init()
    if not cfg.cursor_enabled then
        self.enabled = false
        return false
    end

    -- Ensure cursor assets are available
    local asset_dir = cursor_assets_ensure_extracted()
    if not asset_dir then
        log("CursorRenderer: Failed to extract cursor assets")
        self.enabled = false
        return false
    end

    -- Get or create the cursor image source
    local source_name = FILTER_PREFIX .. "Cursor"
    self.source = obs.obs_get_source_by_name(source_name)

    if not self.source then
        -- Create new image source
        local settings = obs.obs_data_create()
        local cursor_path = cursor_assets_get_cursor_path("arrow")
        if cursor_path then
            obs.obs_data_set_string(settings, "file", cursor_path)
        end
        self.source = obs.obs_source_create("image_source", source_name, settings, nil)
        obs.obs_data_release(settings)

        if not self.source then
            log("CursorRenderer: Failed to create image source")
            self.enabled = false
            return false
        end
    end

    -- Add to current scene
    self:add_to_scene()

    -- Initialize position
    local mouse = platform_get_mouse_pos()
    self.pos.x = mouse.x
    self.pos.y = mouse.y

    self.enabled = true
    self.initialized = true
    log("CursorRenderer: Initialized")
    return true
end

-- Add cursor source to scene
function CursorRenderer:add_to_scene()
    if not self.source then return false end

    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then return false end

    local scene = obs.obs_scene_from_source(scene_source)
    if not scene then
        obs.obs_source_release(scene_source)
        return false
    end

    -- Check if already in scene
    local source_name = obs.obs_source_get_name(self.source)
    self.sceneitem = obs.obs_scene_find_source(scene, source_name)

    if not self.sceneitem then
        -- Add to scene
        self.sceneitem = obs.obs_scene_add(scene, self.source)
        if self.sceneitem then
            -- Move to top (render last = on top)
            obs.obs_sceneitem_set_order(self.sceneitem, obs.OBS_ORDER_MOVE_TOP)
        end
    end

    obs.obs_source_release(scene_source)
    return true
end

-- Update cursor position and state
function CursorRenderer:update(dt, raw_mouse, camera_crop)
    if not self.enabled or not self.sceneitem then return end

    -- Smooth cursor position
    self.pos.x = SmoothDamp(self.pos.x, raw_mouse.x, self.vel_x, self.cursor_smooth_time, 100000, dt)
    self.pos.y = SmoothDamp(self.pos.y, raw_mouse.y, self.vel_y, self.cursor_smooth_time, 100000, dt)

    -- Snap when very close
    if math.abs(self.pos.x - raw_mouse.x) < 0.5 then
        self.pos.x = raw_mouse.x
        self.vel_x.val = 0
    end
    if math.abs(self.pos.y - raw_mouse.y) < 0.5 then
        self.pos.y = raw_mouse.y
        self.vel_y.val = 0
    end

    -- Cursor shape detection (Windows only)
    local is_pointer = false
    if platform_cursor_shape_available() then
        is_pointer = platform_is_cursor_pointer()
    end

    -- Swap cursor image if needed
    if is_pointer ~= self.was_pointer then
        local asset_dir = cursor_assets_get_dir()
        local sep = IS_WINDOWS and "\\" or "/"
        local new_file = is_pointer and (asset_dir .. sep .. "pointer.png") or (asset_dir .. sep .. "arrow.png")

        local s = obs.obs_source_get_settings(self.source)
        if s then
            obs.obs_data_set_string(s, "file", new_file)
            obs.obs_source_update(self.source, s)
            obs.obs_data_release(s)
        end

        -- Trigger swap pulse
        self.swap_pulse = 0.75
        self.vel_swap.val = 1
        self.was_pointer = is_pointer
    end

    self.swap_pulse = SmoothDamp(self.swap_pulse, 1.0, self.vel_swap, 0.12, 100000, dt)

    -- Click animation
    local is_clicking = platform_is_clicking()
    local target_scale = is_clicking and (self.cursor_scale * self.cursor_click_scale) or self.cursor_scale
    self.current_scale = SmoothDamp(self.current_scale, target_scale, self.vel_scale, 0.1, 100000, dt)

    -- Calculate position relative to zoom
    local zoom_factor = 1.0
    local crop_x, crop_y = 0, 0

    if camera_crop and SM:is_zoomed() then
        zoom_factor = source_manager_get_size() / camera_crop.w
        crop_x = camera_crop.x
        crop_y = camera_crop.y
    end

    local final_x = (self.pos.x - crop_x) * zoom_factor + (self.cursor_offset_x * zoom_factor)
    local final_y = (self.pos.y - crop_y) * zoom_factor + (self.cursor_offset_y * zoom_factor)

    -- Apply to scene item
    local pos = obs.vec2()
    pos.x = final_x
    pos.y = final_y
    obs.obs_sceneitem_set_pos(self.sceneitem, pos)

    local scale = obs.vec2()
    local s = self.current_scale * zoom_factor * self.swap_pulse
    scale.x = s
    scale.y = s
    obs.obs_sceneitem_set_scale(self.sceneitem, scale)

    -- Rotation
    local dynamic_rot = self:compute_rotation(dt)
    obs.obs_sceneitem_set_rot(self.sceneitem, dynamic_rot)
end

-- Compute rotation based on mode
function CursorRenderer:compute_rotation(dt)
    local vx = self.vel_x.val
    local vy = self.vel_y.val
    local speed = math.sqrt(vx * vx + vy * vy)

    if self.cursor_rotation_mode == "Directional" then
        if speed > 20 then
            local angle = math.atan2(vy, vx) * (180 / math.pi)
            local target = angle + self.cursor_angle_offset
            local diff = (target - self.current_rot + 180) % 360 - 180
            self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.05, 100000, dt)
        end
        return self.current_rot

    elseif self.cursor_rotation_mode == "Lean" then
        local lean = clamp(-40, 40, vx * 0.05 * self.cursor_tilt_strength) + self.cursor_angle_offset
        local diff = (lean - self.current_rot + 180) % 360 - 180
        self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.08, 100000, dt)
        return self.current_rot
    end

    -- "None" mode
    local diff = (self.cursor_angle_offset - self.current_rot + 180) % 360 - 180
    self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.15, 100000, dt)
    return self.current_rot
end

-- Update configuration
function CursorRenderer:update_config(settings)
    self.cursor_scale = obs.obs_data_get_double(settings, "cursor_scale")
    self.cursor_click_scale = obs.obs_data_get_double(settings, "cursor_click_scale")
    self.cursor_smooth_time = obs.obs_data_get_double(settings, "cursor_smooth_time")
    self.cursor_offset_x = obs.obs_data_get_int(settings, "cursor_offset_x")
    self.cursor_offset_y = obs.obs_data_get_int(settings, "cursor_offset_y")
    self.cursor_rotation_mode = obs.obs_data_get_string(settings, "cursor_rotation_mode") or "None"
    self.cursor_angle_offset = obs.obs_data_get_double(settings, "cursor_angle_offset")
    self.cursor_tilt_strength = obs.obs_data_get_double(settings, "cursor_tilt_strength")
end

-- Cleanup
function CursorRenderer:cleanup()
    if self.sceneitem then
        obs.obs_sceneitem_remove(self.sceneitem)
        self.sceneitem = nil
    end

    if self.source then
        local source_name = obs.obs_source_get_name(self.source)
        obs.obs_source_release(self.source)

        -- Remove from OBS source list
        local s = obs.obs_get_source_by_name(source_name)
        if s then
            obs.obs_source_remove(s)
            obs.obs_source_release(s)
        end
        self.source = nil
    end

    self.enabled = false
    self.initialized = false
end

-- Check if active
function CursorRenderer:is_active()
    return self.enabled and self.initialized
end

-- Global convenience functions
function cursor_renderer_init()
    return CursorRenderer:init()
end

function cursor_renderer_update(dt, raw_mouse, camera_crop)
    return CursorRenderer:update(dt, raw_mouse, camera_crop)
end

function cursor_renderer_update_config(settings)
    return CursorRenderer:update_config(settings)
end

function cursor_renderer_cleanup()
    return CursorRenderer:cleanup()
end

function cursor_renderer_is_active()
    return CursorRenderer:is_active()
end

--================================================
-- MODULE: Bookmark Manager (M17)
--================================================
-- Manages saved zoom positions (bookmarks)

local BookmarkManager = {
    -- Saved bookmarks: { name = { zoom_level, x, y, w, h, source } }
    bookmarks = {},

    -- Maximum bookmarks
    max_bookmarks = 20,

    -- Hotkey IDs
    hotkeys = {},
}

-- Save current zoom position as a bookmark
function BookmarkManager:save(name)
    if not name or name == "" then
        return false
    end

    -- Check limit
    local count = 0
    for _, _ in pairs(self.bookmarks) do count = count + 1 end

    if count >= self.max_bookmarks and not self.bookmarks[name] then
        log("Bookmark: Max bookmarks reached (" .. self.max_bookmarks .. ")")
        return false
    end

    -- Get current crop
    local crop = crop_filter_get_crop()
    if not crop then
        return false
    end

    -- Save bookmark
    self.bookmarks[name] = {
        zoom_level = SM.zoom_level,
        x = crop.x,
        y = crop.y,
        w = crop.w,
        h = crop.h,
        source = cfg.source_name,
    }

    log("Bookmark: Saved '" .. name .. "' (zoom=" .. string.format("%.2f", SM.zoom_level) .. ")")
    return true
end

-- Recall a bookmark
function BookmarkManager:recall(name)
    local bm = self.bookmarks[name]
    if not bm then
        log("Bookmark: Not found: " .. name)
        return false
    end

    if not SM:can_jump() then
        return false
    end

    if not source_manager_is_valid() then
        return false
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        return false
    end

    -- Get current crop as start
    local start_crop = crop_filter_get_crop() or { x = 0, y = 0, w = source_w, h = source_h }

    -- Set target
    local target_crop = {
        x = bm.x,
        y = bm.y,
        w = bm.w,
        h = bm.h,
    }

    -- Transition to bookmark
    SM:transition(ZoomState.JUMPING, {
        start_crop = start_crop,
        target_crop = target_crop,
        target_level = bm.zoom_level
    })

    start_timer()
    log("Bookmark: Recall '" .. name .. "'")
    return true
end

-- Delete a bookmark
function BookmarkManager:delete(name)
    if self.bookmarks[name] then
        self.bookmarks[name] = nil
        log("Bookmark: Deleted '" .. name .. "'")
        return true
    end
    return false
end

-- Rename a bookmark
function BookmarkManager:rename(old_name, new_name)
    if not self.bookmarks[old_name] then
        return false
    end

    if self.bookmarks[new_name] then
        return false
    end

    self.bookmarks[new_name] = self.bookmarks[old_name]
    self.bookmarks[old_name] = nil
    log("Bookmark: Renamed '" .. old_name .. "' to '" .. new_name .. "'")
    return true
end

-- Get all bookmark names
function BookmarkManager:get_names()
    local names = {}
    for k, _ in pairs(self.bookmarks) do
        table.insert(names, k)
    end
    table.sort(names)
    return names
end

-- Get bookmark info
function BookmarkManager:get(name)
    return self.bookmarks[name]
end

-- Persist bookmarks to settings
function BookmarkManager:persist(settings)
    local array = obs.obs_data_array_create()

    for name, bm in pairs(self.bookmarks) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "name", name)
        obs.obs_data_set_double(item, "zoom_level", bm.zoom_level)
        obs.obs_data_set_double(item, "x", bm.x)
        obs.obs_data_set_double(item, "y", bm.y)
        obs.obs_data_set_double(item, "w", bm.w)
        obs.obs_data_set_double(item, "h", bm.h)
        obs.obs_data_set_string(item, "source", bm.source or "")
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "zoom_bookmarks", array)
    obs.obs_data_array_release(array)
end

-- Load bookmarks from settings
function BookmarkManager:load(settings)
    self.bookmarks = {}

    local array = obs.obs_data_get_array(settings, "zoom_bookmarks")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local name = obs.obs_data_get_string(item, "name")

        if name and name ~= "" then
            self.bookmarks[name] = {
                zoom_level = obs.obs_data_get_double(item, "zoom_level"),
                x = obs.obs_data_get_double(item, "x"),
                y = obs.obs_data_get_double(item, "y"),
                w = obs.obs_data_get_double(item, "w"),
                h = obs.obs_data_get_double(item, "h"),
                source = obs.obs_data_get_string(item, "source"),
            }
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)

    local count = 0
    for _, _ in pairs(self.bookmarks) do count = count + 1 end
    log("Bookmark: Loaded " .. count .. " bookmarks")
end

-- Register bookmark hotkeys
function BookmarkManager:register_hotkeys(settings)
    for i = 1, 5 do
        self.hotkeys[i] = obs.obs_hotkey_register_frontend(
            "obs_zoom_pro.bookmark_" .. i,
            "Zoom to Bookmark " .. i,
            function(pressed)
                if not pressed then return end
                local names = self:get_names()
                if names[i] then
                    self:recall(names[i])
                end
            end
        )

        -- Load saved bindings
        local key = "obs_zoom_pro.hotkey.bookmark_" .. i
        local save_array = obs.obs_data_get_array(settings, key)
        if save_array then
            obs.obs_hotkey_load(self.hotkeys[i], save_array)
            obs.obs_data_array_release(save_array)
        end
    end
end

-- Save bookmark hotkeys
function BookmarkManager:save_hotkeys(settings)
    for i = 1, 5 do
        if self.hotkeys[i] then
            local save_array = obs.obs_hotkey_save(self.hotkeys[i])
            obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.bookmark_" .. i, save_array)
            obs.obs_data_array_release(save_array)
        end
    end
end

-- Global convenience functions
function bookmark_save(name)
    return BookmarkManager:save(name)
end

function bookmark_recall(name)
    return BookmarkManager:recall(name)
end

function bookmark_delete(name)
    return BookmarkManager:delete(name)
end

function bookmark_get_names()
    return BookmarkManager:get_names()
end

function bookmark_get(name)
    return BookmarkManager:get(name)
end

--================================================
-- MODULE: UDP API Server (M18)
--================================================
-- Provides external control via UDP for Stream Deck integration

local APIServer = {
    enabled = false,
    port = 12345,
    socket = nil,
}

-- Command handlers
local API_COMMANDS = {
    ZOOM_IN = function(args)
        local level = tonumber(args[1]) or cfg.zoom_value
        on_scroll_zoom_to(level)
        return "OK"
    end,

    ZOOM_OUT = function(args)
        if SM:is_zoomed() then
            on_toggle_zoom(true)
        end
        return "OK"
    end,

    ZOOM_SET = function(args)
        local level = tonumber(args[1])
        if not level then return "ERROR: Missing level" end
        on_scroll_zoom_to(level)
        return "OK"
    end,

    ZOOM_TOGGLE = function(args)
        on_toggle_zoom(true)
        return "OK"
    end,

    FOLLOW_ON = function(args)
        if SM:is_zoomed() then SM.following = true end
        return "OK"
    end,

    FOLLOW_OFF = function(args)
        SM.following = false
        return "OK"
    end,

    FOLLOW_TOGGLE = function(args)
        if SM:is_zoomed() then SM.following = not SM.following end
        return "OK"
    end,

    PRESET = function(args)
        local name = args[1]
        if not name then return "ERROR: Missing preset name" end
        local ok = preset_apply(name)
        return ok and "OK" or "ERROR: Unknown preset"
    end,

    BOOKMARK = function(args)
        local name = args[1]
        if not name then return "ERROR: Missing bookmark name" end
        local ok = bookmark_recall(name)
        return ok and "OK" or "ERROR: Bookmark not found"
    end,

    STATUS = function(args)
        local crop = crop_filter_get_crop()
        return string.format(
            '{"version":"%s","zoom_level":%.2f,"state":"%s","following":%s,"position":{"x":%.0f,"y":%.0f},"preset":"%s"}',
            VERSION,
            SM.zoom_level,
            SM.state,
            tostring(SM.following),
            crop and crop.x or 0,
            crop and crop.y or 0,
            cfg.zoom_preset or ""
        )
    end,

    HELP = function(args)
        return "Commands: ZOOM_IN [level], ZOOM_OUT, ZOOM_SET level, ZOOM_TOGGLE, FOLLOW_ON, FOLLOW_OFF, FOLLOW_TOGGLE, PRESET name, BOOKMARK name, STATUS"
    end,
}

-- Start the API server
function APIServer:start(port)
    self:stop()

    self.port = port or self.port

    -- Try to use luasocket if available
    local socket_ok, socket = pcall(require, "socket")
    if not socket_ok then
        log("API: Socket library not available")
        return false
    end

    -- Try UDP
    local udp, err = socket.udp()
    if not udp then
        log("API: Failed to create UDP socket: " .. tostring(err))
        return false
    end

    -- Set socket options
    udp:setoption("reuseaddr", true)
    udp:settimeout(0)  -- Non-blocking

    -- Bind to port
    local bind_ok, err = udp:setsockname("*", self.port)
    if not bind_ok then
        log("API: Failed to bind to port " .. self.port .. ": " .. tostring(err))
        udp:close()
        return false
    end

    self.socket = udp
    self.enabled = true

    -- Start polling timer
    obs.timer_add(function() self:poll() end, 50)  -- 20Hz polling

    log("API: Listening on port " .. self.port)
    return true
end

-- Stop the API server
function APIServer:stop()
    if self.socket then
        self.socket:close()
        self.socket = nil
    end
    self.enabled = false
    log("API: Stopped")
end

-- Poll for incoming commands
function APIServer:poll()
    if not self.enabled or not self.socket then
        return
    end

    repeat
        local data, err = self.socket:receivefrom()
        if data then
            local response = self:handle_command(data)
            if response then
                -- Note: UDP response requires sender address
                log("API: " .. data:gsub("%s+", " ") .. " Ã¢â€ â€™ " .. response)
            end
        elseif err ~= "timeout" then
            log("API: Error: " .. tostring(err))
        end
    until not data
end

-- Handle a command
function APIServer:handle_command(raw)
    -- Parse command
    local parts = {}
    for word in raw:gmatch("%S+") do
        table.insert(parts, word)
    end

    if #parts == 0 then
        return "ERROR: Empty command"
    end

    local cmd = parts[1]:upper()
    local args = {}
    for i = 2, #parts do
        table.insert(args, parts[i])
    end

    -- Look up handler
    local handler = API_COMMANDS[cmd]
    if handler then
        local ok, result = pcall(handler, args)
        if ok then
            return result
        else
            return "ERROR: " .. tostring(result)
        end
    end

    return "ERROR: Unknown command: " .. cmd
end

-- Check if enabled
function APIServer:is_enabled()
    return self.enabled
end

-- Global convenience functions
function api_start(port)
    return APIServer:start(port)
end

function api_stop()
    return APIServer:stop()
end

function api_is_enabled()
    return APIServer:is_enabled()
end

--================================================
-- OBS SCRIPT REGISTRATION
--================================================

--[[ Called when the script is loaded
--[[ @param data table Script data
function script_load(data)
    log("Script loaded - OBS Zoom Pro v" .. VERSION)

    -- Load custom presets
    PresetManager:load(data)

    -- Load scene memory
    SceneMemory:load(data)

    -- Load bookmarks
    BookmarkManager:load(data)

    -- Register hotkeys
    register_hotkeys(data)

    -- Register bookmark hotkeys
    BookmarkManager:register_hotkeys(data)

    -- Register frontend event handler
    obs.obs_frontend_add_event_callback(on_frontend_event)

    -- Start API server if enabled
    local api_enabled = obs.obs_data_get_bool(data, "api_enabled")
    if api_enabled then
        local api_port = obs.obs_data_get_int(data, "api_port")
        APIServer:start(api_port)
    end
end

--[[ Called when the script is unloaded
function script_unload()
    log("Script unloaded - OBS Zoom Pro")

    -- Stop timer and cleanup
    stop_timer()
    unregister_hotkeys()
    source_manager_release()

    -- Stop API server
    APIServer:stop()

    -- Remove frontend event handler
    obs.obs_frontend_remove_event_callback(on_frontend_event)
end

--[[ Called when settings are updated
--[[ @param data table Settings data
function script_update(data)
    log("Settings updated")

    -- Update legacy settings
    debug_logs = obs.obs_data_get_bool(data, "debug_logging") or false
    settings.debug_logging = debug_logs
    settings.easing_type = obs.obs_data_get_string(data, "easing_type") or defaults.easing_type
    settings.smooth_time = obs.obs_data_get_double(data, "smooth_time") or defaults.smooth_time
    settings.max_speed = obs.obs_data_get_double(data, "max_speed") or defaults.max_speed

    -- Update M09 configuration
    update_config(data)

    -- Update API server settings
    local api_enabled = obs.obs_data_get_bool(data, "api_enabled")
    local api_port = obs.obs_data_get_int(data, "api_port")

    if api_enabled and not APIServer:is_enabled() then
        APIServer:start(api_port)
    elseif not api_enabled and APIServer:is_enabled() then
        APIServer:stop()
    elseif APIServer:is_enabled() and APIServer.port ~= api_port then
        APIServer:start(api_port)
    end
end

--[[ Called to save settings
--[[ @param data table Settings data to save
function script_save(data)
    log("Settings saved")

    -- Save custom presets
    PresetManager:persist(data)

    -- Save scene memory
    SceneMemory:persist(data)

    -- Save bookmarks
    BookmarkManager:persist(data)

    -- Save hotkey bindings
    save_hotkeys(data)

    -- Save bookmark hotkeys
    BookmarkManager:save_hotkeys(data)
end

--[[ Called to create the properties UI
--[[ @return obs.obs_properties_t Properties object
function script_properties()
    local props = obs.obs_properties_create()

    --==========================
    -- QUICK SETUP (always expanded)
    --==========================
    local grp_quick = obs.obs_properties_create()

    -- Source dropdown
    local src_list = obs.obs_properties_add_list(grp_quick, "source", "Zoom Source",
        obs.OBS_COMBO_TYPE_LIST, obs.OBS_COMBO_FORMAT_STRING)
    obs.obs_property_list_add_string(src_list, "-- Select Source --", "")

    -- Populate with available capture sources
    local sources = source_manager_get_available_sources()
    for _, src in ipairs(sources) do
        obs.obs_property_list_add_string(src_list, src.name, src.name)
    end

    -- Zoom Factor
    obs.obs_properties_add_float_slider(grp_quick, "zoom_value", "Zoom Factor", 1.0, 10.0, 0.1)

    -- Duration
    obs.obs_properties_add_float_slider(grp_quick, "zoom_duration", "Duration (s)", 0.05, 3.0, 0.05)

    obs.obs_properties_add_group(props, "quick_setup", "Ã¢Å¡Â¡ Quick Setup", obs.OBS_GROUP_NORMAL, grp_quick)

    --==========================
    -- ANIMATION (collapsed)
    --==========================
    local grp_anim = obs.obs_properties_create()

    -- Overshoot/Bounce
    obs.obs_properties_add_float_slider(grp_anim, "zoom_overshoot", "Bounce", 0.0, 1.0, 0.01)

    -- Easing Curve
    local p_easing = obs.obs_properties_add_list(grp_anim, "zoom_easing", "Easing Curve",
        obs.OBS_COMBO_TYPE_LIST, obs.OBS_COMBO_FORMAT_STRING)
    for _, name in ipairs(Easing.NAMES) do
        obs.obs_property_list_add_string(p_easing, name, name)
    end

    obs.obs_properties_add_group(props, "animation", "Ã°Å¸Å½Â¬ Animation", obs.OBS_GROUP_NORMAL, grp_anim)

    --==========================
    -- MOUSE FOLLOW (collapsed)
    --==========================
    local grp_follow = obs.obs_properties_create()

    obs.obs_properties_add_bool(grp_follow, "auto_follow", "Auto-Follow Mouse")
    obs.obs_properties_add_float_slider(grp_follow, "follow_smooth_time", "Smoothness", 0.01, 1.0, 0.01)
    obs.obs_properties_add_int_slider(grp_follow, "follow_dead_zone", "Dead Zone (px)", 0, 500, 1)

    obs.obs_properties_add_group(props, "follow", "Ã°Å¸Å½Â¯ Mouse Follow", obs.OBS_GROUP_NORMAL, grp_follow)

    --==========================
    -- ADVANCED (collapsed)
    --==========================
    local grp_adv = obs.obs_properties_create()
    obs.obs_properties_add_float_slider(grp_adv, "scroll_step", "Scroll Zoom Step", 0.1, 1.0, 0.05)
    obs.obs_properties_add_bool(grp_adv, "debug_logs", "Debug Logging")
    obs.obs_properties_add_group(props, "advanced", "Ã¢Å¡â„¢Ã¯Â¸Â Advanced", obs.OBS_GROUP_NORMAL, grp_adv)

    --==========================
    -- API SERVER (collapsed)
    --==========================
    local grp_api = obs.obs_properties_create()
    obs.obs_properties_add_bool(grp_api, "api_enabled", "Enable UDP API Server")
    obs.obs_properties_add_int(grp_api, "api_port", "API Port", 1024, 65535, 1)
    obs.obs_properties_add_group(props, "api_server", "Ã°Å¸Å’Â UDP API Server", obs.OBS_GROUP_NORMAL, grp_api)

    --==========================
    -- HELP (collapsed)
    --==========================
    local grp_help = obs.obs_properties_create()
    obs.obs_properties_add_text(grp_help, "help_text",
        "QUICK START:\n" ..
        "1. Select your capture source above\n" ..
        "2. Set hotkeys in OBS Settings Ã¢â€ â€™ Hotkeys\n" ..
        "   Ã¢â‚¬Â¢ 'Toggle Zoom to Mouse' Ã¢â‚¬â€ Main zoom\n" ..
        "   Ã¢â‚¬Â¢ 'Toggle Mouse Follow' Ã¢â‚¬â€ Enable/disable follow\n" ..
        "3. Press the hotkey to zoom!\n\n" ..
        "TIPS:\n" ..
        "Ã¢â‚¬Â¢ Zoom centers on mouse position\n" ..
        "Ã¢â‚¬Â¢ Enable Auto-Follow for smooth tracking\n" ..
        "Ã¢â‚¬Â¢ Adjust Dead Zone to reduce jitter",
        obs.OBS_TEXT_INFO)
    obs.obs_properties_add_group(props, "help", "Ã¢Ââ€œ Help", obs.OBS_GROUP_NORMAL, grp_help)

    return props
end

--[[ Called to set default values
--[[ @param data table Settings data
function script_defaults(data)
    obs.obs_data_set_default_string(data, "source", "")
    obs.obs_data_set_default_double(data, "zoom_value", 2.0)
    obs.obs_data_set_default_double(data, "zoom_duration", 0.6)
    obs.obs_data_set_default_double(data, "zoom_overshoot", 0.0)
    obs.obs_data_set_default_string(data, "zoom_easing", "Cubic.Out")
    obs.obs_data_set_default_bool(data, "auto_follow", true)
    obs.obs_data_set_default_double(data, "follow_smooth_time", 0.15)
    obs.obs_data_set_default_int(data, "follow_dead_zone", 5)
    obs.obs_data_set_default_double(data, "scroll_step", 0.25)
    obs.obs_data_set_default_bool(data, "debug_logs", false)
    obs.obs_data_set_default_bool(data, "api_enabled", false)
    obs.obs_data_set_default_int(data, "api_port", 12345)
end

--================================================
-- SCRIPT METADATA
--================================================
script_info = {
    name = "OBS Zoom Pro",
    version = VERSION,
    description = "Intelligent camera zoom functionality with smooth transitions and easing curves.",
    author = "OBS Zoom Pro Team"
}
)
        handle:close()
        if uname == 'Darwin' then
            is_macos = true
            is_linux = false
        end
    end

    return {
        WINDOWS = is_windows,
        LINUX = is_linux,
        MACOS = is_macos
    }
end

local platform = detect_platform()
local IS_WINDOWS = platform.WINDOWS
local IS_LINUX = platform.LINUX
local IS_MACOS = platform.MACOS

-- Log platform detection
log("Platform detected: " .. (jit and jit.os or "Unknown") .. (IS_WINDOWS and " (Full support)" or " (Basic support)"))

-- Virtual key codes (Lua constants instead of C #define)
local VK_LBUTTON = 0x01
local VK_RBUTTON = 0x02
local VK_MBUTTON = 0x04
local VK_CONTROL = 0x11
local VK_SHIFT = 0x10
local VK_MENU = 0x12  -- Alt

-- FFI declarations for Windows (only if FFI is available)


-- Cursor shape constants (Windows)
local CURSOR_ARROW = 1
local CURSOR_IBEAM = 2
local CURSOR_HAND = 3
local CURSOR_WAIT = 4

-- Module state
local Platform = {
    cursor_shape_available = IS_WINDOWS,
    last_mouse = { x = 0, y = 0 },
    last_click = false,
}

-- Get mouse position (cross-platform)
function Platform.get_mouse_pos()
    if IS_WINDOWS then
        local success, pt = pcall(function()
            local pt = ffi.new("POINT")
            if ffi.C.GetCursorPos(pt) ~= 0 then
                return { x = tonumber(pt.x), y = tonumber(pt.y) }
            end
            return nil
        end)
        if success and pt then
            return pt
        end
    elseif IS_LINUX then
        -- Linux: Use xdotool if available, fallback to X11
        local success, result = pcall(function()
            local handle = io.popen("xdotool getmouselocation 2>/dev/null || echo 'x:0 y:0'")
            if handle then
                local output = handle:read("*a")
                handle:close()
                local x, y = output:match("x:(%d+)%s+y:(%d+)")
                if x and y then
                    return { x = tonumber(x), y = tonumber(y) }
                end
            end
            return nil
        end)
        if success and result then
            return result
        end
    elseif IS_MACOS then
        -- macOS: Use osascript
        local success, result = pcall(function()
            local handle = io.popen(--[[osascript -e 'tell application "System Events" to get position of the mouse' 2>/dev/null || echo "0, 0"]])
            if handle then
                local output = handle:read("*a")
                handle:close()
                local x, y = output:match("(%d+),%s*(%d+)")
                if x and y then
                    return { x = tonumber(x), y = tonumber(y) }
                end
            end
            return nil
        end)
        if success and result then
            return result
        end
    end

    -- Fallback
    return { x = 0, y = 0 }
end

-- Check if left mouse button is clicked (Windows only, others return false)
function Platform.is_clicking()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x01) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if a modifier key is held (Windows only)
function Platform.is_key_held(vk_code)
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(vk_code) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if cursor is a pointer/hand (Windows only)
function Platform.is_cursor_pointer()
    if IS_WINDOWS then
        local success, result = pcall(function()
            local ci = ffi.new("CURSORINFO")
            ci.cbSize = ffi.sizeof("CURSORINFO")
            if ffi.C.GetCursorInfo(ci) ~= 0 then
                -- Check if hCursor is a hand pointer
                -- This is a simplified check; real implementation would compare cursor handles
                return ci.flags ~= 0  -- Simplified; actual implementation needs cursor handle comparison
            end
            return false
        end)
        return success and result or false
    end
    return false
end

-- Get cursor shape (Windows only, returns "arrow" for others)
function Platform.get_cursor_shape()
    if IS_WINDOWS then
        local success, result = pcall(function()
            local ci = ffi.new("CURSORINFO")
            ci.cbSize = ffi.sizeof("CURSORINFO")
            if ffi.C.GetCursorInfo(ci) ~= 0 and ci.hCursor ~= nil then
                local addr = tonumber(ffi.cast("uintptr_t", ci.hCursor))
                -- Common cursor IDs (these are typical values, may vary)
                -- IDC_ARROW = 32512, IDC_IBEAM = 32513, IDC_HAND = 32649
                -- We use address ranges as heuristic
                return "arrow"  -- Simplified; actual implementation would map handles
            end
            return "arrow"
        end)
        return success and result or "arrow"
    end
    return "arrow"
end

-- Check if Control key is held
function Platform.is_ctrl_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x11) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if Shift key is held
function Platform.is_shift_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x10) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Check if Alt key is held
function Platform.is_alt_held()
    if IS_WINDOWS then
        local success, result = pcall(function()
            return ffi.C.GetAsyncKeyState(0x12) ~= 0
        end)
        return success and result or false
    end
    return false
end

-- Convenience wrapper functions
function platform_get_mouse_pos()
    return Platform.get_mouse_pos()
end

function platform_is_clicking()
    return Platform.is_clicking()
end

function platform_is_cursor_pointer()
    return Platform.is_cursor_pointer()
end

function platform_cursor_shape_available()
    return Platform.cursor_shape_available
end

function platform_is_ctrl_held()
    return Platform.is_ctrl_held()
end

function platform_is_shift_held()
    return Platform.is_shift_held()
end

function platform_is_alt_held()
    return Platform.is_alt_held()
end

--================================================
-- MODULE: State Machine (M05)
--================================================
-- Manages zoom states and transitions
-- States: IDLE, ZOOMING_IN, ZOOMED_IN, ZOOMING_OUT, SCROLLING, JUMPING

local ZoomState = {
    IDLE         = "idle",
    ZOOMING_IN   = "zooming_in",
    ZOOMED_IN    = "zoomed_in",
    ZOOMING_OUT  = "zooming_out",
    SCROLLING    = "scrolling",    -- Scroll wheel mid-transition
    JUMPING      = "jumping",      -- Bookmark transition
}

local StateMachine = {
    state = ZoomState.IDLE,
    zoom_time = 0,          -- Animation progress (0 Ã¢â€ â€™ 1)
    zoom_level = 1.0,       -- Current zoom factor
    target_level = 1.0,     -- Target zoom factor
    start_crop = nil,       -- Crop at animation start {x, y, w, h}
    target_crop = nil,      -- Crop at animation end {x, y, w, h}
    following = false,      -- Mouse follow active

    -- Transition guards
    can_zoom_in = function(self)
        return self.state == ZoomState.IDLE
    end,

    can_zoom_out = function(self)
        return self.state == ZoomState.ZOOMED_IN
            or self.state == ZoomState.SCROLLING
    end,

    can_scroll = function(self)
        return self.state == ZoomState.ZOOMED_IN
            or self.state == ZoomState.IDLE
            or self.state == ZoomState.SCROLLING
    end,

    can_jump = function(self)
        return self.state ~= ZoomState.ZOOMING_IN
           and self.state ~= ZoomState.ZOOMING_OUT
           and self.state ~= ZoomState.JUMPING
    end,

    is_animating = function(self)
        return self.state == ZoomState.ZOOMING_IN
            or self.state == ZoomState.ZOOMING_OUT
            or self.state == ZoomState.SCROLLING
            or self.state == ZoomState.JUMPING
    end,

    is_zoomed = function(self)
        return self.state ~= ZoomState.IDLE
    end,
}

-- Transition to a new state
function StateMachine:transition(new_state, params)
    local old = self.state
    self.state = new_state
    self.zoom_time = 0

    if params then
        if params.start_crop then self.start_crop = params.start_crop end
        if params.target_crop then self.target_crop = params.target_crop end
        if params.target_level then self.target_level = params.target_level end
    end

    log("State: " .. old .. " Ã¢â€ â€™ " .. new_state)
end

-- Complete the current animation
function StateMachine:complete()
    if self.state == ZoomState.ZOOMING_IN
       or self.state == ZoomState.SCROLLING
       or self.state == ZoomState.JUMPING then
        self.zoom_level = self.target_level
        self.state = ZoomState.ZOOMED_IN
        self.zoom_time = 0
        log("State: " .. self.state .. " Ã¢â€ â€™ ZOOMED_IN (complete)")
    elseif self.state == ZoomState.ZOOMING_OUT then
        self.zoom_level = 1.0
        self.target_level = 1.0
        self.start_crop = nil
        self.target_crop = nil
        self.following = false
        self.state = ZoomState.IDLE
        self.zoom_time = 0
        log("State: ZOOMING_OUT Ã¢â€ â€™ IDLE (complete)")
    end
end

-- Reset to initial state
function StateMachine:reset()
    self.state = ZoomState.IDLE
    self.zoom_time = 0
    self.zoom_level = 1.0
    self.target_level = 1.0
    self.start_crop = nil
    self.target_crop = nil
    self.following = false
    log("StateMachine: Reset to IDLE")
end

-- Get current animation progress (0-1)
function StateMachine:get_progress()
    return clamp(0, 1, self.zoom_time)
end

-- Check if in a specific state
function StateMachine:is_state(state)
    return self.state == state
end

-- Get state name for display
function StateMachine:get_state_name()
    return self.state
end

-- Create a new state machine instance (for testing/isolation)
function StateMachine:new()
    local sm = {}
    setmetatable(sm, { __index = self })
    sm.state = ZoomState.IDLE
    sm.zoom_time = 0
    sm.zoom_level = 1.0
    sm.target_level = 1.0
    sm.start_crop = nil
    sm.target_crop = nil
    sm.following = false
    return sm
end

-- Global state machine instance
local SM = StateMachine:new()

--================================================
-- MODULE: Crop Filter Manager (M07)
--================================================
-- Manages the crop/pad filter used to simulate zoom
-- Creates, updates, and destroys the filter automatically

local FILTER_PREFIX = "[ZoomPro] "
local CROP_FILTER_NAME = FILTER_PREFIX .. "Crop"

local CropFilterManager = {
    filter = nil,           -- The crop filter source
    source = nil,           -- The parent source
    original_crop = nil,    -- Original crop values for restoration
    current_crop = { x = 0, y = 0, w = 0, h = 0 },
    initialized = false,
}

-- Create the crop filter on a source
function CropFilterManager:create(source)
    if not source then
        log("CropFilter: No source provided")
        return false
    end

    self:cleanup()  -- Clean up any existing filter
    self.source = source

    -- Check if our filter already exists
    local existing = obs.obs_source_get_filter_by_name(source, CROP_FILTER_NAME)
    if existing then
        log("CropFilter: Found existing filter")
        self.filter = existing
        self.initialized = true
        return true
    end

    -- Create new crop/pad filter
    local settings = obs.obs_data_create()
    obs.obs_data_set_int(settings, "left", 0)
    obs.obs_data_set_int(settings, "top", 0)
    obs.obs_data_set_int(settings, "right", 0)
    obs.obs_data_set_int(settings, "bottom", 0)
    obs.obs_data_set_bool(settings, "relative", false)  -- Absolute positioning

    self.filter = obs.obs_source_create_private(
        "crop_filter",      -- Filter type
        CROP_FILTER_NAME,   -- Filter name
        settings            -- Settings
    )

    obs.obs_data_release(settings)

    if not self.filter then
        log("CropFilter: Failed to create filter")
        return false
    end

    -- Add filter to source
    obs.obs_source_filter_add(source, self.filter)

    -- Store original crop (none)
    self.original_crop = { x = 0, y = 0, w = 0, h = 0 }

    self.initialized = true
    log("CropFilter: Created successfully")
    return true
end

-- Update the crop filter with new values
function CropFilterManager:update(x, y, w, h)
    if not self.filter or not self.initialized then
        return false
    end

    -- Store current crop
    self.current_crop = { x = x, y = y, w = w, h = h }

    -- Get filter settings
    local settings = obs.obs_source_get_settings(self.filter)
    if not settings then
        return false
    end

    -- Calculate crop values
    -- For crop_filter: left, top are absolute position
    -- right, bottom are width/height from right/bottom edge
    -- We need to convert our x, y, w, h to this format

    -- Get source dimensions
    local source_w = obs.obs_source_get_width(self.source)
    local source_h = obs.obs_source_get_height(self.source)

    if source_w == 0 or source_h == 0 then
        obs.obs_data_release(settings)
        return false
    end

    -- Set crop values
    -- left = x offset from left
    -- top = y offset from top
    -- right = source_w - (x + w) = remaining width on right
    -- bottom = source_h - (y + h) = remaining height on bottom
    local left = math.floor(x)
    local top = math.floor(y)
    local right = math.floor(source_w - (x + w))
    local bottom = math.floor(source_h - (y + h))

    -- Clamp to valid values
    left = math.max(0, left)
    top = math.max(0, top)
    right = math.max(0, right)
    bottom = math.max(0, bottom)

    obs.obs_data_set_int(settings, "left", left)
    obs.obs_data_set_int(settings, "top", top)
    obs.obs_data_set_int(settings, "right", right)
    obs.obs_data_set_int(settings, "bottom", bottom)

    -- Update the filter
    obs.obs_source_update(self.filter, settings)
    obs.obs_data_release(settings)

    return true
end

-- Get current crop values
function CropFilterManager:get_crop()
    return self.current_crop
end

-- Reset crop to original (no crop)
function CropFilterManager:reset()
    if not self.filter or not self.initialized then
        return false
    end

    local settings = obs.obs_source_get_settings(self.filter)
    if settings then
        obs.obs_data_set_int(settings, "left", 0)
        obs.obs_data_set_int(settings, "top", 0)
        obs.obs_data_set_int(settings, "right", 0)
        obs.obs_data_set_int(settings, "bottom", 0)
        obs.obs_source_update(self.filter, settings)
        obs.obs_data_release(settings)
    end

    self.current_crop = { x = 0, y = 0, w = 0, h = 0 }
    return true
end

-- Remove the filter and restore original state
function CropFilterManager:cleanup()
    if self.filter and self.source then
        -- Reset to no crop first
        self:reset()

        -- Remove filter from source
        obs.obs_source_filter_remove(self.source, self.filter)
        obs.obs_source_release(self.filter)
        self.filter = nil
        log("CropFilter: Removed from source")
    end

    self.source = nil
    self.original_crop = nil
    self.current_crop = { x = 0, y = 0, w = 0, h = 0 }
    self.initialized = false
end

-- Check if filter is ready
function CropFilterManager:is_ready()
    return self.initialized and self.filter ~= nil
end

-- Get source dimensions
function CropFilterManager:get_source_size()
    if not self.source then
        return 0, 0
    end
    return obs.obs_source_get_width(self.source), obs.obs_source_get_height(self.source)
end

-- Convenience wrapper functions
function crop_filter_create(source)
    return CropFilterManager:create(source)
end

function crop_filter_update(x, y, w, h)
    return CropFilterManager:update(x, y, w, h)
end

function crop_filter_reset()
    return CropFilterManager:reset()
end

function crop_filter_cleanup()
    return CropFilterManager:cleanup()
end

function crop_filter_is_ready()
    return CropFilterManager:is_ready()
end

function crop_filter_get_crop()
    return CropFilterManager:get_crop()
end

function crop_filter_get_source_size()
    return CropFilterManager:get_source_size()
end

--================================================
-- MODULE: Source Manager (M08)
--================================================
-- Handles finding sources in scenes, capturing transforms,
-- and managing source state for zoom operations

local SourceManager = {
    source = nil,           -- Current zoom source
    sceneitem = nil,        -- Scene item reference
    scene = nil,            -- Current scene
    original_transform = nil, -- Saved original transform
    source_name = "",       -- Source name for settings
    initialized = false,
}

-- Transform data structure
local TransformData = {
    pos = { x = 0, y = 0 },
    scale = { x = 1.0, y = 1.0 },
    rot = 0,
    bounds_type = 0,
    bounds = { x = 0, y = 0 },
    crop = { left = 0, top = 0, right = 0, bottom = 0 },
}

-- Find a source in a scene (BFS through groups)
function SourceManager:find_sceneitem(scene, source_name)
    if not scene or not source_name then
        return nil
    end

    local scene_source = obs.obs_scene_from_source(scene)
    if not scene_source then
        return nil
    end

    -- BFS queue
    local queue = {}
    table.insert(queue, scene_source)

    while #queue > 0 do
        local current_scene = table.remove(queue, 1)

        -- Iterate through items
        local items = obs.obs_scene_enum_items(current_scene)
        if items then
            for _, item in ipairs(items) do
                local item_source = obs.obs_sceneitem_get_source(item)
                if item_source then
                    local name = obs.obs_source_get_name(item_source)

                    -- Check if this is our target
                    if name == source_name then
                        obs.sceneitem_list_release(items)
                        return item
                    end

                    -- Check if this is a group (nested scene)
                    if obs.obs_source_get_type(item_source) == obs.OBS_SOURCE_TYPE_INPUT then
                        local id = obs.obs_source_get_id(item_source)
                        if id == "group" then
                            local group_scene = obs.obs_group_from_source(item_source)
                            if group_scene then
                                table.insert(queue, group_scene)
                            end
                        end
                    end
                end
            end
            obs.sceneitem_list_release(items)
        end
    end

    return nil
end

-- Capture the current transform of a scene item
function SourceManager:capture_transform(sceneitem)
    if not sceneitem then
        return nil
    end

    local transform = {}

    -- Position
    local pos = obs.vec2()
    obs.obs_sceneitem_get_pos(sceneitem, pos)
    transform.pos = { x = pos.x, y = pos.y }

    -- Scale
    local scale = obs.vec2()
    obs.obs_sceneitem_get_scale(sceneitem, scale)
    transform.scale = { x = scale.x, y = scale.y }

    -- Rotation
    transform.rot = obs.obs_sceneitem_get_rot(sceneitem)

    -- Bounds
    transform.bounds_type = obs.obs_sceneitem_get_bounds_type(sceneitem)
    local bounds = obs.vec2()
    obs.obs_sceneitem_get_bounds(sceneitem, bounds)
    transform.bounds = { x = bounds.x, y = bounds.y }

    -- Crop
    local crop = obs.obs_sceneitem_crop()
    obs.obs_sceneitem_get_crop(sceneitem, crop)
    transform.crop = {
        left = crop.left,
        top = crop.top,
        right = crop.right,
        bottom = crop.bottom
    }

    return transform
end

-- Restore a saved transform to a scene item
function SourceManager:restore_transform(sceneitem, transform)
    if not sceneitem or not transform then
        return false
    end

    -- Position
    local pos = obs.vec2()
    pos.x = transform.pos.x
    pos.y = transform.pos.y
    obs.obs_sceneitem_set_pos(sceneitem, pos)

    -- Scale
    local scale = obs.vec2()
    scale.x = transform.scale.x
    scale.y = transform.scale.y
    obs.obs_sceneitem_set_scale(sceneitem, scale)

    -- Rotation
    obs.obs_sceneitem_set_rot(sceneitem, transform.rot)

    -- Bounds
    obs.obs_sceneitem_set_bounds_type(sceneitem, transform.bounds_type)
    local bounds = obs.vec2()
    bounds.x = transform.bounds.x
    bounds.y = transform.bounds.y
    obs.obs_sceneitem_set_bounds(sceneitem, bounds)

    -- Crop
    local crop = obs.obs_sceneitem_crop()
    crop.left = transform.crop.left
    crop.top = transform.crop.top
    crop.right = transform.crop.right
    crop.bottom = transform.crop.bottom
    obs.obs_sceneitem_set_crop(sceneitem, crop)

    return true
end

-- Initialize with a source name
function SourceManager:init(source_name)
    self:release()  -- Clean up any existing state

    if not source_name or source_name == "" then
        log("SourceManager: No source name provided")
        return false
    end

    self.source_name = source_name

    -- Get current scene
    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then
        log("SourceManager: No current scene")
        return false
    end

    self.scene = scene_source

    -- Find the scene item
    self.sceneitem = self:find_sceneitem(scene_source, source_name)
    if not self.sceneitem then
        log("SourceManager: Source not found in scene: " .. source_name)
        obs.obs_source_release(scene_source)
        return false
    end

    -- Get the source
    self.source = obs.obs_sceneitem_get_source(self.sceneitem)
    if not self.source then
        log("SourceManager: Failed to get source from sceneitem")
        obs.obs_source_release(scene_source)
        return false
    end

    -- Capture original transform
    self.original_transform = self:capture_transform(self.sceneitem)

    -- Create crop filter
    if not crop_filter_create(self.source) then
        log("SourceManager: Failed to create crop filter")
        obs.obs_source_release(scene_source)
        return false
    end

    self.initialized = true
    log("SourceManager: Initialized with source: " .. source_name)

    obs.obs_source_release(scene_source)
    return true
end

-- Release all resources
function SourceManager:release()
    -- Clean up crop filter
    crop_filter_cleanup()

    -- Restore original transform if we have it
    if self.sceneitem and self.original_transform then
        self:restore_transform(self.sceneitem, self.original_transform)
        log("SourceManager: Restored original transform")
    end

    self.source = nil
    self.sceneitem = nil
    self.scene = nil
    self.original_transform = nil
    self.initialized = false

    log("SourceManager: Released")
end

-- Get source dimensions
function SourceManager:get_source_size()
    if not self.source then
        return 0, 0
    end
    return obs.obs_source_get_width(self.source), obs.obs_source_get_height(self.source)
end

-- Check if source is valid
function SourceManager:is_valid()
    return self.initialized and self.source ~= nil and self.sceneitem ~= nil
end

-- Get source info
function SourceManager:get_info()
    if not self:is_valid() then
        return nil
    end

    return {
        name = self.source_name,
        width = obs.obs_source_get_width(self.source),
        height = obs.obs_source_get_height(self.source),
    }
end

-- Get list of available capture sources
function SourceManager.get_available_sources()
    local sources = {}

    -- Get all sources
    local source_list = obs.obs_enum_sources()
    if source_list then
        for _, source in ipairs(source_list) do
            local source_id = obs.obs_source_get_id(source)
            local name = obs.obs_source_get_name(source)

            -- Filter for capture sources
            local is_capture = false
            if source_id == "monitor_capture" or      -- Display capture
               source_id == "window_capture" or       -- Window capture
               source_id == "game_capture" or         -- Game capture
               source_id == "xshm_input" or           -- Linux X11 capture
               source_id == "av_capture_input" then   -- macOS capture
                is_capture = true
            end

            if is_capture then
                table.insert(sources, {
                    name = name,
                    id = source_id,
                })
            end
        end
        obs.source_list_release(source_list)
    end

    return sources
end

-- Convenience wrapper functions
function source_manager_init(source_name)
    return SourceManager:init(source_name)
end

function source_manager_release()
    return SourceManager:release()
end

function source_manager_is_valid()
    return SourceManager:is_valid()
end

function source_manager_get_source()
    return SourceManager.source
end

function source_manager_get_sceneitem()
    return SourceManager.sceneitem
end

function source_manager_get_size()
    return SourceManager:get_source_size()
end

function source_manager_get_available_sources()
    return SourceManager.get_available_sources()
end

--================================================
-- MODULE: Camera Physics (M06)
--================================================
-- Handles camera position calculations, dead zones,
-- and SmoothDamp-based camera movement

local CameraPhysics = {
    -- Smoothed camera position
    pos = { x = 0, y = 0 },

    -- Velocities for SmoothDamp
    vel_x = { val = 0 },
    vel_y = { val = 0 },

    -- Dead zone state
    tracked_pos = { x = 0, y = 0 },
    dead_zone_active = false,

    -- Last camera position (for velocity calculation)
    last_pos = { x = 0, y = 0 },

    -- Monitor offset (for multi-monitor setups)
    monitor_offset = { x = 0, y = 0 },
}

-- Initialize camera tracking with starting position
function CameraPhysics:init(mouse_pos)
    if mouse_pos then
        self.pos.x = mouse_pos.x
        self.pos.y = mouse_pos.y
        self.tracked_pos.x = mouse_pos.x
        self.tracked_pos.y = mouse_pos.y
    end
    self.vel_x.val = 0
    self.vel_y.val = 0
    self.last_pos.x = self.pos.x
    self.last_pos.y = self.pos.y
end

-- Apply dead zone to mouse input
-- Returns the position the camera should track
function CameraPhysics:apply_dead_zone(mouse_pos, dead_zone_radius)
    if not mouse_pos then
        return self.tracked_pos
    end

    if dead_zone_radius <= 0 then
        self.tracked_pos.x = mouse_pos.x
        self.tracked_pos.y = mouse_pos.y
        return self.tracked_pos
    end

    -- Calculate distance from tracked position to mouse
    local dx = mouse_pos.x - self.tracked_pos.x
    local dy = mouse_pos.y - self.tracked_pos.y
    local dist = math.sqrt(dx * dx + dy * dy)

    if dist <= dead_zone_radius then
        -- Mouse is within dead zone, don't move tracked position
        self.dead_zone_active = true
        return self.tracked_pos
    end

    -- Mouse is outside dead zone
    -- Move tracked position so it stays exactly dead_zone_radius from mouse
    self.dead_zone_active = false
    local excess = dist - dead_zone_radius
    local nx = dx / dist  -- Normalized direction
    local ny = dy / dist

    self.tracked_pos.x = self.tracked_pos.x + nx * excess
    self.tracked_pos.y = self.tracked_pos.y + ny * excess

    return self.tracked_pos
end

-- Smooth the input position using SmoothDamp
function CameraPhysics:smooth_input(target_pos, smooth_time, dt)
    if not target_pos then
        return self.pos
    end

    local max_speed = 100000  -- Very high max speed for smooth camera

    self.pos.x = SmoothDamp(self.pos.x, target_pos.x, self.vel_x, smooth_time, max_speed, dt)
    self.pos.y = SmoothDamp(self.pos.y, target_pos.y, self.vel_y, smooth_time, max_speed, dt)

    return self.pos
end

-- Calculate the crop rectangle for a given zoom level and center position
function CameraPhysics:compute_crop(center_x, center_y, zoom_level, source_w, source_h)
    if zoom_level <= 1.0 then
        -- No zoom, return full source
        return {
            x = 0,
            y = 0,
            w = source_w,
            h = source_h,
        }
    end

    -- Calculate crop dimensions
    local crop_w = source_w / zoom_level
    local crop_h = source_h / zoom_level

    -- Center the crop on the target position
    local crop_x = center_x - crop_w / 2
    local crop_y = center_y - crop_h / 2

    -- Clamp to source bounds
    crop_x = clamp(0, source_w - crop_w, crop_x)
    crop_y = clamp(0, source_h - crop_h, crop_y)

    return {
        x = crop_x,
        y = crop_y,
        w = crop_w,
        h = crop_h,
    }
end

-- Calculate target crop for zoom animation
-- mouse_pos: current mouse position
-- zoom_level: target zoom level
-- source_w, source_h: source dimensions
-- monitor_offset: offset for multi-monitor (optional)
function CameraPhysics:get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
    if not mouse_pos then
        return nil
    end

    -- Apply monitor offset if provided
    local target_x = mouse_pos.x
    local target_y = mouse_pos.y

    if monitor_offset then
        target_x = target_x - monitor_offset.x
        target_y = target_y - monitor_offset.y
    end

    -- Clamp to source bounds
    target_x = clamp(0, source_w, target_x)
    target_y = clamp(0, source_h, target_y)

    return self:compute_crop(target_x, target_y, zoom_level, source_w, source_h)
end

-- Interpolate between two crop rectangles
function CameraPhysics:lerp_crop(start_crop, end_crop, t, easing_fn)
    if not start_crop or not end_crop then
        return nil
    end

    t = clamp(0, 1, t)

    -- Apply easing
    local eased_t = easing_fn and easing_fn(t) or t

    return {
        x = lerp(start_crop.x, end_crop.x, eased_t),
        y = lerp(start_crop.y, end_crop.y, eased_t),
        w = lerp(start_crop.w, end_crop.w, eased_t),
        h = lerp(start_crop.h, end_crop.h, eased_t),
    }
end

-- Get camera velocity (for motion blur)
function CameraPhysics:get_velocity()
    return {
        x = self.pos.x - self.last_pos.x,
        y = self.pos.y - self.last_pos.y,
    }
end

-- Update last position (call at end of frame)
function CameraPhysics:update_last_pos()
    self.last_pos.x = self.pos.x
    self.last_pos.y = self.pos.y
end

-- Set monitor offset
function CameraPhysics:set_monitor_offset(offset)
    self.monitor_offset = offset or { x = 0, y = 0 }
end

-- Reset camera state
function CameraPhysics:reset()
    self.pos = { x = 0, y = 0 }
    self.vel_x = { val = 0 }
    self.vel_y = { val = 0 }
    self.tracked_pos = { x = 0, y = 0 }
    self.dead_zone_active = false
    self.last_pos = { x = 0, y = 0 }
end

-- Convenience wrapper functions
function camera_physics_init(mouse_pos)
    return CameraPhysics:init(mouse_pos)
end

function camera_physics_apply_dead_zone(mouse_pos, dead_zone_radius)
    return CameraPhysics:apply_dead_zone(mouse_pos, dead_zone_radius)
end

function camera_physics_smooth_input(target_pos, smooth_time, dt)
    return CameraPhysics:smooth_input(target_pos, smooth_time, dt)
end

function camera_physics_compute_crop(center_x, center_y, zoom_level, source_w, source_h)
    return CameraPhysics:compute_crop(center_x, center_y, zoom_level, source_w, source_h)
end

function camera_physics_get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
    return CameraPhysics:get_target_crop(mouse_pos, zoom_level, source_w, source_h, monitor_offset)
end

function camera_physics_lerp_crop(start_crop, end_crop, t, easing_fn)
    return CameraPhysics:lerp_crop(start_crop, end_crop, t, easing_fn)
end

function camera_physics_get_velocity()
    return CameraPhysics:get_velocity()
end

function camera_physics_update_last_pos()
    return CameraPhysics:update_last_pos()
end

function camera_physics_reset()
    return CameraPhysics:reset()
end

--================================================
-- MODULE: Timer & Main Loop (M09)
--================================================
-- Core integration module that handles frame-by-frame updates,
-- input processing, state machine updates, and output

-- Configuration (will be populated from settings)
local cfg = {
    source_name = "",
    zoom_value = 2.0,
    max_zoom = 10.0,
    zoom_duration = 0.6,
    zoom_overshoot = 0.0,
    zoom_easing = "Cubic.Out",

    auto_follow = true,
    follow_smooth_time = 0.15,
    follow_dead_zone = 5,

    debug_logs = false,
}

-- Timing
local last_tick_time = 0
local timer_running = false

-- Frame diff tracking (skip updates if nothing changed)
local last_output = { x = -1, y = -1, w = -1, h = -1 }

-- Original crop for zoom out
local original_crop = { x = 0, y = 0, w = 0, h = 0 }

-- Hotkey IDs
local hotkey_toggle_zoom = nil
local hotkey_toggle_follow = nil

-- Get reliable delta time
local function get_dt()
    local now = os.clock()
    local dt = now - last_tick_time
    last_tick_time = now
    return clamp(0.001, 0.1, dt)  -- Guard against freezes and div/zero
end

-- Start the timer
local function start_timer()
    if not timer_running then
        timer_running = true
        last_tick_time = os.clock()
        -- Use frame-synced interval
        local interval = 16  -- Default to ~60fps
        obs.timer_add(on_timer, interval)
        log("Timer: Started")
    end
end

-- Stop the timer
local function stop_timer()
    if timer_running then
        timer_running = false
        obs.timer_remove(on_timer)
        log("Timer: Stopped")
    end
end

-- Initialize mouse tracking
local function init_mouse_tracking(mouse_pos)
    camera_physics_init(mouse_pos)
    original_crop = {
        x = 0,
        y = 0,
        w = 0,
        h = 0,
    }
end

-- Main timer callback
function on_timer()
    local dt = get_dt()

    -- Guard: No valid source
    if not source_manager_is_valid() then
        return
    end

    --==========================
    -- 1. INPUT
    --==========================
    local raw_mouse = platform_get_mouse_pos()

    --==========================
    -- 2. STATE MACHINE UPDATE
    --==========================
    if SM:is_animating() then
        SM.zoom_time = SM.zoom_time + (dt / cfg.zoom_duration)

        -- Check for completion
        if SM.zoom_time >= 1.0 then
            SM:complete()

            -- Auto-enable follow after zoom in
            if SM.state == ZoomState.ZOOMED_IN and cfg.auto_follow then
                SM.following = true
            end

            -- Stop timer if idle
            if SM.state == ZoomState.IDLE then
                stop_timer()
            end
        end
    end

    --==========================
    -- 3. CAMERA POSITION
    --==========================
    local crop = nil
    local source_w, source_h = source_manager_get_size()

    if source_w == 0 or source_h == 0 then
        return
    end

    if SM:is_animating() then
        -- Animate between start and target crop
        local easing_fn = Easing.get(cfg.zoom_easing, cfg.zoom_overshoot)
        crop = camera_physics_lerp_crop(SM.start_crop, SM.target_crop, SM.zoom_time, easing_fn)
    elseif SM:is_zoomed() and SM.following then
        -- Follow mouse with dead zone and smoothing
        local tracked = camera_physics_apply_dead_zone(raw_mouse, cfg.follow_dead_zone)
        local smoothed = camera_physics_smooth_input(tracked, cfg.follow_smooth_time, dt)
        crop = camera_physics_compute_crop(smoothed.x, smoothed.y, SM.zoom_level, source_w, source_h)
        camera_physics_update_last_pos()
    elseif SM:is_zoomed() then
        -- Static zoom (not following)
        crop = camera_physics_get_target_crop(
            { x = SM.target_crop.x + SM.target_crop.w / 2, y = SM.target_crop.y + SM.target_crop.h / 2 },
            SM.zoom_level, source_w, source_h, nil
        )
    end

    --==========================
    -- 4. OUTPUT (Diff-based)
    --==========================
    if crop then
        local cx = math.floor(crop.x)
        local cy = math.floor(crop.y)
        local cw = math.floor(crop.w)
        local ch = math.floor(crop.h)

        if cx ~= last_output.x or cy ~= last_output.y or
           cw ~= last_output.w or ch ~= last_output.h then
            crop_filter_update(cx, cy, cw, ch)
            last_output.x = cx
            last_output.y = cy
            last_output.w = cw
            last_output.h = ch
        end
    end
end

--==========================
-- HOTKEY HANDLERS
--==========================

function on_toggle_zoom(pressed)
    if not pressed then return end

    if not source_manager_is_valid() then
        log("Toggle Zoom: No valid source")
        return
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        log("Toggle Zoom: Invalid source dimensions")
        return
    end

    if SM.state == ZoomState.IDLE then
        -- ZOOM IN
        local mouse = platform_get_mouse_pos()
        init_mouse_tracking(mouse)

        -- Store original crop
        original_crop = { x = 0, y = 0, w = source_w, h = source_h }

        -- Calculate target crop
        local target_crop = camera_physics_get_target_crop(mouse, cfg.zoom_value, source_w, source_h, nil)

        SM:transition(ZoomState.ZOOMING_IN, {
            start_crop = original_crop,
            target_crop = target_crop,
            target_level = cfg.zoom_value
        })

        start_timer()

    elseif SM.state == ZoomState.ZOOMED_IN then
        -- ZOOM OUT
        SM.following = false

        local current = crop_filter_get_crop()
        SM:transition(ZoomState.ZOOMING_OUT, {
            start_crop = current,
            target_crop = original_crop,
            target_level = 1.0
        })

        start_timer()
    end
    -- Ignore if already animating (guard against rapid presses)
end

function on_toggle_follow(pressed)
    if not pressed then return end
    if not SM:is_zoomed() then return end

    SM.following = not SM.following
    log("Follow: " .. tostring(SM.following))

    if SM.following and not timer_running then
        start_timer()
    end
end

--==========================
-- HOTKEY REGISTRATION
--==========================

local function register_hotkeys(settings)
    -- Toggle Zoom hotkey
    hotkey_toggle_zoom = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.toggle_zoom",
        "Toggle Zoom to Mouse",
        on_toggle_zoom
    )

    -- Toggle Follow hotkey
    hotkey_toggle_follow = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.toggle_follow",
        "Toggle Mouse Follow",
        on_toggle_follow
    )

    -- Load saved hotkey bindings
    local toggle_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.toggle_zoom")
    if toggle_array then
        obs.obs_hotkey_load(hotkey_toggle_zoom, toggle_array)
        obs.obs_data_array_release(toggle_array)
    end

    local follow_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.toggle_follow")
    if follow_array then
        obs.obs_hotkey_load(hotkey_toggle_follow, follow_array)
        obs.obs_data_array_release(follow_array)
    end

    -- Register scroll zoom hotkeys
    register_scroll_hotkeys(settings)

    log("Hotkeys: Registered")
end

local function save_hotkeys(settings)
    if hotkey_toggle_zoom then
        local array = obs.obs_hotkey_save(hotkey_toggle_zoom)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.toggle_zoom", array)
        obs.obs_data_array_release(array)
    end

    if hotkey_toggle_follow then
        local array = obs.obs_hotkey_save(hotkey_toggle_follow)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.toggle_follow", array)
        obs.obs_data_array_release(array)
    end

    -- Save scroll zoom hotkeys
    save_scroll_hotkeys(settings)
end

local function unregister_hotkeys()
    if hotkey_toggle_zoom then
        obs.obs_hotkey_unregister(hotkey_toggle_zoom)
        hotkey_toggle_zoom = nil
    end
    if hotkey_toggle_follow then
        obs.obs_hotkey_unregister(hotkey_toggle_follow)
        hotkey_toggle_follow = nil
    end
    -- Unregister scroll zoom hotkeys
    unregister_scroll_hotkeys()
    log("Hotkeys: Unregistered")
end

--==========================
-- SCENE EVENT HANDLERS
--==========================

function on_frontend_event(event)
    if event == obs.OBS_FRONTEND_EVENT_SCENE_CHANGED then
        -- Scene changed, re-acquire source
        log("Event: Scene changed")

        -- Handle scene memory
        scene_memory_on_scene_change()

        if cfg.source_name and cfg.source_name ~= "" then
            source_manager_release()
            source_manager_init(cfg.source_name)
        end
    elseif event == obs.OBS_FRONTEND_EVENT_EXIT then
        -- OBS is closing
        log("Event: OBS exiting")
        stop_timer()
        source_manager_release()
    end
end

--==========================
-- CONFIGURATION UPDATE
--==========================

local function update_config(settings)
    cfg.source_name = obs.obs_data_get_string(settings, "source") or ""
    cfg.zoom_value = obs.obs_data_get_double(settings, "zoom_value")
    cfg.zoom_duration = obs.obs_data_get_double(settings, "zoom_duration")
    cfg.zoom_overshoot = obs.obs_data_get_double(settings, "zoom_overshoot")
    cfg.zoom_easing = obs.obs_data_get_string(settings, "zoom_easing") or "Cubic.Out"

    cfg.auto_follow = obs.obs_data_get_bool(settings, "auto_follow")
    cfg.follow_smooth_time = obs.obs_data_get_double(settings, "follow_smooth_time")
    cfg.follow_dead_zone = obs.obs_data_get_int(settings, "follow_dead_zone")

    cfg.debug_logs = obs.obs_data_get_bool(settings, "debug_logs")
    debug_logs = cfg.debug_logs

    -- Update scroll zoom config
    update_scroll_config(settings)

    -- Check if source changed
    local current_source = source_manager_is_valid() and cfg.source_name
    if cfg.source_name ~= "" and cfg.source_name ~= current_source then
        -- Reset state and reinitialize
        SM:reset()
        stop_timer()
        source_manager_release()
        source_manager_init(cfg.source_name)
    end
end

--================================================
-- MODULE: Scroll Zoom (M10)
--================================================
-- Enables gradual zoom control via scroll wheel with modifier key
-- Provides dynamic zoom level adjustment during zoomed state

local ScrollZoom = {
    -- Hotkey IDs for scroll zoom
    hotkey_scroll_up = nil,
    hotkey_scroll_down = nil,

    -- Configuration (populated from settings)
    scroll_step = 0.25,
    scroll_modifier = "ctrl",  -- "ctrl", "alt", "shift"
}

-- Check if modifier key is held
local function is_modifier_held()
    if ScrollZoom.scroll_modifier == "ctrl" then
        return platform_is_ctrl_held()
    elseif ScrollZoom.scroll_modifier == "alt" then
        return platform_is_alt_held()
    elseif ScrollZoom.scroll_modifier == "shift" then
        return platform_is_shift_held()
    end
    return false
end

-- Handle scroll zoom in
function on_scroll_zoom_up(pressed)
    if not pressed then return end
    on_scroll_zoom(1)
end

-- Handle scroll zoom out
function on_scroll_zoom_down(pressed)
    if not pressed then return end
    on_scroll_zoom(-1)
end

-- Main scroll zoom handler
function on_scroll_zoom(direction)
    -- Check if we can scroll
    if not SM:can_scroll() then return end

    -- Check modifier (optional - can be configured)
    -- For now, we rely on OBS hotkey bindings which can include modifiers

    if not source_manager_is_valid() then
        log("Scroll Zoom: No valid source")
        return
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        return
    end

    -- Calculate new zoom level
    local step = ScrollZoom.scroll_step * direction  -- e.g., 0.25
    local new_level

    if SM.state == ZoomState.IDLE then
        -- Starting from unzoomed
        new_level = 1.0 + step
    else
        -- Already zoomed, adjust level
        new_level = SM.target_level + step
    end

    -- Clamp to valid range
    new_level = clamp(1.0, cfg.max_zoom, new_level)

    -- If we hit 1.0, fully zoom out
    if new_level <= 1.0 then
        if SM:is_zoomed() then
            -- Trigger full zoom out
            local current = crop_filter_get_crop()
            SM.following = false
            SM:transition(ZoomState.ZOOMING_OUT, {
                start_crop = current,
                target_crop = original_crop,
                target_level = 1.0
            })
            start_timer()
        end
        return
    end

    -- Get current mouse position
    local mouse = platform_get_mouse_pos()

    -- Calculate new target crop for new zoom level
    local target_crop = camera_physics_get_target_crop(mouse, new_level, source_w, source_h, nil)

    -- Get current crop as start
    local start_crop
    if SM:is_animating() then
        -- Use current interpolated crop
        start_crop = crop_filter_get_crop()
    elseif SM:is_zoomed() then
        -- Use current crop
        start_crop = crop_filter_get_crop()
    else
        -- Starting from unzoomed
        start_crop = { x = 0, y = 0, w = source_w, h = source_h }
        original_crop = start_crop
        camera_physics_init(mouse)
    end

    -- Transition to new zoom level
    if SM.state == ZoomState.IDLE then
        -- First scroll from unzoomed
        SM:transition(ZoomState.SCROLLING, {
            start_crop = start_crop,
            target_crop = target_crop,
            target_level = new_level
        })
    else
        -- Already zoomed, adjust level (interrupt current animation)
        SM:transition(ZoomState.SCROLLING, {
            start_crop = start_crop,
            target_crop = target_crop,
            target_level = new_level
        })
    end

    start_timer()
    log("Scroll Zoom: Level " .. string.format("%.2f", new_level))
end

-- Zoom to a specific level (for API calls)
function on_scroll_zoom_to(level)
    if not source_manager_is_valid() then return end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then return end

    level = clamp(1.0, cfg.max_zoom, level)

    if level <= 1.0 then
        -- Zoom out
        if SM:is_zoomed() then
            local current = crop_filter_get_crop()
            SM.following = false
            SM:transition(ZoomState.ZOOMING_OUT, {
                start_crop = current,
                target_crop = original_crop,
                target_level = 1.0
            })
            start_timer()
        end
        return
    end

    local mouse = platform_get_mouse_pos()
    local target_crop = camera_physics_get_target_crop(mouse, level, source_w, source_h, nil)

    local start_crop
    if SM:is_zoomed() then
        start_crop = crop_filter_get_crop()
    else
        start_crop = { x = 0, y = 0, w = source_w, h = source_h }
        original_crop = start_crop
        camera_physics_init(mouse)
    end

    SM:transition(ZoomState.SCROLLING, {
        start_crop = start_crop,
        target_crop = target_crop,
        target_level = level
    })

    start_timer()
end

-- Register scroll zoom hotkeys
local function register_scroll_hotkeys(settings)
    -- Scroll Up hotkey
    ScrollZoom.hotkey_scroll_up = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.scroll_up",
        "Zoom In (Scroll)",
        on_scroll_zoom_up
    )

    -- Scroll Down hotkey
    ScrollZoom.hotkey_scroll_down = obs.obs_hotkey_register_frontend(
        "obs_zoom_pro.scroll_down",
        "Zoom Out (Scroll)",
        on_scroll_zoom_down
    )

    -- Load saved bindings
    local up_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.scroll_up")
    if up_array then
        obs.obs_hotkey_load(ScrollZoom.hotkey_scroll_up, up_array)
        obs.obs_data_array_release(up_array)
    end

    local down_array = obs.obs_data_get_array(settings, "obs_zoom_pro.hotkey.scroll_down")
    if down_array then
        obs.obs_hotkey_load(ScrollZoom.hotkey_scroll_down, down_array)
        obs.obs_data_array_release(down_array)
    end

    log("Scroll Zoom: Hotkeys registered")
end

-- Save scroll hotkey bindings
local function save_scroll_hotkeys(settings)
    if ScrollZoom.hotkey_scroll_up then
        local array = obs.obs_hotkey_save(ScrollZoom.hotkey_scroll_up)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.scroll_up", array)
        obs.obs_data_array_release(array)
    end

    if ScrollZoom.hotkey_scroll_down then
        local array = obs.obs_hotkey_save(ScrollZoom.hotkey_scroll_down)
        obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.scroll_down", array)
        obs.obs_data_array_release(array)
    end
end

-- Unregister scroll hotkeys
local function unregister_scroll_hotkeys()
    if ScrollZoom.hotkey_scroll_up then
        obs.obs_hotkey_unregister(ScrollZoom.hotkey_scroll_up)
        ScrollZoom.hotkey_scroll_up = nil
    end
    if ScrollZoom.hotkey_scroll_down then
        obs.obs_hotkey_unregister(ScrollZoom.hotkey_scroll_down)
        ScrollZoom.hotkey_scroll_down = nil
    end
end

-- Update scroll zoom config
local function update_scroll_config(settings)
    ScrollZoom.scroll_step = obs.obs_data_get_double(settings, "scroll_step")
    ScrollZoom.scroll_modifier = obs.obs_data_get_string(settings, "scroll_modifier") or "ctrl"
end

--================================================
-- PLACEHOLDER: Future Modules
--================================================

-- M01: Configuration & Settings (TODO)
-- M05: Scene Manager (TODO)
-- M06: Source Manager (TODO)
-- M07: Crop/Zoom Controller (TODO)
-- M08: Motion Tracker (TODO)
-- M09: Face Detection (TODO)
-- M11: Audio Reactor (TODO)
-- M12: Transition Manager (TODO)
-- M13: Animation Controller (TODO)
-- M14: Preset Manager (TODO)
-- M15: Hotkey Manager (TODO)
-- M16: UI Components (TODO)
-- M17: Timer/Scheduler (TODO)
-- M18: State Machine (TODO)
-- M19: Performance Monitor (TODO)

--================================================
-- SCRIPT SETTINGS
--================================================
local settings = {}

-- Default settings
local defaults = {
    debug_logging = false,
    easing_type = "QuadInOut",
    smooth_time = 0.3,
    max_speed = 100.0
}

--================================================
-- MODULE: Preset Manager (M13)
--================================================
-- Manages built-in and custom animation presets

local PresetManager = {
    -- Built-in presets (read-only)
    built_in = {
        {
            name = "Smooth",
            duration = 0.8,
            overshoot = 0.0,
            smoothness = 0.25,
            easing = "Cubic.Out",
        },
        {
            name = "Bounce",
            duration = 0.6,
            overshoot = 0.35,
            smoothness = 0.15,
            easing = "Back.Out",
        },
        {
            name = "Snappy",
            duration = 0.3,
            overshoot = 0.0,
            smoothness = 0.05,
            easing = "Expo.Out",
        },
        {
            name = "Cinematic",
            duration = 1.2,
            overshoot = 0.05,
            smoothness = 0.4,
            easing = "Sine.Out",
        },
    },

    -- Custom user presets
    custom = {},

    -- Currently selected preset name
    current_preset = "Smooth",
}

-- Get all preset names (built-in + custom)
function PresetManager:get_all_names()
    local names = {}

    -- Add built-in presets
    for _, preset in ipairs(self.built_in) do
        table.insert(names, preset.name)
    end

    -- Add custom presets
    for name, _ in pairs(self.custom) do
        table.insert(names, name)
    end

    table.sort(names)
    return names
end

-- Get preset by name
function PresetManager:get_preset(name)
    -- Check built-in first
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            return preset
        end
    end

    -- Check custom
    if self.custom[name] then
        return self.custom[name]
    end

    -- Default to Smooth
    return self.built_in[1]
end

-- Apply preset to configuration
function PresetManager:apply_preset(name)
    local preset = self:get_preset(name)
    if not preset then
        log("Preset: Unknown preset: " .. name)
        return false
    end

    cfg.zoom_duration = preset.duration
    cfg.zoom_overshoot = preset.overshoot
    cfg.follow_smooth_time = preset.smoothness

    if preset.easing then
        cfg.zoom_easing = preset.easing
    end

    self.current_preset = name
    log("Preset: Applied '" .. name .. "'")
    return true
end

-- Save a custom preset
function PresetManager:save_preset(name, duration, overshoot, smoothness, easing)
    if not name or name == "" then
        return false
    end

    -- Check if it's a built-in preset (can't override)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            log("Preset: Cannot override built-in preset: " .. name)
            return false
        end
    end

    -- Save custom preset
    self.custom[name] = {
        name = name,
        duration = duration or cfg.zoom_duration,
        overshoot = overshoot or cfg.zoom_overshoot,
        smoothness = smoothness or cfg.follow_smooth_time,
        easing = easing or cfg.zoom_easing,
    }

    log("Preset: Saved custom preset '" .. name .. "'")
    return true
end

-- Delete a custom preset
function PresetManager:delete_preset(name)
    -- Check if it's a built-in preset (can't delete)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            log("Preset: Cannot delete built-in preset: " .. name)
            return false
        end
    end

    -- Delete custom preset
    if self.custom[name] then
        self.custom[name] = nil
        log("Preset: Deleted custom preset '" .. name .. "'")
        return true
    end

    return false
end

-- Check if a preset is built-in
function PresetManager:is_built_in(name)
    for _, preset in ipairs(self.built_in) do
        if preset.name == name then
            return true
        end
    end
    return false
end

-- Persist custom presets to settings
function PresetManager:persist(settings)
    local array = obs.obs_data_array_create()

    for name, preset in pairs(self.custom) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "name", name)
        obs.obs_data_set_double(item, "duration", preset.duration)
        obs.obs_data_set_double(item, "overshoot", preset.overshoot)
        obs.obs_data_set_double(item, "smoothness", preset.smoothness)
        obs.obs_data_set_string(item, "easing", preset.easing)
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "custom_presets", array)
    obs.obs_data_array_release(array)
end

-- Load custom presets from settings
function PresetManager:load(settings)
    self.custom = {}

    local array = obs.obs_data_get_array(settings, "custom_presets")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local name = obs.obs_data_get_string(item, "name")

        if name and name ~= "" then
            self.custom[name] = {
                name = name,
                duration = obs.obs_data_get_double(item, "duration"),
                overshoot = obs.obs_data_get_double(item, "overshoot"),
                smoothness = obs.obs_data_get_double(item, "smoothness"),
                easing = obs.obs_data_get_string(item, "easing"),
            }
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)
    log("Preset: Loaded " .. self:get_custom_count() .. " custom presets")
end

-- Get count of custom presets
function PresetManager:get_custom_count()
    local count = 0
    for _, _ in pairs(self.custom) do
        count = count + 1
    end
    return count
end

-- Get current preset name
function PresetManager:get_current_name()
    return self.current_preset
end

-- Set current preset name
function PresetManager:set_current_name(name)
    self.current_preset = name
end

-- Check if current preset is custom
function PresetManager:is_current_custom()
    return not self:is_built_in(self.current_preset)
end

-- Global convenience functions
function preset_get_all_names()
    return PresetManager:get_all_names()
end

function preset_apply(name)
    return PresetManager:apply_preset(name)
end

function preset_save(name, duration, overshoot, smoothness, easing)
    return PresetManager:save_preset(name, duration, overshoot, smoothness, easing)
end

function preset_delete(name)
    return PresetManager:delete_preset(name)
end

function preset_is_built_in(name)
    return PresetManager:is_built_in(name)
end

function preset_get_current()
    return PresetManager:get_current_name()
end

--================================================
-- MODULE: Auto Source Detection (M11)
--================================================
-- Automatically detects and selects the best zoom source on first run

local AutoSourceDetector = {
    -- Source type priorities (higher = more likely to be the main display)
    type_priorities = {
        ["monitor_capture"] = 100,     -- Display capture (highest priority)
        ["game_capture"] = 80,          -- Game capture
        ["window_capture"] = 60,        -- Window capture
        ["xshm_input"] = 40,           -- Linux X11 capture
        ["av_capture_input"] = 20,     -- macOS capture
    },

    -- Whether auto-detection has been run
    auto_detected = false,
}

-- Get all capture sources sorted by priority
function AutoSourceDetector:get_capture_sources()
    local sources = {}
    local source_list = obs.obs_enum_sources()

    if not source_list then
        return sources
    end

    for _, source in ipairs(source_list) do
        local source_id = obs.obs_source_get_id(source)
        local name = obs.obs_source_get_name(source)

        -- Check if it's a capture source
        local priority = self.type_priorities[source_id]
        if priority then
            table.insert(sources, {
                name = name,
                id = source_id,
                priority = priority,
            })
        end
    end

    obs.source_list_release(source_list)

    -- Sort by priority (highest first)
    table.sort(sources, function(a, b)
        return a.priority > b.priority
    end)

    return sources
end

-- Auto-detect the best source
function AutoSourceDetector:auto_detect()
    local sources = self:get_capture_sources()

    if #sources == 0 then
        log("AutoSource: No capture sources found")
        return nil
    end

    if #sources == 1 then
        -- Only one source, use it
        log("AutoSource: Found single source: " .. sources[1].name)
        return sources[1].name
    end

    -- Multiple sources - prioritize by type
    -- Prefer monitor_capture > game_capture > window_capture
    local best = sources[1]

    log("AutoSource: Found " .. #sources .. " sources, selecting: " .. best.name)
    return best.name
end

-- Get monitor geometry from a source (if available)
function AutoSourceDetector:get_monitor_geometry(source_name)
    local source = obs.obs_get_source_by_name(source_name)
    if not source then
        return nil
    end

    local settings = obs.obs_source_get_settings(source)
    if not settings then
        obs.obs_source_release(source)
        return nil
    end

    -- Try to get monitor info from settings
    local monitor = obs.obs_data_get_int(settings, "monitor")
    local x = obs.obs_data_get_int(settings, "x")
    local y = obs.obs_data_get_int(settings, "y")
    local width = obs.obs_data_get_int(settings, "width")
    local height = obs.obs_data_get_int(settings, "height")

    obs.obs_data_release(settings)
    obs.obs_source_release(source)

    -- Return geometry if available
    if monitor >= 0 or width > 0 then
        return {
            monitor = monitor,
            x = x,
            y = y,
            width = width or 1920,
            height = height or 1080,
        }
    end

    return nil
end

-- Check if we should auto-detect on first run
function AutoSourceDetector:should_auto_detect(settings)
    -- Check if source has ever been set
    local last_source = obs.obs_data_get_string(settings, "source")
    if last_source and last_source ~= "" then
        return false
    end

    -- Check if auto-detect has been done
    return not self.auto_detected
end

-- Run auto-detection and return the source name
function AutoSourceDetector:run(settings)
    local source_name = self:auto_detect()

    if source_name then
        -- Save the detected source
        obs.obs_data_set_string(settings, "source", source_name)
        self.auto_detected = true
    end

    return source_name
end

-- Global convenience functions
function auto_source_detect()
    return AutoSourceDetector:auto_detect()
end

function auto_source_should_detect(settings)
    return AutoSourceDetector:should_auto_detect(settings)
end

function auto_source_run(settings)
    return AutoSourceDetector:run(settings)
end

--================================================
-- MODULE: Scene Memory (M12)
--================================================
-- Remembers which zoom source to use for each OBS scene

local SceneMemory = {
    -- Scene to source mapping
    scene_source_map = {},

    -- Maximum number of mappings to store
    max_mappings = 50,
}

-- Get the current scene name
function SceneMemory:get_current_scene_name()
    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then
        return nil
    end

    local name = obs.obs_source_get_name(scene_source)
    obs.obs_source_release(scene_source)
    return name
end

-- Get the source to use for the current scene
function SceneMemory:get_source_for_current_scene()
    local scene_name = self:get_current_scene_name()
    if not scene_name then
        return nil
    end

    -- 1. Check explicit mapping for this scene
    if self.scene_source_map[scene_name] then
        return self.scene_source_map[scene_name]
    end

    -- 2. Fall back to global source from config
    return cfg.source_name
end

-- Set the source for a specific scene
function SceneMemory:set(scene_name, source_name)
    if not scene_name or scene_name == "" then
        return false
    end

    -- Check if we're at capacity
    local count = 0
    for _, _ in pairs(self.scene_source_map) do
        count = count + 1
    end

    if count >= self.max_mappings and not self.scene_source_map[scene_name] then
        log("SceneMemory: At capacity (" .. self.max_mappings .. "), cannot add: " .. scene_name)
        return false
    end

    self.scene_source_map[scene_name] = source_name
    log("SceneMemory: " .. scene_name .. " Ã¢â€ â€™ " .. source_name)
    return true
end

-- Remove a scene mapping
function SceneMemory:remove(scene_name)
    if self.scene_source_map[scene_name] then
        self.scene_source_map[scene_name] = nil
        log("SceneMemory: Removed mapping for " .. scene_name)
        return true
    end
    return false
end

-- Get all scene mappings
function SceneMemory:get_all()
    local mappings = {}
    for scene, source in pairs(self.scene_source_map) do
        table.insert(mappings, { scene = scene, source = source })
    end
    table.sort(mappings, function(a, b)
        return a.scene < b.scene
    end)
    return mappings
end

-- Check if a scene has a mapping
function SceneMemory:has_mapping(scene_name)
    return self.scene_source_map[scene_name] ~= nil
end

-- Persist mappings to settings
function SceneMemory:persist(settings)
    local array = obs.obs_data_array_create()

    for scene, source in pairs(self.scene_source_map) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "scene", scene)
        obs.obs_data_set_string(item, "source", source)
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "scene_source_map", array)
    obs.obs_data_array_release(array)
end

-- Load mappings from settings
function SceneMemory:load(settings)
    self.scene_source_map = {}

    local array = obs.obs_data_get_array(settings, "scene_source_map")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local scene = obs.obs_data_get_string(item, "scene")
        local source = obs.obs_data_get_string(item, "source")

        if scene and scene ~= "" and source and source ~= "" then
            self.scene_source_map[scene] = source
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)

    local count = 0
    for _, _ in pairs(self.scene_source_map) do count = count + 1 end
    log("SceneMemory: Loaded " .. count .. " scene mappings")
end

-- Handle scene change
function SceneMemory:on_scene_change()
    local scene_name = self:get_current_scene_name()
    if not scene_name then
        return
    end

    -- Get the source for this scene
    local source_name = self:get_source_for_current_scene()

    if source_name and source_name ~= "" then
        -- Check if source changed
        local current = source_manager_is_valid() and cfg.source_name

        if source_name ~= current then
            log("SceneMemory: Scene changed to " .. scene_name)

            -- Release current source
            source_manager_release()

            -- Initialize with new source
            cfg.source_name = source_name
            source_manager_init(source_name)
        end
    end
end

-- Global convenience functions
function scene_memory_get_source()
    return SceneMemory:get_source_for_current_scene()
end

function scene_memory_set(scene_name, source_name)
    return SceneMemory:set(scene_name, source_name)
end

function scene_memory_remove(scene_name)
    return SceneMemory:remove(scene_name)
end

function scene_memory_get_all()
    return SceneMemory:get_all()
end

function scene_memory_on_scene_change()
    return SceneMemory:on_scene_change()
end

--================================================
-- MODULE: Blur Manager (M14)
--================================================
-- Provides built-in blur effects without external plugins
-- Supports multiple strategies: shader, composite_blur plugin, or none

local BlurManager = {
    -- Current strategy: "shader", "composite_blur", "none"
    strategy = "none",

    -- Filter references
    zoom_blur_filter = nil,
    motion_blur_filter = nil,

    -- Settings references
    zoom_blur_settings = nil,
    motion_blur_settings = nil,

    -- State
    initialized = false,

    -- Configuration
    zoom_blur_enabled = false,
    zoom_blur_intensity = 5,
    zoom_blur_clear_radius = 150,
    motion_blur_enabled = false,
    motion_blur_intensity = 1.0,
}

-- Try to use custom shader (if effect files exist)
function BlurManager:try_shader_strategy(source)
    -- This would require .effect files in assets/shaders/
    -- For now, we'll use a simpler approach
    log("Blur: Shader strategy not implemented (requires effect files)")
    return false
end

-- Try to auto-create Composite Blur filters
function BlurManager:try_composite_blur_strategy(source)
    if not source then return false end

    -- Check if composite_blur filter type exists
    local test_filter = obs.obs_source_create_private("composite_blur", "__test_blur__", nil)
    if test_filter then
        obs.obs_source_release(test_filter)
    else
        log("Blur: Composite Blur plugin not available")
        return false
    end

    -- Create Zoom Blur filter
    local zs = obs.obs_data_create()
    obs.obs_data_set_double(zs, "radius", 0)
    obs.obs_data_set_int(zs, "blur_type", 2) -- Zoom type
    self.zoom_blur_filter = obs.obs_source_create_private(
        "composite_blur",
        FILTER_PREFIX .. "Zoom Blur",
        zs
    )

    if self.zoom_blur_filter then
        obs.obs_source_filter_add(source, self.zoom_blur_filter)
        self.zoom_blur_settings = zs
    else
        obs.obs_data_release(zs)
        return false
    end

    -- Create Motion Blur filter
    local ms = obs.obs_data_create()
    obs.obs_data_set_double(ms, "radius", 0)
    obs.obs_data_set_int(ms, "blur_type", 3) -- Motion/directional type
    self.motion_blur_filter = obs.obs_source_create_private(
        "composite_blur",
        FILTER_PREFIX .. "Motion Blur",
        ms
    )

    if self.motion_blur_filter then
        obs.obs_source_filter_add(source, self.motion_blur_filter)
        self.motion_blur_settings = ms
    else
        obs.obs_data_release(ms)
    end

    self.initialized = true
    return true
end

-- Initialize blur manager
function BlurManager:init(source)
    if not source then
        return false
    end

    self:cleanup()

    -- Try composite_blur strategy
    if self:try_composite_blur_strategy(source) then
        self.strategy = "composite_blur"
        log("Blur: Using Composite Blur plugin (auto-configured)")
        return true
    end

    -- No blur available
    self.strategy = "none"
    log("Blur: No blur backend available. Blur effects disabled.")
    return false
end

-- Update blur based on zoom state
function BlurManager:update(state_machine, crop, camera_velocity)
    if not self.initialized then return end
    if self.strategy == "none" then return end

    -- Zoom Blur: Active during zoom transitions
    if self.zoom_blur_enabled and self.zoom_blur_filter then
        local radius = 0

        if state_machine:is_animating() and
           (state_machine.state == ZoomState.ZOOMING_IN or
            state_machine.state == ZoomState.ZOOMING_OUT) then
            -- Bell curve: 0 at start Ã¢â€ â€™ peak at 50% Ã¢â€ â€™ 0 at end
            local t = clamp(0, 1, state_machine.zoom_time)
            local curve = math.sin(t * math.pi)
            radius = curve * curve * self.zoom_blur_intensity
        end

        self:set_zoom_blur(radius, crop)
    end

    -- Motion Blur: Active during camera panning (not during zoom transition)
    if self.motion_blur_enabled and self.motion_blur_filter then
        if not state_machine:is_animating() and state_machine:is_zoomed() and camera_velocity then
            local speed = math.sqrt(
                camera_velocity.x * camera_velocity.x +
                camera_velocity.y * camera_velocity.y
            )

            if speed > 1.0 then
                local radius = math.min(10, speed * self.motion_blur_intensity * 0.5)
                local angle = math.deg(math.atan2(camera_velocity.y, camera_velocity.x))
                self:set_motion_blur(radius, angle)
            else
                self:set_motion_blur(0, 0)
            end
        else
            self:set_motion_blur(0, 0)
        end
    end
end

-- Set zoom blur parameters
function BlurManager:set_zoom_blur(radius, crop)
    if self.strategy == "composite_blur" and self.zoom_blur_settings then
        obs.obs_data_set_double(self.zoom_blur_settings, "radius", radius)

        if crop then
            local cx = crop.x + (crop.w / 2)
            local cy = crop.y + (crop.h / 2)
            obs.obs_data_set_double(self.zoom_blur_settings, "center_x", cx)
            obs.obs_data_set_double(self.zoom_blur_settings, "center_y", cy)
        end

        obs.obs_data_set_double(self.zoom_blur_settings, "inactive_radius", self.zoom_blur_clear_radius)
        obs.obs_source_update(self.zoom_blur_filter, self.zoom_blur_settings)
    end
end

-- Set motion blur parameters
function BlurManager:set_motion_blur(radius, angle)
    if self.strategy == "composite_blur" and self.motion_blur_settings then
        obs.obs_data_set_double(self.motion_blur_settings, "radius", radius)
        obs.obs_data_set_double(self.motion_blur_settings, "angle", angle)
        obs.obs_source_update(self.motion_blur_filter, self.motion_blur_settings)
    end
end

-- Update configuration
function BlurManager:update_config(settings)
    self.zoom_blur_enabled = obs.obs_data_get_bool(settings, "zoom_blur_enabled")
    self.zoom_blur_intensity = obs.obs_data_get_double(settings, "zoom_blur_intensity")
    self.zoom_blur_clear_radius = obs.obs_data_get_double(settings, "zoom_blur_clear_radius")
    self.motion_blur_enabled = obs.obs_data_get_bool(settings, "motion_blur_enabled")
    self.motion_blur_intensity = obs.obs_data_get_double(settings, "motion_blur_intensity")
end

-- Cleanup filters
function BlurManager:cleanup()
    local source = source_manager_get_source()

    if self.zoom_blur_filter and source then
        obs.obs_source_filter_remove(source, self.zoom_blur_filter)
        obs.obs_source_release(self.zoom_blur_filter)
        self.zoom_blur_filter = nil
    end

    if self.motion_blur_filter and source then
        obs.obs_source_filter_remove(source, self.motion_blur_filter)
        obs.obs_source_release(self.motion_blur_filter)
        self.motion_blur_filter = nil
    end

    if self.zoom_blur_settings then
        obs.obs_data_release(self.zoom_blur_settings)
        self.zoom_blur_settings = nil
    end

    if self.motion_blur_settings then
        obs.obs_data_release(self.motion_blur_settings)
        self.motion_blur_settings = nil
    end

    self.initialized = false
    self.strategy = "none"
end

-- Check if blur is available
function BlurManager:is_available()
    return self.strategy ~= "none"
end

-- Global convenience functions
function blur_manager_init(source)
    return BlurManager:init(source)
end

function blur_manager_update(state_machine, crop, camera_velocity)
    return BlurManager:update(state_machine, crop, camera_velocity)
end

function blur_manager_update_config(settings)
    return BlurManager:update_config(settings)
end

function blur_manager_cleanup()
    return BlurManager:cleanup()
end

function blur_manager_is_available()
    return BlurManager:is_available()
end

--================================================
-- MODULE: Cursor Asset Manager (M16)
--================================================
-- Handles extracting and managing cursor image assets

local CursorAssets = {
    extracted = false,
    dir = nil,
}

-- Get the platform-specific asset directory
function CursorAssets:get_platform_dir()
    if IS_WINDOWS then
        local appdata = os.getenv("APPDATA")
        return appdata and (appdata .. "\\obs-studio\\obs-zoom-pro\\cursors") or nil
    elseif IS_LINUX then
        local home = os.getenv("HOME")
        return home and (home .. "/.config/obs-studio/obs-zoom-pro/cursors") or nil
    elseif IS_MACOS then
        local home = os.getenv("HOME")
        return home and (home .. "/Library/Application Support/obs-studio/obs-zoom-pro/cursors") or nil
    end
    -- Fallback for non-FFI environments
    return "cursors"
end

-- Ensure assets are extracted
function CursorAssets:ensure_extracted()
    if self.extracted then
        return self.dir
    end

    local dir = self:get_platform_dir()
    if not dir then
        log("CursorAssets: Could not determine asset directory")
        return nil
    end

    -- Create directory
    local cmd
    if IS_WINDOWS then
        cmd = 'mkdir "' .. dir .. '" 2>nul'
    else
        cmd = 'mkdir -p "' .. dir .. '"'
    end
    os.execute(cmd)

    -- Check if assets exist
    local sep = IS_WINDOWS and "\\" or "/"
    local arrow_path = dir .. sep .. "arrow.png"

    local f = io.open(arrow_path, "rb")
    if f then
        f:close()
        self.dir = dir
        self.extracted = true
        log("CursorAssets: Using existing assets from " .. dir)
        return dir
    end

    -- Try to copy from script directory
    local script_dir = get_script_directory()
    local assets_src = script_dir .. "assets" .. sep .. "cursors" .. sep

    local files = { "arrow.png", "pointer.png", "ibeam.png" }
    for _, filename in ipairs(files) do
        local src_path = assets_src .. filename
        local dst_path = dir .. sep .. filename

        local src = io.open(src_path, "rb")
        if src then
            local data = src:read("*a")
            src:close()

            local dst = io.open(dst_path, "wb")
            if dst then
                dst:write(data)
                dst:close()
                log("CursorAssets: Copied " .. filename)
            end
        end
    end

    self.dir = dir
    self.extracted = true
    return dir
end

-- Get the asset directory
function CursorAssets:get_dir()
    return self.dir
end

-- Check if assets are available
function CursorAssets:is_available()
    if not self.extracted then
        self:ensure_extracted()
    end
    return self.dir ~= nil
end

-- Get cursor image path
function CursorAssets:get_cursor_path(cursor_type)
    if not self:is_available() then
        return nil
    end

    local sep = IS_WINDOWS and "\\" or "/"
    local filename = (cursor_type or "arrow") .. ".png"
    return self.dir .. sep .. filename
end

-- Global convenience functions
function cursor_assets_ensure_extracted()
    return CursorAssets:ensure_extracted()
end

function cursor_assets_get_dir()
    return CursorAssets:get_dir()
end

function cursor_assets_is_available()
    return CursorAssets:is_available()
end

function cursor_assets_get_cursor_path(cursor_type)
    return CursorAssets:get_cursor_path(cursor_type)
end

--================================================
-- MODULE: Cursor Renderer (M15)
--================================================
-- Provides automatic cursor overlay rendering

local CursorRenderer = {
    enabled = false,
    source = nil,
    sceneitem = nil,

    -- Smoothed state
    pos = { x = 0, y = 0 },
    current_scale = 1.0,
    current_rot = 0,
    swap_pulse = 1.0,

    -- Velocities (SmoothDamp)
    vel_x = { val = 0 },
    vel_y = { val = 0 },
    vel_scale = { val = 0 },
    vel_rot = { val = 0 },
    vel_swap = { val = 0 },

    -- State
    was_pointer = false,
    initialized = false,

    -- Configuration
    cursor_scale = 1.0,
    cursor_click_scale = 0.78,
    cursor_smooth_time = 0.1,
    cursor_offset_x = -6,
    cursor_offset_y = -2,
    cursor_rotation_mode = "None",
    cursor_angle_offset = 0,
    cursor_tilt_strength = 0,
}

-- Initialize cursor renderer
function CursorRenderer:init()
    if not cfg.cursor_enabled then
        self.enabled = false
        return false
    end

    -- Ensure cursor assets are available
    local asset_dir = cursor_assets_ensure_extracted()
    if not asset_dir then
        log("CursorRenderer: Failed to extract cursor assets")
        self.enabled = false
        return false
    end

    -- Get or create the cursor image source
    local source_name = FILTER_PREFIX .. "Cursor"
    self.source = obs.obs_get_source_by_name(source_name)

    if not self.source then
        -- Create new image source
        local settings = obs.obs_data_create()
        local cursor_path = cursor_assets_get_cursor_path("arrow")
        if cursor_path then
            obs.obs_data_set_string(settings, "file", cursor_path)
        end
        self.source = obs.obs_source_create("image_source", source_name, settings, nil)
        obs.obs_data_release(settings)

        if not self.source then
            log("CursorRenderer: Failed to create image source")
            self.enabled = false
            return false
        end
    end

    -- Add to current scene
    self:add_to_scene()

    -- Initialize position
    local mouse = platform_get_mouse_pos()
    self.pos.x = mouse.x
    self.pos.y = mouse.y

    self.enabled = true
    self.initialized = true
    log("CursorRenderer: Initialized")
    return true
end

-- Add cursor source to scene
function CursorRenderer:add_to_scene()
    if not self.source then return false end

    local scene_source = obs.obs_frontend_get_current_scene()
    if not scene_source then return false end

    local scene = obs.obs_scene_from_source(scene_source)
    if not scene then
        obs.obs_source_release(scene_source)
        return false
    end

    -- Check if already in scene
    local source_name = obs.obs_source_get_name(self.source)
    self.sceneitem = obs.obs_scene_find_source(scene, source_name)

    if not self.sceneitem then
        -- Add to scene
        self.sceneitem = obs.obs_scene_add(scene, self.source)
        if self.sceneitem then
            -- Move to top (render last = on top)
            obs.obs_sceneitem_set_order(self.sceneitem, obs.OBS_ORDER_MOVE_TOP)
        end
    end

    obs.obs_source_release(scene_source)
    return true
end

-- Update cursor position and state
function CursorRenderer:update(dt, raw_mouse, camera_crop)
    if not self.enabled or not self.sceneitem then return end

    -- Smooth cursor position
    self.pos.x = SmoothDamp(self.pos.x, raw_mouse.x, self.vel_x, self.cursor_smooth_time, 100000, dt)
    self.pos.y = SmoothDamp(self.pos.y, raw_mouse.y, self.vel_y, self.cursor_smooth_time, 100000, dt)

    -- Snap when very close
    if math.abs(self.pos.x - raw_mouse.x) < 0.5 then
        self.pos.x = raw_mouse.x
        self.vel_x.val = 0
    end
    if math.abs(self.pos.y - raw_mouse.y) < 0.5 then
        self.pos.y = raw_mouse.y
        self.vel_y.val = 0
    end

    -- Cursor shape detection (Windows only)
    local is_pointer = false
    if platform_cursor_shape_available() then
        is_pointer = platform_is_cursor_pointer()
    end

    -- Swap cursor image if needed
    if is_pointer ~= self.was_pointer then
        local asset_dir = cursor_assets_get_dir()
        local sep = IS_WINDOWS and "\\" or "/"
        local new_file = is_pointer and (asset_dir .. sep .. "pointer.png") or (asset_dir .. sep .. "arrow.png")

        local s = obs.obs_source_get_settings(self.source)
        if s then
            obs.obs_data_set_string(s, "file", new_file)
            obs.obs_source_update(self.source, s)
            obs.obs_data_release(s)
        end

        -- Trigger swap pulse
        self.swap_pulse = 0.75
        self.vel_swap.val = 1
        self.was_pointer = is_pointer
    end

    self.swap_pulse = SmoothDamp(self.swap_pulse, 1.0, self.vel_swap, 0.12, 100000, dt)

    -- Click animation
    local is_clicking = platform_is_clicking()
    local target_scale = is_clicking and (self.cursor_scale * self.cursor_click_scale) or self.cursor_scale
    self.current_scale = SmoothDamp(self.current_scale, target_scale, self.vel_scale, 0.1, 100000, dt)

    -- Calculate position relative to zoom
    local zoom_factor = 1.0
    local crop_x, crop_y = 0, 0

    if camera_crop and SM:is_zoomed() then
        zoom_factor = source_manager_get_size() / camera_crop.w
        crop_x = camera_crop.x
        crop_y = camera_crop.y
    end

    local final_x = (self.pos.x - crop_x) * zoom_factor + (self.cursor_offset_x * zoom_factor)
    local final_y = (self.pos.y - crop_y) * zoom_factor + (self.cursor_offset_y * zoom_factor)

    -- Apply to scene item
    local pos = obs.vec2()
    pos.x = final_x
    pos.y = final_y
    obs.obs_sceneitem_set_pos(self.sceneitem, pos)

    local scale = obs.vec2()
    local s = self.current_scale * zoom_factor * self.swap_pulse
    scale.x = s
    scale.y = s
    obs.obs_sceneitem_set_scale(self.sceneitem, scale)

    -- Rotation
    local dynamic_rot = self:compute_rotation(dt)
    obs.obs_sceneitem_set_rot(self.sceneitem, dynamic_rot)
end

-- Compute rotation based on mode
function CursorRenderer:compute_rotation(dt)
    local vx = self.vel_x.val
    local vy = self.vel_y.val
    local speed = math.sqrt(vx * vx + vy * vy)

    if self.cursor_rotation_mode == "Directional" then
        if speed > 20 then
            local angle = math.atan2(vy, vx) * (180 / math.pi)
            local target = angle + self.cursor_angle_offset
            local diff = (target - self.current_rot + 180) % 360 - 180
            self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.05, 100000, dt)
        end
        return self.current_rot

    elseif self.cursor_rotation_mode == "Lean" then
        local lean = clamp(-40, 40, vx * 0.05 * self.cursor_tilt_strength) + self.cursor_angle_offset
        local diff = (lean - self.current_rot + 180) % 360 - 180
        self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.08, 100000, dt)
        return self.current_rot
    end

    -- "None" mode
    local diff = (self.cursor_angle_offset - self.current_rot + 180) % 360 - 180
    self.current_rot = SmoothDamp(self.current_rot, self.current_rot + diff, self.vel_rot, 0.15, 100000, dt)
    return self.current_rot
end

-- Update configuration
function CursorRenderer:update_config(settings)
    self.cursor_scale = obs.obs_data_get_double(settings, "cursor_scale")
    self.cursor_click_scale = obs.obs_data_get_double(settings, "cursor_click_scale")
    self.cursor_smooth_time = obs.obs_data_get_double(settings, "cursor_smooth_time")
    self.cursor_offset_x = obs.obs_data_get_int(settings, "cursor_offset_x")
    self.cursor_offset_y = obs.obs_data_get_int(settings, "cursor_offset_y")
    self.cursor_rotation_mode = obs.obs_data_get_string(settings, "cursor_rotation_mode") or "None"
    self.cursor_angle_offset = obs.obs_data_get_double(settings, "cursor_angle_offset")
    self.cursor_tilt_strength = obs.obs_data_get_double(settings, "cursor_tilt_strength")
end

-- Cleanup
function CursorRenderer:cleanup()
    if self.sceneitem then
        obs.obs_sceneitem_remove(self.sceneitem)
        self.sceneitem = nil
    end

    if self.source then
        local source_name = obs.obs_source_get_name(self.source)
        obs.obs_source_release(self.source)

        -- Remove from OBS source list
        local s = obs.obs_get_source_by_name(source_name)
        if s then
            obs.obs_source_remove(s)
            obs.obs_source_release(s)
        end
        self.source = nil
    end

    self.enabled = false
    self.initialized = false
end

-- Check if active
function CursorRenderer:is_active()
    return self.enabled and self.initialized
end

-- Global convenience functions
function cursor_renderer_init()
    return CursorRenderer:init()
end

function cursor_renderer_update(dt, raw_mouse, camera_crop)
    return CursorRenderer:update(dt, raw_mouse, camera_crop)
end

function cursor_renderer_update_config(settings)
    return CursorRenderer:update_config(settings)
end

function cursor_renderer_cleanup()
    return CursorRenderer:cleanup()
end

function cursor_renderer_is_active()
    return CursorRenderer:is_active()
end

--================================================
-- MODULE: Bookmark Manager (M17)
--================================================
-- Manages saved zoom positions (bookmarks)

local BookmarkManager = {
    -- Saved bookmarks: { name = { zoom_level, x, y, w, h, source } }
    bookmarks = {},

    -- Maximum bookmarks
    max_bookmarks = 20,

    -- Hotkey IDs
    hotkeys = {},
}

-- Save current zoom position as a bookmark
function BookmarkManager:save(name)
    if not name or name == "" then
        return false
    end

    -- Check limit
    local count = 0
    for _, _ in pairs(self.bookmarks) do count = count + 1 end

    if count >= self.max_bookmarks and not self.bookmarks[name] then
        log("Bookmark: Max bookmarks reached (" .. self.max_bookmarks .. ")")
        return false
    end

    -- Get current crop
    local crop = crop_filter_get_crop()
    if not crop then
        return false
    end

    -- Save bookmark
    self.bookmarks[name] = {
        zoom_level = SM.zoom_level,
        x = crop.x,
        y = crop.y,
        w = crop.w,
        h = crop.h,
        source = cfg.source_name,
    }

    log("Bookmark: Saved '" .. name .. "' (zoom=" .. string.format("%.2f", SM.zoom_level) .. ")")
    return true
end

-- Recall a bookmark
function BookmarkManager:recall(name)
    local bm = self.bookmarks[name]
    if not bm then
        log("Bookmark: Not found: " .. name)
        return false
    end

    if not SM:can_jump() then
        return false
    end

    if not source_manager_is_valid() then
        return false
    end

    local source_w, source_h = source_manager_get_size()
    if source_w == 0 or source_h == 0 then
        return false
    end

    -- Get current crop as start
    local start_crop = crop_filter_get_crop() or { x = 0, y = 0, w = source_w, h = source_h }

    -- Set target
    local target_crop = {
        x = bm.x,
        y = bm.y,
        w = bm.w,
        h = bm.h,
    }

    -- Transition to bookmark
    SM:transition(ZoomState.JUMPING, {
        start_crop = start_crop,
        target_crop = target_crop,
        target_level = bm.zoom_level
    })

    start_timer()
    log("Bookmark: Recall '" .. name .. "'")
    return true
end

-- Delete a bookmark
function BookmarkManager:delete(name)
    if self.bookmarks[name] then
        self.bookmarks[name] = nil
        log("Bookmark: Deleted '" .. name .. "'")
        return true
    end
    return false
end

-- Rename a bookmark
function BookmarkManager:rename(old_name, new_name)
    if not self.bookmarks[old_name] then
        return false
    end

    if self.bookmarks[new_name] then
        return false
    end

    self.bookmarks[new_name] = self.bookmarks[old_name]
    self.bookmarks[old_name] = nil
    log("Bookmark: Renamed '" .. old_name .. "' to '" .. new_name .. "'")
    return true
end

-- Get all bookmark names
function BookmarkManager:get_names()
    local names = {}
    for k, _ in pairs(self.bookmarks) do
        table.insert(names, k)
    end
    table.sort(names)
    return names
end

-- Get bookmark info
function BookmarkManager:get(name)
    return self.bookmarks[name]
end

-- Persist bookmarks to settings
function BookmarkManager:persist(settings)
    local array = obs.obs_data_array_create()

    for name, bm in pairs(self.bookmarks) do
        local item = obs.obs_data_create()
        obs.obs_data_set_string(item, "name", name)
        obs.obs_data_set_double(item, "zoom_level", bm.zoom_level)
        obs.obs_data_set_double(item, "x", bm.x)
        obs.obs_data_set_double(item, "y", bm.y)
        obs.obs_data_set_double(item, "w", bm.w)
        obs.obs_data_set_double(item, "h", bm.h)
        obs.obs_data_set_string(item, "source", bm.source or "")
        obs.obs_data_array_push_back(array, item)
        obs.obs_data_release(item)
    end

    obs.obs_data_set_array(settings, "zoom_bookmarks", array)
    obs.obs_data_array_release(array)
end

-- Load bookmarks from settings
function BookmarkManager:load(settings)
    self.bookmarks = {}

    local array = obs.obs_data_get_array(settings, "zoom_bookmarks")
    if not array then
        return
    end

    for i = 0, obs.obs_data_array_count(array) - 1 do
        local item = obs.obs_data_array_item(array, i)
        local name = obs.obs_data_get_string(item, "name")

        if name and name ~= "" then
            self.bookmarks[name] = {
                zoom_level = obs.obs_data_get_double(item, "zoom_level"),
                x = obs.obs_data_get_double(item, "x"),
                y = obs.obs_data_get_double(item, "y"),
                w = obs.obs_data_get_double(item, "w"),
                h = obs.obs_data_get_double(item, "h"),
                source = obs.obs_data_get_string(item, "source"),
            }
        end

        obs.obs_data_release(item)
    end

    obs.obs_data_array_release(array)

    local count = 0
    for _, _ in pairs(self.bookmarks) do count = count + 1 end
    log("Bookmark: Loaded " .. count .. " bookmarks")
end

-- Register bookmark hotkeys
function BookmarkManager:register_hotkeys(settings)
    for i = 1, 5 do
        self.hotkeys[i] = obs.obs_hotkey_register_frontend(
            "obs_zoom_pro.bookmark_" .. i,
            "Zoom to Bookmark " .. i,
            function(pressed)
                if not pressed then return end
                local names = self:get_names()
                if names[i] then
                    self:recall(names[i])
                end
            end
        )

        -- Load saved bindings
        local key = "obs_zoom_pro.hotkey.bookmark_" .. i
        local save_array = obs.obs_data_get_array(settings, key)
        if save_array then
            obs.obs_hotkey_load(self.hotkeys[i], save_array)
            obs.obs_data_array_release(save_array)
        end
    end
end

-- Save bookmark hotkeys
function BookmarkManager:save_hotkeys(settings)
    for i = 1, 5 do
        if self.hotkeys[i] then
            local save_array = obs.obs_hotkey_save(self.hotkeys[i])
            obs.obs_data_set_array(settings, "obs_zoom_pro.hotkey.bookmark_" .. i, save_array)
            obs.obs_data_array_release(save_array)
        end
    end
end

-- Global convenience functions
function bookmark_save(name)
    return BookmarkManager:save(name)
end

function bookmark_recall(name)
    return BookmarkManager:recall(name)
end

function bookmark_delete(name)
    return BookmarkManager:delete(name)
end

function bookmark_get_names()
    return BookmarkManager:get_names()
end

function bookmark_get(name)
    return BookmarkManager:get(name)
end

--================================================
-- MODULE: UDP API Server (M18)
--================================================
-- Provides external control via UDP for Stream Deck integration

local APIServer = {
    enabled = false,
    port = 12345,
    socket = nil,
}

-- Command handlers
local API_COMMANDS = {
    ZOOM_IN = function(args)
        local level = tonumber(args[1]) or cfg.zoom_value
        on_scroll_zoom_to(level)
        return "OK"
    end,

    ZOOM_OUT = function(args)
        if SM:is_zoomed() then
            on_toggle_zoom(true)
        end
        return "OK"
    end,

    ZOOM_SET = function(args)
        local level = tonumber(args[1])
        if not level then return "ERROR: Missing level" end
        on_scroll_zoom_to(level)
        return "OK"
    end,

    ZOOM_TOGGLE = function(args)
        on_toggle_zoom(true)
        return "OK"
    end,

    FOLLOW_ON = function(args)
        if SM:is_zoomed() then SM.following = true end
        return "OK"
    end,

    FOLLOW_OFF = function(args)
        SM.following = false
        return "OK"
    end,

    FOLLOW_TOGGLE = function(args)
        if SM:is_zoomed() then SM.following = not SM.following end
        return "OK"
    end,

    PRESET = function(args)
        local name = args[1]
        if not name then return "ERROR: Missing preset name" end
        local ok = preset_apply(name)
        return ok and "OK" or "ERROR: Unknown preset"
    end,

    BOOKMARK = function(args)
        local name = args[1]
        if not name then return "ERROR: Missing bookmark name" end
        local ok = bookmark_recall(name)
        return ok and "OK" or "ERROR: Bookmark not found"
    end,

    STATUS = function(args)
        local crop = crop_filter_get_crop()
        return string.format(
            '{"version":"%s","zoom_level":%.2f,"state":"%s","following":%s,"position":{"x":%.0f,"y":%.0f},"preset":"%s"}',
            VERSION,
            SM.zoom_level,
            SM.state,
            tostring(SM.following),
            crop and crop.x or 0,
            crop and crop.y or 0,
            cfg.zoom_preset or ""
        )
    end,

    HELP = function(args)
        return "Commands: ZOOM_IN [level], ZOOM_OUT, ZOOM_SET level, ZOOM_TOGGLE, FOLLOW_ON, FOLLOW_OFF, FOLLOW_TOGGLE, PRESET name, BOOKMARK name, STATUS"
    end,
}

-- Start the API server
function APIServer:start(port)
    self:stop()

    self.port = port or self.port

    -- Try to use luasocket if available
    local socket_ok, socket = pcall(require, "socket")
    if not socket_ok then
        log("API: Socket library not available")
        return false
    end

    -- Try UDP
    local udp, err = socket.udp()
    if not udp then
        log("API: Failed to create UDP socket: " .. tostring(err))
        return false
    end

    -- Set socket options
    udp:setoption("reuseaddr", true)
    udp:settimeout(0)  -- Non-blocking

    -- Bind to port
    local bind_ok, err = udp:setsockname("*", self.port)
    if not bind_ok then
        log("API: Failed to bind to port " .. self.port .. ": " .. tostring(err))
        udp:close()
        return false
    end

    self.socket = udp
    self.enabled = true

    -- Start polling timer
    obs.timer_add(function() self:poll() end, 50)  -- 20Hz polling

    log("API: Listening on port " .. self.port)
    return true
end

-- Stop the API server
function APIServer:stop()
    if self.socket then
        self.socket:close()
        self.socket = nil
    end
    self.enabled = false
    log("API: Stopped")
end

-- Poll for incoming commands
function APIServer:poll()
    if not self.enabled or not self.socket then
        return
    end

    repeat
        local data, err = self.socket:receivefrom()
        if data then
            local response = self:handle_command(data)
            if response then
                -- Note: UDP response requires sender address
                log("API: " .. data:gsub("%s+", " ") .. " Ã¢â€ â€™ " .. response)
            end
        elseif err ~= "timeout" then
            log("API: Error: " .. tostring(err))
        end
    until not data
end

-- Handle a command
function APIServer:handle_command(raw)
    -- Parse command
    local parts = {}
    for word in raw:gmatch("%S+") do
        table.insert(parts, word)
    end

    if #parts == 0 then
        return "ERROR: Empty command"
    end

    local cmd = parts[1]:upper()
    local args = {}
    for i = 2, #parts do
        table.insert(args, parts[i])
    end

    -- Look up handler
    local handler = API_COMMANDS[cmd]
    if handler then
        local ok, result = pcall(handler, args)
        if ok then
            return result
        else
            return "ERROR: " .. tostring(result)
        end
    end

    return "ERROR: Unknown command: " .. cmd
end

-- Check if enabled
function APIServer:is_enabled()
    return self.enabled
end

-- Global convenience functions
function api_start(port)
    return APIServer:start(port)
end

function api_stop()
    return APIServer:stop()
end

function api_is_enabled()
    return APIServer:is_enabled()
end

--================================================
-- OBS SCRIPT REGISTRATION
--================================================

--[[ Called when the script is loaded
--[[ @param data table Script data
function script_load(data)
    log("Script loaded - OBS Zoom Pro v" .. VERSION)

    -- Load custom presets
    PresetManager:load(data)

    -- Load scene memory
    SceneMemory:load(data)

    -- Load bookmarks
    BookmarkManager:load(data)

    -- Register hotkeys
    register_hotkeys(data)

    -- Register bookmark hotkeys
    BookmarkManager:register_hotkeys(data)

    -- Register frontend event handler
    obs.obs_frontend_add_event_callback(on_frontend_event)

    -- Start API server if enabled
    local api_enabled = obs.obs_data_get_bool(data, "api_enabled")
    if api_enabled then
        local api_port = obs.obs_data_get_int(data, "api_port")
        APIServer:start(api_port)
    end
end

--[[ Called when the script is unloaded
function script_unload()
    log("Script unloaded - OBS Zoom Pro")

    -- Stop timer and cleanup
    stop_timer()
    unregister_hotkeys()
    source_manager_release()

    -- Stop API server
    APIServer:stop()

    -- Remove frontend event handler
    obs.obs_frontend_remove_event_callback(on_frontend_event)
end

--[[ Called when settings are updated
--[[ @param data table Settings data
function script_update(data)
    log("Settings updated")

    -- Update legacy settings
    debug_logs = obs.obs_data_get_bool(data, "debug_logging") or false
    settings.debug_logging = debug_logs
    settings.easing_type = obs.obs_data_get_string(data, "easing_type") or defaults.easing_type
    settings.smooth_time = obs.obs_data_get_double(data, "smooth_time") or defaults.smooth_time
    settings.max_speed = obs.obs_data_get_double(data, "max_speed") or defaults.max_speed

    -- Update M09 configuration
    update_config(data)

    -- Update API server settings
    local api_enabled = obs.obs_data_get_bool(data, "api_enabled")
    local api_port = obs.obs_data_get_int(data, "api_port")

    if api_enabled and not APIServer:is_enabled() then
        APIServer:start(api_port)
    elseif not api_enabled and APIServer:is_enabled() then
        APIServer:stop()
    elseif APIServer:is_enabled() and APIServer.port ~= api_port then
        APIServer:start(api_port)
    end
end

--[[ Called to save settings
--[[ @param data table Settings data to save
function script_save(data)
    log("Settings saved")

    -- Save custom presets
    PresetManager:persist(data)

    -- Save scene memory
    SceneMemory:persist(data)

    -- Save bookmarks
    BookmarkManager:persist(data)

    -- Save hotkey bindings
    save_hotkeys(data)

    -- Save bookmark hotkeys
    BookmarkManager:save_hotkeys(data)
end

--[[ Called to create the properties UI
--[[ @return obs.obs_properties_t Properties object
function script_properties()
    local props = obs.obs_properties_create()

    --==========================
    -- QUICK SETUP (always expanded)
    --==========================
    local grp_quick = obs.obs_properties_create()

    -- Source dropdown
    local src_list = obs.obs_properties_add_list(grp_quick, "source", "Zoom Source",
        obs.OBS_COMBO_TYPE_LIST, obs.OBS_COMBO_FORMAT_STRING)
    obs.obs_property_list_add_string(src_list, "-- Select Source --", "")

    -- Populate with available capture sources
    local sources = source_manager_get_available_sources()
    for _, src in ipairs(sources) do
        obs.obs_property_list_add_string(src_list, src.name, src.name)
    end

    -- Zoom Factor
    obs.obs_properties_add_float_slider(grp_quick, "zoom_value", "Zoom Factor", 1.0, 10.0, 0.1)

    -- Duration
    obs.obs_properties_add_float_slider(grp_quick, "zoom_duration", "Duration (s)", 0.05, 3.0, 0.05)

    obs.obs_properties_add_group(props, "quick_setup", "Ã¢Å¡Â¡ Quick Setup", obs.OBS_GROUP_NORMAL, grp_quick)

    --==========================
    -- ANIMATION (collapsed)
    --==========================
    local grp_anim = obs.obs_properties_create()

    -- Overshoot/Bounce
    obs.obs_properties_add_float_slider(grp_anim, "zoom_overshoot", "Bounce", 0.0, 1.0, 0.01)

    -- Easing Curve
    local p_easing = obs.obs_properties_add_list(grp_anim, "zoom_easing", "Easing Curve",
        obs.OBS_COMBO_TYPE_LIST, obs.OBS_COMBO_FORMAT_STRING)
    for _, name in ipairs(Easing.NAMES) do
        obs.obs_property_list_add_string(p_easing, name, name)
    end

    obs.obs_properties_add_group(props, "animation", "Ã°Å¸Å½Â¬ Animation", obs.OBS_GROUP_NORMAL, grp_anim)

    --==========================
    -- MOUSE FOLLOW (collapsed)
    --==========================
    local grp_follow = obs.obs_properties_create()

    obs.obs_properties_add_bool(grp_follow, "auto_follow", "Auto-Follow Mouse")
    obs.obs_properties_add_float_slider(grp_follow, "follow_smooth_time", "Smoothness", 0.01, 1.0, 0.01)
    obs.obs_properties_add_int_slider(grp_follow, "follow_dead_zone", "Dead Zone (px)", 0, 500, 1)

    obs.obs_properties_add_group(props, "follow", "Ã°Å¸Å½Â¯ Mouse Follow", obs.OBS_GROUP_NORMAL, grp_follow)

    --==========================
    -- ADVANCED (collapsed)
    --==========================
    local grp_adv = obs.obs_properties_create()
    obs.obs_properties_add_float_slider(grp_adv, "scroll_step", "Scroll Zoom Step", 0.1, 1.0, 0.05)
    obs.obs_properties_add_bool(grp_adv, "debug_logs", "Debug Logging")
    obs.obs_properties_add_group(props, "advanced", "Ã¢Å¡â„¢Ã¯Â¸Â Advanced", obs.OBS_GROUP_NORMAL, grp_adv)

    --==========================
    -- API SERVER (collapsed)
    --==========================
    local grp_api = obs.obs_properties_create()
    obs.obs_properties_add_bool(grp_api, "api_enabled", "Enable UDP API Server")
    obs.obs_properties_add_int(grp_api, "api_port", "API Port", 1024, 65535, 1)
    obs.obs_properties_add_group(props, "api_server", "Ã°Å¸Å’Â UDP API Server", obs.OBS_GROUP_NORMAL, grp_api)

    --==========================
    -- HELP (collapsed)
    --==========================
    local grp_help = obs.obs_properties_create()
    obs.obs_properties_add_text(grp_help, "help_text",
        "QUICK START:\n" ..
        "1. Select your capture source above\n" ..
        "2. Set hotkeys in OBS Settings Ã¢â€ â€™ Hotkeys\n" ..
        "   Ã¢â‚¬Â¢ 'Toggle Zoom to Mouse' Ã¢â‚¬â€ Main zoom\n" ..
        "   Ã¢â‚¬Â¢ 'Toggle Mouse Follow' Ã¢â‚¬â€ Enable/disable follow\n" ..
        "3. Press the hotkey to zoom!\n\n" ..
        "TIPS:\n" ..
        "Ã¢â‚¬Â¢ Zoom centers on mouse position\n" ..
        "Ã¢â‚¬Â¢ Enable Auto-Follow for smooth tracking\n" ..
        "Ã¢â‚¬Â¢ Adjust Dead Zone to reduce jitter",
        obs.OBS_TEXT_INFO)
    obs.obs_properties_add_group(props, "help", "Ã¢Ââ€œ Help", obs.OBS_GROUP_NORMAL, grp_help)

    return props
end

--[[ Called to set default values
--[[ @param data table Settings data
function script_defaults(data)
    obs.obs_data_set_default_string(data, "source", "")
    obs.obs_data_set_default_double(data, "zoom_value", 2.0)
    obs.obs_data_set_default_double(data, "zoom_duration", 0.6)
    obs.obs_data_set_default_double(data, "zoom_overshoot", 0.0)
    obs.obs_data_set_default_string(data, "zoom_easing", "Cubic.Out")
    obs.obs_data_set_default_bool(data, "auto_follow", true)
    obs.obs_data_set_default_double(data, "follow_smooth_time", 0.15)
    obs.obs_data_set_default_int(data, "follow_dead_zone", 5)
    obs.obs_data_set_default_double(data, "scroll_step", 0.25)
    obs.obs_data_set_default_bool(data, "debug_logs", false)
    obs.obs_data_set_default_bool(data, "api_enabled", false)
    obs.obs_data_set_default_int(data, "api_port", 12345)
end

--================================================
-- SCRIPT METADATA
--================================================
script_info = {
    name = "OBS Zoom Pro",
    version = VERSION,
    description = "Intelligent camera zoom functionality with smooth transitions and easing curves.",
    author = "OBS Zoom Pro Team"
}
